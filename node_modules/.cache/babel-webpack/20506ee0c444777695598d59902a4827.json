{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:registrar'), {\n  error: debug('libp2p:registrar:err')\n});\n\nconst errcode = require('err-code');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('./errors');\n\nconst Topology = require('libp2p-interfaces/src/topology');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./peer-store')} PeerStore\n * @typedef {import('./connection-manager')} ConnectionManager\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('./').HandlerProps} HandlerProps\n */\n\n/**\n *\n */\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\n\n\nclass Registrar {\n  /**\n   * @param {Object} props\n   * @param {PeerStore} props.peerStore\n   * @param {ConnectionManager} props.connectionManager\n   * @class\n   */\n  constructor({\n    peerStore,\n    connectionManager\n  }) {\n    // Used on topology to listen for protocol changes\n    this.peerStore = peerStore;\n    this.connectionManager = connectionManager;\n    /**\n     * Map of topologies\n     *\n     * @type {Map<string, Topology>}\n     */\n\n    this.topologies = new Map();\n    /** @type {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} */\n    // @ts-ignore handle is not optional\n\n    this._handle = undefined;\n    this._onDisconnect = this._onDisconnect.bind(this);\n    this.connectionManager.on('peer:disconnect', this._onDisconnect);\n  }\n  /**\n   * @returns {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void}\n   */\n\n\n  get handle() {\n    return this._handle;\n  }\n  /**\n   * @param {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} handle\n   */\n\n\n  set handle(handle) {\n    this._handle = handle;\n  }\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection | null}\n   */\n\n\n  getConnection(peerId) {\n    return this.connectionManager.get(peerId);\n  }\n  /**\n   * Register handlers for a set of multicodecs given\n   *\n   * @param {Topology} topology - protocol topology\n   * @returns {string} registrar identifier\n   */\n\n\n  register(topology) {\n    if (!Topology.isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology');\n      throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS);\n    } // Create topology\n\n\n    const id = (Math.random() * 1e9).toString(36) + Date.now();\n    this.topologies.set(id, topology); // Set registrar\n\n    topology.registrar = this;\n    return id;\n  }\n  /**\n   * Unregister topology.\n   *\n   * @param {string} id - registrar identifier\n   * @returns {boolean} unregistered successfully\n   */\n\n\n  unregister(id) {\n    return this.topologies.delete(id);\n  }\n  /**\n   * Remove a disconnected peer from the record\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n\n\n  _onDisconnect(connection) {\n    for (const [, topology] of this.topologies) {\n      topology.disconnect(connection.remotePeer);\n    }\n  }\n\n}\n\nmodule.exports = Registrar;","map":null,"metadata":{},"sourceType":"script"}