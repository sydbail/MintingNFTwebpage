{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n});\n\nconst errCode = require('err-code'); // @ts-ignore multistream-select does not export types\n\n\nconst Multistream = require('multistream-select');\n\nconst {\n  Connection\n} = require('libp2p-interfaces/src/connection');\n\nconst PeerId = require('peer-id');\n\nconst {\n  pipe\n} = require('it-pipe'); // @ts-ignore mutable-proxy does not export types\n\n\nconst mutableProxy = require('mutable-proxy');\n\nconst {\n  codes\n} = require('./errors');\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor({\n    localPeer,\n    metrics,\n    cryptos = new Map(),\n    muxers = new Map(),\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos;\n    this.muxers = muxers;\n    /** @type {import(\"./pnet\") | null} */\n\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  upgradeInbound(maConn) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let encryptedConn;\n      let remotePeer;\n      let upgradedConn;\n      let Muxer;\n      let cryptoProtocol;\n      let setPeer;\n      let proxyPeer;\n\n      if (_this.metrics) {\n        ({\n          setTarget: setPeer,\n          proxy: proxyPeer\n        } = mutableProxy());\n        const idString = (Math.random() * 1e9).toString(36) + Date.now();\n        setPeer({\n          toB58String: () => idString\n        });\n        maConn = _this.metrics.trackStream({\n          stream: maConn,\n          remotePeer: proxyPeer\n        });\n      }\n\n      log('Starting the inbound connection upgrade'); // Protect\n\n      let protectedConn = maConn;\n\n      if (_this.protector) {\n        protectedConn = yield _this.protector.protect(maConn);\n      }\n\n      try {\n        // Encrypt the connection\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = yield _this._encryptInbound(_this.localPeer, protectedConn, _this.cryptos)); // Multiplex the connection\n\n        if (_this.muxers.size) {\n          ({\n            stream: upgradedConn,\n            Muxer\n          } = yield _this._multiplexInbound(encryptedConn, _this.muxers));\n        } else {\n          upgradedConn = encryptedConn;\n        }\n      } catch (err) {\n        log.error('Failed to upgrade inbound connection', err);\n        yield maConn.close(err);\n        throw err;\n      }\n\n      if (_this.metrics) {\n        _this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n\n        setPeer(remotePeer);\n      }\n\n      log('Successfully upgraded inbound connection');\n      return _this._createConnection({\n        cryptoProtocol,\n        direction: 'inbound',\n        maConn,\n        upgradedConn,\n        Muxer,\n        remotePeer\n      });\n    })();\n  }\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  upgradeOutbound(maConn) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const idStr = maConn.remoteAddr.getPeerId();\n\n      if (!idStr) {\n        throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n      }\n\n      const remotePeerId = PeerId.createFromB58String(idStr);\n      let encryptedConn;\n      let remotePeer;\n      let upgradedConn;\n      let cryptoProtocol;\n      let Muxer;\n      let setPeer;\n      let proxyPeer;\n\n      if (_this2.metrics) {\n        ({\n          setTarget: setPeer,\n          proxy: proxyPeer\n        } = mutableProxy());\n        const idString = (Math.random() * 1e9).toString(36) + Date.now();\n        setPeer({\n          toB58String: () => idString\n        });\n        maConn = _this2.metrics.trackStream({\n          stream: maConn,\n          remotePeer: proxyPeer\n        });\n      }\n\n      log('Starting the outbound connection upgrade'); // Protect\n\n      let protectedConn = maConn;\n\n      if (_this2.protector) {\n        protectedConn = yield _this2.protector.protect(maConn);\n      }\n\n      try {\n        // Encrypt the connection\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = yield _this2._encryptOutbound(_this2.localPeer, protectedConn, remotePeerId, _this2.cryptos)); // Multiplex the connection\n\n        if (_this2.muxers.size) {\n          ({\n            stream: upgradedConn,\n            Muxer\n          } = yield _this2._multiplexOutbound(encryptedConn, _this2.muxers));\n        } else {\n          upgradedConn = encryptedConn;\n        }\n      } catch (err) {\n        log.error('Failed to upgrade outbound connection', err);\n        yield maConn.close(err);\n        throw err;\n      }\n\n      if (_this2.metrics) {\n        _this2.metrics.updatePlaceholder(proxyPeer, remotePeer);\n\n        setPeer(remotePeer);\n      }\n\n      log('Successfully upgraded outbound connection');\n      return _this2._createConnection({\n        cryptoProtocol,\n        direction: 'outbound',\n        maConn,\n        upgradedConn,\n        Muxer,\n        remotePeer\n      });\n    })();\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n\n\n  _createConnection({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    var _this3 = this;\n\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer;\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n\n    let newStream;\n    /** @type {Connection} */\n\n    let connection; // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: function () {\n          var _ref = _asyncToGenerator(function* (muxedStream) {\n            if (!connection) return;\n            const mss = new Multistream.Listener(muxedStream);\n\n            try {\n              const {\n                stream,\n                protocol\n              } = yield mss.handle(Array.from(_this3.protocols.keys()));\n              log('%s: incoming stream opened on %s', direction, protocol);\n              if (_this3.metrics) _this3.metrics.trackStream({\n                stream,\n                remotePeer,\n                protocol\n              });\n              connection.addStream(muxedStream, {\n                protocol\n              });\n\n              _this3._onStream({\n                connection,\n                stream: { ...muxedStream,\n                  ...stream\n                },\n                protocol\n              });\n            } catch (err) {\n              log.error(err);\n            }\n          });\n\n          return function onStream(_x) {\n            return _ref.apply(this, arguments);\n          };\n        }(),\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id);\n        }\n      });\n\n      newStream = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (protocols) {\n          log('%s: starting new stream on %s', direction, protocols);\n          const muxedStream = muxer.newStream();\n          const mss = new Multistream.Dialer(muxedStream);\n\n          try {\n            const {\n              stream,\n              protocol\n            } = yield mss.select(protocols);\n            if (_this3.metrics) _this3.metrics.trackStream({\n              stream,\n              remotePeer,\n              protocol\n            });\n            return {\n              stream: { ...muxedStream,\n                ...stream\n              },\n              protocol\n            };\n          } catch (err) {\n            log.error('could not create new stream', err);\n            throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n          }\n        });\n\n        return function newStream(_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }(); // Pipe all data through the muxer\n\n\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n    }\n\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          _asyncToGenerator(function* () {\n            try {\n              if (connection.stat.status === 'open') {\n                yield connection.close();\n              }\n            } catch (err) {\n              log.error(err);\n            } finally {\n              _this3.onConnectionEnd(connection);\n            }\n          })();\n        }\n\n        return Reflect.set(...args);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');\n    }; // Create the connection\n\n\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: function () {\n        var _ref4 = _asyncToGenerator(function* () {\n          yield maConn.close(); // Ensure remaining streams are aborted\n\n          if (muxer) {\n            muxer.streams.map(stream => stream.abort());\n          }\n        });\n\n        return function close() {\n          return _ref4.apply(this, arguments);\n        };\n      }()\n    });\n    this.onConnection(connection);\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n\n\n  _onStream({\n    connection,\n    stream,\n    protocol\n  }) {\n    const handler = this.protocols.get(protocol);\n    handler({\n      connection,\n      stream,\n      protocol\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  _encryptInbound(localPeer, connection, cryptos) {\n    return _asyncToGenerator(function* () {\n      const mss = new Multistream.Listener(connection);\n      const protocols = Array.from(cryptos.keys());\n      log('handling inbound crypto protocol selection', protocols);\n\n      try {\n        const {\n          stream,\n          protocol\n        } = yield mss.handle(protocols);\n        const crypto = cryptos.get(protocol);\n        log('encrypting inbound connection...');\n\n        if (!crypto) {\n          throw new Error(`no crypto module found for ${protocol}`);\n        }\n\n        return { ...(yield crypto.secureInbound(localPeer, stream)),\n          protocol\n        };\n      } catch (err) {\n        throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n      }\n    })();\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {\n    return _asyncToGenerator(function* () {\n      const mss = new Multistream.Dialer(connection);\n      const protocols = Array.from(cryptos.keys());\n      log('selecting outbound crypto protocol', protocols);\n\n      try {\n        const {\n          stream,\n          protocol\n        } = yield mss.select(protocols);\n        const crypto = cryptos.get(protocol);\n        log('encrypting outbound connection to %j', remotePeerId);\n\n        if (!crypto) {\n          throw new Error(`no crypto module found for ${protocol}`);\n        }\n\n        return { ...(yield crypto.secureOutbound(localPeer, stream, remotePeerId)),\n          protocol\n        };\n      } catch (err) {\n        throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n      }\n    })();\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  _multiplexOutbound(connection, muxers) {\n    return _asyncToGenerator(function* () {\n      const dialer = new Multistream.Dialer(connection);\n      const protocols = Array.from(muxers.keys());\n      log('outbound selecting muxer %s', protocols);\n\n      try {\n        const {\n          stream,\n          protocol\n        } = yield dialer.select(protocols);\n        log('%s selected as muxer protocol', protocol);\n        const Muxer = muxers.get(protocol);\n        return {\n          stream,\n          Muxer\n        };\n      } catch (err) {\n        throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n      }\n    })();\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  _multiplexInbound(connection, muxers) {\n    return _asyncToGenerator(function* () {\n      const listener = new Multistream.Listener(connection);\n      const protocols = Array.from(muxers.keys());\n      log('inbound handling muxers %s', protocols);\n\n      try {\n        const {\n          stream,\n          protocol\n        } = yield listener.handle(protocols);\n        const Muxer = muxers.get(protocol);\n        return {\n          stream,\n          Muxer\n        };\n      } catch (err) {\n        throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n      }\n    })();\n  }\n\n}\n\nmodule.exports = Upgrader;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p/src/upgrader.js"],"names":["debug","require","log","Object","assign","error","errCode","Multistream","Connection","PeerId","pipe","mutableProxy","codes","Upgrader","constructor","localPeer","metrics","cryptos","Map","muxers","onConnectionEnd","onConnection","protector","protocols","upgradeInbound","maConn","encryptedConn","remotePeer","upgradedConn","Muxer","cryptoProtocol","setPeer","proxyPeer","setTarget","proxy","idString","Math","random","toString","Date","now","toB58String","trackStream","stream","protectedConn","protect","conn","protocol","_encryptInbound","size","_multiplexInbound","err","close","updatePlaceholder","_createConnection","direction","upgradeOutbound","idStr","remoteAddr","getPeerId","Error","ERR_INVALID_MULTIADDR","remotePeerId","createFromB58String","_encryptOutbound","_multiplexOutbound","muxer","newStream","connection","onStream","muxedStream","mss","Listener","handle","Array","from","keys","addStream","_onStream","onStreamEnd","removeStream","id","Dialer","select","ERR_UNSUPPORTED_PROTOCOL","catch","_timeline","timeline","Proxy","set","args","stat","status","Reflect","upgraded","errConnectionNotMultiplexed","localAddr","multiplexer","multicodec","encryption","getStreams","streams","map","abort","handler","get","crypto","secureInbound","ERR_ENCRYPTION_FAILED","secureOutbound","dialer","ERR_MUXER_UNAVAILABLE","listener","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n})\nconst errCode = require('err-code')\n// @ts-ignore multistream-select does not export types\nconst Multistream = require('multistream-select')\nconst { Connection } = require('libp2p-interfaces/src/connection')\nconst PeerId = require('peer-id')\nconst { pipe } = require('it-pipe')\n// @ts-ignore mutable-proxy does not export types\nconst mutableProxy = require('mutable-proxy')\n\nconst { codes } = require('./errors')\n\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor ({\n    localPeer,\n    metrics,\n    cryptos = new Map(),\n    muxers = new Map(),\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer\n    this.metrics = metrics\n    this.cryptos = cryptos\n    this.muxers = muxers\n    /** @type {import(\"./pnet\") | null} */\n    this.protector = null\n    this.protocols = new Map()\n    this.onConnection = onConnection\n    this.onConnectionEnd = onConnectionEnd\n  }\n\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeInbound (maConn) {\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let Muxer\n    let cryptoProtocol\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the inbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade inbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded inbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeOutbound (maConn) {\n    const idStr = maConn.remoteAddr.getPeerId()\n    if (!idStr) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR)\n    }\n\n    const remotePeerId = PeerId.createFromB58String(idStr)\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let cryptoProtocol\n    let Muxer\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the outbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n  _createConnection ({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n    let newStream\n    /** @type {Connection} */\n    let connection // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          if (!connection) return\n          const mss = new Multistream.Listener(muxedStream)\n          try {\n            const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()))\n            log('%s: incoming stream opened on %s', direction, protocol)\n            if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n            connection.addStream(muxedStream, { protocol })\n            this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol })\n          } catch (err) {\n            log.error(err)\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id)\n        }\n      })\n\n      newStream = async (protocols) => {\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = muxer.newStream()\n        const mss = new Multistream.Dialer(muxedStream)\n        try {\n          const { stream, protocol } = await mss.select(protocols)\n          if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n          return { stream: { ...muxedStream, ...stream }, protocol }\n        } catch (err) {\n          log.error('could not create new stream', err)\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error)\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'open') {\n                await connection.close()\n              }\n            } catch (err) {\n              log.error(err)\n            } finally {\n              this.onConnectionEnd(connection)\n            }\n          })()\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED')\n    }\n\n    // Create the connection\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close()\n        // Ensure remaining streams are aborted\n        if (muxer) {\n          muxer.streams.map(stream => stream.abort())\n        }\n      }\n    })\n\n    this.onConnection(connection)\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n  _onStream ({ connection, stream, protocol }) {\n    const handler = this.protocols.get(protocol)\n    handler({ connection, stream, protocol })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptInbound (localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting inbound connection...')\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureInbound(localPeer, stream),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptOutbound (localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting outbound connection to %j', remotePeerId)\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureOutbound(localPeer, stream, remotePeerId),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexOutbound (connection, muxers) {\n    const dialer = new Multistream.Dialer(connection)\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await dialer.select(protocols)\n      log('%s selected as muxer protocol', protocol)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexInbound (connection, muxers) {\n    const listener = new Multistream.Listener(connection)\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await listener.handle(protocols)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n\nmodule.exports = Upgrader\n"]},"metadata":{},"sourceType":"script"}