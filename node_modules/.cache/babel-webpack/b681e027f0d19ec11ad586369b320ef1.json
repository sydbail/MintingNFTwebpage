{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:auto-relay'), {\n  error: debug('libp2p:auto-relay:err')\n});\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst {\n  relay: multicodec\n} = require('./multicodec');\n\nconst {\n  canHop\n} = require('./circuit/hop');\n\nconst {\n  namespaceToCid\n} = require('./utils');\n\nconst {\n  CIRCUIT_PROTO_CODE,\n  HOP_METADATA_KEY,\n  HOP_METADATA_VALUE,\n  RELAY_RENDEZVOUS_NS\n} = require('./constants');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('../peer-store/address-book').Address} Address\n */\n\n/**\n * @typedef {Object} AutoRelayProperties\n * @property {import('../')} libp2p\n *\n * @typedef {Object} AutoRelayOptions\n * @property {number} [maxListeners = 1] - maximum number of relays to listen.\n * @property {(error: Error, msg?: string) => {}} [onError]\n */\n\n\nclass AutoRelay {\n  /**\n   * Creates an instance of AutoRelay.\n   *\n   * @class\n   * @param {AutoRelayProperties & AutoRelayOptions} props\n   */\n  constructor({\n    libp2p,\n    maxListeners = 1,\n    onError\n  }) {\n    this._libp2p = libp2p;\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    this._connectionManager = libp2p.connectionManager;\n    this._transportManager = libp2p.transportManager;\n    this._addressSorter = libp2p.dialer.addressSorter;\n    this.maxListeners = maxListeners;\n    /**\n     * @type {Set<string>}\n     */\n\n    this._listenRelays = new Set();\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n\n    this._peerStore.on('change:protocols', this._onProtocolChange);\n\n    this._connectionManager.on('peer:disconnect', this._onPeerDisconnected);\n    /**\n     * @param {Error} error\n     * @param {string} [msg]\n     */\n\n\n    this._onError = (error, msg) => {\n      log.error(msg || error);\n      onError && onError(error, msg);\n    };\n  }\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {string[]} props.protocols\n   * @returns {Promise<void>}\n   */\n\n\n  _onProtocolChange({\n    peerId,\n    protocols\n  }) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const id = peerId.toB58String(); // Check if it has the protocol\n\n      const hasProtocol = protocols.find(protocol => protocol === multicodec); // If no protocol, check if we were keeping the peer before as a listenRelay\n\n      if (!hasProtocol && _this._listenRelays.has(id)) {\n        _this._removeListenRelay(id);\n\n        return;\n      } else if (!hasProtocol || _this._listenRelays.has(id)) {\n        return;\n      } // If protocol, check if can hop, store info in the metadataBook and listen on it\n\n\n      try {\n        const connection = _this._connectionManager.get(peerId);\n\n        if (!connection) {\n          return;\n        } // Do not hop on a relayed connection\n\n\n        if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n          log(`relayed connection to ${id} will not be used to hop on`);\n          return;\n        }\n\n        const supportsHop = yield canHop({\n          connection\n        });\n\n        if (supportsHop) {\n          _this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));\n\n          yield _this._addListenRelay(connection, id);\n        }\n      } catch (err) {\n        _this._onError(err);\n      }\n    })();\n  }\n  /**\n   * Peer disconnects.\n   *\n   * @param {Connection} connection - connection to the peer\n   * @returns {void}\n   */\n\n\n  _onPeerDisconnected(connection) {\n    const peerId = connection.remotePeer;\n    const id = peerId.toB58String(); // Not listening on this relay\n\n    if (!this._listenRelays.has(id)) {\n      return;\n    }\n\n    this._removeListenRelay(id);\n  }\n  /**\n   * Attempt to listen on the given relay connection.\n   *\n   * @private\n   * @param {Connection} connection - connection to the peer\n   * @param {string} id - peer identifier string\n   * @returns {Promise<void>}\n   */\n\n\n  _addListenRelay(connection, id) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Check if already listening on enough relays\n      if (_this2._listenRelays.size >= _this2.maxListeners) {\n        return;\n      } // Get peer known addresses and sort them per public addresses first\n\n\n      const remoteAddrs = _this2._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, _this2._addressSorter);\n\n      if (!remoteAddrs || !remoteAddrs.length) {\n        return;\n      }\n\n      const listenAddr = `${remoteAddrs[0].toString()}/p2p-circuit`;\n\n      _this2._listenRelays.add(id); // Attempt to listen on relay\n\n\n      try {\n        yield _this2._transportManager.listen([new Multiaddr(listenAddr)]); // Announce multiaddrs will update on listen success by TransportManager event being triggered\n      } catch (err) {\n        _this2._onError(err);\n\n        _this2._listenRelays.delete(id);\n      }\n    })();\n  }\n  /**\n   * Remove listen relay.\n   *\n   * @private\n   * @param {string} id - peer identifier string.\n   * @returns {void}\n   */\n\n\n  _removeListenRelay(id) {\n    if (this._listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      this._listenOnAvailableHopRelays([id]);\n    }\n  }\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   *\n   * @param {string[]} [peersToIgnore]\n   * @returns {Promise<void>}\n   */\n\n\n  _listenOnAvailableHopRelays(peersToIgnore = []) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO: The peer redial issue on disconnect should be handled by connection gating\n      // Check if already listening on enough relays\n      if (_this3._listenRelays.size >= _this3.maxListeners) {\n        return;\n      }\n\n      const knownHopsToDial = []; // Check if we have known hop peers to use and attempt to listen on the already connected\n\n      for (const [id, metadataMap] of _this3._peerStore.metadataBook.data.entries()) {\n        // Continue to next if listening on this or peer to ignore\n        if (_this3._listenRelays.has(id) || peersToIgnore.includes(id)) {\n          continue;\n        }\n\n        const supportsHop = metadataMap.get(HOP_METADATA_KEY); // Continue to next if it does not support Hop\n\n        if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n          continue;\n        }\n\n        const peerId = PeerId.createFromB58String(id);\n\n        const connection = _this3._connectionManager.get(peerId); // If not connected, store for possible later use.\n\n\n        if (!connection) {\n          knownHopsToDial.push(peerId);\n          continue;\n        }\n\n        yield _this3._addListenRelay(connection, id); // Check if already listening on enough relays\n\n        if (_this3._listenRelays.size >= _this3.maxListeners) {\n          return;\n        }\n      } // Try to listen on known peers that are not connected\n\n\n      for (const peerId of knownHopsToDial) {\n        yield _this3._tryToListenOnRelay(peerId); // Check if already listening on enough relays\n\n        if (_this3._listenRelays.size >= _this3.maxListeners) {\n          return;\n        }\n      } // Try to find relays to hop on the network\n\n\n      try {\n        const cid = yield namespaceToCid(RELAY_RENDEZVOUS_NS);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(_this3._libp2p.contentRouting.findProviders(cid)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const provider = _value;\n\n            if (!provider.multiaddrs.length) {\n              continue;\n            }\n\n            const peerId = provider.id;\n\n            _this3._peerStore.addressBook.add(peerId, provider.multiaddrs);\n\n            yield _this3._tryToListenOnRelay(peerId); // Check if already listening on enough relays\n\n            if (_this3._listenRelays.size >= _this3.maxListeners) {\n              return;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } catch (err) {\n        _this3._onError(err);\n      }\n    })();\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  _tryToListenOnRelay(peerId) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const connection = yield _this4._libp2p.dial(peerId);\n        yield _this4._addListenRelay(connection, peerId.toB58String());\n      } catch (err) {\n        _this4._onError(err, `could not connect and listen on known hop relay ${peerId.toB58String()}`);\n      }\n    })();\n  }\n\n}\n\nmodule.exports = AutoRelay;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p/src/circuit/auto-relay.js"],"names":["debug","require","log","Object","assign","error","fromString","uint8ArrayFromString","toString","uint8ArrayToString","Multiaddr","PeerId","relay","multicodec","canHop","namespaceToCid","CIRCUIT_PROTO_CODE","HOP_METADATA_KEY","HOP_METADATA_VALUE","RELAY_RENDEZVOUS_NS","AutoRelay","constructor","libp2p","maxListeners","onError","_libp2p","_peerId","peerId","_peerStore","peerStore","_connectionManager","connectionManager","_transportManager","transportManager","_addressSorter","dialer","addressSorter","_listenRelays","Set","_onProtocolChange","bind","_onPeerDisconnected","on","_onError","msg","protocols","id","toB58String","hasProtocol","find","protocol","has","_removeListenRelay","connection","get","remoteAddr","protoCodes","includes","supportsHop","metadataBook","set","_addListenRelay","err","remotePeer","size","remoteAddrs","addressBook","getMultiaddrsForPeer","length","listenAddr","add","listen","delete","_listenOnAvailableHopRelays","peersToIgnore","knownHopsToDial","metadataMap","data","entries","createFromB58String","push","_tryToListenOnRelay","cid","contentRouting","findProviders","provider","multiaddrs","dial","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:auto-relay'), {\n  error: debug('libp2p:auto-relay:err')\n})\n\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst { relay: multicodec } = require('./multicodec')\nconst { canHop } = require('./circuit/hop')\nconst { namespaceToCid } = require('./utils')\nconst {\n  CIRCUIT_PROTO_CODE,\n  HOP_METADATA_KEY,\n  HOP_METADATA_VALUE,\n  RELAY_RENDEZVOUS_NS\n} = require('./constants')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('../peer-store/address-book').Address} Address\n */\n\n/**\n * @typedef {Object} AutoRelayProperties\n * @property {import('../')} libp2p\n *\n * @typedef {Object} AutoRelayOptions\n * @property {number} [maxListeners = 1] - maximum number of relays to listen.\n * @property {(error: Error, msg?: string) => {}} [onError]\n */\n\nclass AutoRelay {\n  /**\n   * Creates an instance of AutoRelay.\n   *\n   * @class\n   * @param {AutoRelayProperties & AutoRelayOptions} props\n   */\n  constructor ({ libp2p, maxListeners = 1, onError }) {\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId\n    this._peerStore = libp2p.peerStore\n    this._connectionManager = libp2p.connectionManager\n    this._transportManager = libp2p.transportManager\n    this._addressSorter = libp2p.dialer.addressSorter\n\n    this.maxListeners = maxListeners\n\n    /**\n     * @type {Set<string>}\n     */\n    this._listenRelays = new Set()\n\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n\n    this._peerStore.on('change:protocols', this._onProtocolChange)\n    this._connectionManager.on('peer:disconnect', this._onPeerDisconnected)\n\n    /**\n     * @param {Error} error\n     * @param {string} [msg]\n     */\n    this._onError = (error, msg) => {\n      log.error(msg || error)\n      onError && onError(error, msg)\n    }\n  }\n\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {string[]} props.protocols\n   * @returns {Promise<void>}\n   */\n  async _onProtocolChange ({ peerId, protocols }) {\n    const id = peerId.toB58String()\n\n    // Check if it has the protocol\n    const hasProtocol = protocols.find(protocol => protocol === multicodec)\n\n    // If no protocol, check if we were keeping the peer before as a listenRelay\n    if (!hasProtocol && this._listenRelays.has(id)) {\n      this._removeListenRelay(id)\n      return\n    } else if (!hasProtocol || this._listenRelays.has(id)) {\n      return\n    }\n\n    // If protocol, check if can hop, store info in the metadataBook and listen on it\n    try {\n      const connection = this._connectionManager.get(peerId)\n      if (!connection) {\n        return\n      }\n\n      // Do not hop on a relayed connection\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(`relayed connection to ${id} will not be used to hop on`)\n        return\n      }\n\n      const supportsHop = await canHop({ connection })\n\n      if (supportsHop) {\n        this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE))\n        await this._addListenRelay(connection, id)\n      }\n    } catch (err) {\n      this._onError(err)\n    }\n  }\n\n  /**\n   * Peer disconnects.\n   *\n   * @param {Connection} connection - connection to the peer\n   * @returns {void}\n   */\n  _onPeerDisconnected (connection) {\n    const peerId = connection.remotePeer\n    const id = peerId.toB58String()\n\n    // Not listening on this relay\n    if (!this._listenRelays.has(id)) {\n      return\n    }\n\n    this._removeListenRelay(id)\n  }\n\n  /**\n   * Attempt to listen on the given relay connection.\n   *\n   * @private\n   * @param {Connection} connection - connection to the peer\n   * @param {string} id - peer identifier string\n   * @returns {Promise<void>}\n   */\n  async _addListenRelay (connection, id) {\n    // Check if already listening on enough relays\n    if (this._listenRelays.size >= this.maxListeners) {\n      return\n    }\n\n    // Get peer known addresses and sort them per public addresses first\n    const remoteAddrs = this._peerStore.addressBook.getMultiaddrsForPeer(\n      connection.remotePeer, this._addressSorter\n    )\n\n    if (!remoteAddrs || !remoteAddrs.length) {\n      return\n    }\n\n    const listenAddr = `${remoteAddrs[0].toString()}/p2p-circuit`\n    this._listenRelays.add(id)\n\n    // Attempt to listen on relay\n    try {\n      await this._transportManager.listen([new Multiaddr(listenAddr)])\n      // Announce multiaddrs will update on listen success by TransportManager event being triggered\n    } catch (err) {\n      this._onError(err)\n      this._listenRelays.delete(id)\n    }\n  }\n\n  /**\n   * Remove listen relay.\n   *\n   * @private\n   * @param {string} id - peer identifier string.\n   * @returns {void}\n   */\n  _removeListenRelay (id) {\n    if (this._listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      this._listenOnAvailableHopRelays([id])\n    }\n  }\n\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   *\n   * @param {string[]} [peersToIgnore]\n   * @returns {Promise<void>}\n   */\n  async _listenOnAvailableHopRelays (peersToIgnore = []) {\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this._listenRelays.size >= this.maxListeners) {\n      return\n    }\n\n    const knownHopsToDial = []\n\n    // Check if we have known hop peers to use and attempt to listen on the already connected\n    for (const [id, metadataMap] of this._peerStore.metadataBook.data.entries()) {\n      // Continue to next if listening on this or peer to ignore\n      if (this._listenRelays.has(id) || peersToIgnore.includes(id)) {\n        continue\n      }\n\n      const supportsHop = metadataMap.get(HOP_METADATA_KEY)\n\n      // Continue to next if it does not support Hop\n      if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue\n      }\n\n      const peerId = PeerId.createFromB58String(id)\n      const connection = this._connectionManager.get(peerId)\n\n      // If not connected, store for possible later use.\n      if (!connection) {\n        knownHopsToDial.push(peerId)\n        continue\n      }\n\n      await this._addListenRelay(connection, id)\n\n      // Check if already listening on enough relays\n      if (this._listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to listen on known peers that are not connected\n    for (const peerId of knownHopsToDial) {\n      await this._tryToListenOnRelay(peerId)\n\n      // Check if already listening on enough relays\n      if (this._listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to find relays to hop on the network\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS)\n      for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {\n        if (!provider.multiaddrs.length) {\n          continue\n        }\n\n        const peerId = provider.id\n        this._peerStore.addressBook.add(peerId, provider.multiaddrs)\n\n        await this._tryToListenOnRelay(peerId)\n\n        // Check if already listening on enough relays\n        if (this._listenRelays.size >= this.maxListeners) {\n          return\n        }\n      }\n    } catch (err) {\n      this._onError(err)\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _tryToListenOnRelay (peerId) {\n    try {\n      const connection = await this._libp2p.dial(peerId)\n      await this._addListenRelay(connection, peerId.toB58String())\n    } catch (err) {\n      this._onError(err, `could not connect and listen on known hop relay ${peerId.toB58String()}`)\n    }\n  }\n}\n\nmodule.exports = AutoRelay\n"]},"metadata":{},"sourceType":"script"}