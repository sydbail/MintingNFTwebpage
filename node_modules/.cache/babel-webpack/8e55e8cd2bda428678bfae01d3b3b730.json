{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  CID\n} = require('multiformats');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58'); // @ts-ignore\n\n\nconst vd = require('varint-decoder');\n\nconst {\n  isMapEqual\n} = require('../../utils');\n\nconst {\n  Message\n} = require('./message');\n\nconst Entry = require('./entry');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst errcode = require('err-code');\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\n\nclass BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor(full) {\n    this.full = full;\n    /** @type {Map<string, Entry>} */\n\n    this.wantlist = new Map();\n    /** @type {Map<string, Uint8Array>} */\n\n    this.blocks = new Map();\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  get empty() {\n    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n  }\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n\n\n  addEntry(cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block;\n    }\n\n    const cidStr = cid.toString(base58btc);\n    const entry = this.wantlist.get(cidStr);\n\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority;\n      } // Only change from \"dont cancel\" to \"do cancel\"\n\n\n      if (cancel) {\n        entry.cancel = Boolean(cancel);\n      } // Only change from \"dont send\" to \"do send\" DONT_HAVE\n\n\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave);\n      } // want-block overrides existing want-have\n\n\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType;\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n\n\n  addBlock(cid, block) {\n    const cidStr = cid.toString(base58btc);\n    this.blocks.set(cidStr, block);\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  addHave(cid) {\n    const cidStr = cid.toString(base58btc);\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n    }\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  addDontHave(cid) {\n    const cidStr = cid.toString(base58btc);\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n    }\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  cancel(cid) {\n    const cidStr = cid.toString(base58btc);\n    this.wantlist.delete(cidStr);\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n  }\n  /**\n   * @param {number} size\n   */\n\n\n  setPendingBytes(size) {\n    this.pendingBytes = size;\n  }\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  serializeToBitswap100() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    };\n    return Message.encode(msg).finish();\n  }\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  serializeToBitswap110() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    };\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr);\n      const codec = Uint8Array.from([cid.code]);\n      const multihash = cid.multihash.bytes.subarray(0, 2);\n      const prefix = uint8ArrayConcat([[cid.version], codec, multihash], 1 + codec.byteLength + multihash.byteLength);\n      msg.payload.push(new Message.Block({\n        prefix,\n        data\n      }));\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }));\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes;\n    }\n\n    return Message.encode(msg).finish();\n  }\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || // @TODO - Is this a bug ?\n    // @ts-expect-error - isMap equals map values to be objects not numbers\n    !isMapEqual(this.blockPresences, other.blockPresences)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    const list = Array.from(this.wantlist.keys());\n    const blocks = Array.from(this.blocks.keys());\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n  }\n\n}\n/**\n * @param {Uint8Array} raw\n * @param {Record<number, MultihashHasher>} [hashers]\n */\n\n\nBitswapMessage.deserialize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (raw, hashers = {}) {\n    const decoded = Message.decode(raw);\n    const isFull = decoded.wantlist && decoded.wantlist.full || false;\n    const msg = new BitswapMessage(isFull);\n\n    if (decoded.wantlist && decoded.wantlist.entries) {\n      decoded.wantlist.entries.forEach(entry => {\n        if (!entry.block) {\n          return;\n        } // note: entry.block is the CID here\n\n\n        const cid = CID.decode(entry.block);\n        msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n      });\n    }\n\n    if (decoded.blockPresences) {\n      decoded.blockPresences.forEach(blockPresence => {\n        if (!blockPresence.cid) {\n          return;\n        }\n\n        const cid = CID.decode(blockPresence.cid);\n\n        if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n          msg.addHave(cid);\n        } else {\n          msg.addDontHave(cid);\n        }\n      });\n    } // Bitswap 1.0.0\n    // decoded.blocks are just the byte arrays\n\n\n    if (decoded.blocks.length > 0) {\n      yield Promise.all(decoded.blocks.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (b) {\n          const hash = yield sha256.digest(b);\n          const cid = CID.createV0(hash);\n          msg.addBlock(cid, b);\n        });\n\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      return msg;\n    } // Bitswap 1.1.0\n\n\n    if (decoded.payload.length > 0) {\n      yield Promise.all(decoded.payload.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (p) {\n          if (!p.prefix || !p.data) {\n            return;\n          }\n\n          const values = vd(p.prefix);\n          const cidVersion = values[0];\n          const multicodec = values[1];\n          const hashAlg = values[2];\n          const hasher = hashAlg === sha256.code ? sha256 : hashers[hashAlg];\n\n          if (!hasher) {\n            throw errcode(new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG');\n          } // const hashLen = values[3] // We haven't need to use this so far\n\n\n          const hash = yield hasher.digest(p.data);\n          const cid = CID.create(cidVersion, multicodec, hash);\n          msg.addBlock(cid, p.data);\n        });\n\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      msg.setPendingBytes(decoded.pendingBytes);\n      return msg;\n    }\n\n    return msg;\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {CID} cid\n */\n\n\nBitswapMessage.blockPresenceSize = cid => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1;\n};\n\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};\nmodule.exports = BitswapMessage;","map":null,"metadata":{},"sourceType":"script"}