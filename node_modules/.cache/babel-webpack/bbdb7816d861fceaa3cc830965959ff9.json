{"ast":null,"code":"'use strict'; // @ts-ignore - TODO vmx 2021-03-31\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils');\n\nconst errCode = require('err-code');\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\n\n\nconst removeLink = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (context, options) {\n    let parent = options.parent;\n\n    if (options.parentCid) {\n      const parentCid = CID.asCID(options.parentCid);\n\n      if (parentCid === null) {\n        throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n      }\n\n      log(`Loading parent node ${parentCid}`);\n      const block = yield context.repo.blocks.get(parentCid);\n      parent = dagPb.decode(block);\n    }\n\n    if (!parent) {\n      throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n    }\n\n    if (!options.name) {\n      throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n    }\n\n    if (!parent.Data) {\n      throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n    }\n\n    const meta = UnixFS.unmarshal(parent.Data);\n\n    if (meta.type === 'hamt-sharded-directory') {\n      log(`Removing ${options.name} from sharded directory`);\n      return removeFromShardedDirectory(context, { ...options,\n        parent\n      });\n    }\n\n    log(`Removing link ${options.name} regular directory`);\n    return removeFromDirectory(context, { ...options,\n      parent\n    });\n  });\n\n  return function removeLink(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst removeFromDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (context, options) {\n    // Remove existing link if it exists\n    options.parent.Links = options.parent.Links.filter(link => {\n      return link.Name !== options.name;\n    });\n    const parentBlock = yield dagPb.encode(options.parent);\n    const hasher = yield context.hashers.getHasher(options.hashAlg);\n    const hash = yield hasher.digest(parentBlock);\n    const parentCid = CID.create(options.cidVersion, dagPb.code, hash);\n    yield context.repo.blocks.put(parentCid, parentBlock);\n    log(`Updated regular directory ${parentCid}`);\n    return {\n      node: options.parent,\n      cid: parentCid\n    };\n  });\n\n  return function removeFromDirectory(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst removeFromShardedDirectory = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (context, options) {\n    const {\n      rootBucket,\n      path\n    } = yield generatePath(context, options.name, options.parent);\n    yield rootBucket.del(options.name);\n    const {\n      node\n    } = yield updateShard(context, path, options.name, options);\n    return updateHamtDirectory(context, node.Links, rootBucket, options);\n  });\n\n  return function removeFromShardedDirectory(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\n\n\nconst updateShard = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (context, positions, name, options) {\n    const last = positions.pop();\n\n    if (!last) {\n      throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n    }\n\n    const {\n      bucket,\n      prefix,\n      node\n    } = last;\n\n    if (!node) {\n      throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n    }\n\n    const link = node.Links.find(link => (link.Name || '').substring(0, 2) === prefix);\n\n    if (!link) {\n      throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND');\n    }\n\n    if (link.Name === `${prefix}${name}`) {\n      log(`Removing existing link ${link.Name}`);\n      const links = node.Links.filter(nodeLink => {\n        return nodeLink.Name !== link.Name;\n      });\n      yield bucket.del(name);\n      return updateHamtDirectory(context, links, bucket, options);\n    }\n\n    log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`);\n    const result = yield updateShard(context, positions, name, options);\n    let cid = result.cid;\n    let size = result.size;\n    let newName = prefix;\n\n    if (result.node.Links.length === 1) {\n      log(`Removing subshard for ${prefix}`); // convert shard back to normal dir\n\n      const link = result.node.Links[0];\n      newName = `${prefix}${(link.Name || '').substring(2)}`;\n      cid = link.Hash;\n      size = link.Tsize || 0;\n    }\n\n    log(`Updating shard ${prefix} with name ${newName}`);\n    return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);\n  });\n\n  return function updateShard(_x7, _x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter(link => {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return updateHamtDirectory(context, parentLinks, bucket, options);\n};\n\nmodule.exports = removeLink;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/components/files/utils/remove-link.js"],"names":["dagPb","require","CID","log","UnixFS","generatePath","updateHamtDirectory","errCode","removeLink","context","options","parent","parentCid","asCID","Error","block","repo","blocks","get","decode","name","Data","meta","unmarshal","type","removeFromShardedDirectory","removeFromDirectory","Links","filter","link","Name","parentBlock","encode","hasher","hashers","getHasher","hashAlg","hash","digest","create","cidVersion","code","put","node","cid","rootBucket","path","del","updateShard","positions","last","pop","bucket","prefix","find","substring","links","nodeLink","result","size","newName","length","Hash","Tsize","updateShardParent","oldName","parentLinks","push","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// @ts-ignore - TODO vmx 2021-03-31\nconst dagPb = require('@ipld/dag-pb')\nconst { CID } = require('multiformats/cid')\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link')\nconst { UnixFS } = require('ipfs-unixfs')\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils')\nconst errCode = require('err-code')\n\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\nconst removeLink = async (context, options) => {\n  let parent = options.parent\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid)\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n    }\n\n    log(`Loading parent node ${parentCid}`)\n    const block = await context.repo.blocks.get(parentCid)\n    parent = dagPb.decode(block)\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE')\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, {\n      ...options,\n      parent\n    })\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, {\n    ...options,\n    parent\n  })\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter((link) => {\n    return link.Name !== options.name\n  })\n\n  const parentBlock = await dagPb.encode(options.parent)\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n  const hash = await hasher.digest(parentBlock)\n  const parentCid = CID.create(options.cidVersion, dagPb.code, hash)\n\n  await context.repo.blocks.put(parentCid, parentBlock)\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: options.parent,\n    cid: parentCid\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, options.name, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop()\n\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last\n\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const link = node.Links\n    .find(link => (link.Name || '').substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    const links = node.Links.filter((nodeLink) => {\n      return nodeLink.Name !== link.Name\n    })\n\n    await bucket.del(name)\n\n    return updateHamtDirectory(context, links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`)\n\n  const result = await updateShard(context, positions, name, options)\n\n  let cid = result.cid\n  let size = result.size\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    const link = result.node.Links[0]\n\n    newName = `${prefix}${(link.Name || '').substring(2)}`\n    cid = link.Hash\n    size = link.Tsize || 0\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter((link) => {\n    return link.Name !== oldName\n  })\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  })\n\n  return updateHamtDirectory(context, parentLinks, bucket, options)\n}\n\nmodule.exports = removeLink\n"]},"metadata":{},"sourceType":"script"}