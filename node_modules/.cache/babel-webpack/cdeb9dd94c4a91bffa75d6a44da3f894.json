{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst loadMfsRoot = require('./with-mfs-root');\n\nconst toPathComponents = require('./to-path-components');\n\nconst {\n  exporter\n} = require('ipfs-unixfs-exporter');\n\nconst errCode = require('err-code');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst IPFS_PREFIX = 'ipfs';\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\n\nconst toMfsPath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (context, path, options) {\n    const root = yield loadMfsRoot(context, options);\n    /** @type {MfsPath} */\n    // @ts-ignore fields get set later\n\n    let output = {\n      entryType: 'file'\n    };\n    let ipfsPath = '';\n\n    if (path instanceof CID) {\n      ipfsPath = `/ipfs/${path}`;\n    } else {\n      ipfsPath = path;\n    }\n\n    ipfsPath = ipfsPath.trim();\n    ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/');\n\n    if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n      ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n    }\n\n    if (!ipfsPath) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n    }\n\n    if (ipfsPath.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n      ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n    }\n\n    const pathComponents = toPathComponents(ipfsPath);\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory;\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `/${pathComponents.join('/')}`;\n      } else {\n        mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n      } // @ts-ignore fields being set\n\n\n      output = {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n        entryType: 'file',\n        mfsPath: `/${pathComponents.join('/')}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      };\n    } else {\n      const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`;\n      const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`; // @ts-ignore fields being set\n\n      output = {\n        type: 'mfs',\n        depth: pathComponents.length,\n        entryType: 'file',\n        mfsDirectory,\n        mfsPath,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      };\n    }\n\n    const cidPath = output.type === 'mfs' ? output.mfsPath : output.path;\n\n    try {\n      const res = yield exporter(cidPath, context.repo.blocks, options);\n      output.cid = res.cid;\n      output.mfsPath = `/ipfs/${res.path}`;\n      output.entryType = res.type;\n      output.content = res.content;\n\n      if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n        output.unixfs = res.unixfs;\n      }\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    }\n\n    output.exists = Boolean(output.cid);\n    return output;\n  });\n\n  return function toMfsPath(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = toMfsPath;","map":null,"metadata":{},"sourceType":"script"}