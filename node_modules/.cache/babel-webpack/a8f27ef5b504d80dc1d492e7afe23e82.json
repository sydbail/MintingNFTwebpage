{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst connect = require('it-ws/client');\n\nconst withIs = require('class-is');\n\nconst toUri = require('multiaddr-to-uri');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst pDefer = require('p-defer');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:websockets');\nlog.error = debug('libp2p:websockets:error');\n\nconst env = require('ipfs-utils/src/env');\n\nconst createListener = require('./listener');\n\nconst toConnection = require('./socket-to-conn');\n\nconst filters = require('./filters');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @class WebSockets\n */\n\n\nclass WebSockets {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   * @param {(multiaddrs: Array<Multiaddr>) => Array<Multiaddr>} options.filter - override transport addresses filter\n   */\n  constructor({\n    upgrader,\n    filter\n  }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');\n    }\n\n    this._upgrader = upgrader;\n    this._filter = filter;\n  }\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n\n\n  dial(ma, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      log('dialing %s', ma);\n      const socket = yield _this._connect(ma, options);\n      const maConn = toConnection(socket, {\n        remoteAddr: ma,\n        signal: options.signal\n      });\n      log('new outbound connection %s', maConn.remoteAddr);\n      const conn = yield _this._upgrader.upgradeOutbound(maConn);\n      log('outbound connection %s upgraded', maConn.remoteAddr);\n      return conn;\n    })();\n  }\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n\n\n  _connect(ma, options = {}) {\n    return _asyncToGenerator(function* () {\n      if (options.signal && options.signal.aborted) {\n        throw new AbortError();\n      }\n\n      const cOpts = ma.toOptions();\n      log('dialing %s:%s', cOpts.host, cOpts.port);\n      const errorPromise = pDefer();\n\n      const errfn = err => {\n        const msg = `connection error: ${err.message}`;\n        log.error(msg);\n        errorPromise.reject(err);\n      };\n\n      const rawSocket = connect(toUri(ma), Object.assign({\n        binary: true\n      }, options));\n\n      if (rawSocket.socket.on) {\n        rawSocket.socket.on('error', errfn);\n      } else {\n        rawSocket.socket.onerror = errfn;\n      }\n\n      if (!options.signal) {\n        yield Promise.race([rawSocket.connected(), errorPromise.promise]);\n        log('connected %s', ma);\n        return rawSocket;\n      } // Allow abort via signal during connect\n\n\n      let onAbort;\n      const abort = new Promise((resolve, reject) => {\n        onAbort = () => {\n          reject(new AbortError()); // FIXME: https://github.com/libp2p/js-libp2p-websockets/issues/121\n\n          setTimeout(() => {\n            rawSocket.close();\n          });\n        }; // Already aborted?\n\n\n        if (options.signal.aborted) return onAbort();\n        options.signal.addEventListener('abort', onAbort);\n      });\n\n      try {\n        yield Promise.race([abort, errorPromise.promise, rawSocket.connected()]);\n      } finally {\n        options.signal.removeEventListener('abort', onAbort);\n      }\n\n      log('connected %s', ma);\n      return rawSocket;\n    })();\n  }\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   *\n   * @param {object} [options]\n   * @param {http.Server} [options.server] - A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n\n\n  createListener(options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    }\n\n    return createListener({\n      handler,\n      upgrader: this._upgrader\n    }, options);\n  }\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n\n    if (this._filter) {\n      return this._filter(multiaddrs);\n    } // Browser\n\n\n    if (env.isBrowser || env.isWebWorker) {\n      return filters.dnsWss(multiaddrs);\n    }\n\n    return filters.all(multiaddrs);\n  }\n\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n});","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-websockets/src/index.js"],"names":["connect","require","withIs","toUri","AbortError","pDefer","debug","log","error","env","createListener","toConnection","filters","WebSockets","constructor","upgrader","filter","Error","_upgrader","_filter","dial","ma","options","socket","_connect","maConn","remoteAddr","signal","conn","upgradeOutbound","aborted","cOpts","toOptions","host","port","errorPromise","errfn","err","msg","message","reject","rawSocket","Object","assign","binary","on","onerror","Promise","race","connected","promise","onAbort","abort","resolve","setTimeout","close","addEventListener","removeEventListener","handler","multiaddrs","Array","isArray","isBrowser","isWebWorker","dnsWss","all","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst connect = require('it-ws/client')\nconst withIs = require('class-is')\nconst toUri = require('multiaddr-to-uri')\nconst { AbortError } = require('abortable-iterator')\nconst pDefer = require('p-defer')\n\nconst debug = require('debug')\nconst log = debug('libp2p:websockets')\nlog.error = debug('libp2p:websockets:error')\nconst env = require('ipfs-utils/src/env')\n\nconst createListener = require('./listener')\nconst toConnection = require('./socket-to-conn')\nconst filters = require('./filters')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @class WebSockets\n */\nclass WebSockets {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   * @param {(multiaddrs: Array<Multiaddr>) => Array<Multiaddr>} options.filter - override transport addresses filter\n   */\n  constructor ({ upgrader, filter }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.')\n    }\n    this._upgrader = upgrader\n    this._filter = filter\n  }\n\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n  async dial (ma, options = {}) {\n    log('dialing %s', ma)\n\n    const socket = await this._connect(ma, options)\n    const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal })\n    log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await this._upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n  async _connect (ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const errorPromise = pDefer()\n    const errfn = (err) => {\n      const msg = `connection error: ${err.message}`\n      log.error(msg)\n\n      errorPromise.reject(err)\n    }\n\n    const rawSocket = connect(toUri(ma), Object.assign({ binary: true }, options))\n\n    if (rawSocket.socket.on) {\n      rawSocket.socket.on('error', errfn)\n    } else {\n      rawSocket.socket.onerror = errfn\n    }\n\n    if (!options.signal) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise])\n\n      log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        // FIXME: https://github.com/libp2p/js-libp2p-websockets/issues/121\n        setTimeout(() => {\n          rawSocket.close()\n        })\n      }\n\n      // Already aborted?\n      if (options.signal.aborted) return onAbort()\n      options.signal.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()])\n    } finally {\n      options.signal.removeEventListener('abort', onAbort)\n    }\n\n    log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   *\n   * @param {object} [options]\n   * @param {http.Server} [options.server] - A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n  createListener (options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    return createListener({ handler, upgrader: this._upgrader }, options)\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n  filter (multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    if (this._filter) {\n      return this._filter(multiaddrs)\n    }\n\n    // Browser\n    if (env.isBrowser || env.isWebWorker) {\n      return filters.dnsWss(multiaddrs)\n    }\n\n    return filters.all(multiaddrs)\n  }\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n})\n"]},"metadata":{},"sourceType":"script"}