{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst debug = require('debug');\n\nconst PeerId = require('peer-id');\n\nconst drain = require('it-drain');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst defer = require('p-defer');\n\nconst log = debug('libp2p-delegated-content-routing');\nlog.error = debug('libp2p-delegated-content-routing:error');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\n\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor(peerId, client) {\n    if (peerId == null) {\n      throw new Error('missing self peerId');\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client;\n    this.peerId = peerId; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    const concurrency = {\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    };\n    this._httpQueue = new PQueue(concurrency); // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }));\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`);\n  }\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n\n\n  findProviders(key, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      log(`findProviders starts: ${key}`);\n      options.timeout = options.timeout || DEFAULT_TIMEOUT;\n      let providers = 0;\n      const onStart = defer();\n      const onFinish = defer();\n\n      _this._httpQueue.add(() => {\n        onStart.resolve();\n        return onFinish.promise;\n      });\n\n      try {\n        yield _awaitAsyncGenerator(onStart.promise);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(_this._client.dht.findProvs(key, {\n            numProviders: options.numProviders,\n            timeout: options.timeout\n          })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const {\n              id,\n              addrs\n            } = _value;\n            yield {\n              id: PeerId.parse(id),\n              multiaddrs: addrs\n            };\n            providers++;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } catch (err) {\n        log.error('findProviders errored:', err);\n        throw err;\n      } finally {\n        onFinish.resolve();\n        log(`findProviders finished: ${key} found ${providers} providers`);\n      }\n    })();\n  }\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   *\n   * @param {CID} key - The delegate will publish a provider record for this CID\n   * @returns {Promise<void>}\n   */\n\n\n  provide(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      log(`provide starts: ${key}`);\n      yield _this2._httpQueueRefs.add( /*#__PURE__*/_asyncToGenerator(function* () {\n        yield _this2._client.block.stat(key);\n        yield drain(_this2._client.dht.provide(key));\n      }));\n      log(`provide finished: ${key}`);\n    })();\n  }\n\n}\n\nmodule.exports = DelegatedContentRouting;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/libp2p-delegated-content-routing/src/index.js"],"names":["debug","require","PeerId","drain","default","PQueue","defer","log","error","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","DelegatedContentRouting","constructor","peerId","client","Error","_client","concurrency","_httpQueue","_httpQueueRefs","Object","assign","protocol","host","port","getEndpointConfig","findProviders","key","options","timeout","providers","onStart","onFinish","add","resolve","promise","dht","findProvs","numProviders","id","addrs","parse","multiaddrs","err","provide","block","stat","module","exports"],"mappings":"AAAA;;;;;;;;;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,UAAD,CAArB;;AAEA,MAAM;AAAEG,EAAAA,OAAO,EAAEC;AAAX,IAAsBJ,OAAO,CAAC,SAAD,CAAnC;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,SAAD,CAArB;;AAEA,MAAMM,GAAG,GAAGP,KAAK,CAAC,kCAAD,CAAjB;AACAO,GAAG,CAACC,KAAJ,GAAYR,KAAK,CAAC,wCAAD,CAAjB;AAEA,MAAMS,eAAe,GAAG,IAAxB,C,CAA6B;;AAC7B,MAAMC,wBAAwB,GAAG,CAAjC;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA,MAAMC,uBAAN,CAA8B;AAC5B;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAAEC,MAAF,EAAUC,MAAV,EAAkB;AAC3B,QAAID,MAAM,IAAI,IAAd,EAAoB;AAClB,YAAM,IAAIE,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,QAAID,MAAM,IAAI,IAAd,EAAoB;AAClB,YAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;AACD;;AAED,SAAKC,OAAL,GAAeF,MAAf;AACA,SAAKD,MAAL,GAAcA,MAAd,CAV2B,CAY3B;AACA;;AACA,UAAMI,WAAW,GAAG;AAAEA,MAAAA,WAAW,EAAEP;AAAf,KAApB;AACA,SAAKQ,UAAL,GAAkB,IAAIb,MAAJ,CAAWY,WAAX,CAAlB,CAf2B,CAgB3B;AACA;;AACA,SAAKE,cAAL,GAAsB,IAAId,MAAJ,CAAWe,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,WAAlB,EAA+B;AAC9DA,MAAAA,WAAW,EAAE;AADiD,KAA/B,CAAX,CAAtB;AAIA,UAAM;AACJK,MAAAA,QADI;AAEJC,MAAAA,IAFI;AAGJC,MAAAA;AAHI,QAIFV,MAAM,CAACW,iBAAP,EAJJ;AAMAlB,IAAAA,GAAG,CAAE,uCAAsCe,QAAS,MAAKC,IAAK,IAAGC,IAAK,EAAnE,CAAH;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUE,EAAAA,aAAa,CAAEC,GAAF,EAAOC,OAAO,GAAG,EAAjB,EAAqB;AAAA;;AAAA;AACxCrB,MAAAA,GAAG,CAAE,yBAAwBoB,GAAI,EAA9B,CAAH;AACAC,MAAAA,OAAO,CAACC,OAAR,GAAkBD,OAAO,CAACC,OAAR,IAAmBpB,eAArC;AAEA,UAAIqB,SAAS,GAAG,CAAhB;AACA,YAAMC,OAAO,GAAGzB,KAAK,EAArB;AACA,YAAM0B,QAAQ,GAAG1B,KAAK,EAAtB;;AAEA,MAAA,KAAI,CAACY,UAAL,CAAgBe,GAAhB,CAAoB,MAAM;AACxBF,QAAAA,OAAO,CAACG,OAAR;AACA,eAAOF,QAAQ,CAACG,OAAhB;AACD,OAHD;;AAKA,UAAI;AACF,mCAAMJ,OAAO,CAACI,OAAd;AADE;AAAA;;AAAA;;AAAA;AAGF,8CAAkC,KAAI,CAACnB,OAAL,CAAaoB,GAAb,CAAiBC,SAAjB,CAA2BV,GAA3B,EAAgC;AAChEW,YAAAA,YAAY,EAAEV,OAAO,CAACU,YAD0C;AAEhET,YAAAA,OAAO,EAAED,OAAO,CAACC;AAF+C,WAAhC,CAAlC,gOAGI;AAAA,kBAHa;AAAEU,cAAAA,EAAF;AAAMC,cAAAA;AAAN,aAGb;AACF,kBAAM;AACJD,cAAAA,EAAE,EAAErC,MAAM,CAACuC,KAAP,CAAaF,EAAb,CADA;AAEJG,cAAAA,UAAU,EAAEF;AAFR,aAAN;AAIAV,YAAAA,SAAS;AACV;AAZC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaH,OAbD,CAaE,OAAOa,GAAP,EAAY;AACZpC,QAAAA,GAAG,CAACC,KAAJ,CAAU,wBAAV,EAAoCmC,GAApC;AACA,cAAMA,GAAN;AACD,OAhBD,SAgBU;AACRX,QAAAA,QAAQ,CAACE,OAAT;AACA3B,QAAAA,GAAG,CAAE,2BAA0BoB,GAAI,UAASG,SAAU,YAAnD,CAAH;AACD;AAhCuC;AAiCzC;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQc,EAAAA,OAAO,CAAEjB,GAAF,EAAO;AAAA;;AAAA;AAClBpB,MAAAA,GAAG,CAAE,mBAAkBoB,GAAI,EAAxB,CAAH;AACA,YAAM,MAAI,CAACR,cAAL,CAAoBc,GAApB,iCAAwB,aAAY;AACxC,cAAM,MAAI,CAACjB,OAAL,CAAa6B,KAAb,CAAmBC,IAAnB,CAAwBnB,GAAxB,CAAN;AACA,cAAMxB,KAAK,CAAC,MAAI,CAACa,OAAL,CAAaoB,GAAb,CAAiBQ,OAAjB,CAAyBjB,GAAzB,CAAD,CAAX;AACD,OAHK,EAAN;AAIApB,MAAAA,GAAG,CAAE,qBAAoBoB,GAAI,EAA1B,CAAH;AANkB;AAOnB;;AA1G2B;;AA6G9BoB,MAAM,CAACC,OAAP,GAAiBrC,uBAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst PeerId = require('peer-id')\nconst drain = require('it-drain')\n\nconst { default: PQueue } = require('p-queue')\nconst defer = require('p-defer')\n\nconst log = debug('libp2p-delegated-content-routing')\nlog.error = debug('libp2p-delegated-content-routing:error')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor (peerId, client) {\n    if (peerId == null) {\n      throw new Error('missing self peerId')\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this._client = client\n    this.peerId = peerId\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    const concurrency = { concurrency: CONCURRENT_HTTP_REQUESTS }\n    this._httpQueue = new PQueue(concurrency)\n    // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }))\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`)\n  }\n\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n  async * findProviders (key, options = {}) {\n    log(`findProviders starts: ${key}`)\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    let providers = 0\n    const onStart = defer()\n    const onFinish = defer()\n\n    this._httpQueue.add(() => {\n      onStart.resolve()\n      return onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      for await (const { id, addrs } of this._client.dht.findProvs(key, {\n        numProviders: options.numProviders,\n        timeout: options.timeout\n      })) {\n        yield {\n          id: PeerId.parse(id),\n          multiaddrs: addrs\n        }\n        providers++\n      }\n    } catch (err) {\n      log.error('findProviders errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log(`findProviders finished: ${key} found ${providers} providers`)\n    }\n  }\n\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   *\n   * @param {CID} key - The delegate will publish a provider record for this CID\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    log(`provide starts: ${key}`)\n    await this._httpQueueRefs.add(async () => {\n      await this._client.block.stat(key)\n      await drain(this._client.dht.provide(key))\n    })\n    log(`provide finished: ${key}`)\n  }\n}\n\nmodule.exports = DelegatedContentRouting\n"]},"metadata":{},"sourceType":"script"}