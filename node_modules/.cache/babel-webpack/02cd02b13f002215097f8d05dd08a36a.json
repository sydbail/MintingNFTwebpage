{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-dht-message\"] || ($protobuf.roots[\"libp2p-dht-message\"] = {});\n\n$root.Record = function () {\n  /**\n   * Properties of a Record.\n   * @exports IRecord\n   * @interface IRecord\n   * @property {Uint8Array|null} [key] Record key\n   * @property {Uint8Array|null} [value] Record value\n   * @property {Uint8Array|null} [author] Record author\n   * @property {Uint8Array|null} [signature] Record signature\n   * @property {string|null} [timeReceived] Record timeReceived\n   */\n\n  /**\n   * Constructs a new Record.\n   * @exports Record\n   * @classdesc Represents a Record.\n   * @implements IRecord\n   * @constructor\n   * @param {IRecord=} [p] Properties to set\n   */\n  function Record(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Record key.\n   * @member {Uint8Array|null|undefined} key\n   * @memberof Record\n   * @instance\n   */\n\n\n  Record.prototype.key = null;\n  /**\n   * Record value.\n   * @member {Uint8Array|null|undefined} value\n   * @memberof Record\n   * @instance\n   */\n\n  Record.prototype.value = null;\n  /**\n   * Record author.\n   * @member {Uint8Array|null|undefined} author\n   * @memberof Record\n   * @instance\n   */\n\n  Record.prototype.author = null;\n  /**\n   * Record signature.\n   * @member {Uint8Array|null|undefined} signature\n   * @memberof Record\n   * @instance\n   */\n\n  Record.prototype.signature = null;\n  /**\n   * Record timeReceived.\n   * @member {string|null|undefined} timeReceived\n   * @memberof Record\n   * @instance\n   */\n\n  Record.prototype.timeReceived = null; // OneOf field names bound to virtual getters and setters\n\n  var $oneOfFields;\n  /**\n   * Record _key.\n   * @member {\"key\"|undefined} _key\n   * @memberof Record\n   * @instance\n   */\n\n  Object.defineProperty(Record.prototype, \"_key\", {\n    get: $util.oneOfGetter($oneOfFields = [\"key\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Record _value.\n   * @member {\"value\"|undefined} _value\n   * @memberof Record\n   * @instance\n   */\n\n  Object.defineProperty(Record.prototype, \"_value\", {\n    get: $util.oneOfGetter($oneOfFields = [\"value\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Record _author.\n   * @member {\"author\"|undefined} _author\n   * @memberof Record\n   * @instance\n   */\n\n  Object.defineProperty(Record.prototype, \"_author\", {\n    get: $util.oneOfGetter($oneOfFields = [\"author\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Record _signature.\n   * @member {\"signature\"|undefined} _signature\n   * @memberof Record\n   * @instance\n   */\n\n  Object.defineProperty(Record.prototype, \"_signature\", {\n    get: $util.oneOfGetter($oneOfFields = [\"signature\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Record _timeReceived.\n   * @member {\"timeReceived\"|undefined} _timeReceived\n   * @memberof Record\n   * @instance\n   */\n\n  Object.defineProperty(Record.prototype, \"_timeReceived\", {\n    get: $util.oneOfGetter($oneOfFields = [\"timeReceived\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Encodes the specified Record message. Does not implicitly {@link Record.verify|verify} messages.\n   * @function encode\n   * @memberof Record\n   * @static\n   * @param {IRecord} m Record message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Record.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.key != null && Object.hasOwnProperty.call(m, \"key\")) w.uint32(10).bytes(m.key);\n    if (m.value != null && Object.hasOwnProperty.call(m, \"value\")) w.uint32(18).bytes(m.value);\n    if (m.author != null && Object.hasOwnProperty.call(m, \"author\")) w.uint32(26).bytes(m.author);\n    if (m.signature != null && Object.hasOwnProperty.call(m, \"signature\")) w.uint32(34).bytes(m.signature);\n    if (m.timeReceived != null && Object.hasOwnProperty.call(m, \"timeReceived\")) w.uint32(42).string(m.timeReceived);\n    return w;\n  };\n  /**\n   * Decodes a Record message from the specified reader or buffer.\n   * @function decode\n   * @memberof Record\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Record} Record\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Record.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Record();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.key = r.bytes();\n          break;\n\n        case 2:\n          m.value = r.bytes();\n          break;\n\n        case 3:\n          m.author = r.bytes();\n          break;\n\n        case 4:\n          m.signature = r.bytes();\n          break;\n\n        case 5:\n          m.timeReceived = r.string();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a Record message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Record\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Record} Record\n   */\n\n\n  Record.fromObject = function fromObject(d) {\n    if (d instanceof $root.Record) return d;\n    var m = new $root.Record();\n\n    if (d.key != null) {\n      if (typeof d.key === \"string\") $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);else if (d.key.length) m.key = d.key;\n    }\n\n    if (d.value != null) {\n      if (typeof d.value === \"string\") $util.base64.decode(d.value, m.value = $util.newBuffer($util.base64.length(d.value)), 0);else if (d.value.length) m.value = d.value;\n    }\n\n    if (d.author != null) {\n      if (typeof d.author === \"string\") $util.base64.decode(d.author, m.author = $util.newBuffer($util.base64.length(d.author)), 0);else if (d.author.length) m.author = d.author;\n    }\n\n    if (d.signature != null) {\n      if (typeof d.signature === \"string\") $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);else if (d.signature.length) m.signature = d.signature;\n    }\n\n    if (d.timeReceived != null) {\n      m.timeReceived = String(d.timeReceived);\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a Record message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Record\n   * @static\n   * @param {Record} m Record\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Record.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (m.key != null && m.hasOwnProperty(\"key\")) {\n      d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;\n      if (o.oneofs) d._key = \"key\";\n    }\n\n    if (m.value != null && m.hasOwnProperty(\"value\")) {\n      d.value = o.bytes === String ? $util.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;\n      if (o.oneofs) d._value = \"value\";\n    }\n\n    if (m.author != null && m.hasOwnProperty(\"author\")) {\n      d.author = o.bytes === String ? $util.base64.encode(m.author, 0, m.author.length) : o.bytes === Array ? Array.prototype.slice.call(m.author) : m.author;\n      if (o.oneofs) d._author = \"author\";\n    }\n\n    if (m.signature != null && m.hasOwnProperty(\"signature\")) {\n      d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;\n      if (o.oneofs) d._signature = \"signature\";\n    }\n\n    if (m.timeReceived != null && m.hasOwnProperty(\"timeReceived\")) {\n      d.timeReceived = m.timeReceived;\n      if (o.oneofs) d._timeReceived = \"timeReceived\";\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Record to JSON.\n   * @function toJSON\n   * @memberof Record\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Record.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Record;\n}();\n\n$root.Message = function () {\n  /**\n   * Properties of a Message.\n   * @exports IMessage\n   * @interface IMessage\n   * @property {Message.MessageType|null} [type] Message type\n   * @property {number|null} [clusterLevelRaw] Message clusterLevelRaw\n   * @property {Uint8Array|null} [key] Message key\n   * @property {Uint8Array|null} [record] Message record\n   * @property {Array.<Message.IPeer>|null} [closerPeers] Message closerPeers\n   * @property {Array.<Message.IPeer>|null} [providerPeers] Message providerPeers\n   */\n\n  /**\n   * Constructs a new Message.\n   * @exports Message\n   * @classdesc Represents a Message.\n   * @implements IMessage\n   * @constructor\n   * @param {IMessage=} [p] Properties to set\n   */\n  function Message(p) {\n    this.closerPeers = [];\n    this.providerPeers = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Message type.\n   * @member {Message.MessageType|null|undefined} type\n   * @memberof Message\n   * @instance\n   */\n\n\n  Message.prototype.type = null;\n  /**\n   * Message clusterLevelRaw.\n   * @member {number|null|undefined} clusterLevelRaw\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.clusterLevelRaw = null;\n  /**\n   * Message key.\n   * @member {Uint8Array|null|undefined} key\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.key = null;\n  /**\n   * Message record.\n   * @member {Uint8Array|null|undefined} record\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.record = null;\n  /**\n   * Message closerPeers.\n   * @member {Array.<Message.IPeer>} closerPeers\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.closerPeers = $util.emptyArray;\n  /**\n   * Message providerPeers.\n   * @member {Array.<Message.IPeer>} providerPeers\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.providerPeers = $util.emptyArray; // OneOf field names bound to virtual getters and setters\n\n  var $oneOfFields;\n  /**\n   * Message _type.\n   * @member {\"type\"|undefined} _type\n   * @memberof Message\n   * @instance\n   */\n\n  Object.defineProperty(Message.prototype, \"_type\", {\n    get: $util.oneOfGetter($oneOfFields = [\"type\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Message _clusterLevelRaw.\n   * @member {\"clusterLevelRaw\"|undefined} _clusterLevelRaw\n   * @memberof Message\n   * @instance\n   */\n\n  Object.defineProperty(Message.prototype, \"_clusterLevelRaw\", {\n    get: $util.oneOfGetter($oneOfFields = [\"clusterLevelRaw\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Message _key.\n   * @member {\"key\"|undefined} _key\n   * @memberof Message\n   * @instance\n   */\n\n  Object.defineProperty(Message.prototype, \"_key\", {\n    get: $util.oneOfGetter($oneOfFields = [\"key\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Message _record.\n   * @member {\"record\"|undefined} _record\n   * @memberof Message\n   * @instance\n   */\n\n  Object.defineProperty(Message.prototype, \"_record\", {\n    get: $util.oneOfGetter($oneOfFields = [\"record\"]),\n    set: $util.oneOfSetter($oneOfFields)\n  });\n  /**\n   * Encodes the specified Message message. Does not implicitly {@link Message.verify|verify} messages.\n   * @function encode\n   * @memberof Message\n   * @static\n   * @param {IMessage} m Message message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Message.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.type != null && Object.hasOwnProperty.call(m, \"type\")) w.uint32(8).int32(m.type);\n    if (m.key != null && Object.hasOwnProperty.call(m, \"key\")) w.uint32(18).bytes(m.key);\n    if (m.record != null && Object.hasOwnProperty.call(m, \"record\")) w.uint32(26).bytes(m.record);\n\n    if (m.closerPeers != null && m.closerPeers.length) {\n      for (var i = 0; i < m.closerPeers.length; ++i) $root.Message.Peer.encode(m.closerPeers[i], w.uint32(66).fork()).ldelim();\n    }\n\n    if (m.providerPeers != null && m.providerPeers.length) {\n      for (var i = 0; i < m.providerPeers.length; ++i) $root.Message.Peer.encode(m.providerPeers[i], w.uint32(74).fork()).ldelim();\n    }\n\n    if (m.clusterLevelRaw != null && Object.hasOwnProperty.call(m, \"clusterLevelRaw\")) w.uint32(80).int32(m.clusterLevelRaw);\n    return w;\n  };\n  /**\n   * Decodes a Message message from the specified reader or buffer.\n   * @function decode\n   * @memberof Message\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Message} Message\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Message.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Message();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.type = r.int32();\n          break;\n\n        case 10:\n          m.clusterLevelRaw = r.int32();\n          break;\n\n        case 2:\n          m.key = r.bytes();\n          break;\n\n        case 3:\n          m.record = r.bytes();\n          break;\n\n        case 8:\n          if (!(m.closerPeers && m.closerPeers.length)) m.closerPeers = [];\n          m.closerPeers.push($root.Message.Peer.decode(r, r.uint32()));\n          break;\n\n        case 9:\n          if (!(m.providerPeers && m.providerPeers.length)) m.providerPeers = [];\n          m.providerPeers.push($root.Message.Peer.decode(r, r.uint32()));\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a Message message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Message\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Message} Message\n   */\n\n\n  Message.fromObject = function fromObject(d) {\n    if (d instanceof $root.Message) return d;\n    var m = new $root.Message();\n\n    switch (d.type) {\n      case \"PUT_VALUE\":\n      case 0:\n        m.type = 0;\n        break;\n\n      case \"GET_VALUE\":\n      case 1:\n        m.type = 1;\n        break;\n\n      case \"ADD_PROVIDER\":\n      case 2:\n        m.type = 2;\n        break;\n\n      case \"GET_PROVIDERS\":\n      case 3:\n        m.type = 3;\n        break;\n\n      case \"FIND_NODE\":\n      case 4:\n        m.type = 4;\n        break;\n\n      case \"PING\":\n      case 5:\n        m.type = 5;\n        break;\n    }\n\n    if (d.clusterLevelRaw != null) {\n      m.clusterLevelRaw = d.clusterLevelRaw | 0;\n    }\n\n    if (d.key != null) {\n      if (typeof d.key === \"string\") $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);else if (d.key.length) m.key = d.key;\n    }\n\n    if (d.record != null) {\n      if (typeof d.record === \"string\") $util.base64.decode(d.record, m.record = $util.newBuffer($util.base64.length(d.record)), 0);else if (d.record.length) m.record = d.record;\n    }\n\n    if (d.closerPeers) {\n      if (!Array.isArray(d.closerPeers)) throw TypeError(\".Message.closerPeers: array expected\");\n      m.closerPeers = [];\n\n      for (var i = 0; i < d.closerPeers.length; ++i) {\n        if (typeof d.closerPeers[i] !== \"object\") throw TypeError(\".Message.closerPeers: object expected\");\n        m.closerPeers[i] = $root.Message.Peer.fromObject(d.closerPeers[i]);\n      }\n    }\n\n    if (d.providerPeers) {\n      if (!Array.isArray(d.providerPeers)) throw TypeError(\".Message.providerPeers: array expected\");\n      m.providerPeers = [];\n\n      for (var i = 0; i < d.providerPeers.length; ++i) {\n        if (typeof d.providerPeers[i] !== \"object\") throw TypeError(\".Message.providerPeers: object expected\");\n        m.providerPeers[i] = $root.Message.Peer.fromObject(d.providerPeers[i]);\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a Message message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Message\n   * @static\n   * @param {Message} m Message\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Message.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.arrays || o.defaults) {\n      d.closerPeers = [];\n      d.providerPeers = [];\n    }\n\n    if (m.type != null && m.hasOwnProperty(\"type\")) {\n      d.type = o.enums === String ? $root.Message.MessageType[m.type] : m.type;\n      if (o.oneofs) d._type = \"type\";\n    }\n\n    if (m.key != null && m.hasOwnProperty(\"key\")) {\n      d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;\n      if (o.oneofs) d._key = \"key\";\n    }\n\n    if (m.record != null && m.hasOwnProperty(\"record\")) {\n      d.record = o.bytes === String ? $util.base64.encode(m.record, 0, m.record.length) : o.bytes === Array ? Array.prototype.slice.call(m.record) : m.record;\n      if (o.oneofs) d._record = \"record\";\n    }\n\n    if (m.closerPeers && m.closerPeers.length) {\n      d.closerPeers = [];\n\n      for (var j = 0; j < m.closerPeers.length; ++j) {\n        d.closerPeers[j] = $root.Message.Peer.toObject(m.closerPeers[j], o);\n      }\n    }\n\n    if (m.providerPeers && m.providerPeers.length) {\n      d.providerPeers = [];\n\n      for (var j = 0; j < m.providerPeers.length; ++j) {\n        d.providerPeers[j] = $root.Message.Peer.toObject(m.providerPeers[j], o);\n      }\n    }\n\n    if (m.clusterLevelRaw != null && m.hasOwnProperty(\"clusterLevelRaw\")) {\n      d.clusterLevelRaw = m.clusterLevelRaw;\n      if (o.oneofs) d._clusterLevelRaw = \"clusterLevelRaw\";\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Message to JSON.\n   * @function toJSON\n   * @memberof Message\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Message.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  /**\n   * MessageType enum.\n   * @name Message.MessageType\n   * @enum {number}\n   * @property {number} PUT_VALUE=0 PUT_VALUE value\n   * @property {number} GET_VALUE=1 GET_VALUE value\n   * @property {number} ADD_PROVIDER=2 ADD_PROVIDER value\n   * @property {number} GET_PROVIDERS=3 GET_PROVIDERS value\n   * @property {number} FIND_NODE=4 FIND_NODE value\n   * @property {number} PING=5 PING value\n   */\n\n\n  Message.MessageType = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"PUT_VALUE\"] = 0;\n    values[valuesById[1] = \"GET_VALUE\"] = 1;\n    values[valuesById[2] = \"ADD_PROVIDER\"] = 2;\n    values[valuesById[3] = \"GET_PROVIDERS\"] = 3;\n    values[valuesById[4] = \"FIND_NODE\"] = 4;\n    values[valuesById[5] = \"PING\"] = 5;\n    return values;\n  }();\n  /**\n   * ConnectionType enum.\n   * @name Message.ConnectionType\n   * @enum {number}\n   * @property {number} NOT_CONNECTED=0 NOT_CONNECTED value\n   * @property {number} CONNECTED=1 CONNECTED value\n   * @property {number} CAN_CONNECT=2 CAN_CONNECT value\n   * @property {number} CANNOT_CONNECT=3 CANNOT_CONNECT value\n   */\n\n\n  Message.ConnectionType = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"NOT_CONNECTED\"] = 0;\n    values[valuesById[1] = \"CONNECTED\"] = 1;\n    values[valuesById[2] = \"CAN_CONNECT\"] = 2;\n    values[valuesById[3] = \"CANNOT_CONNECT\"] = 3;\n    return values;\n  }();\n\n  Message.Peer = function () {\n    /**\n     * Properties of a Peer.\n     * @memberof Message\n     * @interface IPeer\n     * @property {Uint8Array|null} [id] Peer id\n     * @property {Array.<Uint8Array>|null} [addrs] Peer addrs\n     * @property {Message.ConnectionType|null} [connection] Peer connection\n     */\n\n    /**\n     * Constructs a new Peer.\n     * @memberof Message\n     * @classdesc Represents a Peer.\n     * @implements IPeer\n     * @constructor\n     * @param {Message.IPeer=} [p] Properties to set\n     */\n    function Peer(p) {\n      this.addrs = [];\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * Peer id.\n     * @member {Uint8Array|null|undefined} id\n     * @memberof Message.Peer\n     * @instance\n     */\n\n\n    Peer.prototype.id = null;\n    /**\n     * Peer addrs.\n     * @member {Array.<Uint8Array>} addrs\n     * @memberof Message.Peer\n     * @instance\n     */\n\n    Peer.prototype.addrs = $util.emptyArray;\n    /**\n     * Peer connection.\n     * @member {Message.ConnectionType|null|undefined} connection\n     * @memberof Message.Peer\n     * @instance\n     */\n\n    Peer.prototype.connection = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * Peer _id.\n     * @member {\"id\"|undefined} _id\n     * @memberof Message.Peer\n     * @instance\n     */\n\n    Object.defineProperty(Peer.prototype, \"_id\", {\n      get: $util.oneOfGetter($oneOfFields = [\"id\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Peer _connection.\n     * @member {\"connection\"|undefined} _connection\n     * @memberof Message.Peer\n     * @instance\n     */\n\n    Object.defineProperty(Peer.prototype, \"_connection\", {\n      get: $util.oneOfGetter($oneOfFields = [\"connection\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Encodes the specified Peer message. Does not implicitly {@link Message.Peer.verify|verify} messages.\n     * @function encode\n     * @memberof Message.Peer\n     * @static\n     * @param {Message.IPeer} m Peer message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    Peer.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.id != null && Object.hasOwnProperty.call(m, \"id\")) w.uint32(10).bytes(m.id);\n\n      if (m.addrs != null && m.addrs.length) {\n        for (var i = 0; i < m.addrs.length; ++i) w.uint32(18).bytes(m.addrs[i]);\n      }\n\n      if (m.connection != null && Object.hasOwnProperty.call(m, \"connection\")) w.uint32(24).int32(m.connection);\n      return w;\n    };\n    /**\n     * Decodes a Peer message from the specified reader or buffer.\n     * @function decode\n     * @memberof Message.Peer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Message.Peer} Peer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Peer.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.Message.Peer();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.id = r.bytes();\n            break;\n\n          case 2:\n            if (!(m.addrs && m.addrs.length)) m.addrs = [];\n            m.addrs.push(r.bytes());\n            break;\n\n          case 3:\n            m.connection = r.int32();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a Peer message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Message.Peer\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Message.Peer} Peer\n     */\n\n\n    Peer.fromObject = function fromObject(d) {\n      if (d instanceof $root.Message.Peer) return d;\n      var m = new $root.Message.Peer();\n\n      if (d.id != null) {\n        if (typeof d.id === \"string\") $util.base64.decode(d.id, m.id = $util.newBuffer($util.base64.length(d.id)), 0);else if (d.id.length) m.id = d.id;\n      }\n\n      if (d.addrs) {\n        if (!Array.isArray(d.addrs)) throw TypeError(\".Message.Peer.addrs: array expected\");\n        m.addrs = [];\n\n        for (var i = 0; i < d.addrs.length; ++i) {\n          if (typeof d.addrs[i] === \"string\") $util.base64.decode(d.addrs[i], m.addrs[i] = $util.newBuffer($util.base64.length(d.addrs[i])), 0);else if (d.addrs[i].length) m.addrs[i] = d.addrs[i];\n        }\n      }\n\n      switch (d.connection) {\n        case \"NOT_CONNECTED\":\n        case 0:\n          m.connection = 0;\n          break;\n\n        case \"CONNECTED\":\n        case 1:\n          m.connection = 1;\n          break;\n\n        case \"CAN_CONNECT\":\n        case 2:\n          m.connection = 2;\n          break;\n\n        case \"CANNOT_CONNECT\":\n        case 3:\n          m.connection = 3;\n          break;\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a Peer message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Message.Peer\n     * @static\n     * @param {Message.Peer} m Peer\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Peer.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.arrays || o.defaults) {\n        d.addrs = [];\n      }\n\n      if (m.id != null && m.hasOwnProperty(\"id\")) {\n        d.id = o.bytes === String ? $util.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;\n        if (o.oneofs) d._id = \"id\";\n      }\n\n      if (m.addrs && m.addrs.length) {\n        d.addrs = [];\n\n        for (var j = 0; j < m.addrs.length; ++j) {\n          d.addrs[j] = o.bytes === String ? $util.base64.encode(m.addrs[j], 0, m.addrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.addrs[j]) : m.addrs[j];\n        }\n      }\n\n      if (m.connection != null && m.hasOwnProperty(\"connection\")) {\n        d.connection = o.enums === String ? $root.Message.ConnectionType[m.connection] : m.connection;\n        if (o.oneofs) d._connection = \"connection\";\n      }\n\n      return d;\n    };\n    /**\n     * Converts this Peer to JSON.\n     * @function toJSON\n     * @memberof Message.Peer\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Peer.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Peer;\n  }();\n\n  return Message;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}