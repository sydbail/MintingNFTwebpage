{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  findLevelJs\n} = require('../../src/utils');\n\nconst {\n  fromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString\n} = require('uint8arrays/to-string');\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('../../src/types').MigrationProgressCallback} MigrationProgressCallback\n *\n * @typedef {{ type: 'del', key: string | Uint8Array } | { type: 'put', key: string | Uint8Array, value: Uint8Array }} Operation\n * @typedef {function (string, Uint8Array): Operation[]} UpgradeFunction\n * @typedef {function (Uint8Array, Uint8Array): Operation[]} DowngradeFunction\n */\n\n/**\n * @param {string} name\n * @param {Datastore} store\n * @param {(message: string) => void} onProgress\n */\n\n\nfunction keysToBinary(_x, _x2) {\n  return _keysToBinary.apply(this, arguments);\n}\n/**\n * @param {string} name\n * @param {Datastore} store\n * @param {(message: string) => void} onProgress\n */\n\n\nfunction _keysToBinary() {\n  _keysToBinary = _asyncToGenerator(function* (name, store, onProgress = () => {}) {\n    const db = findLevelJs(store); // only interested in level-js\n\n    if (!db) {\n      onProgress(`${name} did not need an upgrade`);\n      return;\n    }\n\n    onProgress(`Upgrading ${name}`);\n    /**\n     * @type {UpgradeFunction}\n     */\n\n    const upgrade = (key, value) => {\n      return [{\n        type: 'del',\n        key: key\n      }, {\n        type: 'put',\n        key: fromString(key),\n        value: value\n      }];\n    };\n\n    yield withEach(db, upgrade);\n  });\n  return _keysToBinary.apply(this, arguments);\n}\n\nfunction keysToStrings(_x3, _x4) {\n  return _keysToStrings.apply(this, arguments);\n}\n/**\n * @param {any} store\n * @returns {Datastore}\n */\n\n\nfunction _keysToStrings() {\n  _keysToStrings = _asyncToGenerator(function* (name, store, onProgress = () => {}) {\n    const db = findLevelJs(store); // only interested in level-js\n\n    if (!db) {\n      onProgress(`${name} did not need a downgrade`);\n      return;\n    }\n\n    onProgress(`Downgrading ${name}`);\n    /**\n     * @type {DowngradeFunction}\n     */\n\n    const downgrade = (key, value) => {\n      return [{\n        type: 'del',\n        key: key\n      }, {\n        type: 'put',\n        key: toString(key),\n        value: value\n      }];\n    };\n\n    yield withEach(db, downgrade);\n  });\n  return _keysToStrings.apply(this, arguments);\n}\n\nfunction unwrap(store) {\n  if (store.child) {\n    return unwrap(store.child);\n  }\n\n  return store;\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\n\n\nfunction process(_x5, _x6, _x7) {\n  return _process.apply(this, arguments);\n}\n/** @type {Migration} */\n\n\nfunction _process() {\n  _process = _asyncToGenerator(function* (backends, onProgress, fn) {\n    /**\n     * @type {{ name: string, store: Datastore }[]}\n     */\n    const datastores = Object.entries(backends).map(([key, backend]) => ({\n      key,\n      backend: unwrap(backend)\n    })).filter(({\n      key,\n      backend\n    }) => backend.constructor.name === 'LevelDatastore').map(({\n      key,\n      backend\n    }) => ({\n      name: key,\n      store: backend\n    }));\n    onProgress(0, `Migrating ${datastores.length} dbs`);\n    let migrated = 0;\n    /**\n     * @param {string} message\n     */\n\n    const progress = message => {\n      onProgress(Math.round(migrated / datastores.length * 100), message);\n    };\n\n    for (const {\n      name,\n      store\n    } of datastores) {\n      yield store.open();\n\n      try {\n        yield fn(name, store, progress);\n      } finally {\n        migrated++;\n        yield store.close();\n      }\n    }\n\n    onProgress(100, `Migrated ${datastores.length} dbs`);\n  });\n  return _process.apply(this, arguments);\n}\n\nmodule.exports = {\n  version: 10,\n  description: 'Migrates datastore-level keys to binary',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keysToBinary);\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keysToStrings);\n  }\n};\n/**\n * Uses the upgrade strategy from level-js@5.x.x - note we can't call the `.upgrade` command\n * directly because it will be removed in level-js@6.x.x and we can't guarantee users will\n * have migrated by then - e.g. they may jump from level-js@4.x.x straight to level-js@6.x.x\n * so we have to duplicate the code here.\n *\n * @param {any} db\n * @param {UpgradeFunction | DowngradeFunction} fn\n * @returns {Promise<void>}\n */\n\nfunction withEach(db, fn) {\n  /**\n   * @param {Operation[]} operations\n   * @param {(error?: Error) => void} next\n   */\n  function batch(operations, next) {\n    const store = db.store('readwrite');\n    const transaction = store.transaction;\n    let index = 0;\n    /** @type {Error | undefined} */\n\n    let error;\n\n    transaction.onabort = () => next(error || transaction.error || new Error('aborted by user'));\n\n    transaction.oncomplete = () => next();\n\n    function loop() {\n      const op = operations[index++];\n      const key = op.key;\n      let req;\n\n      try {\n        req = op.type === 'del' ? store.delete(key) : store.put(op.value, key);\n      } catch (err) {\n        error = err;\n        transaction.abort();\n        return;\n      }\n\n      if (index < operations.length) {\n        req.onsuccess = loop;\n      }\n    }\n\n    loop();\n  }\n\n  return new Promise((resolve, reject) => {\n    const it = db.iterator(); // raw keys and values only\n\n    /**\n     * @template T\n     * @param {T} data\n     */\n\n    const id = data => data;\n\n    it._deserializeKey = it._deserializeValue = id;\n    next();\n\n    function next() {\n      /**\n       * @param {Error | undefined} err\n       * @param {string | undefined} key\n       * @param {Uint8Array} value\n       */\n      const handleNext = (err, key, value) => {\n        if (err || key === undefined) {\n          /**\n           * @param {Error | undefined} err2\n           */\n          const handleEnd = err2 => {\n            if (err2) {\n              reject(err2);\n              return;\n            }\n\n            resolve();\n          };\n\n          it.end(handleEnd);\n          return;\n        } // @ts-ignore\n\n\n        batch(fn(key, value), next);\n      };\n\n      it.next(handleNext);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}