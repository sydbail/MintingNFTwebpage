{"ast":null,"code":"import _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport BufferList from 'bl/BufferList.js';\nimport { create } from 'rabin-wasm';\nimport errcode from 'err-code';\n\nfunction rabinChunker(_x, _x2) {\n  return _rabinChunker.apply(this, arguments);\n}\n\nfunction _rabinChunker() {\n  _rabinChunker = _wrapAsyncGenerator(function* (source, options) {\n    let min, max, avg;\n\n    if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n      avg = options.avgChunkSize;\n      min = options.minChunkSize;\n      max = options.maxChunkSize;\n    } else if (!options.avgChunkSize) {\n      throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n    } else {\n      avg = options.avgChunkSize;\n      min = avg / 3;\n      max = avg + avg / 2;\n    }\n\n    if (min < 16) {\n      throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n    }\n\n    if (max < min) {\n      max = min;\n    }\n\n    if (avg < min) {\n      avg = min;\n    }\n\n    const sizepow = Math.floor(Math.log2(avg));\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(rabin(source, {\n        min: min,\n        max: max,\n        bits: sizepow,\n        window: options.window,\n        polynomial: options.polynomial\n      })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const chunk = _value;\n        yield chunk;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return _rabinChunker.apply(this, arguments);\n}\n\nexport default rabinChunker;\n\nfunction rabin(_x3, _x4) {\n  return _rabin.apply(this, arguments);\n}\n\nfunction _rabin() {\n  _rabin = _wrapAsyncGenerator(function* (source, options) {\n    const r = yield _awaitAsyncGenerator(create(options.bits, options.min, options.max, options.window));\n    const buffers = new BufferList();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n\n    var _iteratorError2;\n\n    try {\n      for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n        const chunk = _value2;\n        buffers.append(chunk);\n        const sizes = r.fingerprint(chunk);\n\n        for (let i = 0; i < sizes.length; i++) {\n          const size = sizes[i];\n          const buf = buffers.slice(0, size);\n          buffers.consume(size);\n          yield buf;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          yield _awaitAsyncGenerator(_iterator2.return());\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    if (buffers.length) {\n      yield buffers.slice(0);\n    }\n  });\n  return _rabin.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}