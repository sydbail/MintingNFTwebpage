{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key,\n  Adapter\n} = require('interface-datastore');\n\nconst {\n  encodeBase32,\n  keyToTopic,\n  topicToKey\n} = require('./utils');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n});\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super();\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  put(key, val) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(key instanceof Uint8Array)) {\n        const errMsg = 'datastore key does not have a valid format';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n      }\n\n      if (!(val instanceof Uint8Array)) {\n        const errMsg = 'received value is not a Uint8Array';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n      }\n\n      const stringifiedTopic = keyToTopic(key);\n      log(`publish value for topic ${stringifiedTopic}`); // Publish record to pubsub\n\n      yield _this._pubsub.publish(stringifiedTopic, val);\n    })();\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  get(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(key instanceof Uint8Array)) {\n        const errMsg = 'datastore key does not have a valid format';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n      }\n\n      const stringifiedTopic = keyToTopic(key);\n      const subscriptions = yield _this2._pubsub.getTopics(); // If already subscribed, just try to get it\n\n      if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n        return _this2._getLocal(key);\n      } // subscribe\n\n\n      try {\n        _this2._pubsub.on(stringifiedTopic, _this2._onMessage);\n\n        yield _this2._pubsub.subscribe(stringifiedTopic);\n      } catch (err) {\n        const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');\n      }\n\n      log(`subscribed values for key ${stringifiedTopic}`);\n      return _this2._getLocal(key);\n    })();\n  }\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n\n    this._pubsub.removeListener(stringifiedTopic, this._onMessage);\n\n    return this._pubsub.unsubscribe(stringifiedTopic);\n  }\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   */\n\n\n  _getLocal(key) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // encode key - base32(/ipns/{cid})\n      const routingKey = new Key('/' + encodeBase32(key), false);\n      let dsVal;\n\n      try {\n        dsVal = yield _this3._datastore.get(routingKey);\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n        }\n\n        const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n      }\n\n      if (!(dsVal instanceof Uint8Array)) {\n        const errMsg = 'found record that we couldn\\'t convert to a value';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');\n      }\n\n      return dsVal;\n    })();\n  }\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {PubSubMessage} msg\n   */\n\n\n  _onMessage(msg) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        data,\n        from,\n        topicIDs\n      } = msg;\n      let key;\n\n      try {\n        key = topicToKey(topicIDs[0]);\n      } catch (err) {\n        log.error(err);\n        return;\n      }\n\n      log(`message received for topic ${topicIDs[0]}`); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n      if (from === _this4._peerId.toB58String()) {\n        log('message discarded as it is from the same peer');\n        return;\n      }\n\n      if (_this4._handleSubscriptionKeyFn) {\n        let res;\n\n        try {\n          res = yield _this4._handleSubscriptionKeyFn(key);\n        } catch (err) {\n          log.error('message discarded by the subscriptionKeyFn');\n          return;\n        }\n\n        key = res;\n      }\n\n      try {\n        yield _this4._storeIfSubscriptionIsBetter(key, data);\n      } catch (err) {\n        log.error(err);\n      }\n    })();\n  }\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n\n\n  _storeIfSubscriptionIsBetter(key, data) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      let isBetter = false;\n\n      try {\n        isBetter = yield _this5._isBetter(key, data);\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_VALID_RECORD') {\n          throw err;\n        }\n      }\n\n      if (isBetter) {\n        yield _this5._storeRecord(key, data);\n      }\n    })();\n  }\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} value\n   * @param {Uint8Array} peerId\n   */\n\n\n  _validateRecord(value, peerId) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      return _this6._validator.validate(value, peerId);\n    })();\n  }\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n\n\n  _selectRecord(key, records) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const res = yield _this7._validator.select(key, records); // If the selected was the first (0), it should be stored (true)\n\n      return res === 0;\n    })();\n  }\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n\n\n  _isBetter(key, val) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this8._validateRecord(val, key);\n      } catch (err) {\n        // If not valid, it is not better than the one currently available\n        const errMsg = 'record received through pubsub is not valid';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n      } // Get Local record\n\n\n      const dsKey = new Key(key);\n      let currentRecord;\n\n      try {\n        currentRecord = yield _this8._getLocal(dsKey.uint8Array());\n      } catch (err) {\n        // if the old one is invalid, the new one is *always* better\n        return true;\n      } // if the same record, do not need to store\n\n\n      if (uint8ArrayEquals(currentRecord, val)) {\n        return false;\n      } // verify if the received record should replace the current one\n\n\n      return _this8._selectRecord(key, [currentRecord, val]);\n    })();\n  }\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n\n\n  _storeRecord(key, data) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      // encode key - base32(/ipns/{cid})\n      const routingKey = new Key('/' + encodeBase32(key), false);\n      yield _this9._datastore.put(routingKey, data);\n      log(`record for ${keyToTopic(key)} was stored in the datastore`);\n    })();\n  }\n\n}\n\nexports = module.exports = DatastorePubsub;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/datastore-pubsub/src/index.js"],"names":["Key","Adapter","require","encodeBase32","keyToTopic","topicToKey","equals","uint8ArrayEquals","errcode","debug","log","Object","assign","error","DatastorePubsub","constructor","pubsub","datastore","peerId","validator","subscriptionKeyFn","TypeError","validate","select","_pubsub","_datastore","_peerId","_validator","_handleSubscriptionKeyFn","_onMessage","bind","put","key","val","Uint8Array","errMsg","Error","stringifiedTopic","publish","get","subscriptions","getTopics","Array","isArray","indexOf","_getLocal","on","subscribe","err","unsubscribe","removeListener","routingKey","dsVal","code","toString","msg","data","from","topicIDs","toB58String","res","_storeIfSubscriptionIsBetter","isBetter","_isBetter","_storeRecord","_validateRecord","value","_selectRecord","records","dsKey","currentRecord","uint8Array","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key, Adapter } = require('interface-datastore')\nconst { encodeBase32, keyToTopic, topicToKey } = require('./utils')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n})\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super()\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async put (key, val) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    await this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async get (key) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.getTopics()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key)\n    }\n\n    // subscribe\n    try {\n      this._pubsub.on(stringifiedTopic, this._onMessage)\n      await this._pubsub.subscribe(stringifiedTopic)\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    this._pubsub.removeListener(stringifiedTopic, this._onMessage)\n    return this._pubsub.unsubscribe(stringifiedTopic)\n  }\n\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   */\n  async _getLocal (key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND')\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {PubSubMessage} msg\n   */\n  async _onMessage (msg) {\n    const { data, from, topicIDs } = msg\n    let key\n    try {\n      key = topicToKey(topicIDs[0])\n    } catch (err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topicIDs[0]}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n  async _storeIfSubscriptionIsBetter (key, data) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data)\n    }\n  }\n\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} value\n   * @param {Uint8Array} peerId\n   */\n  async _validateRecord (value, peerId) { // eslint-disable-line require-await\n    return this._validator.validate(value, peerId)\n  }\n\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n  async _selectRecord (key, records) {\n    const res = await this._validator.select(key, records)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n  async _isBetter (key, val) {\n    try {\n      await this._validateRecord(val, key)\n    } catch (err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array())\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(key, [currentRecord, val])\n  }\n\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n  async _storeRecord (key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n}\n\nexports = module.exports = DatastorePubsub\n"]},"metadata":{},"sourceType":"script"}