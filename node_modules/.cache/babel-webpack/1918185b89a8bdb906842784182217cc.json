{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = debug('dns-over-http-resolver');\nlog.error = debug('dns-over-http-resolver:error');\n\nconst Receptacle = require('receptacle');\n\nconst utils = require('./utils');\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\n\n\nclass Resolver {\n  /**\n   * @class\n   * @param {object} [properties]\n   * @param {number} [properties.maxCache = 100] - maximum number of cached dns records.\n   */\n  constructor({\n    maxCache = 100\n  } = {}) {\n    this._cache = new Receptacle({\n      max: maxCache\n    });\n    this._servers = ['https://cloudflare-dns.com/dns-query', 'https://dns.google/resolve'];\n  }\n  /**\n   * Get an array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n\n\n  getServers() {\n    return this._servers;\n  }\n  /**\n   * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n\n\n  _getShuffledServers() {\n    const newServers = [].concat(this._servers);\n\n    for (let i = newServers.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * i);\n      const temp = newServers[i];\n      newServers[i] = newServers[j];\n      newServers[j] = temp;\n    }\n\n    return newServers;\n  }\n  /**\n   * Sets the IP address and port of servers to be used when performing DNS resolution.\n   *\n   * @param {Array<string>} servers - array of RFC 5952 formatted addresses.\n   */\n\n\n  setServers(servers) {\n    this._servers = servers;\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @param {string} [rrType = 'A'] - resource record type.\n   * @returns {Promise<*>}\n   */\n\n\n  resolve(hostname, rrType = 'A') {\n    switch (rrType) {\n      case 'A':\n        return this.resolve4(hostname);\n\n      case 'AAAA':\n        return this.resolve6(hostname);\n\n      case 'TXT':\n        return this.resolveTxt(hostname);\n\n      default:\n        throw new Error(`${rrType} is not supported`);\n    }\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv4 addresses.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<string>>}\n   */\n\n\n  resolve4(hostname) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const recordType = 'A';\n\n      const cached = _this._cache.get(utils.getCacheKey(hostname, recordType));\n\n      if (cached) {\n        return cached;\n      }\n\n      for (const server of _this._getShuffledServers()) {\n        try {\n          const response = yield utils.fetch(utils.buildResource({\n            serverResolver: server,\n            hostname,\n            recordType\n          }));\n          const d = yield response.json();\n          const data = d.Answer.map(a => a.data);\n          const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n          _this._cache.set(utils.getCacheKey(hostname, recordType), data, {\n            ttl\n          });\n\n          return data;\n        } catch (err) {\n          log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n        }\n      }\n\n      throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n    })();\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv6 addresses.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<string>>}\n   */\n\n\n  resolve6(hostname) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const recordType = 'AAAA';\n\n      const cached = _this2._cache.get(utils.getCacheKey(hostname, recordType));\n\n      if (cached) {\n        return cached;\n      }\n\n      for (const server of _this2._getShuffledServers()) {\n        try {\n          const response = yield utils.fetch(utils.buildResource({\n            serverResolver: server,\n            hostname,\n            recordType\n          }));\n          const d = yield response.json();\n          const data = d.Answer.map(a => a.data);\n          const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n          _this2._cache.set(utils.getCacheKey(hostname, recordType), data, {\n            ttl\n          });\n\n          return data;\n        } catch (err) {\n          log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n        }\n      }\n\n      throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n    })();\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into a Text record.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<Array<string>>>}\n   */\n\n\n  resolveTxt(hostname) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const recordType = 'TXT';\n\n      const cached = _this3._cache.get(utils.getCacheKey(hostname, recordType));\n\n      if (cached) {\n        return cached;\n      }\n\n      for (const server of _this3._getShuffledServers()) {\n        try {\n          const response = yield utils.fetch(utils.buildResource({\n            serverResolver: server,\n            hostname,\n            recordType\n          }));\n          const d = yield response.json();\n          const data = d.Answer.map(a => [a.data.replace(/['\"]+/g, '')]);\n          const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n          _this3._cache.set(utils.getCacheKey(hostname, recordType), data, {\n            ttl\n          });\n\n          return data;\n        } catch (err) {\n          log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n        }\n      }\n\n      throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n    })();\n  }\n\n}\n\nResolver.Resolver = Resolver;\nmodule.exports = Resolver;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/dns-over-http-resolver/src/index.js"],"names":["debug","require","log","error","Receptacle","utils","Resolver","constructor","maxCache","_cache","max","_servers","getServers","_getShuffledServers","newServers","concat","i","length","j","Math","floor","random","temp","setServers","servers","resolve","hostname","rrType","resolve4","resolve6","resolveTxt","Error","recordType","cached","get","getCacheKey","server","response","fetch","buildResource","serverResolver","d","json","data","Answer","map","a","ttl","min","TTL","set","err","replace","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst debug = require('debug')\nconst log = debug('dns-over-http-resolver')\nlog.error = debug('dns-over-http-resolver:error')\n\nconst Receptacle = require('receptacle')\n\nconst utils = require('./utils')\n\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\nclass Resolver {\n  /**\n   * @class\n   * @param {object} [properties]\n   * @param {number} [properties.maxCache = 100] - maximum number of cached dns records.\n   */\n  constructor ({ maxCache = 100 } = {}) {\n    this._cache = new Receptacle({ max: maxCache })\n    this._servers = [\n      'https://cloudflare-dns.com/dns-query',\n      'https://dns.google/resolve'\n    ]\n  }\n\n  /**\n   * Get an array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n  getServers () {\n    return this._servers\n  }\n\n  /**\n   * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n  _getShuffledServers () {\n    const newServers = [].concat(this._servers)\n\n    for (let i = newServers.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * i)\n      const temp = newServers[i]\n      newServers[i] = newServers[j]\n      newServers[j] = temp\n    }\n\n    return newServers\n  }\n\n  /**\n   * Sets the IP address and port of servers to be used when performing DNS resolution.\n   *\n   * @param {Array<string>} servers - array of RFC 5952 formatted addresses.\n   */\n  setServers (servers) {\n    this._servers = servers\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @param {string} [rrType = 'A'] - resource record type.\n   * @returns {Promise<*>}\n   */\n  resolve (hostname, rrType = 'A') {\n    switch (rrType) {\n      case 'A':\n        return this.resolve4(hostname)\n      case 'AAAA':\n        return this.resolve6(hostname)\n      case 'TXT':\n        return this.resolveTxt(hostname)\n      default:\n        throw new Error(`${rrType} is not supported`)\n    }\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv4 addresses.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<string>>}\n   */\n  async resolve4 (hostname) {\n    const recordType = 'A'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached) {\n      return cached\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await utils.fetch(utils.buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }))\n\n        const d = await response.json()\n        const data = d.Answer.map(a => a.data)\n        const ttl = Math.min(d.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      }\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv6 addresses.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<string>>}\n   */\n  async resolve6 (hostname) {\n    const recordType = 'AAAA'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached) {\n      return cached\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await utils.fetch(utils.buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }))\n\n        const d = await response.json()\n        const data = d.Answer.map(a => a.data)\n        const ttl = Math.min(d.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      }\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into a Text record.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<Array<string>>>}\n   */\n  async resolveTxt (hostname) {\n    const recordType = 'TXT'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached) {\n      return cached\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await utils.fetch(utils.buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }))\n\n        const d = await response.json()\n        const data = d.Answer.map(a => [a.data.replace(/['\"]+/g, '')])\n        const ttl = Math.min(d.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      }\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n}\n\nResolver.Resolver = Resolver\nmodule.exports = Resolver\n"]},"metadata":{},"sourceType":"script"}