{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst isIPFS = require('is-ipfs');\n\nconst toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst drain = require('it-drain');\n\nconst {\n  resolve\n} = require('../../utils');\n/**\n * resolves the given path by parsing out protocol-specific entries\n * (e.g. /ipns/<node-key>) and then going through the /ipfs/ entries and returning the final node\n *\n * @param {Object} context\n * @param {import('../ipns')} context.ipns\n * @param {import('ipfs-repo').IPFSRepo} context.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} context.codecs\n * @param {string} name\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\n\n\nexports.resolvePath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    ipns,\n    repo,\n    codecs\n  }, name, options) {\n    // ipns path\n    if (isIPFS.ipnsPath(name)) {\n      return ipns.resolve(name);\n    }\n\n    const {\n      cid,\n      path\n    } = toCidAndPath(name); // ipfs path\n\n    yield drain(resolve(cid, path || '', codecs, repo, options));\n  });\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/ipfs-core/src/components/name/utils.js"],"names":["isIPFS","require","toCidAndPath","drain","resolve","exports","resolvePath","ipns","repo","codecs","name","options","ipnsPath","cid","path"],"mappings":"AAAA;;;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,qCAAD,CAA5B;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,UAAD,CAArB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAcH,OAAO,CAAC,aAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAI,OAAO,CAACC,WAAR;AAAA,+BAAsB,WAAO;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,IAAR;AAAcC,IAAAA;AAAd,GAAP,EAA+BC,IAA/B,EAAqCC,OAArC,EAAiD;AACrE;AACA,QAAIX,MAAM,CAACY,QAAP,CAAgBF,IAAhB,CAAJ,EAA2B;AACzB,aAAOH,IAAI,CAACH,OAAL,CAAaM,IAAb,CAAP;AACD;;AAED,UAAM;AACJG,MAAAA,GADI;AAEJC,MAAAA;AAFI,QAGFZ,YAAY,CAACQ,IAAD,CAHhB,CANqE,CAWrE;;AACA,UAAMP,KAAK,CAACC,OAAO,CAACS,GAAD,EAAMC,IAAI,IAAI,EAAd,EAAkBL,MAAlB,EAA0BD,IAA1B,EAAgCG,OAAhC,CAAR,CAAX;AACD,GAbD;;AAAA;AAAA;AAAA;AAAA","sourcesContent":["'use strict'\n\nconst isIPFS = require('is-ipfs')\nconst toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path')\nconst drain = require('it-drain')\nconst { resolve } = require('../../utils')\n\n/**\n * resolves the given path by parsing out protocol-specific entries\n * (e.g. /ipns/<node-key>) and then going through the /ipfs/ entries and returning the final node\n *\n * @param {Object} context\n * @param {import('../ipns')} context.ipns\n * @param {import('ipfs-repo').IPFSRepo} context.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} context.codecs\n * @param {string} name\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nexports.resolvePath = async ({ ipns, repo, codecs }, name, options) => {\n  // ipns path\n  if (isIPFS.ipnsPath(name)) {\n    return ipns.resolve(name)\n  }\n\n  const {\n    cid,\n    path\n  } = toCidAndPath(name)\n\n  // ipfs path\n  await drain(resolve(cid, path || '', codecs, repo, options))\n}\n"]},"metadata":{},"sourceType":"script"}