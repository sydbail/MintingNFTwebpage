{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-record\"] || ($protobuf.roots[\"libp2p-record\"] = {});\n\n$root.Record = function () {\n  /**\n   * Properties of a Record.\n   * @exports IRecord\n   * @interface IRecord\n   * @property {Uint8Array|null} [key] Record key\n   * @property {Uint8Array|null} [value] Record value\n   * @property {string|null} [timeReceived] Record timeReceived\n   */\n\n  /**\n   * Constructs a new Record.\n   * @exports Record\n   * @classdesc Represents a Record.\n   * @implements IRecord\n   * @constructor\n   * @param {IRecord=} [p] Properties to set\n   */\n  function Record(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Record key.\n   * @member {Uint8Array} key\n   * @memberof Record\n   * @instance\n   */\n\n\n  Record.prototype.key = $util.newBuffer([]);\n  /**\n   * Record value.\n   * @member {Uint8Array} value\n   * @memberof Record\n   * @instance\n   */\n\n  Record.prototype.value = $util.newBuffer([]);\n  /**\n   * Record timeReceived.\n   * @member {string} timeReceived\n   * @memberof Record\n   * @instance\n   */\n\n  Record.prototype.timeReceived = \"\";\n  /**\n   * Encodes the specified Record message. Does not implicitly {@link Record.verify|verify} messages.\n   * @function encode\n   * @memberof Record\n   * @static\n   * @param {IRecord} m Record message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Record.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.key != null && Object.hasOwnProperty.call(m, \"key\")) w.uint32(10).bytes(m.key);\n    if (m.value != null && Object.hasOwnProperty.call(m, \"value\")) w.uint32(18).bytes(m.value);\n    if (m.timeReceived != null && Object.hasOwnProperty.call(m, \"timeReceived\")) w.uint32(42).string(m.timeReceived);\n    return w;\n  };\n  /**\n   * Decodes a Record message from the specified reader or buffer.\n   * @function decode\n   * @memberof Record\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Record} Record\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Record.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Record();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.key = r.bytes();\n          break;\n\n        case 2:\n          m.value = r.bytes();\n          break;\n\n        case 5:\n          m.timeReceived = r.string();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a Record message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Record\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Record} Record\n   */\n\n\n  Record.fromObject = function fromObject(d) {\n    if (d instanceof $root.Record) return d;\n    var m = new $root.Record();\n\n    if (d.key != null) {\n      if (typeof d.key === \"string\") $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);else if (d.key.length) m.key = d.key;\n    }\n\n    if (d.value != null) {\n      if (typeof d.value === \"string\") $util.base64.decode(d.value, m.value = $util.newBuffer($util.base64.length(d.value)), 0);else if (d.value.length) m.value = d.value;\n    }\n\n    if (d.timeReceived != null) {\n      m.timeReceived = String(d.timeReceived);\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a Record message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Record\n   * @static\n   * @param {Record} m Record\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Record.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.defaults) {\n      if (o.bytes === String) d.key = \"\";else {\n        d.key = [];\n        if (o.bytes !== Array) d.key = $util.newBuffer(d.key);\n      }\n      if (o.bytes === String) d.value = \"\";else {\n        d.value = [];\n        if (o.bytes !== Array) d.value = $util.newBuffer(d.value);\n      }\n      d.timeReceived = \"\";\n    }\n\n    if (m.key != null && m.hasOwnProperty(\"key\")) {\n      d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;\n    }\n\n    if (m.value != null && m.hasOwnProperty(\"value\")) {\n      d.value = o.bytes === String ? $util.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;\n    }\n\n    if (m.timeReceived != null && m.hasOwnProperty(\"timeReceived\")) {\n      d.timeReceived = m.timeReceived;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Record to JSON.\n   * @function toJSON\n   * @memberof Record\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Record.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Record;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}