{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  default: Queue\n} = require('p-queue');\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {import('../index')} dht\n   * @param {import('./run')} run\n   * @param {import('./path')} path\n   * @param {Function & {error: Function}} log\n   */\n  constructor(dht, run, path, log) {\n    this.dht = dht;\n    this.run = run;\n    this.path = path;\n    this.log = log;\n    this.concurrency = this.dht.concurrency;\n    this.queue = this.setupQueue(); // a container for resolve/reject functions that will be populated\n    // when execute() is called\n\n    /** @type {{ resolve: (result?: any) => void, reject: (err: Error) => void} | null} */\n\n    this.execution = null;\n    /** @type {Set<PeerId>} */\n\n    this.queuedPeerIds = new Set();\n  }\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Queue}\n   */\n\n\n  setupQueue() {\n    const q = new Queue({\n      concurrency: this.concurrency\n    }); // When all peers in the queue have been processed, stop the worker\n\n    q.on('idle', () => {\n      if (this.path.peersToQuery && !this.path.peersToQuery.length) {\n        this.log('queue:drain');\n        this.stop();\n      }\n    }); // When a space opens up in the queue, add some more peers\n\n    q.on('next', () => {\n      if (!this.running) {\n        return;\n      }\n\n      if (q.pending < this.concurrency) {\n        this.fill();\n      }\n    });\n    return q;\n  }\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} [err]\n   */\n\n\n  stop(err) {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n    this.queue.clear();\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length);\n\n    if (this.execution) {\n      if (err) {\n        this.execution.reject(err);\n      } else {\n        this.execution.resolve();\n      }\n    }\n  }\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  execute() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.running = true; // store the promise resolution functions to be resolved at end of queue\n\n      _this.execution = null;\n      const execPromise = new Promise((resolve, reject) => {\n        _this.execution = {\n          resolve,\n          reject\n        };\n      }); // start queue\n\n      _this.fill(); // await completion\n\n\n      yield execPromise;\n    })();\n  }\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continuously\n   * being added to the peers-to-query queue.\n   */\n\n\n  fill() {\n    if (!this.path.peersToQuery) {\n      return;\n    } // Note:\n    // - queue.pending: number of items that are currently running\n    // - queue.size: the number of items that are waiting to be run\n\n\n    while (this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0) {\n      const peer = this.path.peersToQuery.dequeue(); // store the peer id so we can potentially abort early\n\n      this.queuedPeerIds.add(peer);\n      this.queue.add(() => {\n        return this.processNext(peer).catch(err => {\n          this.log.error('queue', err);\n          this.stop(err);\n        }).finally(() => {\n          this.queuedPeerIds.delete(peer);\n        });\n      });\n    }\n  }\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   */\n\n\n  processNext(peer) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.running) {\n        return;\n      } // The paths must be disjoint, meaning that no two paths in the Query may\n      // traverse the same peer\n\n\n      if (_this2.run.peersSeen.has(peer.toB58String())) {\n        return;\n      } // Check if we've queried enough peers already\n\n\n      let continueQuerying, continueQueryingError;\n\n      try {\n        continueQuerying = yield _this2.run.continueQuerying(_this2);\n      } catch (err) {\n        continueQueryingError = err;\n      } // Abort and ignore any error if we're no longer running\n\n\n      if (!_this2.running) {\n        return;\n      }\n\n      if (continueQueryingError) {\n        throw continueQueryingError;\n      } // No peer we're querying is closer, stop the queue\n      // This will cause queries that may potentially result in\n      // closer nodes to be ended, but it reduces overall query time\n\n\n      if (!continueQuerying) {\n        _this2.stop();\n\n        return;\n      } // Check if another path has queried this peer in the mean time\n\n\n      if (_this2.run.peersSeen.has(peer.toB58String())) {\n        return;\n      }\n\n      _this2.run.peersSeen.add(peer.toB58String()); // Execute the query on the next peer\n\n\n      _this2.log('queue:work');\n\n      let state, execError;\n\n      try {\n        state = yield _this2.execQuery(peer);\n      } catch (err) {\n        execError = err;\n      } // Abort and ignore any error if we're no longer running\n\n\n      if (!_this2.running) {\n        return;\n      }\n\n      _this2.log('queue:work:done', execError, state);\n\n      if (execError) {\n        throw execError;\n      } // If query is complete, stop all workers.\n      // Note: run.stop() calls stop() on all the workers, which kills the\n      // queue and resolves execution\n\n\n      if (state && state.queryComplete) {\n        _this2.log('query:complete');\n\n        _this2.run.stop();\n\n        return;\n      } // If path is complete, just stop this worker.\n      // Note: this.stop() kills the queue and resolves execution\n\n\n      if (state && state.pathComplete) {\n        _this2.stop();\n      }\n    })();\n  }\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  execQuery(peer) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let res, queryError;\n\n      try {\n        res = yield _this3.path.queryFunc(peer);\n      } catch (err) {\n        queryError = err;\n      } // Abort and ignore any error if we're no longer running\n\n\n      if (!_this3.running) {\n        return;\n      }\n\n      if (queryError) {\n        _this3.run.errors.push(queryError);\n\n        return;\n      } // Add the peer to the closest peers we have successfully queried\n\n\n      _this3.run.peersQueried && (yield _this3.run.peersQueried.add(peer));\n\n      if (!res) {\n        return;\n      } // If the query indicates that this path or the whole query is complete\n      // set the path result and bail out\n\n\n      if (res.pathComplete || res.queryComplete) {\n        _this3.path.res = res;\n        return {\n          pathComplete: res.pathComplete,\n          queryComplete: res.queryComplete\n        };\n      } // If there are closer peers to query, add them to the queue\n\n\n      if (res.closerPeers && res.closerPeers.length > 0) {\n        /**\n         * @param {import('../').PeerData} closer\n         */\n        const queryCloser = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (closer) {\n            // don't add ourselves\n            if (_this3.dht._isSelf(closer.id)) {\n              return;\n            }\n\n            _this3.dht._peerDiscovered(closer.id, closer.multiaddrs);\n\n            yield _this3.path.addPeerToQuery(closer.id);\n          });\n\n          return function queryCloser(_x) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n\n        yield Promise.all(res.closerPeers.map(queryCloser));\n      }\n    })();\n  }\n\n}\n\nmodule.exports = WorkerQueue;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/libp2p-kad-dht/src/query/worker-queue.js"],"names":["default","Queue","require","WorkerQueue","constructor","dht","run","path","log","concurrency","queue","setupQueue","execution","queuedPeerIds","Set","q","on","peersToQuery","length","stop","running","pending","fill","err","clear","workers","filter","w","reject","resolve","execute","execPromise","Promise","size","peer","dequeue","add","processNext","catch","error","finally","delete","peersSeen","has","toB58String","continueQuerying","continueQueryingError","state","execError","execQuery","queryComplete","pathComplete","res","queryError","queryFunc","errors","push","peersQueried","closerPeers","queryCloser","closer","_isSelf","id","_peerDiscovered","multiaddrs","addPeerToQuery","all","map","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { default: Queue } = require('p-queue')\n\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {import('../index')} dht\n   * @param {import('./run')} run\n   * @param {import('./path')} path\n   * @param {Function & {error: Function}} log\n   */\n  constructor (dht, run, path, log) {\n    this.dht = dht\n    this.run = run\n    this.path = path\n    this.log = log\n\n    this.concurrency = this.dht.concurrency\n    this.queue = this.setupQueue()\n    // a container for resolve/reject functions that will be populated\n    // when execute() is called\n\n    /** @type {{ resolve: (result?: any) => void, reject: (err: Error) => void} | null} */\n    this.execution = null\n\n    /** @type {Set<PeerId>} */\n    this.queuedPeerIds = new Set()\n  }\n\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Queue}\n   */\n  setupQueue () {\n    const q = new Queue({\n      concurrency: this.concurrency\n    })\n\n    // When all peers in the queue have been processed, stop the worker\n    q.on('idle', () => {\n      if (this.path.peersToQuery && !this.path.peersToQuery.length) {\n        this.log('queue:drain')\n        this.stop()\n      }\n    })\n\n    // When a space opens up in the queue, add some more peers\n    q.on('next', () => {\n      if (!this.running) {\n        return\n      }\n\n      if (q.pending < this.concurrency) {\n        this.fill()\n      }\n    })\n\n    return q\n  }\n\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} [err]\n   */\n  stop (err) {\n    if (!this.running) {\n      return\n    }\n\n    this.running = false\n    this.queue.clear()\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length)\n\n    if (this.execution) {\n      if (err) {\n        this.execution.reject(err)\n      } else {\n        this.execution.resolve()\n      }\n    }\n  }\n\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @returns {Promise<void>}\n   */\n  async execute () {\n    this.running = true\n    // store the promise resolution functions to be resolved at end of queue\n    this.execution = null\n    const execPromise = new Promise((resolve, reject) => {\n      this.execution = {\n        resolve, reject\n      }\n    })\n    // start queue\n    this.fill()\n    // await completion\n    await execPromise\n  }\n\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continuously\n   * being added to the peers-to-query queue.\n   */\n  fill () {\n    if (!this.path.peersToQuery) {\n      return\n    }\n\n    // Note:\n    // - queue.pending: number of items that are currently running\n    // - queue.size: the number of items that are waiting to be run\n    while (this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0) {\n      const peer = this.path.peersToQuery.dequeue()\n\n      // store the peer id so we can potentially abort early\n      this.queuedPeerIds.add(peer)\n\n      this.queue.add(\n        () => {\n          return this.processNext(peer)\n            .catch(err => {\n              this.log.error('queue', err)\n              this.stop(err)\n            })\n            .finally(() => {\n              this.queuedPeerIds.delete(peer)\n            })\n        }\n      )\n    }\n  }\n\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   */\n  async processNext (peer) {\n    if (!this.running) {\n      return\n    }\n\n    // The paths must be disjoint, meaning that no two paths in the Query may\n    // traverse the same peer\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return\n    }\n\n    // Check if we've queried enough peers already\n    let continueQuerying, continueQueryingError\n    try {\n      continueQuerying = await this.run.continueQuerying(this)\n    } catch (err) {\n      continueQueryingError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    if (continueQueryingError) {\n      throw continueQueryingError\n    }\n\n    // No peer we're querying is closer, stop the queue\n    // This will cause queries that may potentially result in\n    // closer nodes to be ended, but it reduces overall query time\n    if (!continueQuerying) {\n      this.stop()\n      return\n    }\n\n    // Check if another path has queried this peer in the mean time\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return\n    }\n    this.run.peersSeen.add(peer.toB58String())\n\n    // Execute the query on the next peer\n    this.log('queue:work')\n    let state, execError\n    try {\n      state = await this.execQuery(peer)\n    } catch (err) {\n      execError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    this.log('queue:work:done', execError, state)\n\n    if (execError) {\n      throw execError\n    }\n\n    // If query is complete, stop all workers.\n    // Note: run.stop() calls stop() on all the workers, which kills the\n    // queue and resolves execution\n    if (state && state.queryComplete) {\n      this.log('query:complete')\n      this.run.stop()\n      return\n    }\n\n    // If path is complete, just stop this worker.\n    // Note: this.stop() kills the queue and resolves execution\n    if (state && state.pathComplete) {\n      this.stop()\n    }\n  }\n\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   */\n  async execQuery (peer) {\n    let res, queryError\n    try {\n      res = await this.path.queryFunc(peer)\n    } catch (err) {\n      queryError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    if (queryError) {\n      this.run.errors.push(queryError)\n      return\n    }\n\n    // Add the peer to the closest peers we have successfully queried\n    this.run.peersQueried && await this.run.peersQueried.add(peer)\n\n    if (!res) {\n      return\n    }\n\n    // If the query indicates that this path or the whole query is complete\n    // set the path result and bail out\n    if (res.pathComplete || res.queryComplete) {\n      this.path.res = res\n\n      return {\n        pathComplete: res.pathComplete,\n        queryComplete: res.queryComplete\n      }\n    }\n\n    // If there are closer peers to query, add them to the queue\n    if (res.closerPeers && res.closerPeers.length > 0) {\n      /**\n       * @param {import('../').PeerData} closer\n       */\n      const queryCloser = async (closer) => {\n        // don't add ourselves\n        if (this.dht._isSelf(closer.id)) {\n          return\n        }\n\n        this.dht._peerDiscovered(closer.id, closer.multiaddrs)\n        await this.path.addPeerToQuery(closer.id)\n      }\n\n      await Promise.all(res.closerPeers.map(queryCloser))\n    }\n  }\n}\n\nmodule.exports = WorkerQueue\n"]},"metadata":{},"sourceType":"script"}