{"ast":null,"code":"/* eslint-disable no-unreachable */\n'use strict'; // @ts-ignore\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst {\n  default: parseDuration\n} = require('parse-duration');\n\nconst {\n  TimeoutError\n} = require('./errors');\n/**\n * @template {any[]} Args\n * @template {Promise<any> | AsyncIterable<any>} R - The return type of `fn`\n * @param {(...args:Args) => R} fn\n * @param {number} [optionsArgIndex]\n * @returns {(...args:Args) => R}\n */\n\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  // eslint-disable-next-line\n  return (\n    /** @returns {R} */\n    (\n    /** @type {Args} */\n    ...args) => {\n      const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n      if (!options || !options.timeout) return fn(...args);\n      const timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n      const controller = new TimeoutController(timeout);\n      options.signal = anySignal([options.signal, controller.signal]);\n      const fnRes = fn(...args); // eslint-disable-next-line promise/param-names\n\n      const timeoutPromise = new Promise((_resolve, reject) => {\n        controller.signal.addEventListener('abort', () => {\n          reject(new TimeoutError());\n        });\n      });\n      const start = Date.now();\n\n      const maybeThrowTimeoutError = () => {\n        if (controller.signal.aborted) {\n          throw new TimeoutError();\n        }\n\n        const timeTaken = Date.now() - start; // if we have starved the event loop by adding microtasks, we could have\n        // timed out already but the TimeoutController will never know because it's\n        // setTimeout will not fire until we stop adding microtasks\n\n        if (timeTaken > timeout) {\n          controller.abort();\n          throw new TimeoutError();\n        }\n      }; // @ts-ignore\n\n\n      if (fnRes[Symbol.asyncIterator]) {\n        // @ts-ignore\n        return _wrapAsyncGenerator(function* () {\n          // @ts-ignore\n          const it = fnRes[Symbol.asyncIterator]();\n\n          try {\n            while (true) {\n              const {\n                value,\n                done\n              } = yield _awaitAsyncGenerator(Promise.race([it.next(), timeoutPromise]));\n\n              if (done) {\n                break;\n              }\n\n              maybeThrowTimeoutError();\n              yield value;\n            }\n          } catch (err) {\n            maybeThrowTimeoutError();\n            throw err;\n          } finally {\n            controller.clear();\n\n            if (it.return) {\n              it.return();\n            }\n          }\n        })();\n      } // @ts-ignore\n\n\n      return _asyncToGenerator(function* () {\n        try {\n          const res = yield Promise.race([fnRes, timeoutPromise]);\n          maybeThrowTimeoutError();\n          return res;\n        } catch (err) {\n          maybeThrowTimeoutError();\n          throw err;\n        } finally {\n          controller.clear();\n        }\n      })();\n    }\n  );\n}\n\nmodule.exports = withTimeoutOption;","map":null,"metadata":{},"sourceType":"script"}