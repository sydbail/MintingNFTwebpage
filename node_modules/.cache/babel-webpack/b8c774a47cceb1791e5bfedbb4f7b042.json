{"ast":null,"code":"var _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst BufferList = require('bl/BufferList');\n\nconst {\n  S_IFMT,\n  S_IFBLK,\n  S_IFCHR,\n  S_IFDIR,\n  S_IFIFO,\n  S_IFLNK\n} = require('iso-constants');\n\nconst concat = require('it-concat');\n\nconst Headers = require('./pack-headers');\n\nconst DMODE = parseInt('755', 8);\nconst FMODE = parseInt('644', 8);\nconst END_OF_TAR = Buffer.alloc(1024);\n\nfunction modeToType(mode) {\n  switch (mode & S_IFMT) {\n    case S_IFBLK:\n      return 'block-device';\n\n    case S_IFCHR:\n      return 'character-device';\n\n    case S_IFDIR:\n      return 'directory';\n\n    case S_IFIFO:\n      return 'fifo';\n\n    case S_IFLNK:\n      return 'symlink';\n  }\n\n  return 'file';\n}\n\nfunction getPadding(size) {\n  size &= 511;\n  if (size) return new BufferList(END_OF_TAR.slice(0, 512 - size));\n}\n\nfunction encode(header) {\n  if (!header.pax) {\n    const encoded = Headers.encode(header);\n    if (encoded) return encoded;\n  }\n\n  return encodePax(header);\n}\n\nfunction encodePax(header) {\n  const paxHeader = Headers.encodePax({\n    name: header.name,\n    linkname: header.linkname,\n    pax: header.pax\n  });\n  const newHeader = {\n    name: 'PaxHeader',\n    mode: header.mode,\n    uid: header.uid,\n    gid: header.gid,\n    size: paxHeader.length,\n    mtime: header.mtime,\n    type: 'pax-header',\n    linkname: header.linkname && 'PaxHeader',\n    uname: header.uname,\n    gname: header.gname,\n    devmajor: header.devmajor,\n    devminor: header.devminor\n  };\n  return new BufferList([Headers.encode(newHeader), paxHeader, getPadding(paxHeader.length), Headers.encode({ ...newHeader,\n    size: header.size,\n    type: header.type\n  })]);\n}\n\nmodule.exports = () => /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (source) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        let {\n          header,\n          body\n        } = _value;\n        if (!header.size || header.type === 'symlink') header.size = 0;\n        if (!header.type) header.type = modeToType(header.mode);\n        if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE;\n        if (!header.uid) header.uid = 0;\n        if (!header.gid) header.gid = 0;\n        if (!header.mtime) header.mtime = new Date();\n        if (typeof body === 'string') body = Buffer.from(body);\n\n        if (Buffer.isBuffer(body) || BufferList.isBufferList(body)) {\n          header.size = body.length;\n          yield new BufferList([encode(header), body, getPadding(header.size)]);\n          continue;\n        }\n\n        if (header.type === 'symlink' && !header.linkname) {\n          header.linkname = (yield _awaitAsyncGenerator(concat(body))).toString();\n          yield encode(header);\n          continue;\n        }\n\n        yield encode(header);\n\n        if (header.type !== 'file' && header.type !== 'contiguous-file') {\n          continue;\n        }\n\n        let written = 0;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n\n        var _iteratorError2;\n\n        try {\n          for (var _iterator2 = _asyncIterator(body), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n            const chunk = _value2;\n            written += chunk.length;\n            yield BufferList.isBufferList(chunk) ? chunk : new BufferList(chunk);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              yield _awaitAsyncGenerator(_iterator2.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        if (written !== header.size) {\n          // corrupting tar\n          throw new Error('size mismatch');\n        }\n\n        const overflow = getPadding(header.size);\n        if (overflow) yield overflow;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    yield new BufferList(END_OF_TAR);\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}