{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst debug = require('debug');\n\nconst PeerId = require('peer-id');\n\nconst drain = require('it-drain');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst defer = require('p-defer');\n\nconst log = debug('libp2p-delegated-content-routing');\nlog.error = debug('libp2p-delegated-content-routing:error');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\n\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor(peerId, client) {\n    if (peerId == null) {\n      throw new Error('missing self peerId');\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client;\n    this.peerId = peerId; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    const concurrency = {\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    };\n    this._httpQueue = new PQueue(concurrency); // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }));\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`);\n  }\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n\n\n  findProviders(key, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      log(`findProviders starts: ${key}`);\n      options.timeout = options.timeout || DEFAULT_TIMEOUT;\n      let providers = 0;\n      const onStart = defer();\n      const onFinish = defer();\n\n      _this._httpQueue.add(() => {\n        onStart.resolve();\n        return onFinish.promise;\n      });\n\n      try {\n        yield _awaitAsyncGenerator(onStart.promise);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(_this._client.dht.findProvs(key, {\n            numProviders: options.numProviders,\n            timeout: options.timeout\n          })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const {\n              id,\n              addrs\n            } = _value;\n            yield {\n              id: PeerId.parse(id),\n              multiaddrs: addrs\n            };\n            providers++;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } catch (err) {\n        log.error('findProviders errored:', err);\n        throw err;\n      } finally {\n        onFinish.resolve();\n        log(`findProviders finished: ${key} found ${providers} providers`);\n      }\n    })();\n  }\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   *\n   * @param {CID} key - The delegate will publish a provider record for this CID\n   * @returns {Promise<void>}\n   */\n\n\n  provide(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      log(`provide starts: ${key}`);\n      yield _this2._httpQueueRefs.add( /*#__PURE__*/_asyncToGenerator(function* () {\n        yield _this2._client.block.stat(key);\n        yield drain(_this2._client.dht.provide(key));\n      }));\n      log(`provide finished: ${key}`);\n    })();\n  }\n\n}\n\nmodule.exports = DelegatedContentRouting;","map":null,"metadata":{},"sourceType":"script"}