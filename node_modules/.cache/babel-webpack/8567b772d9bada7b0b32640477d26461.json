{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  Adapter,\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst sh = require('./shard');\n\nconst KeytransformStore = require('./keytransform');\n\nconst shardKey = new Key(sh.SHARDING_FN);\nconst shardReadmeKey = new Key(sh.README_FN);\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nclass ShardingDatastore extends Adapter {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor(store, shard) {\n    super();\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  open() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.child.open();\n      _this4.shard = yield ShardingDatastore.create(_this4.child, _this4.shard);\n    })();\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _convertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    const parent = new Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _invertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    return Key.withNamespaces(key.list().slice(1));\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static createOrOpen(store, shard) {\n    return _asyncToGenerator(function* () {\n      try {\n        yield ShardingDatastore.create(store, shard);\n      } catch (err) {\n        if (err && err.message !== 'datastore exists') throw err;\n      }\n\n      return ShardingDatastore.open(store);\n    })();\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n\n\n  static open(store) {\n    return _asyncToGenerator(function* () {\n      const shard = yield sh.readShardFun('/', store);\n      return new ShardingDatastore(store, shard);\n    })();\n  }\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static create(store, shard) {\n    return _asyncToGenerator(function* () {\n      const hasShard = yield store.has(shardKey);\n\n      if (!hasShard && !shard) {\n        throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n      }\n\n      if (!hasShard) {\n        // @ts-ignore i have no idea what putRaw is or saw any implementation\n        const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n        yield Promise.all([put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')), put(shardReadmeKey, new TextEncoder().encode(sh.readme))]);\n        return shard;\n      } // test shards\n\n\n      const diskShard = yield sh.readShardFun('/', store);\n      const a = (diskShard || '').toString();\n      const b = shard.toString();\n\n      if (a !== b) {\n        throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n      }\n\n      return diskShard;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n\n\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  putMany(source, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this.child.putMany(source, options)), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n\n\n  getMany(source, options = {}) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this2.child.getMany(source, options)), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n\n\n  deleteMany(source, options = {}) {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this3.child.deleteMany(source, options)), _awaitAsyncGenerator);\n    })();\n  }\n\n  batch() {\n    return this.child.batch();\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n\n      /** @type {QueryOrder[]} */\n      orders: [],\n\n      /** @type {QueryFilter[]} */\n      filters: [\n      /** @type {QueryFilter} */\n      e => e.key.toString() !== shardKey.toString(),\n      /** @type {QueryFilter} */\n      e => e.key.toString() !== shardReadmeKey.toString()]\n    };\n    const {\n      prefix\n    } = q;\n\n    if (prefix != null) {\n      tq.filters.push(e => {\n        return this._invertKey(e.key).toString().startsWith(prefix);\n      });\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {QueryFilter} */\n        const filter = ({\n          key,\n          value\n        }) => {\n          return f({\n            key: this._invertKey(key),\n            value\n          });\n        };\n\n        return filter;\n      });\n      tq.filters = tq.filters.concat(filters);\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {QueryOrder} */\n        const order = (a, b) => {\n          return o({\n            key: this._invertKey(a.key),\n            value: a.value\n          }, {\n            key: this._invertKey(b.key),\n            value: b.value\n          });\n        };\n\n        return order;\n      });\n    }\n\n    return this.child.query(tq, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n\n      /** @type {KeyQueryOrder[]} */\n      orders: [],\n\n      /** @type {KeyQueryFilter[]} */\n      filters: [\n      /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardKey.toString(),\n      /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardReadmeKey.toString()]\n    };\n    const {\n      prefix\n    } = q;\n\n    if (prefix != null) {\n      tq.filters.push(key => {\n        return this._invertKey(key).toString().startsWith(prefix);\n      });\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {KeyQueryFilter} */\n        const filter = key => {\n          return f(this._invertKey(key));\n        };\n\n        return filter;\n      });\n      tq.filters = tq.filters.concat(filters);\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {KeyQueryOrder} */\n        const order = (a, b) => o(this._invertKey(a), this._invertKey(b));\n\n        return order;\n      });\n    }\n\n    return this.child.queryKeys(tq, options);\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n}\n\nmodule.exports = ShardingDatastore;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/datastore-core/src/sharding.js"],"names":["Adapter","Key","Errors","require","sh","KeytransformStore","shardKey","SHARDING_FN","shardReadmeKey","README_FN","ShardingDatastore","constructor","store","shard","child","convert","_convertKey","bind","invert","_invertKey","open","create","key","s","toString","parent","fun","withNamespaces","list","slice","createOrOpen","err","message","readShardFun","hasShard","has","dbOpenFailedError","Error","put","putRaw","Promise","all","TextEncoder","encode","readme","diskShard","a","b","val","options","get","delete","putMany","source","getMany","deleteMany","batch","query","q","tq","offset","limit","orders","filters","e","prefix","push","startsWith","map","f","filter","value","concat","o","order","queryKeys","close","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Adapter, Key, Errors } = require('interface-datastore')\nconst sh = require('./shard')\nconst KeytransformStore = require('./keytransform')\n\nconst shardKey = new Key(sh.SHARDING_FN)\nconst shardReadmeKey = new Key(sh.README_FN)\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nclass ShardingDatastore extends Adapter {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor (store, shard) {\n    super()\n\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    })\n    this.shard = shard\n  }\n\n  async open () {\n    await this.child.open()\n\n    this.shard = await ShardingDatastore.create(this.child, this.shard)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _convertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n\n    const parent = new Key(this.shard.fun(s))\n    return parent.child(key)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _invertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n    return Key.withNamespaces(key.list().slice(1))\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async createOrOpen (store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard)\n    } catch (err) {\n      if (err && err.message !== 'datastore exists') throw err\n    }\n    return ShardingDatastore.open(store)\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n  static async open (store) {\n    const shard = await sh.readShardFun('/', store)\n    return new ShardingDatastore(store, shard)\n  }\n\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async create (store, shard) {\n    const hasShard = await store.has(shardKey)\n    if (!hasShard && !shard) {\n      throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'))\n    }\n    if (!hasShard) {\n      // @ts-ignore i have no idea what putRaw is or saw any implementation\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store)\n      await Promise.all([\n        put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')),\n        put(shardReadmeKey, new TextEncoder().encode(sh.readme))\n      ])\n\n      return shard\n    }\n\n    // test shards\n    const diskShard = await sh.readShardFun('/', store)\n    const a = (diskShard || '').toString()\n    const b = shard.toString()\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`)\n    }\n    return diskShard\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n  put (key, val, options) {\n    return this.child.put(key, val, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get (key, options) {\n    return this.child.get(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has (key, options) {\n    return this.child.has(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete (key, options) {\n    return this.child.delete(key, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async * putMany (source, options = {}) {\n    yield * this.child.putMany(source, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n  async * getMany (source, options = {}) {\n    yield * this.child.getMany(source, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async * deleteMany (source, options = {}) {\n    yield * this.child.deleteMany(source, options)\n  }\n\n  batch () {\n    return this.child.batch()\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n      /** @type {QueryOrder[]} */\n      orders: [],\n      /** @type {QueryFilter[]} */\n      filters: [\n        /** @type {QueryFilter} */\n        e => e.key.toString() !== shardKey.toString(),\n        /** @type {QueryFilter} */\n        e => e.key.toString() !== shardReadmeKey.toString()\n      ]\n    }\n\n    const { prefix } = q\n    if (prefix != null) {\n      tq.filters.push((e) => {\n        return this._invertKey(e.key).toString().startsWith(prefix)\n      })\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {QueryFilter} */\n        const filter = ({ key, value }) => {\n          return f({\n            key: this._invertKey(key),\n            value\n          })\n        }\n\n        return filter\n      })\n      tq.filters = tq.filters.concat(filters)\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {QueryOrder} */\n        const order = (a, b) => {\n          return o({\n            key: this._invertKey(a.key),\n            value: a.value\n          }, {\n            key: this._invertKey(b.key),\n            value: b.value\n          })\n        }\n\n        return order\n      })\n    }\n\n    return this.child.query(tq, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n      /** @type {KeyQueryOrder[]} */\n      orders: [],\n      /** @type {KeyQueryFilter[]} */\n      filters: [\n        /** @type {KeyQueryFilter} */\n        key => key.toString() !== shardKey.toString(),\n        /** @type {KeyQueryFilter} */\n        key => key.toString() !== shardReadmeKey.toString()\n      ]\n    }\n\n    const { prefix } = q\n    if (prefix != null) {\n      tq.filters.push((key) => {\n        return this._invertKey(key).toString().startsWith(prefix)\n      })\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {KeyQueryFilter} */\n        const filter = (key) => {\n          return f(this._invertKey(key))\n        }\n\n        return filter\n      })\n      tq.filters = tq.filters.concat(filters)\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {KeyQueryOrder} */\n        const order = (a, b) => o(this._invertKey(a), this._invertKey(b))\n\n        return order\n      })\n    }\n\n    return this.child.queryKeys(tq, options)\n  }\n\n  close () {\n    return this.child.close()\n  }\n}\n\nmodule.exports = ShardingDatastore\n"]},"metadata":{},"sourceType":"script"}