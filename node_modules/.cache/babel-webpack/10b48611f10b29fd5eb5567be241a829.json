{"ast":null,"code":"'use strict';\n\nconst supports = require('level-supports');\n\nconst isBuffer = require('is-buffer');\n\nconst AbstractIterator = require('./abstract-iterator');\n\nconst AbstractChainedBatch = require('./abstract-chained-batch');\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst rangeOptions = ['lt', 'lte', 'gt', 'gte'];\n\nfunction AbstractLevelDOWN(manifest) {\n  this.status = 'new'; // TODO (next major): make this mandatory\n\n  this.supports = supports(manifest, {\n    status: true\n  });\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  const oldStatus = this.status;\n  if (typeof options === 'function') callback = options;\n\n  if (typeof callback !== 'function') {\n    throw new Error('open() requires a callback argument');\n  }\n\n  if (typeof options !== 'object' || options === null) options = {};\n  options.createIfMissing = options.createIfMissing !== false;\n  options.errorIfExists = !!options.errorIfExists;\n  this.status = 'opening';\n\n  this._open(options, err => {\n    if (err) {\n      this.status = oldStatus;\n      return callback(err);\n    }\n\n    this.status = 'open';\n    callback();\n  });\n};\n\nAbstractLevelDOWN.prototype._open = function (options, callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  const oldStatus = this.status;\n\n  if (typeof callback !== 'function') {\n    throw new Error('close() requires a callback argument');\n  }\n\n  this.status = 'closing';\n\n  this._close(err => {\n    if (err) {\n      this.status = oldStatus;\n      return callback(err);\n    }\n\n    this.status = 'closed';\n    callback();\n  });\n};\n\nAbstractLevelDOWN.prototype._close = function (callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  if (typeof options === 'function') callback = options;\n\n  if (typeof callback !== 'function') {\n    throw new Error('get() requires a callback argument');\n  }\n\n  const err = this._checkKey(key);\n\n  if (err) return this._nextTick(callback, err);\n  key = this._serializeKey(key);\n  if (typeof options !== 'object' || options === null) options = {};\n  options.asBuffer = options.asBuffer !== false;\n\n  this._get(key, options, callback);\n};\n\nAbstractLevelDOWN.prototype._get = function (key, options, callback) {\n  this._nextTick(function () {\n    callback(new Error('NotFound'));\n  });\n};\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  if (typeof options === 'function') callback = options;\n\n  if (typeof callback !== 'function') {\n    throw new Error('put() requires a callback argument');\n  }\n\n  const err = this._checkKey(key) || this._checkValue(value);\n\n  if (err) return this._nextTick(callback, err);\n  key = this._serializeKey(key);\n  value = this._serializeValue(value);\n  if (typeof options !== 'object' || options === null) options = {};\n\n  this._put(key, value, options, callback);\n};\n\nAbstractLevelDOWN.prototype._put = function (key, value, options, callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  if (typeof options === 'function') callback = options;\n\n  if (typeof callback !== 'function') {\n    throw new Error('del() requires a callback argument');\n  }\n\n  const err = this._checkKey(key);\n\n  if (err) return this._nextTick(callback, err);\n  key = this._serializeKey(key);\n  if (typeof options !== 'object' || options === null) options = {};\n\n  this._del(key, options, callback);\n};\n\nAbstractLevelDOWN.prototype._del = function (key, options, callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length) return this._chainedBatch();\n  if (typeof options === 'function') callback = options;\n  if (typeof array === 'function') callback = array;\n\n  if (typeof callback !== 'function') {\n    throw new Error('batch(array) requires a callback argument');\n  }\n\n  if (!Array.isArray(array)) {\n    return this._nextTick(callback, new Error('batch(array) requires an array argument'));\n  }\n\n  if (array.length === 0) {\n    return this._nextTick(callback);\n  }\n\n  if (typeof options !== 'object' || options === null) options = {};\n  const serialized = new Array(array.length);\n\n  for (let i = 0; i < array.length; i++) {\n    if (typeof array[i] !== 'object' || array[i] === null) {\n      return this._nextTick(callback, new Error('batch(array) element must be an object and not `null`'));\n    }\n\n    const e = Object.assign({}, array[i]);\n\n    if (e.type !== 'put' && e.type !== 'del') {\n      return this._nextTick(callback, new Error(\"`type` must be 'put' or 'del'\"));\n    }\n\n    const err = this._checkKey(e.key);\n\n    if (err) return this._nextTick(callback, err);\n    e.key = this._serializeKey(e.key);\n\n    if (e.type === 'put') {\n      const valueErr = this._checkValue(e.value);\n\n      if (valueErr) return this._nextTick(callback, valueErr);\n      e.value = this._serializeValue(e.value);\n    }\n\n    serialized[i] = e;\n  }\n\n  this._batch(serialized, options, callback);\n};\n\nAbstractLevelDOWN.prototype._batch = function (array, options, callback) {\n  this._nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.clear = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof callback !== 'function') {\n    throw new Error('clear() requires a callback argument');\n  }\n\n  options = cleanRangeOptions(this, options);\n  options.reverse = !!options.reverse;\n  options.limit = 'limit' in options ? options.limit : -1;\n\n  this._clear(options, callback);\n};\n\nAbstractLevelDOWN.prototype._clear = function (options, callback) {\n  // Avoid setupIteratorOptions, would serialize range options a second time.\n  options.keys = true;\n  options.values = false;\n  options.keyAsBuffer = true;\n  options.valueAsBuffer = true;\n\n  const iterator = this._iterator(options);\n\n  const emptyOptions = {};\n\n  const next = err => {\n    if (err) {\n      return iterator.end(function () {\n        callback(err);\n      });\n    }\n\n    iterator.next((err, key) => {\n      if (err) return next(err);\n      if (key === undefined) return iterator.end(callback); // This could be optimized by using a batch, but the default _clear\n      // is not meant to be fast. Implementations have more room to optimize\n      // if they override _clear. Note: using _del bypasses key serialization.\n\n      this._del(key, emptyOptions, next);\n    });\n  };\n\n  next();\n};\n\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  options = cleanRangeOptions(this, options);\n  options.reverse = !!options.reverse;\n  options.keys = options.keys !== false;\n  options.values = options.values !== false;\n  options.limit = 'limit' in options ? options.limit : -1;\n  options.keyAsBuffer = options.keyAsBuffer !== false;\n  options.valueAsBuffer = options.valueAsBuffer !== false;\n  return options;\n};\n\nfunction cleanRangeOptions(db, options) {\n  const result = {};\n\n  for (const k in options) {\n    if (!hasOwnProperty.call(options, k)) continue;\n\n    if (k === 'start' || k === 'end') {\n      throw new Error('Legacy range options (\"start\" and \"end\") have been removed');\n    }\n\n    let opt = options[k];\n\n    if (isRangeOption(k)) {\n      // Note that we don't reject nullish and empty options here. While\n      // those types are invalid as keys, they are valid as range options.\n      opt = db._serializeKey(opt);\n    }\n\n    result[k] = opt;\n  }\n\n  return result;\n}\n\nfunction isRangeOption(k) {\n  return rangeOptions.indexOf(k) !== -1;\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options !== 'object' || options === null) options = {};\n  options = this._setupIteratorOptions(options);\n  return this._iterator(options);\n};\n\nAbstractLevelDOWN.prototype._iterator = function (options) {\n  return new AbstractIterator(this);\n};\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this);\n};\n\nAbstractLevelDOWN.prototype._serializeKey = function (key) {\n  return key;\n};\n\nAbstractLevelDOWN.prototype._serializeValue = function (value) {\n  return value;\n};\n\nAbstractLevelDOWN.prototype._checkKey = function (key) {\n  if (key === null || key === undefined) {\n    return new Error('key cannot be `null` or `undefined`');\n  } else if (isBuffer(key) && key.length === 0) {\n    // TODO: replace with typed array check\n    return new Error('key cannot be an empty Buffer');\n  } else if (key === '') {\n    return new Error('key cannot be an empty String');\n  } else if (Array.isArray(key) && key.length === 0) {\n    return new Error('key cannot be an empty Array');\n  }\n};\n\nAbstractLevelDOWN.prototype._checkValue = function (value) {\n  if (value === null || value === undefined) {\n    return new Error('value cannot be `null` or `undefined`');\n  }\n}; // Expose browser-compatible nextTick for dependents\n// TODO: rename _nextTick to _queueMicrotask\n// TODO: after we drop node 10, also use queueMicrotask in node\n\n\nAbstractLevelDOWN.prototype._nextTick = require('./next-tick');\nmodule.exports = AbstractLevelDOWN;","map":null,"metadata":{},"sourceType":"script"}