{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst pipe = require('it-pipe');\n\nconst pushable = require('it-pushable');\n\nconst log = require('debug')('libp2p:mplex');\n\nconst abortable = require('abortable-iterator');\n\nconst Coder = require('./coder');\n\nconst restrictSize = require('./restrict-size');\n\nconst {\n  MessageTypes,\n  MessageTypeNames\n} = require('./message-types');\n\nconst createStream = require('./stream');\n\nlet Mplex = /*#__PURE__*/(() => {\n  class Mplex {\n    /**\n     * @class\n     * @param {object} options\n     * @param {function(*)} options.onStream - Called whenever an inbound stream is created\n     * @param {function(*)} options.onStreamEnd - Called whenever a stream ends\n     * @param {AbortSignal} options.signal - An AbortController signal\n     */\n    constructor(options) {\n      options = options || {};\n      options = typeof options === 'function' ? {\n        onStream: options\n      } : options;\n      this._streamId = 0;\n      this._streams = {\n        /**\n         * @type {Map<number, *>} Stream to ids map\n         */\n        initiators: new Map(),\n\n        /**\n         * @type {Map<number, *>} Stream to ids map\n         */\n        receivers: new Map()\n      };\n      this._options = options;\n      /**\n       * An iterable sink\n       */\n\n      this.sink = this._createSink();\n      /**\n       * An iterable source\n       */\n\n      this.source = this._createSource();\n      /**\n       * @property {Function} onStream\n       */\n\n      this.onStream = options.onStream;\n      /**\n       * @property {Function} onStreamEnd\n       */\n\n      this.onStreamEnd = options.onStreamEnd;\n    }\n    /**\n     * Returns a Map of streams and their ids\n     *\n     * @returns {Map<number,*>}\n     */\n\n\n    get streams() {\n      // Inbound and Outbound streams may have the same ids, so we need to make those unique\n      const streams = [];\n\n      this._streams.initiators.forEach(stream => {\n        streams.push(stream);\n      });\n\n      this._streams.receivers.forEach(stream => {\n        streams.push(stream);\n      });\n\n      return streams;\n    }\n    /**\n     * Initiate a new stream with the given name. If no name is\n     * provided, the id of th stream will be used.\n     *\n     * @param {string} [name] - If name is not a string it will be cast to one\n     * @returns {Stream}\n     */\n\n\n    newStream(name) {\n      const id = this._streamId++;\n      name = name == null ? id.toString() : String(name);\n      const registry = this._streams.initiators;\n      return this._newStream({\n        id,\n        name,\n        type: 'initiator',\n        registry\n      });\n    }\n    /**\n     * Called whenever an inbound stream is created\n     *\n     * @private\n     * @param {*} options\n     * @param {number} options.id\n     * @param {string} options.name\n     * @returns {*} A muxed stream\n     */\n\n\n    _newReceiverStream({\n      id,\n      name\n    }) {\n      const registry = this._streams.receivers;\n      return this._newStream({\n        id,\n        name,\n        type: 'receiver',\n        registry\n      });\n    }\n    /**\n     * Creates a new stream\n     *\n     * @private\n     * @param {object} options\n     * @param {number} options.id\n     * @param {string} options.name\n     * @param {string} options.type\n     * @param {Map<number, *>} options.registry - A map of streams to their ids\n     * @returns {*} A muxed stream\n     */\n\n\n    _newStream({\n      id,\n      name,\n      type,\n      registry\n    }) {\n      if (registry.has(id)) {\n        throw new Error(`${type} stream ${id} already exists!`);\n      }\n\n      log('new %s stream %s %s', type, id, name);\n\n      const send = msg => {\n        if (log.enabled) {\n          log('%s stream %s %s send', type, id, name, { ...msg,\n            type: MessageTypeNames[msg.type],\n            data: msg.data && msg.data.slice()\n          });\n        }\n\n        return this.source.push(msg);\n      };\n\n      const onEnd = () => {\n        log('%s stream %s %s ended', type, id, name);\n        registry.delete(id);\n        this.onStreamEnd && this.onStreamEnd(stream);\n      };\n\n      const stream = createStream({\n        id,\n        name,\n        send,\n        type,\n        onEnd,\n        maxMsgSize: this._options.maxMsgSize\n      });\n      registry.set(id, stream);\n      return stream;\n    }\n    /**\n     * Creates a sink with an abortable source. Incoming messages will\n     * also have their size restricted. All messages will be varint decoded.\n     *\n     * @private\n     * @returns {*} Returns an iterable sink\n     */\n\n\n    _createSink() {\n      var _this = this;\n\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (source) {\n          if (_this._options.signal) {\n            source = abortable(source, _this._options.signal);\n          }\n\n          try {\n            yield pipe(source, Coder.decode, restrictSize(_this._options.maxMsgSize), /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator(function* (source) {\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n\n                var _iteratorError;\n\n                try {\n                  for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n                    const msgs = _value;\n\n                    for (const msg of msgs) {\n                      _this._handleIncoming(msg);\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError = true;\n                  _iteratorError = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n                      yield _iterator.return();\n                    }\n                  } finally {\n                    if (_didIteratorError) {\n                      throw _iteratorError;\n                    }\n                  }\n                }\n              });\n\n              return function (_x2) {\n                return _ref2.apply(this, arguments);\n              };\n            }());\n          } catch (err) {\n            log('error in sink', err);\n            return _this.source.end(err); // End the source with an error\n          }\n\n          _this.source.end();\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    }\n    /**\n     * Creates a source that restricts outgoing message sizes\n     * and varint encodes them.\n     *\n     * @private\n     * @returns {*} An iterable source\n     */\n\n\n    _createSource() {\n      const onEnd = err => {\n        const {\n          initiators,\n          receivers\n        } = this._streams; // Abort all the things!\n\n        for (const s of initiators.values()) s.abort(err);\n\n        for (const s of receivers.values()) s.abort(err);\n      };\n\n      const source = pushable({\n        onEnd,\n        writev: true\n      });\n      return Object.assign(Coder.encode(source), {\n        push: source.push,\n        end: source.end,\n        return: source.return\n      });\n    }\n    /**\n     * @private\n     * @param {object} options\n     * @param {number} options.id\n     * @param {string} options.type\n     * @param {Uint8Array|BufferList} options.data\n     * @returns {void}\n     */\n\n\n    _handleIncoming({\n      id,\n      type,\n      data\n    }) {\n      if (log.enabled) {\n        log('incoming message', {\n          id,\n          type: MessageTypeNames[type],\n          data: data.slice()\n        });\n      } // Create a new stream?\n\n\n      if (type === MessageTypes.NEW_STREAM && this.onStream) {\n        const stream = this._newReceiverStream({\n          id,\n          name: data.toString()\n        });\n\n        return this.onStream(stream);\n      }\n\n      const list = type & 1 ? this._streams.initiators : this._streams.receivers;\n      const stream = list.get(id);\n      if (!stream) return log('missing stream %s', id);\n\n      switch (type) {\n        case MessageTypes.MESSAGE_INITIATOR:\n        case MessageTypes.MESSAGE_RECEIVER:\n          stream.source.push(data);\n          break;\n\n        case MessageTypes.CLOSE_INITIATOR:\n        case MessageTypes.CLOSE_RECEIVER:\n          stream.close();\n          break;\n\n        case MessageTypes.RESET_INITIATOR:\n        case MessageTypes.RESET_RECEIVER:\n          stream.reset();\n          break;\n\n        default:\n          log('unknown message type %s', type);\n      }\n    }\n\n  }\n\n  Mplex.multicodec = '/mplex/6.7.0';\n  return Mplex;\n})();\nmodule.exports = Mplex;","map":null,"metadata":{},"sourceType":"script"}