{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst Stat = require('./stat');\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * @typedef {[number, number, number]} AverageIntervals\n */\n\n\nconst defaultOptions = {\n  enabled: false,\n  computeThrottleTimeout: 1000,\n  computeThrottleMaxQueueSize: 1000,\n  movingAverageIntervals: [60 * 1000, // 1 minute\n  5 * 60 * 1000, // 5 minutes\n  15 * 60 * 1000 // 15 minutes\n  ]\n};\n\nclass Stats extends EventEmitter {\n  /**\n   * @param {string[]} [initialCounters]\n   * @param {Object} _options\n   * @param {boolean} _options.enabled\n   * @param {number} _options.computeThrottleTimeout\n   * @param {number} _options.computeThrottleMaxQueueSize\n   */\n  constructor(initialCounters = [], _options = defaultOptions) {\n    super();\n    const options = Object.assign({}, defaultOptions, _options);\n\n    if (typeof options.computeThrottleTimeout !== 'number') {\n      throw new Error('need computeThrottleTimeout');\n    }\n\n    if (typeof options.computeThrottleMaxQueueSize !== 'number') {\n      throw new Error('need computeThrottleMaxQueueSize');\n    }\n\n    this._initialCounters = initialCounters;\n    this._options = options;\n    this._enabled = this._options.enabled;\n    this._global = new Stat(initialCounters, options);\n\n    this._global.on('update', stats => this.emit('update', stats));\n    /** @type {Map<string, Stat>} */\n\n\n    this._peers = new Map();\n  }\n\n  enable() {\n    this._enabled = true;\n    this._options.enabled = true;\n\n    this._global.enable();\n  }\n\n  disable() {\n    this._enabled = false;\n    this._options.enabled = false;\n\n    this._global.disable();\n  }\n\n  stop() {\n    this._enabled = false;\n\n    this._global.stop();\n\n    for (const peerStat of this._peers) {\n      peerStat[1].stop();\n    }\n  }\n\n  get snapshot() {\n    return this._global.snapshot;\n  }\n\n  get movingAverages() {\n    return this._global.movingAverages;\n  }\n  /**\n   * @param {PeerId|string} peerId\n   * @returns {Stat|undefined}\n   */\n\n\n  forPeer(peerId) {\n    const peerIdStr = typeof peerId !== 'string' && peerId.toB58String ? peerId.toB58String() : `${peerId}`;\n    return this._peers.get(peerIdStr);\n  }\n  /**\n   *\n   * @param {string|null} peer\n   * @param {string} counter\n   * @param {number} inc\n   */\n\n\n  push(peer, counter, inc) {\n    if (this._enabled) {\n      this._global.push(counter, inc);\n\n      if (peer) {\n        let peerStats = this._peers.get(peer);\n\n        if (!peerStats) {\n          peerStats = new Stat(this._initialCounters, this._options);\n\n          this._peers.set(peer, peerStats);\n        }\n\n        peerStats.push(counter, inc);\n      }\n    }\n  }\n  /**\n   * @param {PeerId} peer\n   */\n\n\n  disconnected(peer) {\n    const peerId = peer.toB58String();\n\n    const peerStats = this._peers.get(peerId);\n\n    if (peerStats) {\n      peerStats.stop();\n\n      this._peers.delete(peerId);\n    }\n  }\n\n}\n\nmodule.exports = Stats;","map":null,"metadata":{},"sourceType":"script"}