{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport batch from 'it-batch';\n\nfunction trickleStream(_x, _x2, _x3) {\n  return _trickleStream.apply(this, arguments);\n}\n\nfunction _trickleStream() {\n  _trickleStream = _asyncToGenerator(function* (source, reduce, options) {\n    const root = new Root(options.layerRepeat);\n    let iteration = 0;\n    let maxDepth = 1;\n    let subTree = root;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(batch(source, options.maxChildrenPerNode)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const layer = _value;\n\n        if (subTree.isFull()) {\n          if (subTree !== root) {\n            root.addChild(yield subTree.reduce(reduce));\n          }\n\n          if (iteration && iteration % options.layerRepeat === 0) {\n            maxDepth++;\n          }\n\n          subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n          iteration++;\n        }\n\n        subTree.append(layer);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (subTree && subTree !== root) {\n      root.addChild(yield subTree.reduce(reduce));\n    }\n\n    return root.reduce(reduce);\n  });\n  return _trickleStream.apply(this, arguments);\n}\n\nexport default trickleStream;\n\nclass SubTree {\n  constructor(maxDepth, layerRepeat, iteration = 0) {\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n\n  isFull() {\n    if (!this.root.data) {\n      return false;\n    }\n\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      this._addNextNodeToParent(this.node);\n\n      return false;\n    }\n\n    const distantRelative = this._findParent(this.node, this.currentDepth);\n\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative);\n\n      return false;\n    }\n\n    return true;\n  }\n\n  _addNextNodeToParent(parent) {\n    this.parent = parent;\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    };\n    parent.children.push(nextNode);\n    this.currentDepth = nextNode.depth;\n    this.node = nextNode;\n  }\n\n  append(layer) {\n    this.node.data = layer;\n  }\n\n  reduce(reduce) {\n    return this._reduce(this.root, reduce);\n  }\n\n  _reduce(node, reduce) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let children = [];\n\n      if (node.children.length) {\n        children = yield Promise.all(node.children.filter(child => child.data).map(child => _this._reduce(child, reduce)));\n      }\n\n      return reduce((node.data || []).concat(children));\n    })();\n  }\n\n  _findParent(node, depth) {\n    const parent = node.parent;\n\n    if (!parent || parent.depth === 0) {\n      return;\n    }\n\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      return this._findParent(parent, depth);\n    }\n\n    return parent;\n  }\n\n}\n\nclass Root extends SubTree {\n  constructor(layerRepeat) {\n    super(0, layerRepeat);\n    this.root.depth = 0;\n    this.currentDepth = 1;\n  }\n\n  addChild(child) {\n    this.root.children.push(child);\n  }\n\n  reduce(reduce) {\n    return reduce((this.root.data || []).concat(this.root.children));\n  }\n\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/trickle.js"],"names":["batch","trickleStream","source","reduce","options","root","Root","layerRepeat","iteration","maxDepth","subTree","maxChildrenPerNode","layer","isFull","addChild","SubTree","append","constructor","currentDepth","node","parent","children","depth","maxChildren","data","_addNextNodeToParent","distantRelative","_findParent","nextNode","Math","floor","length","push","_reduce","Promise","all","filter","child","map","concat"],"mappings":"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","sourcesContent":["import batch from 'it-batch';\nasync function trickleStream(source, reduce, options) {\n  const root = new Root(options.layerRepeat);\n  let iteration = 0;\n  let maxDepth = 1;\n  let subTree = root;\n  for await (const layer of batch(source, options.maxChildrenPerNode)) {\n    if (subTree.isFull()) {\n      if (subTree !== root) {\n        root.addChild(await subTree.reduce(reduce));\n      }\n      if (iteration && iteration % options.layerRepeat === 0) {\n        maxDepth++;\n      }\n      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n      iteration++;\n    }\n    subTree.append(layer);\n  }\n  if (subTree && subTree !== root) {\n    root.addChild(await subTree.reduce(reduce));\n  }\n  return root.reduce(reduce);\n}\nexport default trickleStream;\nclass SubTree {\n  constructor(maxDepth, layerRepeat, iteration = 0) {\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n  isFull() {\n    if (!this.root.data) {\n      return false;\n    }\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      this._addNextNodeToParent(this.node);\n      return false;\n    }\n    const distantRelative = this._findParent(this.node, this.currentDepth);\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative);\n      return false;\n    }\n    return true;\n  }\n  _addNextNodeToParent(parent) {\n    this.parent = parent;\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    };\n    parent.children.push(nextNode);\n    this.currentDepth = nextNode.depth;\n    this.node = nextNode;\n  }\n  append(layer) {\n    this.node.data = layer;\n  }\n  reduce(reduce) {\n    return this._reduce(this.root, reduce);\n  }\n  async _reduce(node, reduce) {\n    let children = [];\n    if (node.children.length) {\n      children = await Promise.all(node.children.filter(child => child.data).map(child => this._reduce(child, reduce)));\n    }\n    return reduce((node.data || []).concat(children));\n  }\n  _findParent(node, depth) {\n    const parent = node.parent;\n    if (!parent || parent.depth === 0) {\n      return;\n    }\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      return this._findParent(parent, depth);\n    }\n    return parent;\n  }\n}\nclass Root extends SubTree {\n  constructor(layerRepeat) {\n    super(0, layerRepeat);\n    this.root.depth = 0;\n    this.currentDepth = 1;\n  }\n  addChild(child) {\n    this.root.children.push(child);\n  }\n  reduce(reduce) {\n    return reduce((this.root.data || []).concat(this.root.children));\n  }\n}"]},"metadata":{},"sourceType":"module"}