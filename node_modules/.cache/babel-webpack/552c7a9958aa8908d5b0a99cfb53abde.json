{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst ConsumableBuffer = require('./consumable-buffer');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\n\n\nfunction wrapHash(hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing(value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value;\n    } else {\n      return new InfiniteHash(value, hashFn);\n    }\n  }\n\n  return hashing;\n}\n\nclass InfiniteHash {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  constructor(value, hashFn) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays');\n    }\n\n    this._value = value;\n    this._hashFn = hashFn;\n    this._depth = -1;\n    this._availableBits = 0;\n    this._currentBufferIndex = 0;\n    /** @type {ConsumableBuffer[]} */\n\n    this._buffers = [];\n  }\n  /**\n   * @param {number} bits\n   */\n\n\n  take(bits) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let pendingBits = bits;\n\n      while (_this._availableBits < pendingBits) {\n        yield _this._produceMoreBits();\n      }\n\n      let result = 0;\n\n      while (pendingBits > 0) {\n        const hash = _this._buffers[_this._currentBufferIndex];\n        const available = Math.min(hash.availableBits(), pendingBits);\n        const took = hash.take(available);\n        result = (result << available) + took;\n        pendingBits -= available;\n        _this._availableBits -= available;\n\n        if (hash.availableBits() === 0) {\n          _this._currentBufferIndex++;\n        }\n      }\n\n      return result;\n    })();\n  }\n  /**\n   * @param {number} bits\n   */\n\n\n  untake(bits) {\n    let pendingBits = bits;\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex];\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n      hash.untake(availableForUntake);\n      pendingBits -= availableForUntake;\n      this._availableBits += availableForUntake;\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--;\n        this._currentBufferIndex--;\n      }\n    }\n  }\n\n  _produceMoreBits() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2._depth++;\n      const value = _this2._depth ? uint8ArrayConcat([_this2._value, Uint8Array.from([_this2._depth])]) : _this2._value;\n      const hashValue = yield _this2._hashFn(value);\n      const buffer = new ConsumableBuffer(hashValue);\n\n      _this2._buffers.push(buffer);\n\n      _this2._availableBits += buffer.availableBits();\n    })();\n  }\n\n}\n\nmodule.exports = wrapHash;\nmodule.exports.InfiniteHash = InfiniteHash;","map":null,"metadata":{},"sourceType":"script"}