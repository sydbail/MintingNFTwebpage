{"ast":null,"code":"'use strict';\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  CircuitRelay\n} = require('../protocol');\n/**\n * @typedef {import('./stream-handler')} StreamHandler\n * @typedef {import('../protocol').ICircuitRelay} ICircuitRelay\n */\n\n/**\n * Write a response\n *\n * @param {StreamHandler} streamHandler\n * @param {import('../protocol').CircuitRelay.Status} status\n */\n\n\nfunction writeResponse(streamHandler, status) {\n  streamHandler.write({\n    type: CircuitRelay.Type.STATUS,\n    code: status\n  });\n}\n/**\n * Validate incomming HOP/STOP message\n *\n * @param {ICircuitRelay} msg - A CircuitRelay unencoded protobuf message\n * @param {StreamHandler} streamHandler\n */\n\n\nfunction validateAddrs(msg, streamHandler) {\n  try {\n    if (msg.dstPeer && msg.dstPeer.addrs) {\n      msg.dstPeer.addrs.forEach(addr => {\n        return new Multiaddr(addr);\n      });\n    }\n  } catch (err) {\n    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);\n    throw err;\n  }\n\n  try {\n    if (msg.srcPeer && msg.srcPeer.addrs) {\n      msg.srcPeer.addrs.forEach(addr => {\n        return new Multiaddr(addr);\n      });\n    }\n  } catch (err) {\n    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);\n    throw err;\n  }\n}\n\nmodule.exports = {\n  validateAddrs\n};","map":null,"metadata":{},"sourceType":"script"}