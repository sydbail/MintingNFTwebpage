{"ast":null,"code":"/* eslint complexity: [\"error\", 27] */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst defaultMigrations = require('../migrations');\n\nconst repoVersion = require('./repo/version');\n\nconst errors = require('./errors');\n\nconst {\n  wrapBackends\n} = require('./utils');\n\nconst log = require('debug')('ipfs:repo:migrator');\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\n\n\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\n\n\nfunction migrate(_x, _x2, _x3, _x4, _x5) {\n  return _migrate.apply(this, arguments);\n}\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\n\n\nfunction _migrate() {\n  _migrate = _asyncToGenerator(function* (path, backends, repoOptions, toVersion, {\n    ignoreLock = false,\n    onProgress,\n    isDryRun = false,\n    migrations\n  }) {\n    migrations = migrations || defaultMigrations;\n\n    if (!path) {\n      throw new errors.RequiredParameterError('Path argument is required!');\n    }\n\n    if (!repoOptions) {\n      throw new errors.RequiredParameterError('repoOptions argument is required!');\n    }\n\n    if (!toVersion) {\n      throw new errors.RequiredParameterError('toVersion argument is required!');\n    }\n\n    if (!Number.isInteger(toVersion) || toVersion <= 0) {\n      throw new errors.InvalidValueError('Version has to be positive integer!');\n    } // make sure we can read pre-level@5 datastores\n\n\n    backends = wrapBackends(backends);\n    const currentVersion = yield repoVersion.getVersion(backends);\n\n    if (currentVersion === toVersion) {\n      log('Nothing to migrate.');\n      return;\n    }\n\n    if (currentVersion > toVersion) {\n      throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);\n    }\n\n    verifyAvailableMigrations(migrations, currentVersion, toVersion);\n    let lock;\n\n    if (!isDryRun && !ignoreLock) {\n      lock = yield repoOptions.repoLock.lock(path);\n    }\n\n    try {\n      for (const migration of migrations) {\n        if (toVersion !== undefined && migration.version > toVersion) {\n          break;\n        }\n\n        if (migration.version <= currentVersion) {\n          continue;\n        }\n\n        log(`Migrating version ${migration.version}`);\n\n        try {\n          if (!isDryRun) {\n            /** @type {MigrationProgressCallback} */\n            let progressCallback = () => {};\n\n            if (onProgress) {\n              // eslint-disable-line max-depth\n              progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n            }\n\n            yield migration.migrate(backends, progressCallback);\n          }\n        } catch (e) {\n          const lastSuccessfullyMigratedVersion = migration.version - 1;\n          log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);\n          yield repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends);\n          throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`);\n        }\n\n        log(`Migrating to version ${migration.version} finished`);\n      }\n\n      if (!isDryRun) {\n        yield repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);\n      }\n\n      log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!');\n    } finally {\n      if (!isDryRun && !ignoreLock && lock) {\n        yield lock.close();\n      }\n    }\n  });\n  return _migrate.apply(this, arguments);\n}\n\nfunction revert(_x6, _x7, _x8, _x9, _x10) {\n  return _revert.apply(this, arguments);\n}\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\n\n\nfunction _revert() {\n  _revert = _asyncToGenerator(function* (path, backends, repoOptions, toVersion, {\n    ignoreLock = false,\n    onProgress,\n    isDryRun = false,\n    migrations\n  }) {\n    migrations = migrations || defaultMigrations;\n\n    if (!path) {\n      throw new errors.RequiredParameterError('Path argument is required!');\n    }\n\n    if (!repoOptions) {\n      throw new errors.RequiredParameterError('repoOptions argument is required!');\n    }\n\n    if (!toVersion) {\n      throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n    }\n\n    if (!Number.isInteger(toVersion) || toVersion <= 0) {\n      throw new errors.InvalidValueError('Version has to be positive integer!');\n    } // make sure we can read pre-level@5 datastores\n\n\n    backends = wrapBackends(backends);\n    const currentVersion = yield repoVersion.getVersion(backends);\n\n    if (currentVersion === toVersion) {\n      log('Nothing to revert.');\n      return;\n    }\n\n    if (currentVersion < toVersion) {\n      throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);\n    }\n\n    verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n    let lock;\n\n    if (!isDryRun && !ignoreLock) {\n      lock = yield repoOptions.repoLock.lock(path);\n    }\n\n    log(`Reverting from version ${currentVersion} to ${toVersion}`);\n\n    try {\n      const reversedMigrationArray = migrations.slice().reverse();\n\n      for (const migration of reversedMigrationArray) {\n        if (migration.version <= toVersion) {\n          break;\n        }\n\n        if (migration.version > currentVersion) {\n          continue;\n        }\n\n        log(`Reverting migration version ${migration.version}`);\n\n        try {\n          if (!isDryRun) {\n            /** @type {MigrationProgressCallback} */\n            let progressCallback = () => {};\n\n            if (onProgress) {\n              // eslint-disable-line max-depth\n              progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n            }\n\n            yield migration.revert(backends, progressCallback);\n          }\n        } catch (e) {\n          const lastSuccessfullyRevertedVersion = migration.version;\n          log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);\n          yield repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends);\n          e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`;\n          throw e;\n        }\n\n        log(`Reverting to version ${migration.version} finished`);\n      }\n\n      if (!isDryRun) {\n        yield repoVersion.setVersion(toVersion, backends);\n      }\n\n      log(`All migrations successfully reverted to version ${toVersion}!`);\n    } finally {\n      if (!isDryRun && !ignoreLock && lock) {\n        yield lock.close();\n      }\n    }\n  });\n  return _revert.apply(this, arguments);\n}\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0;\n\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break;\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`);\n      }\n\n      migrationCounter++;\n    }\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);\n  }\n}\n\nmodule.exports = {\n  getCurrentRepoVersion: repoVersion.getVersion,\n  getLatestMigrationVersion,\n  errors,\n  migrate,\n  revert\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-repo-migrations/src/index.js"],"names":["defaultMigrations","require","repoVersion","errors","wrapBackends","log","getLatestMigrationVersion","migrations","Array","isArray","length","version","migrate","path","backends","repoOptions","toVersion","ignoreLock","onProgress","isDryRun","RequiredParameterError","Number","isInteger","InvalidValueError","currentVersion","getVersion","verifyAvailableMigrations","lock","repoLock","migration","undefined","progressCallback","percent","message","toFixed","e","lastSuccessfullyMigratedVersion","setVersion","Error","stack","close","revert","reversedMigrationArray","slice","reverse","lastSuccessfullyRevertedVersion","fromVersion","checkReversibility","migrationCounter","NonReversibleMigrationError","module","exports","getCurrentRepoVersion"],"mappings":"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","sourcesContent":["/* eslint complexity: [\"error\", 27] */\n'use strict'\n\nconst defaultMigrations = require('../migrations')\nconst repoVersion = require('./repo/version')\nconst errors = require('./errors')\nconst { wrapBackends } = require('./utils')\nconst log = require('debug')('ipfs:repo:migrator')\n\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\nfunction getLatestMigrationVersion (migrations) {\n  migrations = migrations || defaultMigrations\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0\n  }\n\n  return migrations[migrations.length - 1].version\n}\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\nasync function migrate (path, backends, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {\n  migrations = migrations || defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.')\n    return\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`)\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion)\n\n  let lock\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break\n      }\n\n      if (migration.version <= currentVersion) {\n        continue\n      }\n\n      log(`Migrating version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.migrate(backends, progressCallback)\n        }\n      } catch (e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1\n\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends)\n\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`)\n      }\n\n      log(`Migrating to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends)\n    }\n\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!')\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\nasync function revert (path, backends, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {\n  migrations = migrations || defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.')\n    return\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`)\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true)\n\n  let lock\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`)\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse()\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break\n      }\n\n      if (migration.version > currentVersion) {\n        continue\n      }\n\n      log(`Reverting migration version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.revert(backends, progressCallback)\n        }\n      } catch (e) {\n        const lastSuccessfullyRevertedVersion = migration.version\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends)\n\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`\n        throw e\n      }\n\n      log(`Reverting to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion, backends)\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`)\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\nfunction verifyAvailableMigrations (migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`)\n      }\n\n      migrationCounter++\n    }\n  }\n\n  if (migrationCounter !== (toVersion - fromVersion)) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`)\n  }\n}\n\nmodule.exports = {\n  getCurrentRepoVersion: repoVersion.getVersion,\n  getLatestMigrationVersion,\n  errors,\n  migrate,\n  revert\n}\n"]},"metadata":{},"sourceType":"script"}