{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:identify'), {\n  error: debug('libp2p:identify:err')\n});\n\nconst errCode = require('err-code');\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  collect,\n  take,\n  consume\n} = require('streaming-iterables');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr'); // @ts-ignore it-buffer does not have types\n\n\nconst {\n  toBuffer\n} = require('it-buffer');\n\nconst Message = require('./message');\n\nconst Envelope = require('../record/envelope');\n\nconst PeerRecord = require('../record/peer-record');\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} = require('./consts');\n\nconst {\n  codes\n} = require('../errors');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @typedef {Object} HostProperties\n * @property {string} agentVersion\n */\n\n\nclass IdentifyService {\n  /**\n   * @param {import('../')} libp2p\n   */\n  static getProtocolStr(libp2p) {\n    return {\n      identifyProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,\n      identifyPushProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`\n    };\n  }\n  /**\n   * @class\n   * @param {Object} options\n   * @param {import('../')} options.libp2p\n   */\n\n\n  constructor({\n    libp2p\n  }) {\n    this._libp2p = libp2p;\n    this.peerStore = libp2p.peerStore;\n    this.addressManager = libp2p.addressManager;\n    this.connectionManager = libp2p.connectionManager;\n    this.peerId = libp2p.peerId;\n    this.handleMessage = this.handleMessage.bind(this);\n    const protocolStr = IdentifyService.getProtocolStr(libp2p);\n    this.identifyProtocolStr = protocolStr.identifyProtocolStr;\n    this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr; // Store self host metadata\n\n    this._host = {\n      protocolVersion: `${libp2p._config.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      ...libp2p._options.host\n    };\n    this.peerStore.metadataBook.set(this.peerId, 'AgentVersion', uint8ArrayFromString(this._host.agentVersion));\n    this.peerStore.metadataBook.set(this.peerId, 'ProtocolVersion', uint8ArrayFromString(this._host.protocolVersion)); // When a new connection happens, trigger identify\n\n    this.connectionManager.on('peer:connect', connection => {\n      this.identify(connection).catch(log.error);\n    }); // When self multiaddrs change, trigger identify-push\n\n    this.peerStore.on('change:multiaddrs', ({\n      peerId\n    }) => {\n      if (peerId.toString() === this.peerId.toString()) {\n        this.pushToPeerStore();\n      }\n    }); // When self protocols change, trigger identify-push\n\n    this.peerStore.on('change:protocols', ({\n      peerId\n    }) => {\n      if (peerId.toString() === this.peerId.toString()) {\n        this.pushToPeerStore();\n      }\n    });\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   *\n   * @param {Connection[]} connections\n   * @returns {Promise<void[]>}\n   */\n\n\n  push(connections) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const signedPeerRecord = yield _this.peerStore.addressBook.getRawEnvelope(_this.peerId);\n\n      const listenAddrs = _this._libp2p.multiaddrs.map(ma => ma.bytes);\n\n      const protocols = _this.peerStore.protoBook.get(_this.peerId) || [];\n      const pushes = connections.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (connection) {\n          try {\n            const {\n              stream\n            } = yield connection.newStream(_this.identifyPushProtocolStr);\n            yield pipe([Message.Identify.encode({\n              listenAddrs,\n              signedPeerRecord,\n              protocols\n            }).finish()], lp.encode(), stream, consume);\n          } catch (err) {\n            // Just log errors\n            log.error('could not push identify update to peer', err);\n          }\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return Promise.all(pushes);\n    })();\n  }\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   *\n   * @returns {void}\n   */\n\n\n  pushToPeerStore() {\n    // Do not try to push if libp2p node is not running\n    if (!this._libp2p.isStarted()) {\n      return;\n    }\n\n    const connections = [];\n    let connection;\n\n    for (const peer of this.peerStore.peers.values()) {\n      if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection);\n      }\n    }\n\n    this.push(connections);\n  }\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n\n\n  identify(connection) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        stream\n      } = yield connection.newStream(_this2.identifyProtocolStr);\n      const [data] = yield pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n      if (!data) {\n        throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n      }\n\n      let message;\n\n      try {\n        message = Message.Identify.decode(data);\n      } catch (err) {\n        throw errCode(err, codes.ERR_INVALID_MESSAGE);\n      }\n\n      const {\n        publicKey,\n        listenAddrs,\n        protocols,\n        observedAddr,\n        signedPeerRecord\n      } = message;\n      const id = yield PeerId.createFromPubKey(publicKey);\n\n      if (connection.remotePeer.toB58String() !== id.toB58String()) {\n        throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n      } // Get the observedAddr if there is one\n\n\n      const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);\n\n      try {\n        const envelope = yield Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);\n\n        if (_this2.peerStore.addressBook.consumePeerRecord(envelope)) {\n          _this2.peerStore.protoBook.set(id, protocols);\n\n          _this2.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion));\n\n          _this2.peerStore.metadataBook.set(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion));\n\n          return;\n        }\n      } catch (err) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n      } // LEGACY: Update peers data in PeerStore\n\n\n      try {\n        _this2.peerStore.addressBook.set(id, listenAddrs.map(addr => new Multiaddr(addr)));\n      } catch (err) {\n        log.error('received invalid addrs', err);\n      }\n\n      _this2.peerStore.protoBook.set(id, protocols);\n\n      _this2.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion));\n\n      _this2.peerStore.metadataBook.set(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion)); // TODO: Add and score our observed addr\n\n\n      log('received observed address of %s', cleanObservedAddr); // this.addressManager.addObservedAddr(observedAddr)\n    })();\n  }\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {Object} options\n   * @param {Connection} options.connection\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   * @returns {Promise<void>|undefined}\n   */\n\n\n  handleMessage({\n    connection,\n    stream,\n    protocol\n  }) {\n    switch (protocol) {\n      case this.identifyProtocolStr:\n        return this._handleIdentify({\n          connection,\n          stream\n        });\n\n      case this.identifyPushProtocolStr:\n        return this._handlePush({\n          connection,\n          stream\n        });\n\n      default:\n        log.error('cannot handle unknown protocol %s', protocol);\n    }\n  }\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   *\n   * @private\n   * @param {Object} options\n   * @param {MuxedStream} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n\n\n  _handleIdentify({\n    connection,\n    stream\n  }) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let publicKey = new Uint8Array(0);\n\n      if (_this3.peerId.pubKey) {\n        publicKey = _this3.peerId.pubKey.bytes;\n      }\n\n      const signedPeerRecord = yield _this3.peerStore.addressBook.getRawEnvelope(_this3.peerId);\n      const protocols = _this3.peerStore.protoBook.get(_this3.peerId) || [];\n      const message = Message.Identify.encode({\n        protocolVersion: _this3._host.protocolVersion,\n        agentVersion: _this3._host.agentVersion,\n        publicKey,\n        listenAddrs: _this3._libp2p.multiaddrs.map(ma => ma.bytes),\n        signedPeerRecord,\n        observedAddr: connection.remoteAddr.bytes,\n        protocols\n      }).finish();\n\n      try {\n        yield pipe([message], lp.encode(), stream, consume);\n      } catch (err) {\n        log.error('could not respond to identify request', err);\n      }\n    })();\n  }\n  /**\n   * Reads the Identify Push message from the given `connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {MuxedStream} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n\n\n  _handlePush({\n    connection,\n    stream\n  }) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let message;\n\n      try {\n        const [data] = yield pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n        message = Message.Identify.decode(data);\n      } catch (err) {\n        return log.error('received invalid message', err);\n      }\n\n      const id = connection.remotePeer;\n\n      try {\n        const envelope = yield Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);\n\n        if (_this4.peerStore.addressBook.consumePeerRecord(envelope)) {\n          _this4.peerStore.protoBook.set(id, message.protocols);\n\n          return;\n        }\n      } catch (err) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n      } // LEGACY: Update peers data in PeerStore\n\n\n      try {\n        _this4.peerStore.addressBook.set(id, message.listenAddrs.map(addr => new Multiaddr(addr)));\n      } catch (err) {\n        log.error('received invalid addrs', err);\n      } // Update the protocols\n\n\n      _this4.peerStore.protoBook.set(id, message.protocols);\n    })();\n  }\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   *\n   * @param {Uint8Array | string} addr\n   * @returns {Multiaddr|null}\n   */\n\n\n  static getCleanMultiaddr(addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return new Multiaddr(addr);\n      } catch (_) {\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n}\n/**\n * The protocols the IdentifyService supports\n *\n * @property multicodecs\n */\n\n\nconst multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nIdentifyService.multicodecs = multicodecs;\nIdentifyService.Messsage = Message;\nmodule.exports = IdentifyService;","map":null,"metadata":{},"sourceType":"script"}