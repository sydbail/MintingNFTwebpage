{"ast":null,"code":"/* eslint-env browser */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst TLRU = require('../utils/tlru');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst HTTP = require('ipfs-utils/src/http'); // Avoid sending multiple queries for the same hostname by caching results\n\n\nconst cache = new TLRU(1000); // TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\n\nconst ttl = 60 * 1000; // browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\n\nconst httpQueue = new PQueue({\n  concurrency: 4\n});\n/**\n * @param {{ Path: string, Message: string }} response\n */\n\nconst ipfsPath = response => {\n  if (response.Path) return response.Path;\n  throw new Error(response.Message);\n};\n/**\n * @param {string} fqdn\n * @param {object} opts\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (fqdn, opts) {\n    // eslint-disable-line require-await\n\n    /**\n     * @param {string} fqdn\n     * @param {object} opts\n     * @param {boolean} [opts.nocache]\n     */\n    const resolveDnslink = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (fqdn, opts = {}) {\n        // @ts-ignore - URLSearchParams does not take boolean options, only strings\n        const searchParams = new URLSearchParams(opts);\n        searchParams.set('arg', fqdn); // try cache first\n\n        const query = searchParams.toString();\n\n        if (!opts.nocache && cache.has(query)) {\n          const response = cache.get(query);\n          return ipfsPath(response);\n        } // fallback to delegated DNS resolver\n\n\n        const response = yield httpQueue.add( /*#__PURE__*/_asyncToGenerator(function* () {\n          // Delegated HTTP resolver sending DNSLink queries to ipfs.io\n          // TODO: replace hardcoded host with configurable DNS over HTTPS: https://github.com/ipfs/js-ipfs/issues/2212\n          const res = yield HTTP.get('https://ipfs.io/api/v0/dns', {\n            searchParams\n          });\n          const query = new URL(res.url).search.slice(1);\n          const json = yield res.json();\n          cache.set(query, json, ttl);\n          return json;\n        }));\n        return ipfsPath(response);\n      });\n\n      return function resolveDnslink(_x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    return resolveDnslink(fqdn, opts);\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/ipfs-core/src/runtime/dns-browser.js"],"names":["TLRU","require","default","PQueue","HTTP","cache","ttl","httpQueue","concurrency","ipfsPath","response","Path","Error","Message","module","exports","fqdn","opts","resolveDnslink","searchParams","URLSearchParams","set","query","toString","nocache","has","get","add","res","URL","url","search","slice","json"],"mappings":"AAAA;AACA;;;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,eAAD,CAApB;;AACA,MAAM;AAAEC,EAAAA,OAAO,EAAEC;AAAX,IAAsBF,OAAO,CAAC,SAAD,CAAnC;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,qBAAD,CAApB,C,CAEA;;;AACA,MAAMI,KAAK,GAAG,IAAIL,IAAJ,CAAS,IAAT,CAAd,C,CACA;AACA;AACA;;AACA,MAAMM,GAAG,GAAG,KAAK,IAAjB,C,CAEA;AACA;;AACA,MAAMC,SAAS,GAAG,IAAIJ,MAAJ,CAAW;AAAEK,EAAAA,WAAW,EAAE;AAAf,CAAX,CAAlB;AAEA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAIC,QAAD,IAAc;AAC7B,MAAIA,QAAQ,CAACC,IAAb,EAAmB,OAAOD,QAAQ,CAACC,IAAhB;AACnB,QAAM,IAAIC,KAAJ,CAAUF,QAAQ,CAACG,OAAnB,CAAN;AACD,CAHD;AAKA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP;AAAA,+BAAiB,WAAOC,IAAP,EAAaC,IAAb,EAAsB;AAAE;;AACvC;AACF;AACA;AACA;AACA;AACE,UAAMC,cAAc;AAAA,oCAAG,WAAOF,IAAP,EAAaC,IAAI,GAAG,EAApB,EAA2B;AAChD;AACA,cAAME,YAAY,GAAG,IAAIC,eAAJ,CAAoBH,IAApB,CAArB;AACAE,QAAAA,YAAY,CAACE,GAAb,CAAiB,KAAjB,EAAwBL,IAAxB,EAHgD,CAKhD;;AACA,cAAMM,KAAK,GAAGH,YAAY,CAACI,QAAb,EAAd;;AACA,YAAI,CAACN,IAAI,CAACO,OAAN,IAAiBnB,KAAK,CAACoB,GAAN,CAAUH,KAAV,CAArB,EAAuC;AACrC,gBAAMZ,QAAQ,GAAGL,KAAK,CAACqB,GAAN,CAAUJ,KAAV,CAAjB;AACA,iBAAOb,QAAQ,CAACC,QAAD,CAAf;AACD,SAV+C,CAYhD;;;AACA,cAAMA,QAAQ,SAASH,SAAS,CAACoB,GAAV,iCAAc,aAAY;AAC/C;AACA;AACA,gBAAMC,GAAG,SAASxB,IAAI,CAACsB,GAAL,CAAS,4BAAT,EAAuC;AAAEP,YAAAA;AAAF,WAAvC,CAAlB;AACA,gBAAMG,KAAK,GAAG,IAAIO,GAAJ,CAAQD,GAAG,CAACE,GAAZ,EAAiBC,MAAjB,CAAwBC,KAAxB,CAA8B,CAA9B,CAAd;AACA,gBAAMC,IAAI,SAASL,GAAG,CAACK,IAAJ,EAAnB;AACA5B,UAAAA,KAAK,CAACgB,GAAN,CAAUC,KAAV,EAAiBW,IAAjB,EAAuB3B,GAAvB;AAEA,iBAAO2B,IAAP;AACD,SATsB,EAAvB;AAUA,eAAOxB,QAAQ,CAACC,QAAD,CAAf;AACD,OAxBmB;;AAAA,sBAAdQ,cAAc;AAAA;AAAA;AAAA,OAApB;;AA0BA,WAAOA,cAAc,CAACF,IAAD,EAAOC,IAAP,CAArB;AACD,GAjCD;;AAAA;AAAA;AAAA;AAAA","sourcesContent":["/* eslint-env browser */\n'use strict'\n\nconst TLRU = require('../utils/tlru')\nconst { default: PQueue } = require('p-queue')\nconst HTTP = require('ipfs-utils/src/http')\n\n// Avoid sending multiple queries for the same hostname by caching results\nconst cache = new TLRU(1000)\n// TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\nconst ttl = 60 * 1000\n\n// browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\nconst httpQueue = new PQueue({ concurrency: 4 })\n\n/**\n * @param {{ Path: string, Message: string }} response\n */\nconst ipfsPath = (response) => {\n  if (response.Path) return response.Path\n  throw new Error(response.Message)\n}\n\n/**\n * @param {string} fqdn\n * @param {object} opts\n */\nmodule.exports = async (fqdn, opts) => { // eslint-disable-line require-await\n  /**\n   * @param {string} fqdn\n   * @param {object} opts\n   * @param {boolean} [opts.nocache]\n   */\n  const resolveDnslink = async (fqdn, opts = {}) => {\n    // @ts-ignore - URLSearchParams does not take boolean options, only strings\n    const searchParams = new URLSearchParams(opts)\n    searchParams.set('arg', fqdn)\n\n    // try cache first\n    const query = searchParams.toString()\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query)\n      return ipfsPath(response)\n    }\n\n    // fallback to delegated DNS resolver\n    const response = await httpQueue.add(async () => {\n      // Delegated HTTP resolver sending DNSLink queries to ipfs.io\n      // TODO: replace hardcoded host with configurable DNS over HTTPS: https://github.com/ipfs/js-ipfs/issues/2212\n      const res = await HTTP.get('https://ipfs.io/api/v0/dns', { searchParams })\n      const query = new URL(res.url).search.slice(1)\n      const json = await res.json()\n      cache.set(query, json, ttl)\n\n      return json\n    })\n    return ipfsPath(response)\n  }\n\n  return resolveDnslink(fqdn, opts)\n}\n"]},"metadata":{},"sourceType":"script"}