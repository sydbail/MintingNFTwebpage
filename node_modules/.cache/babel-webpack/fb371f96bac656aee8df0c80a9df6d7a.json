{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require(\"debug\")(\"contract:execute\");\n\nconst PromiEvent = require(\"./promievent\");\n\nconst EventEmitter = require(\"events\");\n\nconst utils = require(\"./utils\");\n\nconst StatusError = require(\"./statuserror\");\n\nconst Reason = require(\"./reason\");\n\nconst handlers = require(\"./handlers\");\n\nconst override = require(\"./override\");\n\nconst reformat = require(\"./reformat\");\n\nconst {\n  sendTransactionManual\n} = require(\"./manual-send\");\n\nconst execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * Lacking an estimate, sets gas to have of latest blockLimit\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function (params, blockLimit, stacktrace = false) {\n    const constructor = this;\n    const interfaceAdapter = this.interfaceAdapter;\n    return new Promise(function (accept) {\n      // Always prefer gas specified by user (if a user sets gas to 0, that is treated\n      // as undefined here and we do proceed to do gas estimation)\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n      interfaceAdapter.estimateGas(params, stacktrace).then(gas => {\n        // there are situations where the web3 gas estimation function in interfaceAdapter\n        // fails, specifically when a transaction will revert; we still want to continue\n        // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a\n        // default gas for that situation, equal to half of the blockLimit for the latest block\n        //\n        // note: this means if a transaction will revert but the user does not have stacktracing enabled,\n        // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this\n        if (gas === null) {\n          const defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));\n          accept(defaultGas.toHexString());\n        } else {\n          const limit = utils.bigNumberify(blockLimit); // if we did get a numerical gas estimate from interfaceAdapter, we\n          // multiply that estimate by the gasMultiplier to help ensure we\n          // have enough gas for the transaction\n\n          const bestEstimate = utils.multiplyBigNumberByDecimal(utils.bigNumberify(gas), constructor.gasMultiplier); // Check that we don't go over blockLimit\n\n          bestEstimate.gte(limit) ? accept(limit.sub(1).toHexString()) : accept(bestEstimate.toHexString());\n        }\n      }).catch(() => accept());\n    });\n  },\n\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: function () {\n    var _ref = _asyncToGenerator(function* (constructor, methodABI, _arguments) {\n      let args = Array.prototype.slice.call(_arguments);\n      let params = utils.getTxParams.call(constructor, methodABI, args);\n      args = utils.convertToEthersBN(args);\n\n      if (constructor.ens && constructor.ens.enabled) {\n        const {\n          web3\n        } = constructor;\n        const processedValues = yield utils.ens.convertENSNames({\n          networkId: constructor.network_id,\n          ensSettings: constructor.ens,\n          inputArgs: args,\n          inputParams: params,\n          methodABI,\n          web3\n        });\n        args = processedValues.args;\n        params = processedValues.params;\n      }\n\n      const network = yield constructor.detectNetwork();\n      return {\n        args,\n        params,\n        network\n      };\n    });\n\n    return function prepareCall(_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }(),\n\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function (arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  inputs     ABI segment defining method arguments\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function (args, lastArg, inputs) {\n    const hasDefaultBlock = !execute.hasTxParams(lastArg) && args.length > inputs.length;\n    const hasDefaultBlockWithParams = execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      let defaultBlock = constructor.web3.eth.defaultBlock || \"latest\";\n      const args = Array.prototype.slice.call(arguments);\n      const lastArg = args[args.length - 1];\n      const promiEvent = new PromiEvent(); // Extract defaultBlock parameter\n\n      if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {\n        defaultBlock = args.pop();\n      }\n\n      execute.prepareCall(constructor, methodABI, args).then( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* ({\n          args,\n          params\n        }) {\n          let result;\n          params.to = address;\n          promiEvent.eventEmitter.emit(\"execute:call:method\", {\n            fn: fn,\n            args: args,\n            address: address,\n            abi: methodABI,\n            contract: constructor\n          });\n          result = yield fn(...args).call(params, defaultBlock);\n          result = reformat.numbers.call(constructor, result, methodABI.outputs);\n          return promiEvent.resolve(result);\n        });\n\n        return function (_x4) {\n          return _ref2.apply(this, arguments);\n        };\n      }()).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Executes method as .send\n   * @param  {Function} fn         Method to invoke\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @param  {String}   address    Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function (fn, methodABI, address) {\n    const constructor = this;\n    const web3 = constructor.web3;\n    return function () {\n      const promiEvent = new PromiEvent(false, constructor.debugger);\n      execute.prepareCall(constructor, methodABI, arguments).then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* ({\n          args,\n          params,\n          network\n        }) {\n          const context = {\n            contract: constructor,\n            // Can't name this field `constructor` or `_constructor`\n            promiEvent: promiEvent,\n            params: params\n          };\n          params.to = address;\n          params.data = fn ? fn(...args).encodeABI() : params.data;\n          promiEvent.eventEmitter.emit(\"execute:send:method\", {\n            fn,\n            args,\n            address,\n            abi: methodABI,\n            contract: constructor\n          });\n          const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n\n          try {\n            params.gas = yield execute.getGasEstimate.call(constructor, params, network.blockLimit, stacktrace);\n          } catch (error) {\n            promiEvent.reject(error);\n            return;\n          }\n\n          execute.sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...\n          .then(receipt => {\n            if (promiEvent.debug) {\n              // in this case, we need to manually invoke the handler since it\n              // hasn't been set up (hack?)\n              handlers.receipt(context, receipt);\n            } //otherwise, just let the handlers handle things\n\n          }).catch(override.start.bind(constructor, context));\n        });\n\n        return function (_x5) {\n          return _ref3.apply(this, arguments);\n        };\n      }()).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Deploys an instance\n   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys\n   * @return {PromiEvent}             Resolves a TruffleContract instance\n   */\n  deploy: function (constructorABI) {\n    const constructor = this;\n    const web3 = constructor.web3;\n    return function () {\n      let deferred;\n      const promiEvent = new PromiEvent(false, constructor.debugger, true);\n      execute.prepareCall(constructor, constructorABI, arguments).then( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* ({\n          args,\n          params,\n          network\n        }) {\n          const {\n            blockLimit\n          } = network;\n          utils.checkLibraries.apply(constructor); // Promievent and flag that allows instance to resolve (rather than just receipt)\n\n          const context = {\n            contract: constructor,\n            promiEvent,\n            onlyEmitReceipt: true\n          };\n          const options = {\n            data: constructor.binary,\n            arguments: args\n          };\n          const contract = new web3.eth.Contract(constructor.abi);\n          params.data = contract.deploy(options).encodeABI();\n          const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n          params.gas = yield execute.getGasEstimate.call(constructor, params, blockLimit, stacktrace);\n          context.params = params;\n          promiEvent.eventEmitter.emit(\"execute:deploy:method\", {\n            args,\n            abi: constructorABI,\n            contract: constructor\n          });\n          deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...\n\n          try {\n            const receipt = yield deferred;\n\n            if (receipt.status !== undefined && !receipt.status) {\n              const reason = yield Reason.get(params, web3);\n              const error = new StatusError(params, context.transactionHash, receipt, reason);\n              return context.promiEvent.reject(error);\n            }\n\n            const web3Instance = new web3.eth.Contract(constructor.abi, receipt.contractAddress);\n            web3Instance.transactionHash = context.transactionHash;\n            context.promiEvent.resolve(new constructor(web3Instance));\n          } catch (web3Error) {\n            // Manage web3's 50 blocks' timeout error.\n            // Web3's own subscriptions go dead here.\n            yield override.start.call(constructor, context, web3Error);\n          }\n        });\n\n        return function (_x6) {\n          return _ref4.apply(this, arguments);\n        };\n      }()).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function (fn) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params, callback) {\n      if (typeof params === \"function\") {\n        callback = params;\n        params = {};\n      } // As callback\n\n\n      if (callback !== undefined) {\n        const intermediary = function (err, e) {\n          if (err) return callback(err);\n          if (!dedupe(e.id)) return;\n          callback(null, decode.call(constructor, e, true)[0]);\n        };\n\n        return constructor.detectNetwork().then(() => fn.call(constructor.events, params, intermediary));\n      } // As EventEmitter\n\n\n      const emitter = new EventEmitter();\n      constructor.detectNetwork().then(() => {\n        const event = fn(params);\n        event.on(\"data\", e => dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]));\n        event.on(\"changed\", e => dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]));\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params) {\n      const emitter = new EventEmitter();\n      constructor.detectNetwork().then(() => {\n        const event = web3Instance.events.allEvents(params);\n        event.on(\"data\", e => dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]));\n        event.on(\"changed\", e => dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]));\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    return function (event, options) {\n      return web3Instance.getPastEvents(event, options).then(events => decode.call(constructor, events, false));\n    };\n  },\n\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  estimate: function (fn, methodABI) {\n    const constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(res => fn(...res.args).estimateGas(res.params));\n    };\n  },\n\n  /**\n   *\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  request: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(res => {\n        //clone res.params\n        let tx = {};\n\n        for (let key in res.params) {\n          tx[key] = res.params[key];\n        } //set to\n\n\n        tx.to = address; //set data\n\n        tx.data = fn(...res.args).encodeABI();\n        return tx;\n      });\n    };\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimateGas`\n  estimateDeployment: function () {\n    const constructor = this;\n    const constructorABI = constructor.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(res => {\n      const options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      delete res.params[\"data\"]; // Is this necessary?\n\n      const instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      return instance.deploy(options).estimateGas(res.params);\n    });\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `request`\n  requestDeployment: function () {\n    const constructor = this;\n    const constructorABI = constructor.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(res => {\n      //clone res.params\n      let tx = {};\n\n      for (let key in res.params) {\n        tx[key] = res.params[key];\n      }\n\n      const options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      const instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      tx.data = instance.deploy(options).encodeABI();\n      return tx;\n    });\n  },\n  //our own custom sendTransaction function, made to mimic web3's,\n  //while also being able to do things, like, say, store the transaction\n  //hash even in case of failure.  it's not as powerful in some ways,\n  //as it just returns an ordinary Promise rather than web3's PromiEvent,\n  //but it's more suited to our purposes (we're not using that PromiEvent\n  //functionality here anyway)\n  //input works the same as input to web3.sendTransaction\n  //(well, OK, it's lacking some things there too, but again, good enough\n  //for our purposes)\n  sendTransaction: function () {\n    var _ref5 = _asyncToGenerator(function* (web3, params, promiEvent, context) {\n      //if we don't need the debugger, let's not risk any errors on our part,\n      //and just have web3 do everything\n      if (!promiEvent || !promiEvent.debug) {\n        const deferred = web3.eth.sendTransaction(params);\n        handlers.setup(deferred, context);\n        return deferred;\n      } //otherwise, do things manually!\n      //(and skip the PromiEvent stuff :-/ )\n\n\n      return sendTransactionManual(web3, params, promiEvent);\n    });\n\n    return function sendTransaction(_x7, _x8, _x9, _x10) {\n      return _ref5.apply(this, arguments);\n    };\n  }()\n};\nmodule.exports = execute;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/@truffle/contract/lib/execute.js"],"names":["debug","require","PromiEvent","EventEmitter","utils","StatusError","Reason","handlers","override","reformat","sendTransactionManual","execute","getGasEstimate","params","blockLimit","stacktrace","constructor","interfaceAdapter","Promise","accept","gas","autoGas","estimateGas","then","defaultGas","bigNumberify","Math","floor","toHexString","limit","bestEstimate","multiplyBigNumberByDecimal","gasMultiplier","gte","sub","catch","prepareCall","methodABI","_arguments","args","Array","prototype","slice","call","getTxParams","convertToEthersBN","ens","enabled","web3","processedValues","convertENSNames","networkId","network_id","ensSettings","inputArgs","inputParams","network","detectNetwork","hasTxParams","arg","is_object","is_big_number","hasDefaultBlock","lastArg","inputs","length","hasDefaultBlockWithParams","fn","address","defaultBlock","eth","arguments","promiEvent","pop","result","to","eventEmitter","emit","abi","contract","numbers","outputs","resolve","reject","send","debugger","context","data","encodeABI","error","sendTransaction","receipt","start","bind","deploy","constructorABI","deferred","checkLibraries","apply","onlyEmitReceipt","options","binary","Contract","status","undefined","reason","get","transactionHash","web3Instance","contractAddress","web3Error","event","decode","decodeLogs","currentLogID","dedupe","id","callback","intermediary","err","e","events","emitter","on","allEvents","getPastEvents","estimate","res","request","tx","key","estimateDeployment","filter","i","type","instance","requestDeployment","setup","module","exports"],"mappings":"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","sourcesContent":["const debug = require(\"debug\")(\"contract:execute\");\nconst PromiEvent = require(\"./promievent\");\nconst EventEmitter = require(\"events\");\nconst utils = require(\"./utils\");\nconst StatusError = require(\"./statuserror\");\nconst Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\nconst override = require(\"./override\");\nconst reformat = require(\"./reformat\");\nconst { sendTransactionManual } = require(\"./manual-send\");\n\nconst execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * Lacking an estimate, sets gas to have of latest blockLimit\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function (params, blockLimit, stacktrace = false) {\n    const constructor = this;\n    const interfaceAdapter = this.interfaceAdapter;\n\n    return new Promise(function (accept) {\n      // Always prefer gas specified by user (if a user sets gas to 0, that is treated\n      // as undefined here and we do proceed to do gas estimation)\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n\n      interfaceAdapter\n        .estimateGas(params, stacktrace)\n        .then(gas => {\n          // there are situations where the web3 gas estimation function in interfaceAdapter\n          // fails, specifically when a transaction will revert; we still want to continue\n          // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a\n          // default gas for that situation, equal to half of the blockLimit for the latest block\n          //\n          // note: this means if a transaction will revert but the user does not have stacktracing enabled,\n          // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this\n          if (gas === null) {\n            const defaultGas = utils.bigNumberify(Math.floor(blockLimit/2));\n            accept(defaultGas.toHexString());\n          } else {\n            const limit = utils.bigNumberify(blockLimit);\n            // if we did get a numerical gas estimate from interfaceAdapter, we\n            // multiply that estimate by the gasMultiplier to help ensure we\n            // have enough gas for the transaction\n            const bestEstimate = utils.multiplyBigNumberByDecimal(\n              utils.bigNumberify(gas),\n              constructor.gasMultiplier\n            );\n            // Check that we don't go over blockLimit\n            bestEstimate.gte(limit)\n              ? accept(limit.sub(1).toHexString())\n              : accept(bestEstimate.toHexString());\n          }\n        })\n        .catch(() => accept());\n    });\n  },\n\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: async function (constructor, methodABI, _arguments) {\n    let args = Array.prototype.slice.call(_arguments);\n    let params = utils.getTxParams.call(constructor, methodABI, args);\n\n    args = utils.convertToEthersBN(args);\n\n    if (constructor.ens && constructor.ens.enabled) {\n      const { web3 } = constructor;\n      const processedValues = await utils.ens.convertENSNames({\n        networkId: constructor.network_id,\n        ensSettings: constructor.ens,\n        inputArgs: args,\n        inputParams: params,\n        methodABI,\n        web3\n      });\n      args = processedValues.args;\n      params = processedValues.params;\n    }\n\n    const network = await constructor.detectNetwork();\n    return { args, params, network };\n  },\n\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function (arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  inputs     ABI segment defining method arguments\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function (args, lastArg, inputs) {\n    const hasDefaultBlock =\n      !execute.hasTxParams(lastArg) && args.length > inputs.length;\n    const hasDefaultBlockWithParams =\n      execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function (fn, methodABI, address) {\n    const constructor = this;\n\n    return function () {\n      let defaultBlock = constructor.web3.eth.defaultBlock || \"latest\";\n      const args = Array.prototype.slice.call(arguments);\n      const lastArg = args[args.length - 1];\n      const promiEvent = new PromiEvent();\n\n      // Extract defaultBlock parameter\n      if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {\n        defaultBlock = args.pop();\n      }\n\n      execute\n        .prepareCall(constructor, methodABI, args)\n        .then(async ({ args, params }) => {\n          let result;\n\n          params.to = address;\n\n          promiEvent.eventEmitter.emit(\"execute:call:method\", {\n            fn: fn,\n            args: args,\n            address: address,\n            abi: methodABI,\n            contract: constructor\n          });\n\n          result = await fn(...args).call(params, defaultBlock);\n          result = reformat.numbers.call(\n            constructor,\n            result,\n            methodABI.outputs\n          );\n          return promiEvent.resolve(result);\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Executes method as .send\n   * @param  {Function} fn         Method to invoke\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @param  {String}   address    Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function (fn, methodABI, address) {\n    const constructor = this;\n    const web3 = constructor.web3;\n\n    return function () {\n      const promiEvent = new PromiEvent(false, constructor.debugger);\n\n      execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(async ({ args, params, network }) => {\n          const context = {\n            contract: constructor, // Can't name this field `constructor` or `_constructor`\n            promiEvent: promiEvent,\n            params: params\n          };\n\n          params.to = address;\n          params.data = fn ? fn(...args).encodeABI() : params.data;\n\n          promiEvent.eventEmitter.emit(\"execute:send:method\", {\n            fn,\n            args,\n            address,\n            abi: methodABI,\n            contract: constructor\n          });\n\n          const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n          try {\n            params.gas = await execute.getGasEstimate.call(\n              constructor,\n              params,\n              network.blockLimit,\n              stacktrace\n            );\n          } catch (error) {\n            promiEvent.reject(error);\n            return;\n          }\n\n          execute\n            .sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...\n            .then(receipt => {\n              if (promiEvent.debug) {\n                // in this case, we need to manually invoke the handler since it\n                // hasn't been set up (hack?)\n                handlers.receipt(context, receipt);\n              }\n              //otherwise, just let the handlers handle things\n            })\n            .catch(override.start.bind(constructor, context));\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Deploys an instance\n   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys\n   * @return {PromiEvent}             Resolves a TruffleContract instance\n   */\n  deploy: function (constructorABI) {\n    const constructor = this;\n    const web3 = constructor.web3;\n\n    return function () {\n      let deferred;\n      const promiEvent = new PromiEvent(false, constructor.debugger, true);\n\n      execute\n        .prepareCall(constructor, constructorABI, arguments)\n        .then(async ({ args, params, network }) => {\n          const { blockLimit } = network;\n\n          utils.checkLibraries.apply(constructor);\n\n          // Promievent and flag that allows instance to resolve (rather than just receipt)\n          const context = {\n            contract: constructor,\n            promiEvent,\n            onlyEmitReceipt: true\n          };\n\n          const options = {\n            data: constructor.binary,\n            arguments: args\n          };\n\n          const contract = new web3.eth.Contract(constructor.abi);\n          params.data = contract.deploy(options).encodeABI();\n          const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n\n          params.gas = await execute.getGasEstimate.call(\n            constructor,\n            params,\n            blockLimit,\n            stacktrace\n          );\n\n          context.params = params;\n\n          promiEvent.eventEmitter.emit(\"execute:deploy:method\", {\n            args,\n            abi: constructorABI,\n            contract: constructor\n          });\n\n          deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...\n\n          try {\n            const receipt = await deferred;\n            if (receipt.status !== undefined && !receipt.status) {\n              const reason = await Reason.get(params, web3);\n\n              const error = new StatusError(\n                params,\n                context.transactionHash,\n                receipt,\n                reason\n              );\n\n              return context.promiEvent.reject(error);\n            }\n\n            const web3Instance = new web3.eth.Contract(\n              constructor.abi,\n              receipt.contractAddress\n            );\n            web3Instance.transactionHash = context.transactionHash;\n\n            context.promiEvent.resolve(new constructor(web3Instance));\n          } catch (web3Error) {\n            // Manage web3's 50 blocks' timeout error.\n            // Web3's own subscriptions go dead here.\n            await override.start.call(constructor, context, web3Error);\n          }\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function (fn) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null;\n\n    // Someone upstream is firing duplicates :/\n    function dedupe(id) {\n      return id === currentLogID ? false : (currentLogID = id);\n    }\n\n    return function (params, callback) {\n      if (typeof params === \"function\") {\n        callback = params;\n        params = {};\n      }\n\n      // As callback\n      if (callback !== undefined) {\n        const intermediary = function (err, e) {\n          if (err) return callback(err);\n          if (!dedupe(e.id)) return;\n          callback(null, decode.call(constructor, e, true)[0]);\n        };\n\n        return constructor\n          .detectNetwork()\n          .then(() => fn.call(constructor.events, params, intermediary));\n      }\n\n      // As EventEmitter\n      const emitter = new EventEmitter();\n\n      constructor.detectNetwork().then(() => {\n        const event = fn(params);\n\n        event.on(\n          \"data\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"data\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\n          \"changed\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"changed\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null;\n\n    // Someone upstream is firing duplicates :/\n    function dedupe(id) {\n      return id === currentLogID ? false : (currentLogID = id);\n    }\n\n    return function (params) {\n      const emitter = new EventEmitter();\n\n      constructor.detectNetwork().then(() => {\n        const event = web3Instance.events.allEvents(params);\n\n        event.on(\n          \"data\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"data\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\n          \"changed\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"changed\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n\n    return function (event, options) {\n      return web3Instance\n        .getPastEvents(event, options)\n        .then(events => decode.call(constructor, events, false));\n    };\n  },\n\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  estimate: function (fn, methodABI) {\n    const constructor = this;\n    return function () {\n      return execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(res => fn(...res.args).estimateGas(res.params));\n    };\n  },\n\n  /**\n   *\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  request: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(res => {\n          //clone res.params\n          let tx = {};\n          for (let key in res.params) {\n            tx[key] = res.params[key];\n          }\n          //set to\n          tx.to = address;\n          //set data\n          tx.data = fn(...res.args).encodeABI();\n          return tx;\n        });\n    };\n  },\n\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimateGas`\n  estimateDeployment: function () {\n    const constructor = this;\n\n    const constructorABI = constructor.abi.filter(\n      i => i.type === \"constructor\"\n    )[0];\n\n    return execute\n      .prepareCall(constructor, constructorABI, arguments)\n      .then(res => {\n        const options = {\n          data: constructor.binary,\n          arguments: res.args\n        };\n\n        delete res.params[\"data\"]; // Is this necessary?\n\n        const instance = new constructor.web3.eth.Contract(\n          constructor.abi,\n          res.params\n        );\n        return instance.deploy(options).estimateGas(res.params);\n      });\n  },\n\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `request`\n  requestDeployment: function () {\n    const constructor = this;\n\n    const constructorABI = constructor.abi.filter(\n      i => i.type === \"constructor\"\n    )[0];\n\n    return execute\n      .prepareCall(constructor, constructorABI, arguments)\n      .then(res => {\n        //clone res.params\n        let tx = {};\n        for (let key in res.params) {\n          tx[key] = res.params[key];\n        }\n\n        const options = {\n          data: constructor.binary,\n          arguments: res.args\n        };\n\n        const instance = new constructor.web3.eth.Contract(\n          constructor.abi,\n          res.params\n        );\n        tx.data = instance.deploy(options).encodeABI();\n        return tx;\n      });\n  },\n\n  //our own custom sendTransaction function, made to mimic web3's,\n  //while also being able to do things, like, say, store the transaction\n  //hash even in case of failure.  it's not as powerful in some ways,\n  //as it just returns an ordinary Promise rather than web3's PromiEvent,\n  //but it's more suited to our purposes (we're not using that PromiEvent\n  //functionality here anyway)\n  //input works the same as input to web3.sendTransaction\n  //(well, OK, it's lacking some things there too, but again, good enough\n  //for our purposes)\n  sendTransaction: async function (web3, params, promiEvent, context) {\n    //if we don't need the debugger, let's not risk any errors on our part,\n    //and just have web3 do everything\n    if (!promiEvent || !promiEvent.debug) {\n      const deferred = web3.eth.sendTransaction(params);\n      handlers.setup(deferred, context);\n      return deferred;\n    }\n    //otherwise, do things manually!\n    //(and skip the PromiEvent stuff :-/ )\n    return sendTransactionManual(web3, params, promiEvent);\n  }\n};\n\nmodule.exports = execute;\n"]},"metadata":{},"sourceType":"script"}