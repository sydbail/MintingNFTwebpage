{"ast":null,"code":"'use strict'; // @ts-ignore nat-api does not export types\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst NatAPI = require('@motrix/nat-api');\n\nconst debug = require('debug');\n\nconst {\n  promisify\n} = require('es6-promisify');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst log = Object.assign(debug('libp2p:nat'), {\n  error: debug('libp2p:nat:err')\n});\n\nconst {\n  isBrowser\n} = require('wherearewe');\n\nconst retry = require('p-retry'); // @ts-ignore private-api does not export types\n\n\nconst isPrivateIp = require('private-ip');\n\nconst pkg = require('../package.json');\n\nconst errcode = require('err-code');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('./errors');\n\nconst isLoopback = require('libp2p-utils/src/multiaddr/is-loopback');\n\nconst DEFAULT_TTL = 7200;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./transport-manager')} TransportManager\n * @typedef {import('./address-manager')} AddressManager\n */\n\n/**\n * @typedef {Object} NatManagerProperties\n * @property {PeerId} peerId - The peer ID of the current node\n * @property {TransportManager} transportManager - A transport manager\n * @property {AddressManager} addressManager - An address manager\n *\n * @typedef {Object} NatManagerOptions\n * @property {boolean} enabled - Whether to enable the NAT manager\n * @property {string} [externalIp] - Pass a value to use instead of auto-detection\n * @property {string} [description] - A string value to use for the port mapping description on the gateway\n * @property {number} [ttl = DEFAULT_TTL] - How long UPnP port mappings should last for in seconds (minimum 1200)\n * @property {boolean} [keepAlive] - Whether to automatically refresh UPnP port mappings when their TTL is reached\n * @property {string} [gateway] - Pass a value to use instead of auto-detection\n * @property {object} [pmp] - PMP options\n * @property {boolean} [pmp.enabled] - Whether to enable PMP as well as UPnP\n */\n\nfunction highPort(min = 1024, max = 65535) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nclass NatManager {\n  /**\n   * @class\n   * @param {NatManagerProperties & NatManagerOptions} options\n   */\n  constructor({\n    peerId,\n    addressManager,\n    transportManager,\n    ...options\n  }) {\n    this._peerId = peerId;\n    this._addressManager = addressManager;\n    this._transportManager = transportManager;\n    this._enabled = options.enabled;\n    this._externalIp = options.externalIp;\n    this._options = {\n      description: options.description || `${pkg.name}@${pkg.version} ${this._peerId}`,\n      ttl: options.ttl || DEFAULT_TTL,\n      autoUpdate: options.keepAlive || true,\n      gateway: options.gateway,\n      enablePMP: Boolean(options.pmp && options.pmp.enabled)\n    };\n\n    if (this._options.ttl < DEFAULT_TTL) {\n      throw errcode(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), ERR_INVALID_PARAMETERS);\n    }\n  }\n  /**\n   * Starts the NAT manager\n   */\n\n\n  start() {\n    if (isBrowser || !this._enabled) {\n      return;\n    } // done async to not slow down startup\n\n\n    this._start().catch(err => {\n      // hole punching errors are non-fatal\n      log.error(err);\n    });\n  }\n\n  _start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const addrs = _this._transportManager.getAddrs();\n\n      for (const addr of addrs) {\n        // try to open uPnP ports for each thin waist address\n        const {\n          family,\n          host,\n          port,\n          transport\n        } = addr.toOptions();\n\n        if (!addr.isThinWaistAddress() || transport !== 'tcp') {\n          // only bare tcp addresses\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        if (isLoopback(addr)) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        if (family !== 4) {\n          // ignore ipv6\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        const client = _this._getClient();\n\n        const publicIp = _this._externalIp || (yield client.externalIp());\n\n        if (isPrivateIp(publicIp)) {\n          throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);\n        }\n\n        const publicPort = highPort();\n        log(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);\n        yield client.map({\n          publicPort,\n          privatePort: port,\n          protocol: transport.toUpperCase()\n        });\n\n        _this._addressManager.addObservedAddr(Multiaddr.fromNodeAddress({\n          family: 4,\n          address: publicIp,\n          port: publicPort\n        }, transport));\n      }\n    })();\n  }\n\n  _getClient() {\n    if (this._client) {\n      return this._client;\n    }\n\n    const client = new NatAPI(this._options);\n    /** @type {(...any: any) => any} */\n\n    const map = promisify(client.map.bind(client));\n    /** @type {(...any: any) => any} */\n\n    const destroy = promisify(client.destroy.bind(client));\n    /** @type {(...any: any) => any} */\n\n    const externalIp = promisify(client.externalIp.bind(client)); // these are all network operations so add a retry\n\n    this._client = {\n      /**\n       * @param  {...any} args\n       * @returns {Promise<void>}\n       */\n      map: (...args) => retry(() => map(...args), {\n        onFailedAttempt: log.error,\n        unref: true\n      }),\n\n      /**\n       * @param  {...any} args\n       * @returns {Promise<void>}\n       */\n      destroy: (...args) => retry(() => destroy(...args), {\n        onFailedAttempt: log.error,\n        unref: true\n      }),\n\n      /**\n       * @param  {...any} args\n       * @returns {Promise<string>}\n       */\n      externalIp: (...args) => retry(() => externalIp(...args), {\n        onFailedAttempt: log.error,\n        unref: true\n      })\n    };\n    return this._client;\n  }\n  /**\n   * Stops the NAT manager\n   *\n   * @async\n   */\n\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (isBrowser || !_this2._client) {\n        return;\n      }\n\n      try {\n        yield _this2._client.destroy();\n        _this2._client = null;\n      } catch (err) {\n        log.error(err);\n      }\n    })();\n  }\n\n}\n\nmodule.exports = NatManager;","map":null,"metadata":{},"sourceType":"script"}