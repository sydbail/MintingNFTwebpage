{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst isIpfs = require('is-ipfs');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst PeerID = require('peer-id');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  resolve: res\n} = require('../utils');\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-utils/src/multibases')} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\n\n\nmodule.exports = ({\n  repo,\n  codecs,\n  bases,\n  name\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"resolve\"]}\n   */\n  function resolve(_x) {\n    return _resolve.apply(this, arguments);\n  }\n\n  function _resolve() {\n    _resolve = _asyncToGenerator(function* (path, opts = {}) {\n      if (!isIpfs.path(path)) {\n        throw new Error('invalid argument ' + path);\n      }\n\n      if (isIpfs.ipnsPath(path)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(name.resolve(path, opts)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const resolvedPath = _value;\n            path = resolvedPath;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      const [, schema, hash, ...rest] = path.split('/'); // ['', 'ipfs', 'hash', ...path]\n\n      const base = opts.cidBase ? yield bases.getBase(opts.cidBase) : undefined;\n      const bytes = parseBytes(hash); // nothing to resolve return the input\n\n      if (rest.length === 0) {\n        const str = base ? base.encoder.encode(bytes) : hash;\n        return `/${schema}/${str}`;\n      }\n\n      const cid = CID.decode(bytes);\n      path = rest.join('/');\n      const results = res(cid, path, codecs, repo, opts);\n      let value = cid;\n      let remainderPath = path;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(results), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const result = _value2;\n\n          if (result.value instanceof CID) {\n            value = result.value;\n            remainderPath = result.remainderPath;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`;\n    });\n    return _resolve.apply(this, arguments);\n  }\n\n  return withTimeoutOption(resolve);\n};\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\n\n\nfunction parseBytes(str) {\n  try {\n    return PeerID.parse(str).toBytes();\n  } catch {\n    return CID.parse(str).bytes;\n  }\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/components/resolve.js"],"names":["isIpfs","require","CID","PeerID","withTimeoutOption","resolve","res","module","exports","repo","codecs","bases","name","path","opts","Error","ipnsPath","resolvedPath","schema","hash","rest","split","base","cidBase","getBase","undefined","bytes","parseBytes","length","str","encoder","encode","cid","decode","join","results","value","remainderPath","result","toString","parse","toBytes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst { CID } = require('multiformats/cid')\nconst PeerID = require('peer-id')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { resolve: res } = require('../utils')\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-utils/src/multibases')} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\nmodule.exports = ({ repo, codecs, bases, name }) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"resolve\"]}\n   */\n  async function resolve (path, opts = {}) {\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path)\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath\n      }\n    }\n\n    const [, schema, hash, ...rest] = path.split('/') // ['', 'ipfs', 'hash', ...path]\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined\n    const bytes = parseBytes(hash)\n\n    // nothing to resolve return the input\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash\n\n      return `/${schema}/${str}`\n    }\n\n    const cid = CID.decode(bytes)\n\n    path = rest.join('/')\n\n    const results = res(cid, path, codecs, repo, opts)\n    let value = cid\n    let remainderPath = path\n\n    for await (const result of results) {\n      if (result.value instanceof CID) {\n        value = result.value\n        remainderPath = result.remainderPath\n      }\n    }\n\n    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`\n  }\n\n  return withTimeoutOption(resolve)\n}\n\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\nfunction parseBytes (str) {\n  try {\n    return PeerID.parse(str).toBytes()\n  } catch {\n    return CID.parse(str).bytes\n  }\n}\n"]},"metadata":{},"sourceType":"script"}