{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst drain = require('it-drain');\n\nconst filter = require('it-filter');\n\nconst take = require('it-take');\n\nconst all = require('it-all');\n/**\n * Collect all values from the iterable and sort them using\n * the passed sorter function\n *\n * @template T\n * @param {AsyncIterable<T> | Iterable<T>} iterable\n * @param {(a: T, b: T) => -1 | 0 | 1} sorter\n * @returns {AsyncIterable<T>}\n */\n\n\nconst sortAll = (iterable, sorter) => {\n  return _wrapAsyncGenerator(function* () {\n    const values = yield _awaitAsyncGenerator(all(iterable));\n    yield* _asyncGeneratorDelegate(_asyncIterator(values.sort(sorter)), _awaitAsyncGenerator);\n  })();\n};\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').Pair} Pair\n * @typedef {import('./types').Blockstore} Blockstore\n * @typedef {import('./types').Query} Query\n * @typedef {import('./types').KeyQuery} KeyQuery\n * @typedef {import('./types').Batch} Batch\n *\n * @typedef {import('multiformats').CID} CID\n */\n\n/**\n * @template O\n * @typedef {import('interface-store').AwaitIterable<O>} AwaitIterable\n */\n\n/**\n * @implements {Blockstore}\n */\n\n\nclass BlockstoreAdapter {\n  /**\n   * @returns {Promise<void>}\n   */\n  open() {\n    return Promise.reject(new Error('.open is not implemented'));\n  }\n  /**\n   * @returns {Promise<void>}\n   */\n\n\n  close() {\n    return Promise.reject(new Error('.close is not implemented'));\n  }\n  /**\n   * @param {CID} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   * @returns {Promise<void>}\n   */\n\n\n  put(key, val, options) {\n    return Promise.reject(new Error('.put is not implemented'));\n  }\n  /**\n   * @param {CID} key\n   * @param {Options} [options]\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  get(key, options) {\n    return Promise.reject(new Error('.get is not implemented'));\n  }\n  /**\n   * @param {CID} key\n   * @param {Options} [options]\n   * @returns {Promise<boolean>}\n   */\n\n\n  has(key, options) {\n    return Promise.reject(new Error('.has is not implemented'));\n  }\n  /**\n   * @param {CID} key\n   * @param {Options} [options]\n   * @returns {Promise<void>}\n   */\n\n\n  delete(key, options) {\n    return Promise.reject(new Error('.delete is not implemented'));\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  putMany(source, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const {\n            key,\n            value\n          } = _value;\n          yield _awaitAsyncGenerator(_this.put(key, value, options));\n          yield {\n            key,\n            value\n          };\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {AwaitIterable<CID>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n\n\n  getMany(source, options = {}) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const key = _value2;\n          yield _this2.get(key, options);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {AwaitIterable<CID>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<CID>}\n   */\n\n\n  deleteMany(source, options = {}) {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(source), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const key = _value3;\n          yield _awaitAsyncGenerator(_this3.delete(key, options));\n          yield key;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            yield _awaitAsyncGenerator(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    var _this4 = this;\n\n    /** @type {Pair[]} */\n    let puts = [];\n    /** @type {CID[]} */\n\n    let dels = [];\n    return {\n      put(key, value) {\n        puts.push({\n          key,\n          value\n        });\n      },\n\n      delete(key) {\n        dels.push(key);\n      },\n\n      commit: function () {\n        var _ref2 = _asyncToGenerator(function* (options) {\n          yield drain(_this4.putMany(puts, options));\n          puts = [];\n          yield drain(_this4.deleteMany(dels, options));\n          dels = [];\n        });\n\n        return function commit(_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }()\n    };\n  }\n  /**\n   * Extending classes should override `query` or implement this method\n   *\n   * @param {Query} q\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  // eslint-disable-next-line require-yield\n\n\n  _all(q, options) {\n    return _wrapAsyncGenerator(function* () {\n      throw new Error('._all is not implemented');\n    })();\n  }\n  /**\n   * Extending classes should override `queryKeys` or implement this method\n   *\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   * @returns {AsyncIterable<CID>}\n   */\n  // eslint-disable-next-line require-yield\n\n\n  _allKeys(q, options) {\n    return _wrapAsyncGenerator(function* () {\n      throw new Error('._allKeys is not implemented');\n    })();\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    let it = this._all(q, options);\n\n    if (q.prefix != null) {\n      it = filter(it, (\n      /** @type {Pair} */\n      e) => e.key.toString().startsWith(q.prefix || ''));\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= (q.offset || 0));\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n\n    return it;\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    let it = this._allKeys(q, options);\n\n    if (q.prefix != null) {\n      it = filter(it, (\n      /** @type {CID} */\n      cid) => cid.toString().startsWith(q.prefix || ''));\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n\n    return it;\n  }\n\n}\n\nmodule.exports = BlockstoreAdapter;","map":null,"metadata":{},"sourceType":"script"}