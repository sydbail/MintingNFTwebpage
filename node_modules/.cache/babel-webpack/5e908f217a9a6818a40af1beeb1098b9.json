{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { asyncIterableReader, bytesReader, createDecoder } from './decoder.js';\nexport class CarIteratorBase {\n  constructor(version, roots, iterable) {\n    this._version = version;\n    this._roots = roots;\n    this._iterable = iterable;\n    this._decoded = false;\n  }\n\n  get version() {\n    return this._version;\n  }\n\n  getRoots() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this._roots;\n    })();\n  }\n\n}\nexport class CarBlockIterator extends CarIteratorBase {\n  [Symbol.asyncIterator]() {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once');\n    }\n\n    if (!this._iterable) {\n      throw new Error('Block iterable not found');\n    }\n\n    this._decoded = true;\n    return this._iterable[Symbol.asyncIterator]();\n  }\n\n  static fromBytes(bytes) {\n    return _asyncToGenerator(function* () {\n      const {\n        version,\n        roots,\n        iterator\n      } = yield fromBytes(bytes);\n      return new CarBlockIterator(version, roots, iterator);\n    })();\n  }\n\n  static fromIterable(asyncIterable) {\n    return _asyncToGenerator(function* () {\n      const {\n        version,\n        roots,\n        iterator\n      } = yield fromIterable(asyncIterable);\n      return new CarBlockIterator(version, roots, iterator);\n    })();\n  }\n\n}\nexport class CarCIDIterator extends CarIteratorBase {\n  [Symbol.asyncIterator]() {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once');\n    }\n\n    if (!this._iterable) {\n      throw new Error('Block iterable not found');\n    }\n\n    this._decoded = true;\n\n    const iterable = this._iterable[Symbol.asyncIterator]();\n\n    return {\n      next() {\n        return _asyncToGenerator(function* () {\n          const next = yield iterable.next();\n\n          if (next.done) {\n            return next;\n          }\n\n          return {\n            done: false,\n            value: next.value.cid\n          };\n        })();\n      }\n\n    };\n  }\n\n  static fromBytes(bytes) {\n    return _asyncToGenerator(function* () {\n      const {\n        version,\n        roots,\n        iterator\n      } = yield fromBytes(bytes);\n      return new CarCIDIterator(version, roots, iterator);\n    })();\n  }\n\n  static fromIterable(asyncIterable) {\n    return _asyncToGenerator(function* () {\n      const {\n        version,\n        roots,\n        iterator\n      } = yield fromIterable(asyncIterable);\n      return new CarCIDIterator(version, roots, iterator);\n    })();\n  }\n\n}\n\nfunction fromBytes(_x) {\n  return _fromBytes.apply(this, arguments);\n}\n\nfunction _fromBytes() {\n  _fromBytes = _asyncToGenerator(function* (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n\n    return decodeIterator(bytesReader(bytes));\n  });\n  return _fromBytes.apply(this, arguments);\n}\n\nfunction fromIterable(_x2) {\n  return _fromIterable.apply(this, arguments);\n}\n\nfunction _fromIterable() {\n  _fromIterable = _asyncToGenerator(function* (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n\n    return decodeIterator(asyncIterableReader(asyncIterable));\n  });\n  return _fromIterable.apply(this, arguments);\n}\n\nfunction decodeIterator(_x3) {\n  return _decodeIterator.apply(this, arguments);\n}\n\nfunction _decodeIterator() {\n  _decodeIterator = _asyncToGenerator(function* (reader) {\n    const decoder = createDecoder(reader);\n    const {\n      version,\n      roots\n    } = yield decoder.header();\n    return {\n      version,\n      roots,\n      iterator: decoder.blocks()\n    };\n  });\n  return _decodeIterator.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}