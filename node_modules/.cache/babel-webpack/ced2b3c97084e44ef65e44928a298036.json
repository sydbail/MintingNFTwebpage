{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\n\nfunction readVarint(_x) {\n  return _readVarint.apply(this, arguments);\n}\n\nfunction _readVarint() {\n  _readVarint = _asyncToGenerator(function* (reader) {\n    const bytes = yield reader.upTo(8);\n    const i = varint.decode(bytes);\n    reader.seek(varint.decode.bytes);\n    return i;\n  });\n  return _readVarint.apply(this, arguments);\n}\n\nexport function readHeader(_x2) {\n  return _readHeader.apply(this, arguments);\n}\n\nfunction _readHeader() {\n  _readHeader = _asyncToGenerator(function* (reader) {\n    const length = yield readVarint(reader);\n\n    if (length === 0) {\n      throw new Error('Invalid CAR header (zero length)');\n    }\n\n    const header = yield reader.exactly(length);\n    reader.seek(length);\n    const block = decodeDagCbor(header);\n\n    if (block == null || Array.isArray(block) || typeof block !== 'object') {\n      throw new Error('Invalid CAR header format');\n    }\n\n    if (block.version !== 1) {\n      if (typeof block.version === 'string') {\n        throw new Error(`Invalid CAR version: \"${block.version}\"`);\n      }\n\n      throw new Error(`Invalid CAR version: ${block.version}`);\n    }\n\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format');\n    }\n\n    if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n      throw new Error('Invalid CAR header format');\n    }\n\n    return block;\n  });\n  return _readHeader.apply(this, arguments);\n}\n\nfunction readMultihash(_x3) {\n  return _readMultihash.apply(this, arguments);\n}\n\nfunction _readMultihash() {\n  _readMultihash = _asyncToGenerator(function* (reader) {\n    const bytes = yield reader.upTo(8);\n    varint.decode(bytes);\n    const codeLength = varint.decode.bytes;\n    const length = varint.decode(bytes.subarray(varint.decode.bytes));\n    const lengthLength = varint.decode.bytes;\n    const mhLength = codeLength + lengthLength + length;\n    const multihash = yield reader.exactly(mhLength);\n    reader.seek(mhLength);\n    return multihash;\n  });\n  return _readMultihash.apply(this, arguments);\n}\n\nfunction readCid(_x4) {\n  return _readCid.apply(this, arguments);\n}\n\nfunction _readCid() {\n  _readCid = _asyncToGenerator(function* (reader) {\n    const first = yield reader.exactly(2);\n\n    if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n      const bytes = yield reader.exactly(34);\n      reader.seek(34);\n      const multihash = Digest.decode(bytes);\n      return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n    }\n\n    const version = yield readVarint(reader);\n\n    if (version !== 1) {\n      throw new Error(`Unexpected CID version (${version})`);\n    }\n\n    const codec = yield readVarint(reader);\n    const bytes = yield readMultihash(reader);\n    const multihash = Digest.decode(bytes);\n    return CID.create(version, codec, multihash);\n  });\n  return _readCid.apply(this, arguments);\n}\n\nfunction readBlockHead(_x5) {\n  return _readBlockHead.apply(this, arguments);\n}\n\nfunction _readBlockHead() {\n  _readBlockHead = _asyncToGenerator(function* (reader) {\n    const start = reader.pos;\n    let length = yield readVarint(reader);\n\n    if (length === 0) {\n      throw new Error('Invalid CAR section (zero length)');\n    }\n\n    length += reader.pos - start;\n    const cid = yield readCid(reader);\n    const blockLength = length - (reader.pos - start);\n    return {\n      cid,\n      length,\n      blockLength\n    };\n  });\n  return _readBlockHead.apply(this, arguments);\n}\n\nfunction readBlock(_x6) {\n  return _readBlock.apply(this, arguments);\n}\n\nfunction _readBlock() {\n  _readBlock = _asyncToGenerator(function* (reader) {\n    const {\n      cid,\n      blockLength\n    } = yield readBlockHead(reader);\n    const bytes = yield reader.exactly(blockLength);\n    reader.seek(blockLength);\n    return {\n      bytes,\n      cid\n    };\n  });\n  return _readBlock.apply(this, arguments);\n}\n\nfunction readBlockIndex(_x7) {\n  return _readBlockIndex.apply(this, arguments);\n}\n\nfunction _readBlockIndex() {\n  _readBlockIndex = _asyncToGenerator(function* (reader) {\n    const offset = reader.pos;\n    const {\n      cid,\n      length,\n      blockLength\n    } = yield readBlockHead(reader);\n    const index = {\n      cid,\n      length,\n      blockLength,\n      offset,\n      blockOffset: reader.pos\n    };\n    reader.seek(index.blockLength);\n    return index;\n  });\n  return _readBlockIndex.apply(this, arguments);\n}\n\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n\n    blocks() {\n      return _wrapAsyncGenerator(function* () {\n        yield _awaitAsyncGenerator(headerPromise);\n\n        while ((yield _awaitAsyncGenerator(reader.upTo(8))).length > 0) {\n          yield readBlock(reader);\n        }\n      })();\n    },\n\n    blocksIndex() {\n      return _wrapAsyncGenerator(function* () {\n        yield _awaitAsyncGenerator(headerPromise);\n\n        while ((yield _awaitAsyncGenerator(reader.upTo(8))).length > 0) {\n          yield readBlockIndex(reader);\n        }\n      })();\n    }\n\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    upTo(length) {\n      return _asyncToGenerator(function* () {\n        return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n      })();\n    },\n\n    exactly(length) {\n      return _asyncToGenerator(function* () {\n        if (length > bytes.length - pos) {\n          throw new Error('Unexpected end of data');\n        }\n\n        return bytes.subarray(pos, pos + length);\n      })();\n    },\n\n    seek(length) {\n      pos += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n\n  const read = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (length) {\n      have = currentChunk.length - offset;\n      const bufa = [currentChunk.subarray(offset)];\n\n      while (have < length) {\n        const chunk = yield readChunk();\n\n        if (chunk == null) {\n          break;\n        }\n\n        if (have < 0) {\n          if (chunk.length > have) {\n            bufa.push(chunk.subarray(-have));\n          }\n        } else {\n          bufa.push(chunk);\n        }\n\n        have += chunk.length;\n      }\n\n      currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n      let off = 0;\n\n      for (const b of bufa) {\n        currentChunk.set(b, off);\n        off += b.length;\n      }\n\n      offset = 0;\n    });\n\n    return function read(_x8) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return {\n    upTo(length) {\n      return _asyncToGenerator(function* () {\n        if (currentChunk.length - offset < length) {\n          yield read(length);\n        }\n\n        return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n      })();\n    },\n\n    exactly(length) {\n      return _asyncToGenerator(function* () {\n        if (currentChunk.length - offset < length) {\n          yield read(length);\n        }\n\n        if (currentChunk.length - offset < length) {\n          throw new Error('Unexpected end of data');\n        }\n\n        return currentChunk.subarray(offset, offset + length);\n      })();\n    },\n\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n\n  function readChunk() {\n    return _readChunk.apply(this, arguments);\n  }\n\n  function _readChunk() {\n    _readChunk = _asyncToGenerator(function* () {\n      const next = yield iterator.next();\n\n      if (next.done) {\n        return null;\n      }\n\n      return next.value;\n    });\n    return _readChunk.apply(this, arguments);\n  }\n\n  return chunkReader(readChunk);\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/@ipld/car/esm/lib/decoder.js"],"names":["varint","CID","Digest","decode","decodeDagCbor","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","reader","bytes","upTo","i","seek","readHeader","length","Error","header","exactly","block","Array","isArray","version","roots","Object","keys","filter","p","readMultihash","codeLength","subarray","lengthLength","mhLength","multihash","readCid","first","create","codec","readBlockHead","start","pos","cid","blockLength","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","blocks","blocksIndex","bytesReader","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done","value"],"mappings":"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","sourcesContent":["import varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\nasync function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}"]},"metadata":{},"sourceType":"module"}