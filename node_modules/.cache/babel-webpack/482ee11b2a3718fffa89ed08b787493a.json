{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errcode = require('err-code');\n\nconst webcrypto = require('../webcrypto');\n\nconst {\n  base64urlToBuffer\n} = require('../util');\n\nconst validateCurveType = require('./validate-curve-type');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\n\nexports.generateEphmeralKeyPair = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (curve) {\n    validateCurveType(Object.keys(bits), curve);\n    const pair = yield webcrypto.get().subtle.generateKey({\n      name: 'ECDH',\n      namedCurve: curve\n    }, true, ['deriveBits']); // forcePrivate is used for testing only\n\n    const genSharedKey = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (theirPub, forcePrivate) {\n        let privateKey;\n\n        if (forcePrivate) {\n          privateKey = yield webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n            name: 'ECDH',\n            namedCurve: curve\n          }, false, ['deriveBits']);\n        } else {\n          privateKey = pair.privateKey;\n        }\n\n        const keys = [yield webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n          name: 'ECDH',\n          namedCurve: curve\n        }, false, []), privateKey];\n        const buffer = yield webcrypto.get().subtle.deriveBits({\n          name: 'ECDH',\n          namedCurve: curve,\n          public: keys[0]\n        }, keys[1], bits[curve]);\n        return new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength);\n      });\n\n      return function genSharedKey(_x2, _x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    const publicKey = yield webcrypto.get().subtle.exportKey('jwk', pair.publicKey);\n    return {\n      key: marshalPublicKey(publicKey),\n      genSharedKey\n    };\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}; // Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\n\nfunction marshalPublicKey(jwk) {\n  const byteLen = curveLengths[jwk.crv];\n  return uint8ArrayConcat([Uint8Array.from([4]), // uncompressed point\n  base64urlToBuffer(jwk.x, byteLen), base64urlToBuffer(jwk.y, byteLen)], 1 + byteLen * 2);\n} // Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n\n\nfunction unmarshalPublicKey(curve, key) {\n  const byteLen = curveLengths[curve];\n\n  if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {\n    throw errcode(new Error('Cannot unmarshal public key - invalid key format'), 'ERR_INVALID_KEY_FORMAT');\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.slice(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.slice(1 + byteLen), 'base64url'),\n    ext: true\n  };\n}\n\nconst unmarshalPrivateKey = (curve, key) => ({ ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n});","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-crypto/src/keys/ecdh-browser.js"],"names":["errcode","require","webcrypto","base64urlToBuffer","validateCurveType","toString","uint8ArrayToString","concat","uint8ArrayConcat","equals","uint8ArrayEquals","bits","exports","generateEphmeralKeyPair","curve","Object","keys","pair","get","subtle","generateKey","name","namedCurve","genSharedKey","theirPub","forcePrivate","privateKey","importKey","unmarshalPrivateKey","unmarshalPublicKey","buffer","deriveBits","public","Uint8Array","byteOffset","byteLength","publicKey","exportKey","key","marshalPublicKey","curveLengths","jwk","byteLen","crv","from","x","y","slice","Error","kty","ext","d","private"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst webcrypto = require('../webcrypto')\nconst { base64urlToBuffer } = require('../util')\nconst validateCurveType = require('./validate-curve-type')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n}\n\nexports.generateEphmeralKeyPair = async function (curve) {\n  validateCurveType(Object.keys(bits), curve)\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub, forcePrivate) => {\n    let privateKey\n\n    if (forcePrivate) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const keys = [\n      await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPublicKey(curve, theirPub),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        []\n      ),\n      privateKey\n    ]\n\n    const buffer = await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        namedCurve: curve,\n        public: keys[0]\n      },\n      keys[1],\n      bits[curve]\n    )\n\n    return new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength)\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  return {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n}\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\n// Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk) {\n  const byteLen = curveLengths[jwk.crv]\n\n  return uint8ArrayConcat([\n    Uint8Array.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey (curve, key) {\n  const byteLen = curveLengths[curve]\n\n  if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {\n    throw errcode(new Error('Cannot unmarshal public key - invalid key format'), 'ERR_INVALID_KEY_FORMAT')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.slice(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.slice(1 + byteLen), 'base64url'),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve, key) => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n})\n"]},"metadata":{},"sourceType":"script"}