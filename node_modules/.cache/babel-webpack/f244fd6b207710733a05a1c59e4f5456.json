{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key,\n  Adapter\n} = require('interface-datastore');\n\nconst {\n  encodeBase32,\n  keyToTopic,\n  topicToKey\n} = require('./utils');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n});\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super();\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  put(key, val) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(key instanceof Uint8Array)) {\n        const errMsg = 'datastore key does not have a valid format';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n      }\n\n      if (!(val instanceof Uint8Array)) {\n        const errMsg = 'received value is not a Uint8Array';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n      }\n\n      const stringifiedTopic = keyToTopic(key);\n      log(`publish value for topic ${stringifiedTopic}`); // Publish record to pubsub\n\n      yield _this._pubsub.publish(stringifiedTopic, val);\n    })();\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  get(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(key instanceof Uint8Array)) {\n        const errMsg = 'datastore key does not have a valid format';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n      }\n\n      const stringifiedTopic = keyToTopic(key);\n      const subscriptions = yield _this2._pubsub.getTopics(); // If already subscribed, just try to get it\n\n      if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n        return _this2._getLocal(key);\n      } // subscribe\n\n\n      try {\n        _this2._pubsub.on(stringifiedTopic, _this2._onMessage);\n\n        yield _this2._pubsub.subscribe(stringifiedTopic);\n      } catch (err) {\n        const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');\n      }\n\n      log(`subscribed values for key ${stringifiedTopic}`);\n      return _this2._getLocal(key);\n    })();\n  }\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n\n    this._pubsub.removeListener(stringifiedTopic, this._onMessage);\n\n    return this._pubsub.unsubscribe(stringifiedTopic);\n  }\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   */\n\n\n  _getLocal(key) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // encode key - base32(/ipns/{cid})\n      const routingKey = new Key('/' + encodeBase32(key), false);\n      let dsVal;\n\n      try {\n        dsVal = yield _this3._datastore.get(routingKey);\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n        }\n\n        const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n      }\n\n      if (!(dsVal instanceof Uint8Array)) {\n        const errMsg = 'found record that we couldn\\'t convert to a value';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');\n      }\n\n      return dsVal;\n    })();\n  }\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {PubSubMessage} msg\n   */\n\n\n  _onMessage(msg) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        data,\n        from,\n        topicIDs\n      } = msg;\n      let key;\n\n      try {\n        key = topicToKey(topicIDs[0]);\n      } catch (err) {\n        log.error(err);\n        return;\n      }\n\n      log(`message received for topic ${topicIDs[0]}`); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n      if (from === _this4._peerId.toB58String()) {\n        log('message discarded as it is from the same peer');\n        return;\n      }\n\n      if (_this4._handleSubscriptionKeyFn) {\n        let res;\n\n        try {\n          res = yield _this4._handleSubscriptionKeyFn(key);\n        } catch (err) {\n          log.error('message discarded by the subscriptionKeyFn');\n          return;\n        }\n\n        key = res;\n      }\n\n      try {\n        yield _this4._storeIfSubscriptionIsBetter(key, data);\n      } catch (err) {\n        log.error(err);\n      }\n    })();\n  }\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n\n\n  _storeIfSubscriptionIsBetter(key, data) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      let isBetter = false;\n\n      try {\n        isBetter = yield _this5._isBetter(key, data);\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_VALID_RECORD') {\n          throw err;\n        }\n      }\n\n      if (isBetter) {\n        yield _this5._storeRecord(key, data);\n      }\n    })();\n  }\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} value\n   * @param {Uint8Array} peerId\n   */\n\n\n  _validateRecord(value, peerId) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      return _this6._validator.validate(value, peerId);\n    })();\n  }\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n\n\n  _selectRecord(key, records) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const res = yield _this7._validator.select(key, records); // If the selected was the first (0), it should be stored (true)\n\n      return res === 0;\n    })();\n  }\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n\n\n  _isBetter(key, val) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this8._validateRecord(val, key);\n      } catch (err) {\n        // If not valid, it is not better than the one currently available\n        const errMsg = 'record received through pubsub is not valid';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n      } // Get Local record\n\n\n      const dsKey = new Key(key);\n      let currentRecord;\n\n      try {\n        currentRecord = yield _this8._getLocal(dsKey.uint8Array());\n      } catch (err) {\n        // if the old one is invalid, the new one is *always* better\n        return true;\n      } // if the same record, do not need to store\n\n\n      if (uint8ArrayEquals(currentRecord, val)) {\n        return false;\n      } // verify if the received record should replace the current one\n\n\n      return _this8._selectRecord(key, [currentRecord, val]);\n    })();\n  }\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n\n\n  _storeRecord(key, data) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      // encode key - base32(/ipns/{cid})\n      const routingKey = new Key('/' + encodeBase32(key), false);\n      yield _this9._datastore.put(routingKey, data);\n      log(`record for ${keyToTopic(key)} was stored in the datastore`);\n    })();\n  }\n\n}\n\nexports = module.exports = DatastorePubsub;","map":null,"metadata":{},"sourceType":"script"}