{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport _asyncGeneratorDelegate from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\nimport DirFlat from './dir-flat.js';\nimport flatToShard from './flat-to-shard.js';\nimport Dir from './dir.js';\nimport toPathComponents from './utils/to-path-components.js';\n\nfunction addToTree(_x6, _x7, _x8) {\n  return _addToTree.apply(this, arguments);\n}\n\nfunction _addToTree() {\n  _addToTree = _asyncToGenerator(function* (elem, tree, options) {\n    const pathElems = toPathComponents(elem.path || '');\n    const lastIndex = pathElems.length - 1;\n    let parent = tree;\n    let currentPath = '';\n\n    for (let i = 0; i < pathElems.length; i++) {\n      const pathElem = pathElems[i];\n      currentPath += `${currentPath ? '/' : ''}${pathElem}`;\n      const last = i === lastIndex;\n      parent.dirty = true;\n      parent.cid = undefined;\n      parent.size = undefined;\n\n      if (last) {\n        yield parent.put(pathElem, elem);\n        tree = yield flatToShard(null, parent, options.shardSplitThreshold, options);\n      } else {\n        let dir = yield parent.get(pathElem);\n\n        if (!dir || !(dir instanceof Dir)) {\n          dir = new DirFlat({\n            root: false,\n            dir: true,\n            parent: parent,\n            parentKey: pathElem,\n            path: currentPath,\n            dirty: true,\n            flat: true,\n            mtime: dir && dir.unixfs && dir.unixfs.mtime,\n            mode: dir && dir.unixfs && dir.unixfs.mode\n          }, options);\n        }\n\n        yield parent.put(pathElem, dir);\n        parent = dir;\n      }\n    }\n\n    return tree;\n  });\n  return _addToTree.apply(this, arguments);\n}\n\nfunction flushAndYield(_x, _x2) {\n  return _flushAndYield.apply(this, arguments);\n}\n\nfunction _flushAndYield() {\n  _flushAndYield = _wrapAsyncGenerator(function* (tree, blockstore) {\n    if (!(tree instanceof Dir)) {\n      if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n        yield tree;\n      }\n\n      return;\n    }\n\n    yield* _asyncGeneratorDelegate(_asyncIterator(tree.flush(blockstore)), _awaitAsyncGenerator);\n  });\n  return _flushAndYield.apply(this, arguments);\n}\n\nfunction treeBuilder(_x3, _x4, _x5) {\n  return _treeBuilder.apply(this, arguments);\n}\n\nfunction _treeBuilder() {\n  _treeBuilder = _wrapAsyncGenerator(function* (source, block, options) {\n    let tree = new DirFlat({\n      root: true,\n      dir: true,\n      path: '',\n      dirty: true,\n      flat: true\n    }, options);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const entry = _value;\n\n        if (!entry) {\n          continue;\n        }\n\n        tree = yield _awaitAsyncGenerator(addToTree(entry, tree, options));\n\n        if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n          yield entry;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (options.wrapWithDirectory) {\n      yield* _asyncGeneratorDelegate(_asyncIterator(flushAndYield(tree, block)), _awaitAsyncGenerator);\n    } else {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(tree.eachChildSeries()), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const unwrapped = _value2;\n\n          if (!unwrapped) {\n            continue;\n          }\n\n          yield* _asyncGeneratorDelegate(_asyncIterator(flushAndYield(unwrapped.child, block)), _awaitAsyncGenerator);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  });\n  return _treeBuilder.apply(this, arguments);\n}\n\nexport default treeBuilder;","map":null,"metadata":{},"sourceType":"module"}