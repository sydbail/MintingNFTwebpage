{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-pubsub-rpc\"] || ($protobuf.roots[\"libp2p-pubsub-rpc\"] = {});\n\n$root.RPC = function () {\n  /**\n   * Properties of a RPC.\n   * @exports IRPC\n   * @interface IRPC\n   * @property {Array.<RPC.ISubOpts>|null} [subscriptions] RPC subscriptions\n   * @property {Array.<RPC.IMessage>|null} [msgs] RPC msgs\n   */\n\n  /**\n   * Constructs a new RPC.\n   * @exports RPC\n   * @classdesc Represents a RPC.\n   * @implements IRPC\n   * @constructor\n   * @param {IRPC=} [p] Properties to set\n   */\n  function RPC(p) {\n    this.subscriptions = [];\n    this.msgs = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * RPC subscriptions.\n   * @member {Array.<RPC.ISubOpts>} subscriptions\n   * @memberof RPC\n   * @instance\n   */\n\n\n  RPC.prototype.subscriptions = $util.emptyArray;\n  /**\n   * RPC msgs.\n   * @member {Array.<RPC.IMessage>} msgs\n   * @memberof RPC\n   * @instance\n   */\n\n  RPC.prototype.msgs = $util.emptyArray;\n  /**\n   * Encodes the specified RPC message. Does not implicitly {@link RPC.verify|verify} messages.\n   * @function encode\n   * @memberof RPC\n   * @static\n   * @param {IRPC} m RPC message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  RPC.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n\n    if (m.subscriptions != null && m.subscriptions.length) {\n      for (var i = 0; i < m.subscriptions.length; ++i) $root.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();\n    }\n\n    if (m.msgs != null && m.msgs.length) {\n      for (var i = 0; i < m.msgs.length; ++i) $root.RPC.Message.encode(m.msgs[i], w.uint32(18).fork()).ldelim();\n    }\n\n    return w;\n  };\n  /**\n   * Decodes a RPC message from the specified reader or buffer.\n   * @function decode\n   * @memberof RPC\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {RPC} RPC\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  RPC.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.RPC();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          if (!(m.subscriptions && m.subscriptions.length)) m.subscriptions = [];\n          m.subscriptions.push($root.RPC.SubOpts.decode(r, r.uint32()));\n          break;\n\n        case 2:\n          if (!(m.msgs && m.msgs.length)) m.msgs = [];\n          m.msgs.push($root.RPC.Message.decode(r, r.uint32()));\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a RPC message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof RPC\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {RPC} RPC\n   */\n\n\n  RPC.fromObject = function fromObject(d) {\n    if (d instanceof $root.RPC) return d;\n    var m = new $root.RPC();\n\n    if (d.subscriptions) {\n      if (!Array.isArray(d.subscriptions)) throw TypeError(\".RPC.subscriptions: array expected\");\n      m.subscriptions = [];\n\n      for (var i = 0; i < d.subscriptions.length; ++i) {\n        if (typeof d.subscriptions[i] !== \"object\") throw TypeError(\".RPC.subscriptions: object expected\");\n        m.subscriptions[i] = $root.RPC.SubOpts.fromObject(d.subscriptions[i]);\n      }\n    }\n\n    if (d.msgs) {\n      if (!Array.isArray(d.msgs)) throw TypeError(\".RPC.msgs: array expected\");\n      m.msgs = [];\n\n      for (var i = 0; i < d.msgs.length; ++i) {\n        if (typeof d.msgs[i] !== \"object\") throw TypeError(\".RPC.msgs: object expected\");\n        m.msgs[i] = $root.RPC.Message.fromObject(d.msgs[i]);\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a RPC message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof RPC\n   * @static\n   * @param {RPC} m RPC\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  RPC.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.arrays || o.defaults) {\n      d.subscriptions = [];\n      d.msgs = [];\n    }\n\n    if (m.subscriptions && m.subscriptions.length) {\n      d.subscriptions = [];\n\n      for (var j = 0; j < m.subscriptions.length; ++j) {\n        d.subscriptions[j] = $root.RPC.SubOpts.toObject(m.subscriptions[j], o);\n      }\n    }\n\n    if (m.msgs && m.msgs.length) {\n      d.msgs = [];\n\n      for (var j = 0; j < m.msgs.length; ++j) {\n        d.msgs[j] = $root.RPC.Message.toObject(m.msgs[j], o);\n      }\n    }\n\n    return d;\n  };\n  /**\n   * Converts this RPC to JSON.\n   * @function toJSON\n   * @memberof RPC\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  RPC.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  RPC.SubOpts = function () {\n    /**\n     * Properties of a SubOpts.\n     * @memberof RPC\n     * @interface ISubOpts\n     * @property {boolean|null} [subscribe] SubOpts subscribe\n     * @property {string|null} [topicID] SubOpts topicID\n     */\n\n    /**\n     * Constructs a new SubOpts.\n     * @memberof RPC\n     * @classdesc Represents a SubOpts.\n     * @implements ISubOpts\n     * @constructor\n     * @param {RPC.ISubOpts=} [p] Properties to set\n     */\n    function SubOpts(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * SubOpts subscribe.\n     * @member {boolean|null|undefined} subscribe\n     * @memberof RPC.SubOpts\n     * @instance\n     */\n\n\n    SubOpts.prototype.subscribe = null;\n    /**\n     * SubOpts topicID.\n     * @member {string|null|undefined} topicID\n     * @memberof RPC.SubOpts\n     * @instance\n     */\n\n    SubOpts.prototype.topicID = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * SubOpts _subscribe.\n     * @member {\"subscribe\"|undefined} _subscribe\n     * @memberof RPC.SubOpts\n     * @instance\n     */\n\n    Object.defineProperty(SubOpts.prototype, \"_subscribe\", {\n      get: $util.oneOfGetter($oneOfFields = [\"subscribe\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * SubOpts _topicID.\n     * @member {\"topicID\"|undefined} _topicID\n     * @memberof RPC.SubOpts\n     * @instance\n     */\n\n    Object.defineProperty(SubOpts.prototype, \"_topicID\", {\n      get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Encodes the specified SubOpts message. Does not implicitly {@link RPC.SubOpts.verify|verify} messages.\n     * @function encode\n     * @memberof RPC.SubOpts\n     * @static\n     * @param {RPC.ISubOpts} m SubOpts message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    SubOpts.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.subscribe != null && Object.hasOwnProperty.call(m, \"subscribe\")) w.uint32(8).bool(m.subscribe);\n      if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\")) w.uint32(18).string(m.topicID);\n      return w;\n    };\n    /**\n     * Decodes a SubOpts message from the specified reader or buffer.\n     * @function decode\n     * @memberof RPC.SubOpts\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {RPC.SubOpts} SubOpts\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    SubOpts.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.RPC.SubOpts();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.subscribe = r.bool();\n            break;\n\n          case 2:\n            m.topicID = r.string();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a SubOpts message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof RPC.SubOpts\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {RPC.SubOpts} SubOpts\n     */\n\n\n    SubOpts.fromObject = function fromObject(d) {\n      if (d instanceof $root.RPC.SubOpts) return d;\n      var m = new $root.RPC.SubOpts();\n\n      if (d.subscribe != null) {\n        m.subscribe = Boolean(d.subscribe);\n      }\n\n      if (d.topicID != null) {\n        m.topicID = String(d.topicID);\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a SubOpts message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof RPC.SubOpts\n     * @static\n     * @param {RPC.SubOpts} m SubOpts\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    SubOpts.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (m.subscribe != null && m.hasOwnProperty(\"subscribe\")) {\n        d.subscribe = m.subscribe;\n        if (o.oneofs) d._subscribe = \"subscribe\";\n      }\n\n      if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n        d.topicID = m.topicID;\n        if (o.oneofs) d._topicID = \"topicID\";\n      }\n\n      return d;\n    };\n    /**\n     * Converts this SubOpts to JSON.\n     * @function toJSON\n     * @memberof RPC.SubOpts\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    SubOpts.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return SubOpts;\n  }();\n\n  RPC.Message = function () {\n    /**\n     * Properties of a Message.\n     * @memberof RPC\n     * @interface IMessage\n     * @property {Uint8Array|null} [from] Message from\n     * @property {Uint8Array|null} [data] Message data\n     * @property {Uint8Array|null} [seqno] Message seqno\n     * @property {Array.<string>|null} [topicIDs] Message topicIDs\n     * @property {Uint8Array|null} [signature] Message signature\n     * @property {Uint8Array|null} [key] Message key\n     */\n\n    /**\n     * Constructs a new Message.\n     * @memberof RPC\n     * @classdesc Represents a Message.\n     * @implements IMessage\n     * @constructor\n     * @param {RPC.IMessage=} [p] Properties to set\n     */\n    function Message(p) {\n      this.topicIDs = [];\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * Message from.\n     * @member {Uint8Array|null|undefined} from\n     * @memberof RPC.Message\n     * @instance\n     */\n\n\n    Message.prototype.from = null;\n    /**\n     * Message data.\n     * @member {Uint8Array|null|undefined} data\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Message.prototype.data = null;\n    /**\n     * Message seqno.\n     * @member {Uint8Array|null|undefined} seqno\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Message.prototype.seqno = null;\n    /**\n     * Message topicIDs.\n     * @member {Array.<string>} topicIDs\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Message.prototype.topicIDs = $util.emptyArray;\n    /**\n     * Message signature.\n     * @member {Uint8Array|null|undefined} signature\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Message.prototype.signature = null;\n    /**\n     * Message key.\n     * @member {Uint8Array|null|undefined} key\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Message.prototype.key = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * Message _from.\n     * @member {\"from\"|undefined} _from\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Object.defineProperty(Message.prototype, \"_from\", {\n      get: $util.oneOfGetter($oneOfFields = [\"from\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Message _data.\n     * @member {\"data\"|undefined} _data\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Object.defineProperty(Message.prototype, \"_data\", {\n      get: $util.oneOfGetter($oneOfFields = [\"data\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Message _seqno.\n     * @member {\"seqno\"|undefined} _seqno\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Object.defineProperty(Message.prototype, \"_seqno\", {\n      get: $util.oneOfGetter($oneOfFields = [\"seqno\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Message _signature.\n     * @member {\"signature\"|undefined} _signature\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Object.defineProperty(Message.prototype, \"_signature\", {\n      get: $util.oneOfGetter($oneOfFields = [\"signature\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Message _key.\n     * @member {\"key\"|undefined} _key\n     * @memberof RPC.Message\n     * @instance\n     */\n\n    Object.defineProperty(Message.prototype, \"_key\", {\n      get: $util.oneOfGetter($oneOfFields = [\"key\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Encodes the specified Message message. Does not implicitly {@link RPC.Message.verify|verify} messages.\n     * @function encode\n     * @memberof RPC.Message\n     * @static\n     * @param {RPC.IMessage} m Message message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    Message.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.from != null && Object.hasOwnProperty.call(m, \"from\")) w.uint32(10).bytes(m.from);\n      if (m.data != null && Object.hasOwnProperty.call(m, \"data\")) w.uint32(18).bytes(m.data);\n      if (m.seqno != null && Object.hasOwnProperty.call(m, \"seqno\")) w.uint32(26).bytes(m.seqno);\n\n      if (m.topicIDs != null && m.topicIDs.length) {\n        for (var i = 0; i < m.topicIDs.length; ++i) w.uint32(34).string(m.topicIDs[i]);\n      }\n\n      if (m.signature != null && Object.hasOwnProperty.call(m, \"signature\")) w.uint32(42).bytes(m.signature);\n      if (m.key != null && Object.hasOwnProperty.call(m, \"key\")) w.uint32(50).bytes(m.key);\n      return w;\n    };\n    /**\n     * Decodes a Message message from the specified reader or buffer.\n     * @function decode\n     * @memberof RPC.Message\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {RPC.Message} Message\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Message.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.RPC.Message();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.from = r.bytes();\n            break;\n\n          case 2:\n            m.data = r.bytes();\n            break;\n\n          case 3:\n            m.seqno = r.bytes();\n            break;\n\n          case 4:\n            if (!(m.topicIDs && m.topicIDs.length)) m.topicIDs = [];\n            m.topicIDs.push(r.string());\n            break;\n\n          case 5:\n            m.signature = r.bytes();\n            break;\n\n          case 6:\n            m.key = r.bytes();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a Message message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof RPC.Message\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {RPC.Message} Message\n     */\n\n\n    Message.fromObject = function fromObject(d) {\n      if (d instanceof $root.RPC.Message) return d;\n      var m = new $root.RPC.Message();\n\n      if (d.from != null) {\n        if (typeof d.from === \"string\") $util.base64.decode(d.from, m.from = $util.newBuffer($util.base64.length(d.from)), 0);else if (d.from.length) m.from = d.from;\n      }\n\n      if (d.data != null) {\n        if (typeof d.data === \"string\") $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);else if (d.data.length) m.data = d.data;\n      }\n\n      if (d.seqno != null) {\n        if (typeof d.seqno === \"string\") $util.base64.decode(d.seqno, m.seqno = $util.newBuffer($util.base64.length(d.seqno)), 0);else if (d.seqno.length) m.seqno = d.seqno;\n      }\n\n      if (d.topicIDs) {\n        if (!Array.isArray(d.topicIDs)) throw TypeError(\".RPC.Message.topicIDs: array expected\");\n        m.topicIDs = [];\n\n        for (var i = 0; i < d.topicIDs.length; ++i) {\n          m.topicIDs[i] = String(d.topicIDs[i]);\n        }\n      }\n\n      if (d.signature != null) {\n        if (typeof d.signature === \"string\") $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);else if (d.signature.length) m.signature = d.signature;\n      }\n\n      if (d.key != null) {\n        if (typeof d.key === \"string\") $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);else if (d.key.length) m.key = d.key;\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a Message message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof RPC.Message\n     * @static\n     * @param {RPC.Message} m Message\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Message.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.arrays || o.defaults) {\n        d.topicIDs = [];\n      }\n\n      if (m.from != null && m.hasOwnProperty(\"from\")) {\n        d.from = o.bytes === String ? $util.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;\n        if (o.oneofs) d._from = \"from\";\n      }\n\n      if (m.data != null && m.hasOwnProperty(\"data\")) {\n        d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;\n        if (o.oneofs) d._data = \"data\";\n      }\n\n      if (m.seqno != null && m.hasOwnProperty(\"seqno\")) {\n        d.seqno = o.bytes === String ? $util.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;\n        if (o.oneofs) d._seqno = \"seqno\";\n      }\n\n      if (m.topicIDs && m.topicIDs.length) {\n        d.topicIDs = [];\n\n        for (var j = 0; j < m.topicIDs.length; ++j) {\n          d.topicIDs[j] = m.topicIDs[j];\n        }\n      }\n\n      if (m.signature != null && m.hasOwnProperty(\"signature\")) {\n        d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;\n        if (o.oneofs) d._signature = \"signature\";\n      }\n\n      if (m.key != null && m.hasOwnProperty(\"key\")) {\n        d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;\n        if (o.oneofs) d._key = \"key\";\n      }\n\n      return d;\n    };\n    /**\n     * Converts this Message to JSON.\n     * @function toJSON\n     * @memberof RPC.Message\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Message.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Message;\n  }();\n\n  return RPC;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}