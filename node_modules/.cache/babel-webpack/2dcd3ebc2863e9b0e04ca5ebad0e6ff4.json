{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  Adapter,\n  Errors\n} = require('interface-datastore');\n\nconst log = require('debug')('datastore:core:tiered');\n\nconst pushable = require('it-pushable');\n\nconst drain = require('it-drain');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\n\n\nclass TieredDatastore extends Adapter {\n  /**\n   * @param {Datastore[]} stores\n   */\n  constructor(stores) {\n    super();\n    this.stores = stores.slice();\n  }\n\n  open() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield Promise.all(_this3.stores.map(store => store.open()));\n      } catch (err) {\n        throw Errors.dbOpenFailedError();\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n\n\n  put(key, value) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield Promise.all(_this4.stores.map(store => store.put(key, value)));\n      } catch (err) {\n        throw Errors.dbWriteFailedError();\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const store of _this5.stores) {\n        try {\n          const res = yield store.get(key, options);\n          if (res) return res;\n        } catch (err) {\n          log(err);\n        }\n      }\n\n      throw Errors.notFoundError();\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const s of _this6.stores) {\n        if (yield s.has(key, options)) {\n          return true;\n        }\n      }\n\n      return false;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield Promise.all(_this7.stores.map(store => store.delete(key, options)));\n      } catch (err) {\n        throw Errors.dbDeleteFailedError();\n      }\n    })();\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  putMany(source, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      let error;\n\n      const pushables = _this.stores.map(store => {\n        const source = pushable();\n        drain(store.putMany(source, options)).catch(err => {\n          // store threw while putting, make sure we bubble the error up\n          error = err;\n        });\n        return source;\n      });\n\n      try {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const pair = _value;\n\n            if (error) {\n              throw error;\n            }\n\n            pushables.forEach(p => p.push(pair));\n            yield pair;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } finally {\n        pushables.forEach(p => p.end());\n      }\n    })();\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n\n\n  deleteMany(source, options = {}) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      let error;\n\n      const pushables = _this2.stores.map(store => {\n        const source = pushable();\n        drain(store.deleteMany(source, options)).catch(err => {\n          // store threw while deleting, make sure we bubble the error up\n          error = err;\n        });\n        return source;\n      });\n\n      try {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n\n        var _iteratorError2;\n\n        try {\n          for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n            const key = _value2;\n\n            if (error) {\n              throw error;\n            }\n\n            pushables.forEach(p => p.push(key));\n            yield key;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              yield _awaitAsyncGenerator(_iterator2.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } finally {\n        pushables.forEach(p => p.end());\n      }\n    })();\n  }\n\n  close() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      yield Promise.all(_this8.stores.map(store => store.close()));\n    })();\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: function () {\n        var _ref = _asyncToGenerator(function* (options) {\n          for (const batch of batches) {\n            yield batch.commit(options);\n          }\n        });\n\n        return function commit(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()\n    };\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    return this.stores[this.stores.length - 1].query(q, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options);\n  }\n\n}\n\nmodule.exports = TieredDatastore;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/datastore-core/src/tiered.js"],"names":["Adapter","Errors","require","log","pushable","drain","TieredDatastore","constructor","stores","slice","open","Promise","all","map","store","err","dbOpenFailedError","put","key","value","dbWriteFailedError","get","options","res","notFoundError","has","s","delete","dbDeleteFailedError","putMany","source","error","pushables","catch","pair","forEach","p","push","end","deleteMany","close","batch","batches","b","commit","query","q","length","queryKeys","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Adapter, Errors } = require('interface-datastore')\nconst log = require('debug')('datastore:core:tiered')\nconst pushable = require('it-pushable')\nconst drain = require('it-drain')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nclass TieredDatastore extends Adapter {\n  /**\n   * @param {Datastore[]} stores\n   */\n  constructor (stores) {\n    super()\n\n    this.stores = stores.slice()\n  }\n\n  async open () {\n    try {\n      await Promise.all(this.stores.map((store) => store.open()))\n    } catch (err) {\n      throw Errors.dbOpenFailedError()\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n  async put (key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)))\n    } catch (err) {\n      throw Errors.dbWriteFailedError()\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async get (key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options)\n        if (res) return res\n      } catch (err) {\n        log(err)\n      }\n    }\n    throw Errors.notFoundError()\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async has (key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async delete (key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)))\n    } catch (err) {\n      throw Errors.dbDeleteFailedError()\n    }\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async * putMany (source, options = {}) {\n    let error\n    const pushables = this.stores.map(store => {\n      const source = pushable()\n\n      drain(store.putMany(source, options))\n        .catch(err => {\n          // store threw while putting, make sure we bubble the error up\n          error = err\n        })\n\n      return source\n    })\n\n    try {\n      for await (const pair of source) {\n        if (error) {\n          throw error\n        }\n\n        pushables.forEach(p => p.push(pair))\n\n        yield pair\n      }\n    } finally {\n      pushables.forEach(p => p.end())\n    }\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async * deleteMany (source, options = {}) {\n    let error\n    const pushables = this.stores.map(store => {\n      const source = pushable()\n\n      drain(store.deleteMany(source, options))\n        .catch(err => {\n          // store threw while deleting, make sure we bubble the error up\n          error = err\n        })\n\n      return source\n    })\n\n    try {\n      for await (const key of source) {\n        if (error) {\n          throw error\n        }\n\n        pushables.forEach(p => p.push(key))\n\n        yield key\n      }\n    } finally {\n      pushables.forEach(p => p.end())\n    }\n  }\n\n  async close () {\n    await Promise.all(this.stores.map(store => store.close()))\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    const batches = this.stores.map(store => store.batch())\n\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value))\n      },\n      delete: (key) => {\n        batches.forEach(b => b.delete(key))\n      },\n      commit: async (options) => {\n        for (const batch of batches) {\n          await batch.commit(options)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    return this.stores[this.stores.length - 1].query(q, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options)\n  }\n}\n\nmodule.exports = TieredDatastore\n"]},"metadata":{},"sourceType":"script"}