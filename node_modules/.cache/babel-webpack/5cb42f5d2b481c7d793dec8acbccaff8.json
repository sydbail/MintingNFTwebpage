{"ast":null,"code":"'use strict';\n/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n * @template T\n * @param {ReadableStream<T>} stream\n * @param {Object} [options]\n * @param {boolean} [options.preventCancel=boolean]\n * @returns {AsyncIterable<T>}\n */\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nfunction browserReadableStreamToIt(_x) {\n  return _browserReadableStreamToIt.apply(this, arguments);\n}\n\nfunction _browserReadableStreamToIt() {\n  _browserReadableStreamToIt = _wrapAsyncGenerator(function* (stream, options = {}) {\n    const reader = stream.getReader();\n\n    try {\n      while (true) {\n        const result = yield _awaitAsyncGenerator(reader.read());\n\n        if (result.done) {\n          return;\n        }\n\n        yield result.value;\n      }\n    } finally {\n      if (options.preventCancel !== true) {\n        reader.cancel();\n      }\n\n      reader.releaseLock();\n    }\n  });\n  return _browserReadableStreamToIt.apply(this, arguments);\n}\n\nmodule.exports = browserReadableStreamToIt;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/browser-readablestream-to-it/index.js"],"names":["browserReadableStreamToIt","stream","options","reader","getReader","result","read","done","value","preventCancel","cancel","releaseLock","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;SACiBA,yB;;;;;mDAAjB,WAA4CC,MAA5C,EAAoDC,OAAO,GAAG,EAA9D,EAAkE;AAChE,UAAMC,MAAM,GAAGF,MAAM,CAACG,SAAP,EAAf;;AAEA,QAAI;AACF,aAAO,IAAP,EAAa;AACX,cAAMC,MAAM,8BAASF,MAAM,CAACG,IAAP,EAAT,CAAZ;;AAEA,YAAID,MAAM,CAACE,IAAX,EAAiB;AACf;AACD;;AAED,cAAMF,MAAM,CAACG,KAAb;AACD;AACF,KAVD,SAUU;AACR,UAAIN,OAAO,CAACO,aAAR,KAA0B,IAA9B,EAAoC;AAClCN,QAAAA,MAAM,CAACO,MAAP;AACD;;AAEDP,MAAAA,MAAM,CAACQ,WAAP;AACD;AACF,G;;;;AAEDC,MAAM,CAACC,OAAP,GAAiBb,yBAAjB","sourcesContent":["'use strict'\n\n/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n * @template T\n * @param {ReadableStream<T>} stream\n * @param {Object} [options]\n * @param {boolean} [options.preventCancel=boolean]\n * @returns {AsyncIterable<T>}\n */\nasync function * browserReadableStreamToIt (stream, options = {}) {\n  const reader = stream.getReader()\n\n  try {\n    while (true) {\n      const result = await reader.read()\n\n      if (result.done) {\n        return\n      }\n\n      yield result.value\n    }\n  } finally {\n    if (options.preventCancel !== true) {\n      reader.cancel()\n    }\n\n    reader.releaseLock()\n  }\n}\n\nmodule.exports = browserReadableStreamToIt\n"]},"metadata":{},"sourceType":"script"}