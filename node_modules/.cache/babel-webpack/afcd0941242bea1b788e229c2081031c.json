{"ast":null,"code":"'use strict'; // @ts-ignore\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst SparseArray = require('sparse-array');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\n\n\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor(options, parent, posAtParent = 0) {\n    this._options = options;\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n\n    this._children = new SparseArray();\n    /** @type {string | null} */\n\n    this.key = null;\n  }\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n\n\n  put(key, value) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const place = yield _this._findNewBucketAndPos(key);\n      yield place.bucket._putAt(place, key, value);\n    })();\n  }\n  /**\n   * @param {string} key\n   */\n\n\n  get(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const child = yield _this2._findChild(key);\n\n      if (child) {\n        return child.value;\n      }\n    })();\n  }\n  /**\n   * @param {string} key\n   */\n\n\n  del(key) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const place = yield _this3._findPlace(key);\n\n      const child = place.bucket._at(place.pos);\n\n      if (child && child.key === key) {\n        place.bucket._delAt(place.pos);\n      }\n    })();\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  leafCount() {\n    const children = this._children.compactArray();\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount();\n      }\n\n      return acc + 1;\n    }, 0);\n  }\n\n  childrenCount() {\n    return this._children.length;\n  }\n\n  onlyChild() {\n    return this._children.get(0);\n  }\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n\n\n  *eachLeafSeries() {\n    const children = this._children.compactArray();\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield* child.eachLeafSeries();\n      } else {\n        yield child;\n      }\n    } // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n\n\n    return [];\n  }\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n\n\n  serialize(map, reduce) {\n    /** @type {T[]} */\n    const acc = []; // serialize to a custom non-sparse representation\n\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce));\n        } else {\n          acc.push(map(child, index));\n        }\n      }\n\n      return acc;\n    }, acc));\n  }\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n\n\n  asyncTransform(asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce);\n  }\n\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, '  ');\n  }\n\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n\n\n  _findChild(key) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield _this4._findPlace(key);\n\n      const child = result.bucket._at(result.pos);\n\n      if (child instanceof Bucket) {\n        // should not be possible, this._findPlace should always\n        // return a location for a child, not a bucket\n        return undefined;\n      }\n\n      if (child && child.key === key) {\n        return child;\n      }\n    })();\n  }\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n\n\n  _findPlace(key) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const hashValue = _this5._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);\n\n      const index = yield hashValue.take(_this5._options.bits);\n\n      const child = _this5._children.get(index);\n\n      if (child instanceof Bucket) {\n        return child._findPlace(hashValue);\n      }\n\n      return {\n        bucket: _this5,\n        pos: index,\n        hash: hashValue,\n        existingChild: child\n      };\n    })();\n  }\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n\n\n  _findNewBucketAndPos(key) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const place = yield _this6._findPlace(key);\n\n      if (place.existingChild && place.existingChild.key !== key) {\n        // conflict\n        const bucket = new Bucket(_this6._options, place.bucket, place.pos);\n\n        place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n        const newPlace = yield bucket._findPlace(place.existingChild.hash);\n\n        newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n\n        return bucket._findNewBucketAndPos(place.hash);\n      } // no conflict, we found the place\n\n\n      return place;\n    })();\n  }\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n\n\n  _putAt(place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    });\n  }\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n\n\n  _putObjectAt(pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++;\n    }\n\n    this._children.set(pos, object);\n  }\n  /**\n   * @param {number} pos\n   */\n\n\n  _delAt(pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position');\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--;\n    }\n\n    this._children.unset(pos);\n\n    this._level();\n  }\n\n  _level() {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists);\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash;\n          hash.untake(this._options.bits);\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          };\n\n          this._parent._putAt(place, onlyChild.key, onlyChild.value);\n        }\n      } else {\n        this._parent._delAt(this._posAtParent);\n      }\n    }\n  }\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n\n\n  _at(index) {\n    return this._children.get(index);\n  }\n\n}\n/**\n * @param {any} o\n */\n\n\nfunction exists(o) {\n  return Boolean(o);\n}\n/**\n *\n * @param {*} node\n * @param {number} index\n */\n\n\nfunction mapNode(node, index) {\n  return node.key;\n}\n/**\n * @param {*} nodes\n */\n\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\n\n\nfunction asyncTransformBucket(_x, _x2, _x3) {\n  return _asyncTransformBucket.apply(this, arguments);\n}\n\nfunction _asyncTransformBucket() {\n  _asyncTransformBucket = _asyncToGenerator(function* (bucket, asyncMap, asyncReduce) {\n    const output = [];\n\n    for (const child of bucket._children.compactArray()) {\n      if (child instanceof Bucket) {\n        yield asyncTransformBucket(child, asyncMap, asyncReduce);\n      } else {\n        const mappedChildren = yield asyncMap(child);\n        output.push({\n          bitField: bucket._children.bitField(),\n          children: mappedChildren\n        });\n      }\n    }\n\n    return asyncReduce(output);\n  });\n  return _asyncTransformBucket.apply(this, arguments);\n}\n\nmodule.exports = Bucket;","map":null,"metadata":{},"sourceType":"script"}