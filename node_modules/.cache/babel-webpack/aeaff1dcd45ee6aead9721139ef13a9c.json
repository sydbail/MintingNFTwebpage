{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport findShardCid from '../../utils/find-cid-in-shard.js';\nimport { decode } from '@ipld/dag-pb';\nimport contentFile from './content/file.js';\nimport contentDirectory from './content/directory.js';\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js';\n\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name);\n  return link && link.Hash;\n};\n\nconst contentExporters = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  }\n};\n\nconst unixFsResolver = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (cid, name, path, toResolve, resolve, depth, blockstore, options) {\n    const block = yield blockstore.get(cid, options);\n    const node = decode(block);\n    let unixfs;\n    let next;\n\n    if (!name) {\n      name = cid.toString();\n    }\n\n    if (node.Data == null) {\n      throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n    }\n\n    try {\n      unixfs = UnixFS.unmarshal(node.Data);\n    } catch (err) {\n      throw errCode(err, 'ERR_NOT_UNIXFS');\n    }\n\n    if (!path) {\n      path = name;\n    }\n\n    if (toResolve.length) {\n      let linkCid;\n\n      if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n        linkCid = yield findShardCid(node, toResolve[0], blockstore);\n      } else {\n        linkCid = findLinkCid(node, toResolve[0]);\n      }\n\n      if (!linkCid) {\n        throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND');\n      }\n\n      const nextName = toResolve.shift();\n      const nextPath = `${path}/${nextName}`;\n      next = {\n        cid: linkCid,\n        toResolve,\n        name: nextName || '',\n        path: nextPath\n      };\n    }\n\n    return {\n      entry: {\n        type: unixfs.isDirectory() ? 'directory' : 'file',\n        name,\n        path,\n        cid,\n        content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore),\n        unixfs,\n        depth,\n        node,\n        size: unixfs.fileSize()\n      },\n      next\n    };\n  });\n\n  return function unixFsResolver(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport default unixFsResolver;","map":null,"metadata":{},"sourceType":"module"}