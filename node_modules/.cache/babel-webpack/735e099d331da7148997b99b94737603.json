{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} = require('./content-routing/utils');\n\nconst merge = require('it-merge');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst first = require('it-first');\n\nconst drain = require('it-drain');\n\nconst filter = require('it-filter');\n\nconst {\n  setDelayedInterval,\n  clearDelayedInterval // @ts-ignore module with no types\n\n} = require('set-delayed-interval');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor(libp2p) {\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    /** @type {PeerRoutingModule[]} */\n\n    this._routers = libp2p._modules.peerRouting || []; // If we have the dht, add it to the available peer routers\n\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(libp2p._dht);\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);\n  }\n  /**\n   * Start peer routing service.\n   */\n\n\n  start() {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return;\n    }\n\n    this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);\n  }\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n\n\n  _findClosestPeersTask() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // nb getClosestPeers adds the addresses to the address book\n        yield drain(_this2.getClosestPeers(_this2._peerId.id));\n      } catch (err) {\n        log.error(err);\n      }\n    })();\n  }\n  /**\n   * Stop peer routing service.\n   */\n\n\n  stop() {\n    clearDelayedInterval(this._timeoutId);\n  }\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  findPeer(id, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (!_this3._routers.length) {\n        throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      if (id.toB58String() === _this3._peerId.toB58String()) {\n        throw errCode(new Error('Should not try to find self'), 'ERR_FIND_SELF');\n      }\n\n      const output = yield pipe(merge(..._this3._routers.map(router => [router.findPeer(id, options)])), source => filter(source, Boolean), // @ts-ignore findPeer resolves a Promise\n      source => storeAddresses(source, _this3._peerStore), source => first(source));\n\n      if (output) {\n        return output;\n      }\n\n      throw errCode(new Error('not found'), 'NOT_FOUND');\n    })();\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  getClosestPeers(key, options = {\n    timeout: 30e3\n  }) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      if (!_this._routers.length) {\n        throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      yield* _asyncGeneratorDelegate(_asyncIterator(pipe(merge(..._this._routers.map(router => router.getClosestPeers(key, options))), source => storeAddresses(source, _this._peerStore), source => uniquePeers(source), source => requirePeers(source))), _awaitAsyncGenerator);\n    })();\n  }\n\n}\n\nmodule.exports = PeerRouting;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p/src/peer-routing.js"],"names":["debug","require","log","Object","assign","error","errCode","storeAddresses","uniquePeers","requirePeers","merge","pipe","first","drain","filter","setDelayedInterval","clearDelayedInterval","PeerRouting","constructor","libp2p","_peerId","peerId","_peerStore","peerStore","_routers","_modules","peerRouting","_dht","_config","dht","enabled","push","_refreshManagerOptions","_options","refreshManager","_findClosestPeersTask","bind","start","length","_timeoutId","interval","bootDelay","getClosestPeers","id","err","stop","findPeer","options","Error","toB58String","output","map","router","source","Boolean","key","timeout","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n})\nconst errCode = require('err-code')\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} = require('./content-routing/utils')\n\nconst merge = require('it-merge')\nconst { pipe } = require('it-pipe')\nconst first = require('it-first')\nconst drain = require('it-drain')\nconst filter = require('it-filter')\nconst {\n  setDelayedInterval,\n  clearDelayedInterval\n// @ts-ignore module with no types\n} = require('set-delayed-interval')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor (libp2p) {\n    this._peerId = libp2p.peerId\n    this._peerStore = libp2p.peerStore\n    /** @type {PeerRoutingModule[]} */\n    this._routers = libp2p._modules.peerRouting || []\n\n    // If we have the dht, add it to the available peer routers\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(libp2p._dht)\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager\n\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this)\n  }\n\n  /**\n   * Start peer routing service.\n   */\n  start () {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return\n    }\n\n    this._timeoutId = setDelayedInterval(\n      this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay\n    )\n  }\n\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n  async _findClosestPeersTask () {\n    try {\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this._peerId.id))\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Stop peer routing service.\n   */\n  stop () {\n    clearDelayedInterval(this._timeoutId)\n  }\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async findPeer (id, options) { // eslint-disable-line require-await\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    if (id.toB58String() === this._peerId.toB58String()) {\n      throw errCode(new Error('Should not try to find self'), 'ERR_FIND_SELF')\n    }\n\n    const output = await pipe(\n      merge(\n        ...this._routers.map(router => [router.findPeer(id, options)])\n      ),\n      (source) => filter(source, Boolean),\n      // @ts-ignore findPeer resolves a Promise\n      (source) => storeAddresses(source, this._peerStore),\n      (source) => first(source)\n    )\n\n    if (output) {\n      return output\n    }\n\n    throw errCode(new Error('not found'), 'NOT_FOUND')\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * getClosestPeers (key, options = { timeout: 30e3 }) {\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    yield * pipe(\n      merge(\n        ...this._routers.map(router => router.getClosestPeers(key, options))\n      ),\n      (source) => storeAddresses(source, this._peerStore),\n      (source) => uniquePeers(source),\n      (source) => requirePeers(source)\n    )\n  }\n}\n\nmodule.exports = PeerRouting\n"]},"metadata":{},"sourceType":"script"}