{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  Adapter,\n  Errors\n} = require('interface-datastore');\n\nconst log = require('debug')('datastore:core:tiered');\n\nconst pushable = require('it-pushable');\n\nconst drain = require('it-drain');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\n\n\nclass TieredDatastore extends Adapter {\n  /**\n   * @param {Datastore[]} stores\n   */\n  constructor(stores) {\n    super();\n    this.stores = stores.slice();\n  }\n\n  open() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield Promise.all(_this3.stores.map(store => store.open()));\n      } catch (err) {\n        throw Errors.dbOpenFailedError();\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n\n\n  put(key, value) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield Promise.all(_this4.stores.map(store => store.put(key, value)));\n      } catch (err) {\n        throw Errors.dbWriteFailedError();\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const store of _this5.stores) {\n        try {\n          const res = yield store.get(key, options);\n          if (res) return res;\n        } catch (err) {\n          log(err);\n        }\n      }\n\n      throw Errors.notFoundError();\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const s of _this6.stores) {\n        if (yield s.has(key, options)) {\n          return true;\n        }\n      }\n\n      return false;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield Promise.all(_this7.stores.map(store => store.delete(key, options)));\n      } catch (err) {\n        throw Errors.dbDeleteFailedError();\n      }\n    })();\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  putMany(source, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      let error;\n\n      const pushables = _this.stores.map(store => {\n        const source = pushable();\n        drain(store.putMany(source, options)).catch(err => {\n          // store threw while putting, make sure we bubble the error up\n          error = err;\n        });\n        return source;\n      });\n\n      try {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const pair = _value;\n\n            if (error) {\n              throw error;\n            }\n\n            pushables.forEach(p => p.push(pair));\n            yield pair;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } finally {\n        pushables.forEach(p => p.end());\n      }\n    })();\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n\n\n  deleteMany(source, options = {}) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      let error;\n\n      const pushables = _this2.stores.map(store => {\n        const source = pushable();\n        drain(store.deleteMany(source, options)).catch(err => {\n          // store threw while deleting, make sure we bubble the error up\n          error = err;\n        });\n        return source;\n      });\n\n      try {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n\n        var _iteratorError2;\n\n        try {\n          for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n            const key = _value2;\n\n            if (error) {\n              throw error;\n            }\n\n            pushables.forEach(p => p.push(key));\n            yield key;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              yield _awaitAsyncGenerator(_iterator2.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } finally {\n        pushables.forEach(p => p.end());\n      }\n    })();\n  }\n\n  close() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      yield Promise.all(_this8.stores.map(store => store.close()));\n    })();\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: function () {\n        var _ref = _asyncToGenerator(function* (options) {\n          for (const batch of batches) {\n            yield batch.commit(options);\n          }\n        });\n\n        return function commit(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()\n    };\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    return this.stores[this.stores.length - 1].query(q, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options);\n  }\n\n}\n\nmodule.exports = TieredDatastore;","map":null,"metadata":{},"sourceType":"script"}