{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst abortable = require('abortable-iterator');\n\nconst AbortController = require('abort-controller');\n\nconst log = require('debug')('libp2p:mplex:stream');\n\nconst pushable = require('it-pushable');\n\nconst BufferList = require('bl/BufferList');\n\nconst errCode = require('err-code');\n\nconst {\n  MAX_MSG_SIZE\n} = require('./restrict-size');\n\nconst {\n  InitiatorMessageTypes,\n  ReceiverMessageTypes\n} = require('./message-types');\n\nconst ERR_MPLEX_STREAM_RESET = 'ERR_MPLEX_STREAM_RESET';\nconst ERR_MPLEX_STREAM_ABORT = 'ERR_MPLEX_STREAM_ABORT';\n/**\n * @param {object} options\n * @param {number} options.id\n * @param {string} options.name\n * @param {function(*)} options.send - Called to send data through the stream\n * @param {function(Error)} [options.onEnd] - Called whenever the stream ends\n * @param {string} [options.type] - One of ['initiator','receiver']. Defaults to 'initiator'\n * @param {number} [options.maxMsgSize] - Max size of an mplex message in bytes. Writes > size are automatically split. Defaults to 1MB\n * @returns {*} A muxed stream\n */\n\nmodule.exports = ({\n  id,\n  name,\n  send,\n  onEnd = () => {},\n  type = 'initiator',\n  maxMsgSize = MAX_MSG_SIZE\n}) => {\n  const abortController = new AbortController();\n  const resetController = new AbortController();\n  const Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes;\n  const externalId = type === 'initiator' ? `i${id}` : `r${id}`;\n  name = String(name == null ? id : name);\n  let sourceEnded = false;\n  let sinkEnded = false;\n  let endErr;\n\n  const onSourceEnd = err => {\n    if (sourceEnded) return;\n    sourceEnded = true;\n    log('%s stream %s source end', type, name, err);\n    if (err && !endErr) endErr = err;\n\n    if (sinkEnded) {\n      stream.timeline.close = Date.now();\n      onEnd(endErr);\n    }\n  };\n\n  const onSinkEnd = err => {\n    if (sinkEnded) return;\n    sinkEnded = true;\n    log('%s stream %s sink end', type, name, err);\n    if (err && !endErr) endErr = err;\n\n    if (sourceEnded) {\n      stream.timeline.close = Date.now();\n      onEnd(endErr);\n    }\n  };\n\n  const stream = {\n    // Close for reading\n    close: () => stream.source.end(),\n    // Close for reading and writing (local error)\n    abort: err => {\n      log('%s stream %s abort', type, name, err); // End the source with the passed error\n\n      stream.source.end(err);\n      abortController.abort();\n      onSinkEnd(err);\n    },\n    // Close immediately for reading and writing (remote error)\n    reset: () => {\n      const err = errCode(new Error('stream reset'), ERR_MPLEX_STREAM_RESET);\n      resetController.abort();\n      stream.source.end(err);\n      onSinkEnd(err);\n    },\n    sink: function () {\n      var _ref = _asyncToGenerator(function* (source) {\n        source = abortable(source, [{\n          signal: abortController.signal,\n          options: {\n            abortMessage: 'stream aborted',\n            abortCode: ERR_MPLEX_STREAM_ABORT\n          }\n        }, {\n          signal: resetController.signal,\n          options: {\n            abortMessage: 'stream reset',\n            abortCode: ERR_MPLEX_STREAM_RESET\n          }\n        }]);\n\n        if (type === 'initiator') {\n          // If initiator, open a new stream\n          send({\n            id,\n            type: Types.NEW_STREAM,\n            data: name\n          });\n        }\n\n        try {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n\n          var _iteratorError;\n\n          try {\n            for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n              let data = _value;\n\n              while (data.length) {\n                if (data.length <= maxMsgSize) {\n                  send({\n                    id,\n                    type: Types.MESSAGE,\n                    data\n                  });\n                  break;\n                }\n\n                data = BufferList.isBufferList(data) ? data : new BufferList(data);\n                send({\n                  id,\n                  type: Types.MESSAGE,\n                  data: data.shallowSlice(0, maxMsgSize)\n                });\n                data.consume(maxMsgSize);\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                yield _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        } catch (err) {\n          // Send no more data if this stream was remotely reset\n          if (err.code === ERR_MPLEX_STREAM_RESET) {\n            log('%s stream %s reset', type, name);\n          } else {\n            log('%s stream %s error', type, name, err);\n            send({\n              id,\n              type: Types.RESET\n            });\n          }\n\n          stream.source.end(err);\n          return onSinkEnd(err);\n        }\n\n        send({\n          id,\n          type: Types.CLOSE\n        });\n        onSinkEnd();\n      });\n\n      return function sink(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }(),\n    source: pushable(onSourceEnd),\n    timeline: {\n      open: Date.now(),\n      close: null\n    },\n    id: externalId\n  };\n  return stream;\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/libp2p-mplex/src/stream.js"],"names":["abortable","require","AbortController","log","pushable","BufferList","errCode","MAX_MSG_SIZE","InitiatorMessageTypes","ReceiverMessageTypes","ERR_MPLEX_STREAM_RESET","ERR_MPLEX_STREAM_ABORT","module","exports","id","name","send","onEnd","type","maxMsgSize","abortController","resetController","Types","externalId","String","sourceEnded","sinkEnded","endErr","onSourceEnd","err","stream","timeline","close","Date","now","onSinkEnd","source","end","abort","reset","Error","sink","signal","options","abortMessage","abortCode","NEW_STREAM","data","length","MESSAGE","isBufferList","shallowSlice","consume","code","RESET","CLOSE","open"],"mappings":"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","sourcesContent":["'use strict'\n\nconst abortable = require('abortable-iterator')\nconst AbortController = require('abort-controller')\nconst log = require('debug')('libp2p:mplex:stream')\nconst pushable = require('it-pushable')\nconst BufferList = require('bl/BufferList')\nconst errCode = require('err-code')\nconst { MAX_MSG_SIZE } = require('./restrict-size')\nconst { InitiatorMessageTypes, ReceiverMessageTypes } = require('./message-types')\n\nconst ERR_MPLEX_STREAM_RESET = 'ERR_MPLEX_STREAM_RESET'\nconst ERR_MPLEX_STREAM_ABORT = 'ERR_MPLEX_STREAM_ABORT'\n\n/**\n * @param {object} options\n * @param {number} options.id\n * @param {string} options.name\n * @param {function(*)} options.send - Called to send data through the stream\n * @param {function(Error)} [options.onEnd] - Called whenever the stream ends\n * @param {string} [options.type] - One of ['initiator','receiver']. Defaults to 'initiator'\n * @param {number} [options.maxMsgSize] - Max size of an mplex message in bytes. Writes > size are automatically split. Defaults to 1MB\n * @returns {*} A muxed stream\n */\nmodule.exports = ({ id, name, send, onEnd = () => {}, type = 'initiator', maxMsgSize = MAX_MSG_SIZE }) => {\n  const abortController = new AbortController()\n  const resetController = new AbortController()\n  const Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes\n  const externalId = type === 'initiator' ? (`i${id}`) : `r${id}`\n\n  name = String(name == null ? id : name)\n\n  let sourceEnded = false\n  let sinkEnded = false\n  let endErr\n\n  const onSourceEnd = err => {\n    if (sourceEnded) return\n    sourceEnded = true\n    log('%s stream %s source end', type, name, err)\n    if (err && !endErr) endErr = err\n    if (sinkEnded) {\n      stream.timeline.close = Date.now()\n      onEnd(endErr)\n    }\n  }\n\n  const onSinkEnd = err => {\n    if (sinkEnded) return\n    sinkEnded = true\n    log('%s stream %s sink end', type, name, err)\n    if (err && !endErr) endErr = err\n    if (sourceEnded) {\n      stream.timeline.close = Date.now()\n      onEnd(endErr)\n    }\n  }\n\n  const stream = {\n    // Close for reading\n    close: () => stream.source.end(),\n    // Close for reading and writing (local error)\n    abort: err => {\n      log('%s stream %s abort', type, name, err)\n      // End the source with the passed error\n      stream.source.end(err)\n      abortController.abort()\n      onSinkEnd(err)\n    },\n    // Close immediately for reading and writing (remote error)\n    reset: () => {\n      const err = errCode(new Error('stream reset'), ERR_MPLEX_STREAM_RESET)\n      resetController.abort()\n      stream.source.end(err)\n      onSinkEnd(err)\n    },\n    sink: async source => {\n      source = abortable(source, [\n        { signal: abortController.signal, options: { abortMessage: 'stream aborted', abortCode: ERR_MPLEX_STREAM_ABORT } },\n        { signal: resetController.signal, options: { abortMessage: 'stream reset', abortCode: ERR_MPLEX_STREAM_RESET } }\n      ])\n\n      if (type === 'initiator') { // If initiator, open a new stream\n        send({ id, type: Types.NEW_STREAM, data: name })\n      }\n\n      try {\n        for await (let data of source) {\n          while (data.length) {\n            if (data.length <= maxMsgSize) {\n              send({ id, type: Types.MESSAGE, data })\n              break\n            }\n            data = BufferList.isBufferList(data) ? data : new BufferList(data)\n            send({ id, type: Types.MESSAGE, data: data.shallowSlice(0, maxMsgSize) })\n            data.consume(maxMsgSize)\n          }\n        }\n      } catch (err) {\n        // Send no more data if this stream was remotely reset\n        if (err.code === ERR_MPLEX_STREAM_RESET) {\n          log('%s stream %s reset', type, name)\n        } else {\n          log('%s stream %s error', type, name, err)\n          send({ id, type: Types.RESET })\n        }\n\n        stream.source.end(err)\n        return onSinkEnd(err)\n      }\n\n      send({ id, type: Types.CLOSE })\n      onSinkEnd()\n    },\n    source: pushable(onSourceEnd),\n    timeline: {\n      open: Date.now(),\n      close: null\n    },\n    id: externalId\n  }\n\n  return stream\n}\n"]},"metadata":{},"sourceType":"script"}