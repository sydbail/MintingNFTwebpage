{"ast":null,"code":"'use strict';\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst arrayEquals = require('libp2p-utils/src/array-equals');\n\nconst {\n  PeerRecord: Protobuf\n} = require('./peer-record');\n\nconst {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} = require('./consts');\n/**\n * @typedef {import('../../peer-store/address-book.js').Address} Address\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\n/**\n * @implements {Record}\n */\n\n\nlet PeerRecord = /*#__PURE__*/(() => {\n  class PeerRecord {\n    /**\n     * The PeerRecord is used for distributing peer routing records across the network.\n     * It contains the peer's reachable listen addresses.\n     *\n     * @class\n     * @param {Object} params\n     * @param {PeerId} params.peerId\n     * @param {Multiaddr[]} params.multiaddrs - addresses of the associated peer.\n     * @param {number} [params.seqNumber] - monotonically-increasing sequence counter that's used to order PeerRecords in time.\n     */\n    constructor({\n      peerId,\n      multiaddrs = [],\n      seqNumber = Date.now()\n    }) {\n      this.domain = ENVELOPE_DOMAIN_PEER_RECORD;\n      this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;\n      this.peerId = peerId;\n      this.multiaddrs = multiaddrs;\n      this.seqNumber = seqNumber; // Cache\n\n      this._marshal = undefined;\n    }\n    /**\n     * Marshal a record to be used in an envelope.\n     *\n     * @returns {Uint8Array}\n     */\n\n\n    marshal() {\n      if (this._marshal) {\n        return this._marshal;\n      }\n\n      this._marshal = Protobuf.encode({\n        peerId: this.peerId.toBytes(),\n        seq: this.seqNumber,\n        addresses: this.multiaddrs.map(m => ({\n          multiaddr: m.bytes\n        }))\n      }).finish();\n      return this._marshal;\n    }\n    /**\n     * Returns true if `this` record equals the `other`.\n     *\n     * @param {unknown} other\n     * @returns {boolean}\n     */\n\n\n    equals(other) {\n      if (!(other instanceof PeerRecord)) {\n        return false;\n      } // Validate PeerId\n\n\n      if (!this.peerId.equals(other.peerId)) {\n        return false;\n      } // Validate seqNumber\n\n\n      if (this.seqNumber !== other.seqNumber) {\n        return false;\n      } // Validate multiaddrs\n\n\n      if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n        return false;\n      }\n\n      return true;\n    }\n\n  }\n\n  /**\n   * Unmarshal Peer Record Protobuf.\n   *\n   * @param {Uint8Array} buf - marshaled peer record.\n   * @returns {PeerRecord}\n   */\n  PeerRecord.createFromProtobuf = buf => {\n    const peerRecord = Protobuf.decode(buf);\n    const peerId = PeerId.createFromBytes(peerRecord.peerId);\n    const multiaddrs = (peerRecord.addresses || []).map(a => new Multiaddr(a.multiaddr));\n    const seqNumber = Number(peerRecord.seq);\n    return new PeerRecord({\n      peerId,\n      multiaddrs,\n      seqNumber\n    });\n  };\n\n  PeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;\n  return PeerRecord;\n})();\nmodule.exports = PeerRecord;","map":null,"metadata":{},"sourceType":"script"}