{"ast":null,"code":"/* eslint complexity: [\"error\", 27] */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst defaultMigrations = require('../migrations');\n\nconst repoVersion = require('./repo/version');\n\nconst errors = require('./errors');\n\nconst {\n  wrapBackends\n} = require('./utils');\n\nconst log = require('debug')('ipfs:repo:migrator');\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\n\n\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\n\n\nfunction migrate(_x, _x2, _x3, _x4, _x5) {\n  return _migrate.apply(this, arguments);\n}\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\n\n\nfunction _migrate() {\n  _migrate = _asyncToGenerator(function* (path, backends, repoOptions, toVersion, {\n    ignoreLock = false,\n    onProgress,\n    isDryRun = false,\n    migrations\n  }) {\n    migrations = migrations || defaultMigrations;\n\n    if (!path) {\n      throw new errors.RequiredParameterError('Path argument is required!');\n    }\n\n    if (!repoOptions) {\n      throw new errors.RequiredParameterError('repoOptions argument is required!');\n    }\n\n    if (!toVersion) {\n      throw new errors.RequiredParameterError('toVersion argument is required!');\n    }\n\n    if (!Number.isInteger(toVersion) || toVersion <= 0) {\n      throw new errors.InvalidValueError('Version has to be positive integer!');\n    } // make sure we can read pre-level@5 datastores\n\n\n    backends = wrapBackends(backends);\n    const currentVersion = yield repoVersion.getVersion(backends);\n\n    if (currentVersion === toVersion) {\n      log('Nothing to migrate.');\n      return;\n    }\n\n    if (currentVersion > toVersion) {\n      throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);\n    }\n\n    verifyAvailableMigrations(migrations, currentVersion, toVersion);\n    let lock;\n\n    if (!isDryRun && !ignoreLock) {\n      lock = yield repoOptions.repoLock.lock(path);\n    }\n\n    try {\n      for (const migration of migrations) {\n        if (toVersion !== undefined && migration.version > toVersion) {\n          break;\n        }\n\n        if (migration.version <= currentVersion) {\n          continue;\n        }\n\n        log(`Migrating version ${migration.version}`);\n\n        try {\n          if (!isDryRun) {\n            /** @type {MigrationProgressCallback} */\n            let progressCallback = () => {};\n\n            if (onProgress) {\n              // eslint-disable-line max-depth\n              progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n            }\n\n            yield migration.migrate(backends, progressCallback);\n          }\n        } catch (e) {\n          const lastSuccessfullyMigratedVersion = migration.version - 1;\n          log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);\n          yield repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends);\n          throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`);\n        }\n\n        log(`Migrating to version ${migration.version} finished`);\n      }\n\n      if (!isDryRun) {\n        yield repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);\n      }\n\n      log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!');\n    } finally {\n      if (!isDryRun && !ignoreLock && lock) {\n        yield lock.close();\n      }\n    }\n  });\n  return _migrate.apply(this, arguments);\n}\n\nfunction revert(_x6, _x7, _x8, _x9, _x10) {\n  return _revert.apply(this, arguments);\n}\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\n\n\nfunction _revert() {\n  _revert = _asyncToGenerator(function* (path, backends, repoOptions, toVersion, {\n    ignoreLock = false,\n    onProgress,\n    isDryRun = false,\n    migrations\n  }) {\n    migrations = migrations || defaultMigrations;\n\n    if (!path) {\n      throw new errors.RequiredParameterError('Path argument is required!');\n    }\n\n    if (!repoOptions) {\n      throw new errors.RequiredParameterError('repoOptions argument is required!');\n    }\n\n    if (!toVersion) {\n      throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n    }\n\n    if (!Number.isInteger(toVersion) || toVersion <= 0) {\n      throw new errors.InvalidValueError('Version has to be positive integer!');\n    } // make sure we can read pre-level@5 datastores\n\n\n    backends = wrapBackends(backends);\n    const currentVersion = yield repoVersion.getVersion(backends);\n\n    if (currentVersion === toVersion) {\n      log('Nothing to revert.');\n      return;\n    }\n\n    if (currentVersion < toVersion) {\n      throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);\n    }\n\n    verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n    let lock;\n\n    if (!isDryRun && !ignoreLock) {\n      lock = yield repoOptions.repoLock.lock(path);\n    }\n\n    log(`Reverting from version ${currentVersion} to ${toVersion}`);\n\n    try {\n      const reversedMigrationArray = migrations.slice().reverse();\n\n      for (const migration of reversedMigrationArray) {\n        if (migration.version <= toVersion) {\n          break;\n        }\n\n        if (migration.version > currentVersion) {\n          continue;\n        }\n\n        log(`Reverting migration version ${migration.version}`);\n\n        try {\n          if (!isDryRun) {\n            /** @type {MigrationProgressCallback} */\n            let progressCallback = () => {};\n\n            if (onProgress) {\n              // eslint-disable-line max-depth\n              progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n            }\n\n            yield migration.revert(backends, progressCallback);\n          }\n        } catch (e) {\n          const lastSuccessfullyRevertedVersion = migration.version;\n          log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);\n          yield repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends);\n          e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`;\n          throw e;\n        }\n\n        log(`Reverting to version ${migration.version} finished`);\n      }\n\n      if (!isDryRun) {\n        yield repoVersion.setVersion(toVersion, backends);\n      }\n\n      log(`All migrations successfully reverted to version ${toVersion}!`);\n    } finally {\n      if (!isDryRun && !ignoreLock && lock) {\n        yield lock.close();\n      }\n    }\n  });\n  return _revert.apply(this, arguments);\n}\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0;\n\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break;\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`);\n      }\n\n      migrationCounter++;\n    }\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);\n  }\n}\n\nmodule.exports = {\n  getCurrentRepoVersion: repoVersion.getVersion,\n  getLatestMigrationVersion,\n  errors,\n  migrate,\n  revert\n};","map":null,"metadata":{},"sourceType":"script"}