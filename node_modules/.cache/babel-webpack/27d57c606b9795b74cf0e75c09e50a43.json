{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errCode = require('err-code');\n\nconst log = require('debug')('ipfs:mfs:mkdir');\n\nconst {\n  exporter\n} = require('ipfs-unixfs-exporter');\n\nconst createNode = require('./utils/create-node');\n\nconst toPathComponents = require('./utils/to-path-components');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst updateTree = require('./utils/update-tree');\n\nconst addLink = require('./utils/add-link');\n\nconst withMfsRoot = require('./utils/with-mfs-root');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"mkdir\"]}\n   */\n  function mfsMkdir(_x) {\n    return _mfsMkdir.apply(this, arguments);\n  }\n\n  function _mfsMkdir() {\n    _mfsMkdir = _asyncToGenerator(function* (path, options = {}) {\n      /** @type {DefaultOptions} */\n      const opts = mergeOptions(defaultOptions, options);\n\n      if (!path) {\n        throw new Error('no path given to Mkdir');\n      }\n\n      path = path.trim();\n\n      if (path === '/') {\n        if (opts.parents) {\n          return;\n        }\n\n        throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n      }\n\n      if (path.substring(0, 1) !== '/') {\n        throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n      }\n\n      log(`Creating ${path}`);\n      const pathComponents = toPathComponents(path);\n\n      if (pathComponents[0] === 'ipfs') {\n        throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n      }\n\n      const root = yield withMfsRoot(context, opts);\n      let parent;\n      const trail = [];\n      const emptyDir = yield createNode(context, 'directory', opts); // make sure the containing folder exists, creating it if necessary\n\n      for (let i = 0; i <= pathComponents.length; i++) {\n        const subPathComponents = pathComponents.slice(0, i);\n        const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`;\n\n        try {\n          parent = yield exporter(subPath, context.repo.blocks);\n\n          if (parent.type !== 'file' && parent.type !== 'directory') {\n            throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n          }\n\n          if (i === pathComponents.length) {\n            if (opts.parents) {\n              return;\n            }\n\n            throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n          }\n\n          trail.push({\n            name: parent.name,\n            cid: parent.cid\n          });\n        } catch (err) {\n          if (err.code === 'ERR_NOT_FOUND') {\n            if (i < pathComponents.length && !opts.parents) {\n              throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n            } // add the intermediate directory\n\n\n            yield addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n          } else {\n            throw err;\n          }\n        }\n      } // add an empty dir to the last path component\n      // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n      // update the tree from the leaf to the root\n\n\n      const newRootCid = yield updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n      yield updateMfsRoot(context, newRootCid, opts);\n    });\n    return _mfsMkdir.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsMkdir);\n};\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\n\n\nconst addEmptyDir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (context, childName, emptyDir, parent, trail, options) {\n    log(`Adding empty dir called ${childName} to ${parent.cid}`);\n    const result = yield addLink(context, {\n      parent: parent.node,\n      parentCid: parent.cid,\n      // TODO vmx 2021-03-09: Remove the usage of size completely\n      size: 0,\n      cid: emptyDir.cid,\n      name: childName,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold\n    });\n    trail[trail.length - 1].cid = result.cid;\n    trail.push({\n      name: childName,\n      cid: emptyDir.cid\n    });\n  });\n\n  return function addEmptyDir(_x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}