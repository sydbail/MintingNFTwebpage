{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package hmac implements HMAC algorithm.\n */\n\nvar hash_1 = require(\"@stablelib/hash\");\n\nvar constant_time_1 = require(\"@stablelib/constant-time\");\n\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\n\n\nvar HMAC = function () {\n  /**\n   * Constructs a new HMAC with the given Hash and secret key.\n   */\n  function HMAC(hash, key) {\n    this._finished = false; // true if HMAC was finalized\n    // Initialize inner and outer hashes.\n\n    this._inner = new hash();\n    this._outer = new hash(); // Set block and digest sizes for this HMAC\n    // instance to values from the hash.\n\n    this.blockSize = this._outer.blockSize;\n    this.digestLength = this._outer.digestLength; // Pad temporary stores a key (or its hash) padded with zeroes.\n\n    var pad = new Uint8Array(this.blockSize);\n\n    if (key.length > this.blockSize) {\n      // If key is bigger than hash block size, it must be\n      // hashed and this hash is used as a key instead.\n      this._inner.update(key).finish(pad).clean();\n    } else {\n      // Otherwise, copy the key into pad.\n      pad.set(key);\n    } // Now two different keys are derived from padded key\n    // by xoring a different byte value to each.\n    // To make inner hash key, xor byte 0x36 into pad.\n\n\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36;\n    } // Update inner hash with the result.\n\n\n    this._inner.update(pad); // To make outer hash key, xor byte 0x5c into pad.\n    // But since we already xored 0x36 there, we must\n    // first undo this by xoring it again.\n\n\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36 ^ 0x5c;\n    } // Update outer hash with the result.\n\n\n    this._outer.update(pad); // Save states of both hashes, so that we can quickly restore\n    // them later in reset() without the need to remember the actual\n    // key and perform this initialization again.\n\n\n    if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n      this._innerKeyedState = this._inner.saveState();\n      this._outerKeyedState = this._outer.saveState();\n    } // Clean pad.\n\n\n    wipe_1.wipe(pad);\n  }\n  /**\n   * Returns HMAC state to the state initialized with key\n   * to make it possible to run HMAC over the other data with the same\n   * key without creating a new instance.\n   */\n\n\n  HMAC.prototype.reset = function () {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n    } // Restore keyed states of inner and outer hashes.\n\n\n    this._inner.restoreState(this._innerKeyedState);\n\n    this._outer.restoreState(this._outerKeyedState);\n\n    this._finished = false;\n    return this;\n  };\n  /**\n   * Cleans HMAC state.\n   */\n\n\n  HMAC.prototype.clean = function () {\n    if (hash_1.isSerializableHash(this._inner)) {\n      this._inner.cleanSavedState(this._innerKeyedState);\n    }\n\n    if (hash_1.isSerializableHash(this._outer)) {\n      this._outer.cleanSavedState(this._outerKeyedState);\n    }\n\n    this._inner.clean();\n\n    this._outer.clean();\n  };\n  /**\n   * Updates state with provided data.\n   */\n\n\n  HMAC.prototype.update = function (data) {\n    this._inner.update(data);\n\n    return this;\n  };\n  /**\n   * Finalizes HMAC and puts the result in out.\n   */\n\n\n  HMAC.prototype.finish = function (out) {\n    if (this._finished) {\n      // If HMAC was finalized, outer hash is also finalized,\n      // so it produces the same digest it produced when it\n      // was finalized.\n      this._outer.finish(out);\n\n      return this;\n    } // Finalize inner hash and store the result temporarily.\n\n\n    this._inner.finish(out); // Update outer hash with digest of inner hash and and finalize it.\n\n\n    this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n\n    this._finished = true;\n    return this;\n  };\n  /**\n   * Returns the computed message authentication code.\n   */\n\n\n  HMAC.prototype.digest = function () {\n    var out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  };\n  /**\n   * Saves HMAC state.\n   * This function is needed for PBKDF2 optimization.\n   */\n\n\n  HMAC.prototype.saveState = function () {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n    }\n\n    return this._inner.saveState();\n  };\n\n  HMAC.prototype.restoreState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n    }\n\n    this._inner.restoreState(savedState);\n\n    this._outer.restoreState(this._outerKeyedState);\n\n    this._finished = false;\n    return this;\n  };\n\n  HMAC.prototype.cleanSavedState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n    }\n\n    this._inner.cleanSavedState(savedState);\n  };\n\n  return HMAC;\n}();\n\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\n\nfunction hmac(hash, key, data) {\n  var h = new HMAC(hash, key);\n  h.update(data);\n  var digest = h.digest();\n  h.clean();\n  return digest;\n}\n\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\n\nexports.equal = constant_time_1.equal; //# sourceMappingURL=hmac.js.map","map":null,"metadata":{},"sourceType":"script"}