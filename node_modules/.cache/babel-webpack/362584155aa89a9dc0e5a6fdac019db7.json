{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IKHandshake = void 0;\n\nconst ik_1 = require(\"./handshakes/ik\");\n\nconst buffer_1 = require(\"buffer\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst logger_1 = require(\"./logger\");\n\nclass IKHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = buffer_1.Buffer.from(payload);\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n  }\n\n  stage0() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      logger_1.logLocalStaticKeys(_this.session.hs.s);\n      logger_1.logRemoteStaticKey(_this.session.hs.rs);\n\n      if (_this.isInitiator) {\n        logger_1.logger('IK Stage 0 - Initiator sending message...');\n\n        const messageBuffer = _this.ik.sendMessage(_this.session, _this.payload);\n\n        _this.connection.writeLP(encoder_1.encode1(messageBuffer));\n\n        logger_1.logger('IK Stage 0 - Initiator sent message.');\n        logger_1.logLocalEphemeralKeys(_this.session.hs.e);\n      } else {\n        logger_1.logger('IK Stage 0 - Responder receiving message...');\n        const receivedMsg = yield _this.connection.readLP();\n\n        try {\n          const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());\n\n          const {\n            plaintext,\n            valid\n          } = _this.ik.recvMessage(_this.session, receivedMessageBuffer);\n\n          if (!valid) {\n            throw new Error('ik handshake stage 0 decryption validation fail');\n          }\n\n          logger_1.logger('IK Stage 0 - Responder got message, going to verify payload.');\n          const decodedPayload = yield utils_1.decodePayload(plaintext);\n          _this.remotePeer = _this.remotePeer || (yield utils_1.getPeerIdFromPayload(decodedPayload));\n          yield utils_1.verifySignedPayload(_this.session.hs.rs, decodedPayload, _this.remotePeer);\n\n          _this.setRemoteEarlyData(decodedPayload.data);\n\n          logger_1.logger('IK Stage 0 - Responder successfully verified payload!');\n          logger_1.logRemoteEphemeralKey(_this.session.hs.re);\n        } catch (e) {\n          const err = e;\n          logger_1.logger('Responder breaking up with IK handshake in stage 0.');\n          throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);\n        }\n      }\n    })();\n  }\n\n  stage1() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isInitiator) {\n        logger_1.logger('IK Stage 1 - Initiator receiving message...');\n        const receivedMsg = (yield _this2.connection.readLP()).slice();\n        const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));\n\n        const {\n          plaintext,\n          valid\n        } = _this2.ik.recvMessage(_this2.session, receivedMessageBuffer);\n\n        logger_1.logger('IK Stage 1 - Initiator got message, going to verify payload.');\n\n        try {\n          if (!valid) {\n            throw new Error('ik stage 1 decryption validation fail');\n          }\n\n          const decodedPayload = yield utils_1.decodePayload(plaintext);\n          _this2.remotePeer = _this2.remotePeer || (yield utils_1.getPeerIdFromPayload(decodedPayload));\n          yield utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, _this2.remotePeer);\n\n          _this2.setRemoteEarlyData(decodedPayload.data);\n\n          logger_1.logger('IK Stage 1 - Initiator successfully verified payload!');\n          logger_1.logRemoteEphemeralKey(_this2.session.hs.re);\n        } catch (e) {\n          const err = e;\n          logger_1.logger('Initiator breaking up with IK handshake in stage 1.');\n          throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);\n        }\n      } else {\n        logger_1.logger('IK Stage 1 - Responder sending message...');\n\n        const messageBuffer = _this2.ik.sendMessage(_this2.session, _this2.payload);\n\n        _this2.connection.writeLP(encoder_1.encode0(messageBuffer));\n\n        logger_1.logger('IK Stage 1 - Responder sent message...');\n        logger_1.logLocalEphemeralKeys(_this2.session.hs.e);\n      }\n\n      logger_1.logCipherState(_this2.session);\n    })();\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n  }\n\n  getLocalEphemeralKeys() {\n    if (!this.session.hs.e) {\n      throw new Error('Ephemeral keys do not exist.');\n    }\n\n    return this.session.hs.e;\n  }\n\n  getCS(session, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}\n\nexports.IKHandshake = IKHandshake;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@chainsafe/libp2p-noise/dist/src/handshake-ik.js"],"names":["Object","defineProperty","exports","value","IKHandshake","ik_1","require","buffer_1","encoder_1","utils_1","errors_1","logger_1","constructor","isInitiator","payload","prologue","staticKeypair","connection","remoteStaticKey","remotePeer","handshake","Buffer","from","ik","IK","session","initSession","remoteEarlyData","alloc","stage0","logLocalStaticKeys","hs","s","logRemoteStaticKey","rs","logger","messageBuffer","sendMessage","writeLP","encode1","logLocalEphemeralKeys","e","receivedMsg","readLP","receivedMessageBuffer","decode1","slice","plaintext","valid","recvMessage","Error","decodedPayload","decodePayload","getPeerIdFromPayload","verifySignedPayload","setRemoteEarlyData","data","logRemoteEphemeralKey","re","err","FailedIKError","message","stage1","decode0","ns","encode0","logCipherState","decrypt","ciphertext","cs","getCS","decryptWithAd","encrypt","encryptWithAd","getLocalEphemeralKeys","encryption","cs1","cs2","buffer","byteOffset","length"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IKHandshake = void 0;\nconst ik_1 = require(\"./handshakes/ik\");\nconst buffer_1 = require(\"buffer\");\nconst encoder_1 = require(\"./encoder\");\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst logger_1 = require(\"./logger\");\nclass IKHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n        this.isInitiator = isInitiator;\n        this.payload = buffer_1.Buffer.from(payload);\n        this.prologue = prologue;\n        this.staticKeypair = staticKeypair;\n        this.connection = connection;\n        if (remotePeer) {\n            this.remotePeer = remotePeer;\n        }\n        this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();\n        this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n        this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n    }\n    async stage0() {\n        logger_1.logLocalStaticKeys(this.session.hs.s);\n        logger_1.logRemoteStaticKey(this.session.hs.rs);\n        if (this.isInitiator) {\n            logger_1.logger('IK Stage 0 - Initiator sending message...');\n            const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode1(messageBuffer));\n            logger_1.logger('IK Stage 0 - Initiator sent message.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('IK Stage 0 - Responder receiving message...');\n            const receivedMsg = await this.connection.readLP();\n            try {\n                const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());\n                const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n                if (!valid) {\n                    throw new Error('ik handshake stage 0 decryption validation fail');\n                }\n                logger_1.logger('IK Stage 0 - Responder got message, going to verify payload.');\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n                logger_1.logger('IK Stage 0 - Responder successfully verified payload!');\n                logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            }\n            catch (e) {\n                const err = e;\n                logger_1.logger('Responder breaking up with IK handshake in stage 0.');\n                throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);\n            }\n        }\n    }\n    async stage1() {\n        if (this.isInitiator) {\n            logger_1.logger('IK Stage 1 - Initiator receiving message...');\n            const receivedMsg = (await this.connection.readLP()).slice();\n            const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));\n            const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n            logger_1.logger('IK Stage 1 - Initiator got message, going to verify payload.');\n            try {\n                if (!valid) {\n                    throw new Error('ik stage 1 decryption validation fail');\n                }\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n                logger_1.logger('IK Stage 1 - Initiator successfully verified payload!');\n                logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            }\n            catch (e) {\n                const err = e;\n                logger_1.logger('Initiator breaking up with IK handshake in stage 1.');\n                throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);\n            }\n        }\n        else {\n            logger_1.logger('IK Stage 1 - Responder sending message...');\n            const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode0(messageBuffer));\n            logger_1.logger('IK Stage 1 - Responder sent message...');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        logger_1.logCipherState(this.session);\n    }\n    decrypt(ciphertext, session) {\n        const cs = this.getCS(session, false);\n        return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n    }\n    encrypt(plaintext, session) {\n        const cs = this.getCS(session);\n        return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n    }\n    getLocalEphemeralKeys() {\n        if (!this.session.hs.e) {\n            throw new Error('Ephemeral keys do not exist.');\n        }\n        return this.session.hs.e;\n    }\n    getCS(session, encryption = true) {\n        if (!session.cs1 || !session.cs2) {\n            throw new Error('Handshake not completed properly, cipher state does not exist.');\n        }\n        if (this.isInitiator) {\n            return encryption ? session.cs1 : session.cs2;\n        }\n        else {\n            return encryption ? session.cs2 : session.cs1;\n        }\n    }\n    setRemoteEarlyData(data) {\n        if (data) {\n            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n        }\n    }\n}\nexports.IKHandshake = IKHandshake;\n"]},"metadata":{},"sourceType":"script"}