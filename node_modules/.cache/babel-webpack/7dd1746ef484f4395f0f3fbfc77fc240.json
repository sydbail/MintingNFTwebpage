{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst PeerId = require('peer-id');\n\nconst errCode = require('err-code');\n\nconst {\n  NotEnabledError\n} = require('../errors');\n\nconst get = require('dlv');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = ({\n  network,\n  repo\n}) => {\n  const {\n    get,\n    put,\n    findProvs,\n    findPeer,\n    provide,\n    query\n  } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"get\"]}\n     */\n    get(key, options = {}) {\n      return _asyncToGenerator(function* () {\n        const {\n          libp2p\n        } = yield use(network, options);\n        return libp2p._dht.get(key, options);\n      })();\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"put\"]}\n     */\n    put(key, value, options) {\n      return _wrapAsyncGenerator(function* () {\n        const {\n          libp2p\n        } = yield _awaitAsyncGenerator(use(network, options));\n        yield* _asyncGeneratorDelegate(_asyncIterator(libp2p._dht.put(key, value)), _awaitAsyncGenerator);\n      })();\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findProvs\"]}\n     */\n    findProvs(cid, options = {\n      numProviders: 20\n    }) {\n      return _wrapAsyncGenerator(function* () {\n        const {\n          libp2p\n        } = yield _awaitAsyncGenerator(use(network, options));\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(libp2p._dht.findProviders(cid, {\n            maxNumProviders: options.numProviders,\n            signal: options.signal\n          })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const peer = _value;\n            yield {\n              id: peer.id.toB58String(),\n              addrs: peer.addrs\n            };\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      })();\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findPeer\"]}\n     */\n    findPeer(peerId, options) {\n      return _asyncToGenerator(function* () {\n        const {\n          libp2p\n        } = yield use(network, options);\n        const peer = yield libp2p._dht.findPeer(PeerId.parse(peerId));\n        return {\n          id: peer.id.toB58String(),\n          addrs: peer.multiaddrs\n        };\n      })();\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"provide\"]}\n     */\n    provide(cids, options = {\n      recursive: false\n    }) {\n      return _wrapAsyncGenerator(function* () {\n        const {\n          libp2p\n        } = yield _awaitAsyncGenerator(use(network, options));\n        const cidArr = Array.isArray(cids) ? cids : [cids]; // ensure blocks are actually local\n\n        const hasCids = yield _awaitAsyncGenerator(Promise.all(cidArr.map(cid => repo.blocks.has(cid))));\n        const hasAll = hasCids.every(has => has);\n\n        if (!hasAll) {\n          throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n        }\n\n        if (options.recursive) {\n          // TODO: Implement recursive providing\n          throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n        }\n\n        for (const cid of cidArr) {\n          yield libp2p._dht.provide(cid);\n        }\n      })();\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"query\"]}\n     */\n    query(peerId, options) {\n      return _wrapAsyncGenerator(function* () {\n        const {\n          libp2p\n        } = yield _awaitAsyncGenerator(use(network, options));\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n\n        var _iteratorError2;\n\n        try {\n          for (var _iterator2 = _asyncIterator(libp2p._dht.getClosestPeers(PeerId.parse(peerId).toBytes())), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n            const closerPeerId = _value2;\n            yield {\n              id: closerPeerId.toB58String(),\n              addrs: [] // TODO: get addrs?\n\n            };\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              yield _awaitAsyncGenerator(_iterator2.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      })();\n    }\n\n  };\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  };\n};\n/**\n * @param {import('../types').NetworkService} network\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\n\n\nconst use = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (network, options) {\n    const net = yield network.use(options);\n\n    if (get(net.libp2p, '_config.dht.enabled', false)) {\n      return net;\n    } else {\n      throw new NotEnabledError('dht not enabled');\n    }\n  });\n\n  return function use(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/components/dht.js"],"names":["PeerId","require","errCode","NotEnabledError","get","withTimeoutOption","module","exports","network","repo","put","findProvs","findPeer","provide","query","key","options","libp2p","use","_dht","value","cid","numProviders","findProviders","maxNumProviders","signal","peer","id","toB58String","addrs","peerId","parse","multiaddrs","cids","recursive","cidArr","Array","isArray","hasCids","Promise","all","map","blocks","has","hasAll","every","Error","getClosestPeers","toBytes","closerPeerId","net"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst errCode = require('err-code')\nconst { NotEnabledError } = require('../errors')\nconst get = require('dlv')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ network, repo }) => {\n  const { get, put, findProvs, findPeer, provide, query } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"get\"]}\n     */\n    async get (key, options = {}) {\n      const { libp2p } = await use(network, options)\n      return libp2p._dht.get(key, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"put\"]}\n     */\n    async * put (key, value, options) {\n      const { libp2p } = await use(network, options)\n      yield * libp2p._dht.put(key, value)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findProvs\"]}\n     */\n    async * findProvs (cid, options = { numProviders: 20 }) {\n      const { libp2p } = await use(network, options)\n\n      for await (const peer of libp2p._dht.findProviders(cid, {\n        maxNumProviders: options.numProviders,\n        signal: options.signal\n      })) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        }\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findPeer\"]}\n     */\n    async findPeer (peerId, options) {\n      const { libp2p } = await use(network, options)\n      const peer = await libp2p._dht.findPeer(PeerId.parse(peerId))\n\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.multiaddrs\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"provide\"]}\n     */\n    async * provide (cids, options = { recursive: false }) {\n      const { libp2p } = await use(network, options)\n      const cidArr = Array.isArray(cids) ? cids : [cids]\n\n      // ensure blocks are actually local\n      const hasCids = await Promise.all(cidArr.map(cid => repo.blocks.has(cid)))\n      const hasAll = hasCids.every(has => has)\n\n      if (!hasAll) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET')\n      }\n\n      for (const cid of cidArr) {\n        yield libp2p._dht.provide(cid)\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"query\"]}\n     */\n    async * query (peerId, options) {\n      const { libp2p } = await use(network, options)\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(PeerId.parse(peerId).toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n        }\n      }\n    }\n  }\n\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  }\n}\n\n/**\n * @param {import('../types').NetworkService} network\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nconst use = async (network, options) => {\n  const net = await network.use(options)\n  if (get(net.libp2p, '_config.dht.enabled', false)) {\n    return net\n  } else {\n    throw new NotEnabledError('dht not enabled')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}