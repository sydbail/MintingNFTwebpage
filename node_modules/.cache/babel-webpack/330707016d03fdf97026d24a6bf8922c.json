{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst errcode = require('err-code');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nrequire('node-forge/lib/sha512');\n\nrequire('node-forge/lib/ed25519');\n\nconst forge = require('node-forge/lib/forge');\n\nconst crypto = require('./rsa');\n\nconst pbm = require('./keys');\n\nconst exporter = require('./exporter');\n\nclass RsaPublicKey {\n  constructor(key) {\n    this._key = key;\n  }\n\n  verify(data, sig) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      return crypto.hashAndVerify(_this._key, sig, data);\n    })();\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  encrypt(bytes) {\n    return crypto.encrypt(this._key, bytes);\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  hash() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        bytes\n      } = yield sha256.digest(_this2.bytes);\n      return bytes;\n    })();\n  }\n\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  genSecret() {\n    return crypto.getRandomValues(16);\n  }\n\n  sign(message) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      return crypto.hashAndSign(_this3._key, message);\n    })();\n  }\n\n  get public() {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED');\n    }\n\n    return new RsaPublicKey(this._publicKey);\n  }\n\n  decrypt(bytes) {\n    return crypto.decrypt(this._key, bytes);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  hash() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        bytes\n      } = yield sha256.digest(_this4.bytes);\n      return bytes;\n    })();\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  id() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const hash = yield _this5.public.hash();\n      return uint8ArrayToString(hash, 'base58btc');\n    })();\n  }\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n\n\n  export(password, format = 'pkcs-8') {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (format === 'pkcs-8') {\n        const buffer = new forge.util.ByteBuffer(_this6.marshal());\n        const asn1 = forge.asn1.fromDer(buffer);\n        const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n        const options = {\n          algorithm: 'aes256',\n          count: 10000,\n          saltSize: 128 / 8,\n          prfAlgorithm: 'sha512'\n        };\n        return forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n      } else if (format === 'libp2p-key') {\n        return exporter.export(_this6.bytes, password);\n      } else {\n        throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n      }\n    })();\n  }\n\n}\n\nfunction unmarshalRsaPrivateKey(_x) {\n  return _unmarshalRsaPrivateKey.apply(this, arguments);\n}\n\nfunction _unmarshalRsaPrivateKey() {\n  _unmarshalRsaPrivateKey = _asyncToGenerator(function* (bytes) {\n    const jwk = crypto.utils.pkcs1ToJwk(bytes);\n    const keys = yield crypto.unmarshalPrivateKey(jwk);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n  });\n  return _unmarshalRsaPrivateKey.apply(this, arguments);\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nfunction fromJwk(_x2) {\n  return _fromJwk.apply(this, arguments);\n}\n\nfunction _fromJwk() {\n  _fromJwk = _asyncToGenerator(function* (jwk) {\n    const keys = yield crypto.unmarshalPrivateKey(jwk);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n  });\n  return _fromJwk.apply(this, arguments);\n}\n\nfunction generateKeyPair(_x3) {\n  return _generateKeyPair.apply(this, arguments);\n}\n\nfunction _generateKeyPair() {\n  _generateKeyPair = _asyncToGenerator(function* (bits) {\n    const keys = yield crypto.generateKey(bits);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n  });\n  return _generateKeyPair.apply(this, arguments);\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"names":["sha256","require","errcode","equals","uint8ArrayEquals","toString","uint8ArrayToString","forge","crypto","pbm","exporter","RsaPublicKey","constructor","key","_key","verify","data","sig","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","finish","encrypt","hash","digest","RsaPrivateKey","publicKey","_publicKey","genSecret","getRandomValues","sign","message","hashAndSign","public","Error","decrypt","jwkToPkcs1","PrivateKey","id","export","password","format","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","keys","unmarshalPrivateKey","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nrequire('node-forge/lib/sha512')\nrequire('node-forge/lib/ed25519')\nconst forge = require('node-forge/lib/forge')\n\nconst crypto = require('./rsa')\nconst pbm = require('./keys')\nconst exporter = require('./exporter')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  encrypt (bytes) {\n    return crypto.encrypt(this._key, bytes)\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(16)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes) {\n    return crypto.decrypt(this._key, bytes)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n  async export (password, format = 'pkcs-8') { // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal())\n      const asn1 = forge.asn1.fromDer(buffer)\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      }\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n    } else if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nasync function unmarshalRsaPrivateKey (bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n  return new RsaPublicKey(jwk)\n}\n\nasync function fromJwk (jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nasync function generateKeyPair (bits) {\n  const keys = await crypto.generateKey(bits)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"]},"metadata":{},"sourceType":"script"}