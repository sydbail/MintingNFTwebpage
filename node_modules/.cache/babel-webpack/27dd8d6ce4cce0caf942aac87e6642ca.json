{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Property = void 0;\n\nconst PreconditionFailure_1 = require(\"../precondition/PreconditionFailure\");\n\nconst IRawProperty_1 = require(\"./IRawProperty\");\n\nconst GlobalParameters_1 = require(\"../runner/configuration/GlobalParameters\");\n\nconst ConverterFromNext_1 = require(\"../arbitrary/definition/ConverterFromNext\");\n\nclass Property {\n  constructor(arb, predicate) {\n    this.arb = arb;\n    this.predicate = predicate;\n\n    this.isAsync = () => false;\n\n    const {\n      beforeEach = Property.dummyHook,\n      afterEach = Property.dummyHook,\n      asyncBeforeEach,\n      asyncAfterEach\n    } = GlobalParameters_1.readConfigureGlobal() || {};\n\n    if (asyncBeforeEach !== undefined) {\n      throw Error('\"asyncBeforeEach\" can\\'t be set when running synchronous properties');\n    }\n\n    if (asyncAfterEach !== undefined) {\n      throw Error('\"asyncAfterEach\" can\\'t be set when running synchronous properties');\n    }\n\n    this.beforeEachHook = beforeEach;\n    this.afterEachHook = afterEach;\n  }\n\n  generate(mrng, runId) {\n    if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(this.arb)) {\n      return this.arb.toShrinkable(this.arb.arb.generate(mrng, runId != null ? IRawProperty_1.runIdToFrequency(runId) : undefined));\n    }\n\n    return runId != null ? this.arb.withBias(IRawProperty_1.runIdToFrequency(runId)).generate(mrng) : this.arb.generate(mrng);\n  }\n\n  run(v) {\n    this.beforeEachHook();\n\n    try {\n      const output = this.predicate(v);\n      return output == null || output === true ? null : 'Property failed by returning false';\n    } catch (err) {\n      if (PreconditionFailure_1.PreconditionFailure.isFailure(err)) return err;\n      if (err instanceof Error && err.stack) return `${err}\\n\\nStack trace: ${err.stack}`;\n      return `${err}`;\n    } finally {\n      this.afterEachHook();\n    }\n  }\n\n  beforeEach(hookFunction) {\n    const previousBeforeEachHook = this.beforeEachHook;\n\n    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);\n\n    return this;\n  }\n\n  afterEach(hookFunction) {\n    const previousAfterEachHook = this.afterEachHook;\n\n    this.afterEachHook = () => hookFunction(previousAfterEachHook);\n\n    return this;\n  }\n\n}\n\nexports.Property = Property;\n\nProperty.dummyHook = () => {};","map":null,"metadata":{},"sourceType":"script"}