{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst filter = require('it-filter');\n\nconst pushable = require('it-pushable');\n\nconst drain = require('it-drain');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n *\n * @param {Blockstore} blockstore\n */\n\n\nmodule.exports = createIdStore;\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\n\nfunction createIdStore(store) {\n  return {\n    open() {\n      return store.open();\n    },\n\n    close() {\n      return store.close();\n    },\n\n    query(query, options) {\n      return store.query(query, options);\n    },\n\n    queryKeys(query, options) {\n      return store.queryKeys(query, options);\n    },\n\n    get(cid, options) {\n      return _asyncToGenerator(function* () {\n        const extracted = extractContents(cid);\n\n        if (extracted.isIdentity) {\n          return Promise.resolve(extracted.digest);\n        }\n\n        return store.get(cid, options);\n      })();\n    },\n\n    getMany(cids, options) {\n      var _this = this;\n\n      return _wrapAsyncGenerator(function* () {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(cids), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const cid = _value;\n            yield _this.get(cid, options);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      })();\n    },\n\n    put(cid, buf, options) {\n      return _asyncToGenerator(function* () {\n        const {\n          isIdentity\n        } = extractContents(cid);\n\n        if (isIdentity) {\n          return;\n        }\n\n        yield store.put(cid, buf, options);\n      })();\n    },\n\n    putMany(pairs, options) {\n      return _wrapAsyncGenerator(function* () {\n        // in order to return all blocks. we're going to assemble a seperate iterable\n        // return rather than return the resolves of store.putMany using the same\n        // process used by blockstore.putMany\n        const output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n        // event loop iteration so is slower. Use process.nextTick if it is available.\n\n        const runner = process && process.nextTick ? process.nextTick : setImmediate;\n        runner( /*#__PURE__*/_asyncToGenerator(function* () {\n          try {\n            yield drain(store.putMany(_wrapAsyncGenerator(function* () {\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n\n              var _iteratorError2;\n\n              try {\n                for (var _iterator2 = _asyncIterator(pairs), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n                  const {\n                    key,\n                    value\n                  } = _value2;\n\n                  if (!extractContents(key).isIdentity) {\n                    yield {\n                      key,\n                      value\n                    };\n                  } // if non identity blocks successfully write, blocks are included in output\n\n\n                  output.push({\n                    key,\n                    value\n                  });\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    yield _awaitAsyncGenerator(_iterator2.return());\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            })()));\n            output.end();\n          } catch (err) {\n            output.end(err);\n          }\n        }));\n        yield* _asyncGeneratorDelegate(_asyncIterator(output), _awaitAsyncGenerator);\n      })();\n    },\n\n    has(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve(true);\n      }\n\n      return store.has(cid, options);\n    },\n\n    delete(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve();\n      }\n\n      return store.delete(cid, options);\n    },\n\n    deleteMany(cids, options) {\n      return store.deleteMany(filter(cids, cid => !extractContents(cid).isIdentity), options);\n    },\n\n    batch() {\n      const batch = store.batch();\n      return {\n        put(cid, buf) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.put(cid, buf);\n        },\n\n        delete(cid) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.delete(cid);\n        },\n\n        commit: options => {\n          return batch.commit(options);\n        }\n      };\n    }\n\n  };\n}\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\n\n\nfunction extractContents(k) {\n  const cid = CID.asCID(k);\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    };\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  };\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-repo/src/idstore.js"],"names":["filter","require","pushable","drain","CID","errCode","identity","module","exports","createIdStore","store","open","close","query","options","queryKeys","get","cid","extracted","extractContents","isIdentity","Promise","resolve","digest","getMany","cids","put","buf","putMany","pairs","output","runner","process","nextTick","setImmediate","key","value","push","end","err","has","delete","deleteMany","batch","commit","k","asCID","Error","multihash","code"],"mappings":"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","sourcesContent":["'use strict'\n\nconst filter = require('it-filter')\nconst pushable = require('it-pushable')\nconst drain = require('it-drain')\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\nconst { identity } = require('multiformats/hashes/identity')\n\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n *\n * @param {Blockstore} blockstore\n */\nmodule.exports = createIdStore\n\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\nfunction createIdStore (store) {\n  return {\n    open () {\n      return store.open()\n    },\n\n    close () {\n      return store.close()\n    },\n\n    query (query, options) {\n      return store.query(query, options)\n    },\n\n    queryKeys (query, options) {\n      return store.queryKeys(query, options)\n    },\n\n    async get (cid, options) {\n      const extracted = extractContents(cid)\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest)\n      }\n      return store.get(cid, options)\n    },\n\n    async * getMany (cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options)\n      }\n    },\n\n    async put (cid, buf, options) {\n      const { isIdentity } = extractContents(cid)\n\n      if (isIdentity) {\n        return\n      }\n\n      await store.put(cid, buf, options)\n    },\n\n    async * putMany (pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable()\n\n      // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n      const runner = process && process.nextTick ? process.nextTick : setImmediate\n\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function * () {\n            for await (const { key, value } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield { key, value }\n              }\n\n              // if non identity blocks successfully write, blocks are included in output\n              output.push({ key, value })\n            }\n          }()))\n\n          output.end()\n        } catch (err) {\n          output.end(err)\n        }\n      })\n\n      yield * output\n    },\n\n    has (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve(true)\n      }\n      return store.has(cid, options)\n    },\n\n    delete (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve()\n      }\n      return store.delete(cid, options)\n    },\n\n    deleteMany (cids, options) {\n      return store.deleteMany(filter(cids, (cid) => !extractContents(cid).isIdentity), options)\n    },\n\n    batch () {\n      const batch = store.batch()\n\n      return {\n        put (cid, buf) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.put(cid, buf)\n        },\n        delete (cid) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.delete(cid)\n        },\n        commit: (options) => {\n          return batch.commit(options)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\nfunction extractContents (k) {\n  const cid = CID.asCID(k)\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    }\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  }\n}\n"]},"metadata":{},"sourceType":"script"}