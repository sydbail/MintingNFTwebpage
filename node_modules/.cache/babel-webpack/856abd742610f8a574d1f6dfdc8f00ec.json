{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errcode = require('err-code');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst hmac = require('../hmac');\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}; // Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (cipherType, hash, secret) {\n    const cipher = cipherMap[cipherType];\n\n    if (!cipher) {\n      const allowed = Object.keys(cipherMap).join(' / ');\n      throw errcode(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), 'ERR_INVALID_CIPHER_TYPE');\n    }\n\n    if (!hash) {\n      throw errcode(new Error('missing hash type'), 'ERR_MISSING_HASH_TYPE');\n    }\n\n    const cipherKeySize = cipher.keySize;\n    const ivSize = cipher.ivSize;\n    const hmacKeySize = 20;\n    const seed = uint8ArrayFromString('key expansion');\n    const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n    const m = yield hmac.create(hash, secret);\n    let a = yield m.digest(seed);\n    const result = [];\n    let j = 0;\n\n    while (j < resultLength) {\n      const b = yield m.digest(uint8ArrayConcat([a, seed]));\n      let todo = b.length;\n\n      if (j + todo > resultLength) {\n        todo = resultLength - j;\n      }\n\n      result.push(b);\n      j += todo;\n      a = yield m.digest(a);\n    }\n\n    const half = resultLength / 2;\n    const resultBuffer = uint8ArrayConcat(result);\n    const r1 = resultBuffer.slice(0, half);\n    const r2 = resultBuffer.slice(half, resultLength);\n\n    const createKey = res => ({\n      iv: res.slice(0, ivSize),\n      cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n      macKey: res.slice(ivSize + cipherKeySize)\n    });\n\n    return {\n      k1: createKey(r1),\n      k2: createKey(r2)\n    };\n  });\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}