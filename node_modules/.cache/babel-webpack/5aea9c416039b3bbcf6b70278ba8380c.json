{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst log = require('debug')('ipfs:mfs:touch');\n\nconst errCode = require('err-code');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst toTrail = require('./utils/to-trail');\n\nconst addLink = require('./utils/add-link');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  importer\n} = require('ipfs-unixfs-importer');\n\nconst {\n  recursive\n} = require('ipfs-unixfs-exporter');\n\nconst last = require('it-last');\n\nconst cp = require('./cp');\n\nconst rm = require('./rm');\n\nconst persist = require('./utils/persist');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n/**\n * @param {string} references\n * @param {number} modification\n */\n\n\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\n\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n}\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`);\n  }\n\n  let [, references, operator, mode] = match;\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n\n  return originalMode;\n}\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\n\n\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`;\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      // @ts-ignore freaks out over the curr: number, acc: string thing\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n\n  return mode;\n}\n/**\n * @param {MfsContext} context\n */\n\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"chmod\"]}\n   */\n  function mfsChmod(_x4, _x5) {\n    return _mfsChmod.apply(this, arguments);\n  }\n\n  function _mfsChmod() {\n    _mfsChmod = _asyncToGenerator(function* (path, mode, options = {}) {\n      /** @type {DefaultOptions} */\n      const opts = mergeOptions(defaultOptions, options);\n      log(`Fetching stats for ${path}`);\n      const {\n        cid,\n        mfsDirectory,\n        name\n      } = yield toMfsPath(context, path, opts);\n\n      if (cid.code !== dagPb.code) {\n        throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n      }\n\n      if (opts.recursive) {\n        // recursively export from root CID, change perms of each entry then reimport\n        // but do not reimport files, only manipulate dag-pb nodes\n        const root = yield pipe( /*#__PURE__*/_wrapAsyncGenerator(function* () {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n\n          var _iteratorError;\n\n          try {\n            for (var _iterator = _asyncIterator(recursive(cid, context.repo.blocks)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n              const entry = _value;\n\n              if (entry.type !== 'file' && entry.type !== 'directory') {\n                throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n              }\n\n              entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n              const node = dagPb.prepare({\n                Data: entry.unixfs.marshal(),\n                Links: entry.node.Links\n              });\n              yield {\n                path: entry.path,\n                content: node\n              };\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                yield _awaitAsyncGenerator(_iterator.return());\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }), // @ts-ignore we account for the incompatible source type with our custom dag builder below\n        source => importer(source, context.repo.blocks, { ...opts,\n          pin: false,\n          dagBuilder: function () {\n            var _ref2 = _wrapAsyncGenerator(function* (source, block, opts) {\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n\n              var _iteratorError2;\n\n              try {\n                for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n                  const entry = _value2;\n                  yield /*#__PURE__*/_asyncToGenerator(function* () {\n                    /** @type {PBNode} */\n                    // @ts-ignore - cannot derive type\n                    const node = entry.content;\n                    const buf = dagPb.encode(node);\n                    const cid = yield persist(buf, block, opts);\n\n                    if (!node.Data) {\n                      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n                    }\n\n                    const unixfs = UnixFS.unmarshal(node.Data);\n                    return {\n                      cid,\n                      size: buf.length,\n                      path: entry.path,\n                      unixfs\n                    };\n                  });\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    yield _awaitAsyncGenerator(_iterator2.return());\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            });\n\n            return function dagBuilder(_x, _x2, _x3) {\n              return _ref2.apply(this, arguments);\n            };\n          }()\n        }), nodes => last(nodes));\n\n        if (!root) {\n          throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD');\n        } // remove old path from mfs\n\n\n        yield rm(context)(path, opts); // add newly created tree to mfs at path\n\n        yield cp(context)(`/ipfs/${root.cid}`, path, opts);\n        return;\n      }\n\n      const block = yield context.repo.blocks.get(cid);\n      const node = dagPb.decode(block);\n\n      if (!node.Data) {\n        throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n      }\n\n      const metadata = UnixFS.unmarshal(node.Data);\n      metadata.mode = calculateMode(mode, metadata);\n      const updatedBlock = dagPb.encode({\n        Data: metadata.marshal(),\n        Links: node.Links\n      });\n      const hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n      const hasher = yield context.hashers.getHasher(hashAlg);\n      const hash = yield hasher.digest(updatedBlock);\n      const updatedCid = CID.create(opts.cidVersion, dagPb.code, hash);\n\n      if (opts.flush) {\n        yield context.repo.blocks.put(updatedCid, updatedBlock);\n      }\n\n      const trail = yield toTrail(context, mfsDirectory);\n      const parent = trail[trail.length - 1];\n      const parentCid = CID.decode(parent.cid.bytes);\n      const parentBlock = yield context.repo.blocks.get(parentCid);\n      const parentNode = dagPb.decode(parentBlock);\n      const result = yield addLink(context, {\n        parent: parentNode,\n        name: name,\n        cid: updatedCid,\n        size: updatedBlock.length,\n        flush: opts.flush,\n        // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n        hashAlg,\n        cidVersion: cid.version,\n        shardSplitThreshold: Infinity\n      });\n      parent.cid = result.cid; // update the tree with the new child\n\n      const newRootCid = yield updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n      yield updateMfsRoot(context, newRootCid, opts);\n    });\n    return _mfsChmod.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsChmod);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/components/files/chmod.js"],"names":["mergeOptions","require","bind","ignoreUndefined","toMfsPath","log","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPb","CID","pipe","importer","recursive","last","cp","rm","persist","withTimeoutOption","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","operator","calculateMode","metadata","String","strMode","split","reduce","curr","acc","module","exports","context","mfsChmod","path","options","opts","cid","mfsDirectory","name","code","root","repo","blocks","entry","type","unixfs","node","prepare","Data","marshal","Links","content","source","pin","dagBuilder","block","buf","encode","unmarshal","size","length","nodes","get","decode","updatedBlock","hasher","hashers","getHasher","hash","digest","updatedCid","create","put","trail","parent","parentCid","bytes","parentBlock","parentNode","result","version","Infinity","newRootCid"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst toMfsPath = require('./utils/to-mfs-path')\nconst log = require('debug')('ipfs:mfs:touch')\nconst errCode = require('err-code')\nconst { UnixFS } = require('ipfs-unixfs')\nconst toTrail = require('./utils/to-trail')\nconst addLink = require('./utils/add-link')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst dagPb = require('@ipld/dag-pb')\nconst { CID } = require('multiformats/cid')\nconst { pipe } = require('it-pipe')\nconst { importer } = require('ipfs-unixfs-importer')\nconst { recursive } = require('ipfs-unixfs-exporter')\nconst last = require('it-last')\nconst cp = require('./cp')\nconst rm = require('./rm')\nconst persist = require('./utils/persist')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n}\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    ,\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n\n  return originalMode\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode (mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8)\n    } else {\n      // @ts-ignore freaks out over the curr: number, acc: string thing\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode || 0)\n    }\n  }\n\n  return mode\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"chmod\"]}\n   */\n  async function mfsChmod (path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts)\n\n    if (cid.code !== dagPb.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of recursive(cid, context.repo.blocks)) {\n            if (entry.type !== 'file' && entry.type !== 'directory') {\n              throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n            }\n\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n\n            const node = dagPb.prepare({\n              Data: entry.unixfs.marshal(),\n              Links: entry.node.Links\n            })\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        // @ts-ignore we account for the incompatible source type with our custom dag builder below\n        (source) => importer(source, context.repo.blocks, {\n          ...opts,\n          pin: false,\n          dagBuilder: async function * (source, block, opts) {\n            for await (const entry of source) {\n              yield async function () {\n                /** @type {PBNode} */\n                // @ts-ignore - cannot derive type\n                const node = entry.content\n\n                const buf = dagPb.encode(node)\n                const cid = await persist(buf, block, opts)\n\n                if (!node.Data) {\n                  throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n                }\n\n                const unixfs = UnixFS.unmarshal(node.Data)\n\n                return {\n                  cid,\n                  size: buf.length,\n                  path: entry.path,\n                  unixfs\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD')\n      }\n\n      // remove old path from mfs\n      await rm(context)(path, opts)\n\n      // add newly created tree to mfs at path\n      await cp(context)(`/ipfs/${root.cid}`, path, opts)\n\n      return\n    }\n\n    const block = await context.repo.blocks.get(cid)\n    const node = dagPb.decode(block)\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    const updatedBlock = dagPb.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    })\n\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n    const hash = await hasher.digest(updatedBlock)\n    const updatedCid = CID.create(opts.cidVersion, dagPb.code, hash)\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock)\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = CID.decode(parent.cid.bytes)\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPb.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsChmod)\n}\n"]},"metadata":{},"sourceType":"script"}