{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"ipfs-bitswap\"] || ($protobuf.roots[\"ipfs-bitswap\"] = {});\n\n$root.Message = function () {\n  /**\n   * Properties of a Message.\n   * @exports IMessage\n   * @interface IMessage\n   * @property {Message.IWantlist|null} [wantlist] Message wantlist\n   * @property {Array.<Uint8Array>|null} [blocks] Message blocks\n   * @property {Array.<Message.IBlock>|null} [payload] Message payload\n   * @property {Array.<Message.IBlockPresence>|null} [blockPresences] Message blockPresences\n   * @property {number|null} [pendingBytes] Message pendingBytes\n   */\n\n  /**\n   * Constructs a new Message.\n   * @exports Message\n   * @classdesc Represents a Message.\n   * @implements IMessage\n   * @constructor\n   * @param {IMessage=} [p] Properties to set\n   */\n  function Message(p) {\n    this.blocks = [];\n    this.payload = [];\n    this.blockPresences = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Message wantlist.\n   * @member {Message.IWantlist|null|undefined} wantlist\n   * @memberof Message\n   * @instance\n   */\n\n\n  Message.prototype.wantlist = null;\n  /**\n   * Message blocks.\n   * @member {Array.<Uint8Array>} blocks\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.blocks = $util.emptyArray;\n  /**\n   * Message payload.\n   * @member {Array.<Message.IBlock>} payload\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.payload = $util.emptyArray;\n  /**\n   * Message blockPresences.\n   * @member {Array.<Message.IBlockPresence>} blockPresences\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.blockPresences = $util.emptyArray;\n  /**\n   * Message pendingBytes.\n   * @member {number} pendingBytes\n   * @memberof Message\n   * @instance\n   */\n\n  Message.prototype.pendingBytes = 0;\n  /**\n   * Encodes the specified Message message. Does not implicitly {@link Message.verify|verify} messages.\n   * @function encode\n   * @memberof Message\n   * @static\n   * @param {IMessage} m Message message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Message.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.wantlist != null && Object.hasOwnProperty.call(m, \"wantlist\")) $root.Message.Wantlist.encode(m.wantlist, w.uint32(10).fork()).ldelim();\n\n    if (m.blocks != null && m.blocks.length) {\n      for (var i = 0; i < m.blocks.length; ++i) w.uint32(18).bytes(m.blocks[i]);\n    }\n\n    if (m.payload != null && m.payload.length) {\n      for (var i = 0; i < m.payload.length; ++i) $root.Message.Block.encode(m.payload[i], w.uint32(26).fork()).ldelim();\n    }\n\n    if (m.blockPresences != null && m.blockPresences.length) {\n      for (var i = 0; i < m.blockPresences.length; ++i) $root.Message.BlockPresence.encode(m.blockPresences[i], w.uint32(34).fork()).ldelim();\n    }\n\n    if (m.pendingBytes != null && Object.hasOwnProperty.call(m, \"pendingBytes\")) w.uint32(40).int32(m.pendingBytes);\n    return w;\n  };\n  /**\n   * Decodes a Message message from the specified reader or buffer.\n   * @function decode\n   * @memberof Message\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Message} Message\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Message.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Message();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.wantlist = $root.Message.Wantlist.decode(r, r.uint32());\n          break;\n\n        case 2:\n          if (!(m.blocks && m.blocks.length)) m.blocks = [];\n          m.blocks.push(r.bytes());\n          break;\n\n        case 3:\n          if (!(m.payload && m.payload.length)) m.payload = [];\n          m.payload.push($root.Message.Block.decode(r, r.uint32()));\n          break;\n\n        case 4:\n          if (!(m.blockPresences && m.blockPresences.length)) m.blockPresences = [];\n          m.blockPresences.push($root.Message.BlockPresence.decode(r, r.uint32()));\n          break;\n\n        case 5:\n          m.pendingBytes = r.int32();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a Message message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Message\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Message} Message\n   */\n\n\n  Message.fromObject = function fromObject(d) {\n    if (d instanceof $root.Message) return d;\n    var m = new $root.Message();\n\n    if (d.wantlist != null) {\n      if (typeof d.wantlist !== \"object\") throw TypeError(\".Message.wantlist: object expected\");\n      m.wantlist = $root.Message.Wantlist.fromObject(d.wantlist);\n    }\n\n    if (d.blocks) {\n      if (!Array.isArray(d.blocks)) throw TypeError(\".Message.blocks: array expected\");\n      m.blocks = [];\n\n      for (var i = 0; i < d.blocks.length; ++i) {\n        if (typeof d.blocks[i] === \"string\") $util.base64.decode(d.blocks[i], m.blocks[i] = $util.newBuffer($util.base64.length(d.blocks[i])), 0);else if (d.blocks[i].length) m.blocks[i] = d.blocks[i];\n      }\n    }\n\n    if (d.payload) {\n      if (!Array.isArray(d.payload)) throw TypeError(\".Message.payload: array expected\");\n      m.payload = [];\n\n      for (var i = 0; i < d.payload.length; ++i) {\n        if (typeof d.payload[i] !== \"object\") throw TypeError(\".Message.payload: object expected\");\n        m.payload[i] = $root.Message.Block.fromObject(d.payload[i]);\n      }\n    }\n\n    if (d.blockPresences) {\n      if (!Array.isArray(d.blockPresences)) throw TypeError(\".Message.blockPresences: array expected\");\n      m.blockPresences = [];\n\n      for (var i = 0; i < d.blockPresences.length; ++i) {\n        if (typeof d.blockPresences[i] !== \"object\") throw TypeError(\".Message.blockPresences: object expected\");\n        m.blockPresences[i] = $root.Message.BlockPresence.fromObject(d.blockPresences[i]);\n      }\n    }\n\n    if (d.pendingBytes != null) {\n      m.pendingBytes = d.pendingBytes | 0;\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a Message message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Message\n   * @static\n   * @param {Message} m Message\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Message.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.arrays || o.defaults) {\n      d.blocks = [];\n      d.payload = [];\n      d.blockPresences = [];\n    }\n\n    if (o.defaults) {\n      d.wantlist = null;\n      d.pendingBytes = 0;\n    }\n\n    if (m.wantlist != null && m.hasOwnProperty(\"wantlist\")) {\n      d.wantlist = $root.Message.Wantlist.toObject(m.wantlist, o);\n    }\n\n    if (m.blocks && m.blocks.length) {\n      d.blocks = [];\n\n      for (var j = 0; j < m.blocks.length; ++j) {\n        d.blocks[j] = o.bytes === String ? $util.base64.encode(m.blocks[j], 0, m.blocks[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.blocks[j]) : m.blocks[j];\n      }\n    }\n\n    if (m.payload && m.payload.length) {\n      d.payload = [];\n\n      for (var j = 0; j < m.payload.length; ++j) {\n        d.payload[j] = $root.Message.Block.toObject(m.payload[j], o);\n      }\n    }\n\n    if (m.blockPresences && m.blockPresences.length) {\n      d.blockPresences = [];\n\n      for (var j = 0; j < m.blockPresences.length; ++j) {\n        d.blockPresences[j] = $root.Message.BlockPresence.toObject(m.blockPresences[j], o);\n      }\n    }\n\n    if (m.pendingBytes != null && m.hasOwnProperty(\"pendingBytes\")) {\n      d.pendingBytes = m.pendingBytes;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Message to JSON.\n   * @function toJSON\n   * @memberof Message\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Message.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  Message.Wantlist = function () {\n    /**\n     * Properties of a Wantlist.\n     * @memberof Message\n     * @interface IWantlist\n     * @property {Array.<Message.Wantlist.IEntry>|null} [entries] Wantlist entries\n     * @property {boolean|null} [full] Wantlist full\n     */\n\n    /**\n     * Constructs a new Wantlist.\n     * @memberof Message\n     * @classdesc Represents a Wantlist.\n     * @implements IWantlist\n     * @constructor\n     * @param {Message.IWantlist=} [p] Properties to set\n     */\n    function Wantlist(p) {\n      this.entries = [];\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * Wantlist entries.\n     * @member {Array.<Message.Wantlist.IEntry>} entries\n     * @memberof Message.Wantlist\n     * @instance\n     */\n\n\n    Wantlist.prototype.entries = $util.emptyArray;\n    /**\n     * Wantlist full.\n     * @member {boolean} full\n     * @memberof Message.Wantlist\n     * @instance\n     */\n\n    Wantlist.prototype.full = false;\n    /**\n     * Encodes the specified Wantlist message. Does not implicitly {@link Message.Wantlist.verify|verify} messages.\n     * @function encode\n     * @memberof Message.Wantlist\n     * @static\n     * @param {Message.IWantlist} m Wantlist message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    Wantlist.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n\n      if (m.entries != null && m.entries.length) {\n        for (var i = 0; i < m.entries.length; ++i) $root.Message.Wantlist.Entry.encode(m.entries[i], w.uint32(10).fork()).ldelim();\n      }\n\n      if (m.full != null && Object.hasOwnProperty.call(m, \"full\")) w.uint32(16).bool(m.full);\n      return w;\n    };\n    /**\n     * Decodes a Wantlist message from the specified reader or buffer.\n     * @function decode\n     * @memberof Message.Wantlist\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Message.Wantlist} Wantlist\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Wantlist.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.Message.Wantlist();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            if (!(m.entries && m.entries.length)) m.entries = [];\n            m.entries.push($root.Message.Wantlist.Entry.decode(r, r.uint32()));\n            break;\n\n          case 2:\n            m.full = r.bool();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a Wantlist message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Message.Wantlist\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Message.Wantlist} Wantlist\n     */\n\n\n    Wantlist.fromObject = function fromObject(d) {\n      if (d instanceof $root.Message.Wantlist) return d;\n      var m = new $root.Message.Wantlist();\n\n      if (d.entries) {\n        if (!Array.isArray(d.entries)) throw TypeError(\".Message.Wantlist.entries: array expected\");\n        m.entries = [];\n\n        for (var i = 0; i < d.entries.length; ++i) {\n          if (typeof d.entries[i] !== \"object\") throw TypeError(\".Message.Wantlist.entries: object expected\");\n          m.entries[i] = $root.Message.Wantlist.Entry.fromObject(d.entries[i]);\n        }\n      }\n\n      if (d.full != null) {\n        m.full = Boolean(d.full);\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a Wantlist message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Message.Wantlist\n     * @static\n     * @param {Message.Wantlist} m Wantlist\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Wantlist.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.arrays || o.defaults) {\n        d.entries = [];\n      }\n\n      if (o.defaults) {\n        d.full = false;\n      }\n\n      if (m.entries && m.entries.length) {\n        d.entries = [];\n\n        for (var j = 0; j < m.entries.length; ++j) {\n          d.entries[j] = $root.Message.Wantlist.Entry.toObject(m.entries[j], o);\n        }\n      }\n\n      if (m.full != null && m.hasOwnProperty(\"full\")) {\n        d.full = m.full;\n      }\n\n      return d;\n    };\n    /**\n     * Converts this Wantlist to JSON.\n     * @function toJSON\n     * @memberof Message.Wantlist\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Wantlist.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    /**\n     * WantType enum.\n     * @name Message.Wantlist.WantType\n     * @enum {number}\n     * @property {number} Block=0 Block value\n     * @property {number} Have=1 Have value\n     */\n\n\n    Wantlist.WantType = function () {\n      var valuesById = {},\n          values = Object.create(valuesById);\n      values[valuesById[0] = \"Block\"] = 0;\n      values[valuesById[1] = \"Have\"] = 1;\n      return values;\n    }();\n\n    Wantlist.Entry = function () {\n      /**\n       * Properties of an Entry.\n       * @memberof Message.Wantlist\n       * @interface IEntry\n       * @property {Uint8Array|null} [block] Entry block\n       * @property {number|null} [priority] Entry priority\n       * @property {boolean|null} [cancel] Entry cancel\n       * @property {Message.Wantlist.WantType|null} [wantType] Entry wantType\n       * @property {boolean|null} [sendDontHave] Entry sendDontHave\n       */\n\n      /**\n       * Constructs a new Entry.\n       * @memberof Message.Wantlist\n       * @classdesc Represents an Entry.\n       * @implements IEntry\n       * @constructor\n       * @param {Message.Wantlist.IEntry=} [p] Properties to set\n       */\n      function Entry(p) {\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * Entry block.\n       * @member {Uint8Array} block\n       * @memberof Message.Wantlist.Entry\n       * @instance\n       */\n\n\n      Entry.prototype.block = $util.newBuffer([]);\n      /**\n       * Entry priority.\n       * @member {number} priority\n       * @memberof Message.Wantlist.Entry\n       * @instance\n       */\n\n      Entry.prototype.priority = 0;\n      /**\n       * Entry cancel.\n       * @member {boolean} cancel\n       * @memberof Message.Wantlist.Entry\n       * @instance\n       */\n\n      Entry.prototype.cancel = false;\n      /**\n       * Entry wantType.\n       * @member {Message.Wantlist.WantType} wantType\n       * @memberof Message.Wantlist.Entry\n       * @instance\n       */\n\n      Entry.prototype.wantType = 0;\n      /**\n       * Entry sendDontHave.\n       * @member {boolean} sendDontHave\n       * @memberof Message.Wantlist.Entry\n       * @instance\n       */\n\n      Entry.prototype.sendDontHave = false;\n      /**\n       * Encodes the specified Entry message. Does not implicitly {@link Message.Wantlist.Entry.verify|verify} messages.\n       * @function encode\n       * @memberof Message.Wantlist.Entry\n       * @static\n       * @param {Message.Wantlist.IEntry} m Entry message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      Entry.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n        if (m.block != null && Object.hasOwnProperty.call(m, \"block\")) w.uint32(10).bytes(m.block);\n        if (m.priority != null && Object.hasOwnProperty.call(m, \"priority\")) w.uint32(16).int32(m.priority);\n        if (m.cancel != null && Object.hasOwnProperty.call(m, \"cancel\")) w.uint32(24).bool(m.cancel);\n        if (m.wantType != null && Object.hasOwnProperty.call(m, \"wantType\")) w.uint32(32).int32(m.wantType);\n        if (m.sendDontHave != null && Object.hasOwnProperty.call(m, \"sendDontHave\")) w.uint32(40).bool(m.sendDontHave);\n        return w;\n      };\n      /**\n       * Decodes an Entry message from the specified reader or buffer.\n       * @function decode\n       * @memberof Message.Wantlist.Entry\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {Message.Wantlist.Entry} Entry\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      Entry.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.Message.Wantlist.Entry();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              m.block = r.bytes();\n              break;\n\n            case 2:\n              m.priority = r.int32();\n              break;\n\n            case 3:\n              m.cancel = r.bool();\n              break;\n\n            case 4:\n              m.wantType = r.int32();\n              break;\n\n            case 5:\n              m.sendDontHave = r.bool();\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates an Entry message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof Message.Wantlist.Entry\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {Message.Wantlist.Entry} Entry\n       */\n\n\n      Entry.fromObject = function fromObject(d) {\n        if (d instanceof $root.Message.Wantlist.Entry) return d;\n        var m = new $root.Message.Wantlist.Entry();\n\n        if (d.block != null) {\n          if (typeof d.block === \"string\") $util.base64.decode(d.block, m.block = $util.newBuffer($util.base64.length(d.block)), 0);else if (d.block.length) m.block = d.block;\n        }\n\n        if (d.priority != null) {\n          m.priority = d.priority | 0;\n        }\n\n        if (d.cancel != null) {\n          m.cancel = Boolean(d.cancel);\n        }\n\n        switch (d.wantType) {\n          case \"Block\":\n          case 0:\n            m.wantType = 0;\n            break;\n\n          case \"Have\":\n          case 1:\n            m.wantType = 1;\n            break;\n        }\n\n        if (d.sendDontHave != null) {\n          m.sendDontHave = Boolean(d.sendDontHave);\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from an Entry message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof Message.Wantlist.Entry\n       * @static\n       * @param {Message.Wantlist.Entry} m Entry\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      Entry.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (o.defaults) {\n          if (o.bytes === String) d.block = \"\";else {\n            d.block = [];\n            if (o.bytes !== Array) d.block = $util.newBuffer(d.block);\n          }\n          d.priority = 0;\n          d.cancel = false;\n          d.wantType = o.enums === String ? \"Block\" : 0;\n          d.sendDontHave = false;\n        }\n\n        if (m.block != null && m.hasOwnProperty(\"block\")) {\n          d.block = o.bytes === String ? $util.base64.encode(m.block, 0, m.block.length) : o.bytes === Array ? Array.prototype.slice.call(m.block) : m.block;\n        }\n\n        if (m.priority != null && m.hasOwnProperty(\"priority\")) {\n          d.priority = m.priority;\n        }\n\n        if (m.cancel != null && m.hasOwnProperty(\"cancel\")) {\n          d.cancel = m.cancel;\n        }\n\n        if (m.wantType != null && m.hasOwnProperty(\"wantType\")) {\n          d.wantType = o.enums === String ? $root.Message.Wantlist.WantType[m.wantType] : m.wantType;\n        }\n\n        if (m.sendDontHave != null && m.hasOwnProperty(\"sendDontHave\")) {\n          d.sendDontHave = m.sendDontHave;\n        }\n\n        return d;\n      };\n      /**\n       * Converts this Entry to JSON.\n       * @function toJSON\n       * @memberof Message.Wantlist.Entry\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      Entry.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return Entry;\n    }();\n\n    return Wantlist;\n  }();\n\n  Message.Block = function () {\n    /**\n     * Properties of a Block.\n     * @memberof Message\n     * @interface IBlock\n     * @property {Uint8Array|null} [prefix] Block prefix\n     * @property {Uint8Array|null} [data] Block data\n     */\n\n    /**\n     * Constructs a new Block.\n     * @memberof Message\n     * @classdesc Represents a Block.\n     * @implements IBlock\n     * @constructor\n     * @param {Message.IBlock=} [p] Properties to set\n     */\n    function Block(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * Block prefix.\n     * @member {Uint8Array} prefix\n     * @memberof Message.Block\n     * @instance\n     */\n\n\n    Block.prototype.prefix = $util.newBuffer([]);\n    /**\n     * Block data.\n     * @member {Uint8Array} data\n     * @memberof Message.Block\n     * @instance\n     */\n\n    Block.prototype.data = $util.newBuffer([]);\n    /**\n     * Encodes the specified Block message. Does not implicitly {@link Message.Block.verify|verify} messages.\n     * @function encode\n     * @memberof Message.Block\n     * @static\n     * @param {Message.IBlock} m Block message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    Block.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.prefix != null && Object.hasOwnProperty.call(m, \"prefix\")) w.uint32(10).bytes(m.prefix);\n      if (m.data != null && Object.hasOwnProperty.call(m, \"data\")) w.uint32(18).bytes(m.data);\n      return w;\n    };\n    /**\n     * Decodes a Block message from the specified reader or buffer.\n     * @function decode\n     * @memberof Message.Block\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Message.Block} Block\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Block.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.Message.Block();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.prefix = r.bytes();\n            break;\n\n          case 2:\n            m.data = r.bytes();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a Block message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Message.Block\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Message.Block} Block\n     */\n\n\n    Block.fromObject = function fromObject(d) {\n      if (d instanceof $root.Message.Block) return d;\n      var m = new $root.Message.Block();\n\n      if (d.prefix != null) {\n        if (typeof d.prefix === \"string\") $util.base64.decode(d.prefix, m.prefix = $util.newBuffer($util.base64.length(d.prefix)), 0);else if (d.prefix.length) m.prefix = d.prefix;\n      }\n\n      if (d.data != null) {\n        if (typeof d.data === \"string\") $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);else if (d.data.length) m.data = d.data;\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a Block message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Message.Block\n     * @static\n     * @param {Message.Block} m Block\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Block.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.defaults) {\n        if (o.bytes === String) d.prefix = \"\";else {\n          d.prefix = [];\n          if (o.bytes !== Array) d.prefix = $util.newBuffer(d.prefix);\n        }\n        if (o.bytes === String) d.data = \"\";else {\n          d.data = [];\n          if (o.bytes !== Array) d.data = $util.newBuffer(d.data);\n        }\n      }\n\n      if (m.prefix != null && m.hasOwnProperty(\"prefix\")) {\n        d.prefix = o.bytes === String ? $util.base64.encode(m.prefix, 0, m.prefix.length) : o.bytes === Array ? Array.prototype.slice.call(m.prefix) : m.prefix;\n      }\n\n      if (m.data != null && m.hasOwnProperty(\"data\")) {\n        d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;\n      }\n\n      return d;\n    };\n    /**\n     * Converts this Block to JSON.\n     * @function toJSON\n     * @memberof Message.Block\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Block.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Block;\n  }();\n  /**\n   * BlockPresenceType enum.\n   * @name Message.BlockPresenceType\n   * @enum {number}\n   * @property {number} Have=0 Have value\n   * @property {number} DontHave=1 DontHave value\n   */\n\n\n  Message.BlockPresenceType = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"Have\"] = 0;\n    values[valuesById[1] = \"DontHave\"] = 1;\n    return values;\n  }();\n\n  Message.BlockPresence = function () {\n    /**\n     * Properties of a BlockPresence.\n     * @memberof Message\n     * @interface IBlockPresence\n     * @property {Uint8Array|null} [cid] BlockPresence cid\n     * @property {Message.BlockPresenceType|null} [type] BlockPresence type\n     */\n\n    /**\n     * Constructs a new BlockPresence.\n     * @memberof Message\n     * @classdesc Represents a BlockPresence.\n     * @implements IBlockPresence\n     * @constructor\n     * @param {Message.IBlockPresence=} [p] Properties to set\n     */\n    function BlockPresence(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * BlockPresence cid.\n     * @member {Uint8Array} cid\n     * @memberof Message.BlockPresence\n     * @instance\n     */\n\n\n    BlockPresence.prototype.cid = $util.newBuffer([]);\n    /**\n     * BlockPresence type.\n     * @member {Message.BlockPresenceType} type\n     * @memberof Message.BlockPresence\n     * @instance\n     */\n\n    BlockPresence.prototype.type = 0;\n    /**\n     * Encodes the specified BlockPresence message. Does not implicitly {@link Message.BlockPresence.verify|verify} messages.\n     * @function encode\n     * @memberof Message.BlockPresence\n     * @static\n     * @param {Message.IBlockPresence} m BlockPresence message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    BlockPresence.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.cid != null && Object.hasOwnProperty.call(m, \"cid\")) w.uint32(10).bytes(m.cid);\n      if (m.type != null && Object.hasOwnProperty.call(m, \"type\")) w.uint32(16).int32(m.type);\n      return w;\n    };\n    /**\n     * Decodes a BlockPresence message from the specified reader or buffer.\n     * @function decode\n     * @memberof Message.BlockPresence\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Message.BlockPresence} BlockPresence\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BlockPresence.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.Message.BlockPresence();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.cid = r.bytes();\n            break;\n\n          case 2:\n            m.type = r.int32();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a BlockPresence message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Message.BlockPresence\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Message.BlockPresence} BlockPresence\n     */\n\n\n    BlockPresence.fromObject = function fromObject(d) {\n      if (d instanceof $root.Message.BlockPresence) return d;\n      var m = new $root.Message.BlockPresence();\n\n      if (d.cid != null) {\n        if (typeof d.cid === \"string\") $util.base64.decode(d.cid, m.cid = $util.newBuffer($util.base64.length(d.cid)), 0);else if (d.cid.length) m.cid = d.cid;\n      }\n\n      switch (d.type) {\n        case \"Have\":\n        case 0:\n          m.type = 0;\n          break;\n\n        case \"DontHave\":\n        case 1:\n          m.type = 1;\n          break;\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a BlockPresence message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Message.BlockPresence\n     * @static\n     * @param {Message.BlockPresence} m BlockPresence\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    BlockPresence.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.defaults) {\n        if (o.bytes === String) d.cid = \"\";else {\n          d.cid = [];\n          if (o.bytes !== Array) d.cid = $util.newBuffer(d.cid);\n        }\n        d.type = o.enums === String ? \"Have\" : 0;\n      }\n\n      if (m.cid != null && m.hasOwnProperty(\"cid\")) {\n        d.cid = o.bytes === String ? $util.base64.encode(m.cid, 0, m.cid.length) : o.bytes === Array ? Array.prototype.slice.call(m.cid) : m.cid;\n      }\n\n      if (m.type != null && m.hasOwnProperty(\"type\")) {\n        d.type = o.enums === String ? $root.Message.BlockPresenceType[m.type] : m.type;\n      }\n\n      return d;\n    };\n    /**\n     * Converts this BlockPresence to JSON.\n     * @function toJSON\n     * @memberof Message.BlockPresence\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    BlockPresence.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return BlockPresence;\n  }();\n\n  return Message;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}