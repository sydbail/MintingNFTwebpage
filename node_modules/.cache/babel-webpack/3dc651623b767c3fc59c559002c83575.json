{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { CID } from 'multiformats/cid';\nimport { createEncoder, createHeader } from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport { bytesReader, readHeader } from './decoder.js';\nexport class CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n\n  put(block) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n        throw new TypeError('Can only write {cid, bytes} objects');\n      }\n\n      if (_this._ended) {\n        throw new Error('Already closed');\n      }\n\n      const cid = CID.asCID(block.cid);\n\n      if (!cid) {\n        throw new TypeError('Can only write {cid, bytes} objects');\n      }\n\n      _this._mutex = _this._mutex.then(() => _this._encoder.writeBlock({\n        cid,\n        bytes: block.bytes\n      }));\n      return _this._mutex;\n    })();\n  }\n\n  close() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2._ended) {\n        throw new Error('Already closed');\n      }\n\n      yield _this2._mutex;\n      _this2._ended = true;\n      return _this2._encoder.close();\n    })();\n  }\n\n  static create(roots) {\n    roots = toRoots(roots);\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n\n  static createAppender() {\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n\n    encoder.setRoots = () => Promise.resolve();\n\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n\n  static updateRootsInBytes(bytes, roots) {\n    return _asyncToGenerator(function* () {\n      const reader = bytesReader(bytes);\n      yield readHeader(reader);\n      const newHeader = createHeader(roots);\n\n      if (reader.pos !== newHeader.length) {\n        throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);\n      }\n\n      bytes.set(newHeader, 0);\n      return bytes;\n    })();\n  }\n\n}\nexport class CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n\n    this._iterating = true;\n    return this._iterator;\n  }\n\n}\n\nfunction encodeWriter() {\n  const iw = iteratorChannel();\n  const {\n    writer,\n    iterator\n  } = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\n\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    return [cid];\n  }\n\n  const _roots = [];\n\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    _roots.push(_root);\n  }\n\n  return _roots;\n}\n\nexport const __browser = true;","map":null,"metadata":{},"sourceType":"module"}