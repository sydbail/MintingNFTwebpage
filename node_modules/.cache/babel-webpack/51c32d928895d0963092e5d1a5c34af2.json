{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n});\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst errCode = require('err-code');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerRouting = require('./peer-routing');\n\nconst ContentRouting = require('./content-routing');\n\nconst getPeer = require('./get-peer');\n\nconst {\n  validate: validateConfig\n} = require('./config');\n\nconst {\n  codes,\n  messages\n} = require('./errors');\n\nconst AddressManager = require('./address-manager');\n\nconst ConnectionManager = require('./connection-manager');\n\nconst Circuit = require('./circuit/transport');\n\nconst Relay = require('./circuit');\n\nconst Dialer = require('./dialer');\n\nconst Keychain = require('./keychain');\n\nconst Metrics = require('./metrics');\n\nconst TransportManager = require('./transport-manager');\n\nconst Upgrader = require('./upgrader');\n\nconst PeerStore = require('./peer-store');\n\nconst PubsubAdapter = require('./pubsub-adapter');\n\nconst PersistentPeerStore = require('./peer-store/persistent');\n\nconst Registrar = require('./registrar');\n\nconst ping = require('./ping');\n\nconst IdentifyService = require('./identify');\n\nconst NatManager = require('./nat-manager');\n\nconst {\n  updateSelfPeerRecord\n} = require('./record/utils');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} RandomWalkOptions\n * @property {boolean} [enabled = false]\n * @property {number} [queriesPerPeriod = 1]\n * @property {number} [interval = 300e3]\n * @property {number} [timeout = 10e3]\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {RandomWalkOptions} [randomWalk]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions & import('./peer-store/persistent').PersistentPeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nclass Libp2p extends EventEmitter {\n  /**\n   * Like `new Libp2p(options)` except it will create a `PeerId`\n   * instance if one is not provided in options.\n   *\n   * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n   * @returns {Promise<Libp2p>}\n   */\n  static create(options) {\n    return _asyncToGenerator(function* () {\n      if (options.peerId) {\n        // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n        return new Libp2p(options);\n      }\n\n      const peerId = yield PeerId.create();\n      options.peerId = peerId; // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n\n      return new Libp2p(options);\n    })();\n  }\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n\n\n  constructor(_options) {\n    super(); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    this._options = validateConfig(_options);\n    /** @type {PeerId} */\n\n    this.peerId = this._options.peerId;\n    this.datastore = this._options.datastore;\n    this.peerStore = this.datastore && this._options.peerStore.persistence ? new PersistentPeerStore({\n      peerId: this.peerId,\n      datastore: this.datastore,\n      ...this._options.peerStore\n    }) : new PeerStore({\n      peerId: this.peerId\n    }); // Addresses {listen, announce, noAnnounce}\n\n    this.addresses = this._options.addresses;\n    this.addressManager = new AddressManager(this.peerId, this._options.addresses); // when addresses change, update our peer record\n\n    this.addressManager.on('change:addresses', () => {\n      updateSelfPeerRecord(this).catch(err => {\n        log.error('Error updating self peer record', err);\n      });\n    });\n    this._modules = this._options.modules;\n    this._config = this._options.config;\n    this._transport = []; // Transport instances/references\n\n    this._discovery = new Map(); // Discovery service instances/references\n    // Create the Connection Manager\n\n    this.connectionManager = new ConnectionManager(this, {\n      autoDial: this._config.peerDiscovery.autoDial,\n      ...this._options.connectionManager\n    }); // Create Metrics\n\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({ ...this._options.metrics,\n        connectionManager: this.connectionManager\n      });\n    } // Create keychain\n\n\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain');\n      const keychainOpts = Keychain.generateOptions();\n      this.keychain = new Keychain(this._options.keychain.datastore, { ...keychainOpts,\n        ...this._options.keychain\n      });\n      log('keychain constructed');\n    } // Setup the Upgrader\n\n\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: connection => this.connectionManager.onConnect(connection),\n      onConnectionEnd: connection => this.connectionManager.onDisconnect(connection)\n    }); // Setup the transport manager\n\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    }); // Create the Nat Manager\n\n    this.natManager = new NatManager({\n      peerId: this.peerId,\n      addressManager: this.addressManager,\n      transportManager: this.transportManager,\n      // @ts-ignore Nat typedef is not understood as Object\n      ...this._options.config.nat\n    }); // Create the Registrar\n\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    });\n    this.handle = this.handle.bind(this);\n    this.registrar.handle = this.handle; // Attach crypto channels\n\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);\n    }\n\n    const cryptos = this._modules.connEncryption;\n    cryptos.forEach(crypto => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto);\n    });\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      ...this._options.dialer\n    });\n\n    this._modules.transport.forEach(Transport => {\n      const key = Transport.prototype[Symbol.toStringTag];\n      const transportOptions = this._config.transport[key];\n      this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n      this.relay = new Relay(this);\n    } // Attach stream multiplexers\n\n\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer;\n      muxers.forEach(muxer => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      this.identifyService = new IdentifyService({\n        libp2p: this\n      });\n      this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (this._modules.dht) {\n      const DHT = this._modules.dht; // @ts-ignore Object is not constructable\n\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      });\n    } // Create pubsub if provided\n\n\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub; // using pubsub adapter with *DEPRECATED* handlers functionality\n\n      /** @type {Pubsub} */\n\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    this.peerRouting = new PeerRouting(this);\n    this.contentRouting = new ContentRouting(this); // Mount default protocols\n\n    ping.mount(this);\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n\n\n  emit(eventName, ...args) {\n    // TODO: do we still need this?\n    // @ts-ignore _events does not exist in libp2p\n    if (eventName === 'error' && !this._events.error) {\n      log.error(args);\n      return false;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      log('libp2p is starting');\n\n      try {\n        yield _this._onStarting();\n        yield _this._onDidStart();\n        log('libp2p has started');\n      } catch (err) {\n        _this.emit('error', err);\n\n        log.error('An error occurred starting libp2p', err);\n        yield _this.stop();\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      log('libp2p is stopping');\n\n      try {\n        _this2._isStarted = false;\n        _this2.relay && _this2.relay.stop();\n\n        _this2.peerRouting.stop();\n\n        for (const service of _this2._discovery.values()) {\n          service.removeListener('peer', _this2._onDiscoveryPeer);\n        }\n\n        yield Promise.all(Array.from(_this2._discovery.values(), s => s.stop()));\n        _this2._discovery = new Map();\n        yield _this2.peerStore.stop();\n        yield _this2.connectionManager.stop();\n        yield Promise.all([_this2.pubsub && _this2.pubsub.stop(), _this2._dht && _this2._dht.stop(), _this2.metrics && _this2.metrics.stop()]);\n        yield _this2.natManager.stop();\n        yield _this2.transportManager.close();\n        ping.unmount(_this2);\n\n        _this2.dialer.destroy();\n      } catch (err) {\n        if (err) {\n          log.error(err);\n\n          _this2.emit('error', err);\n        }\n      }\n\n      log('libp2p has stopped');\n    })();\n  }\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  loadKeychain() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this3.keychain) {\n        return;\n      }\n\n      try {\n        yield _this3.keychain.findKeyByName('self');\n      } catch (err) {\n        yield _this3.keychain.importPeer('self', _this3.peerId);\n      }\n    })();\n  }\n\n  isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   *\n   * @returns {Map<string, Connection[]>}\n   */\n\n\n  get connections() {\n    return this.connectionManager.connections;\n  }\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(peer, options) {\n    return this._dial(peer, options);\n  }\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  dialProtocol(peer, protocols, options) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!protocols || !protocols.length) {\n        throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n      }\n\n      const connection = yield _this4._dial(peer, options);\n      return connection.newStream(protocols);\n    })();\n  }\n  /**\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @returns {Promise<Connection>}\n   */\n\n\n  _dial(peer, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        id,\n        multiaddrs\n      } = getPeer(peer);\n\n      if (id.equals(_this5.peerId)) {\n        throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF);\n      }\n\n      let connection = _this5.connectionManager.get(id);\n\n      if (!connection) {\n        connection = yield _this5.dialer.connectToPeer(peer, options);\n      } else if (multiaddrs) {\n        _this5.peerStore.addressBook.add(id, multiaddrs);\n      }\n\n      return connection;\n    })();\n  }\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  get multiaddrs() {\n    let addrs = this.addressManager.getAnnounceAddrs().map(ma => ma.toString());\n\n    if (!addrs.length) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.transportManager.getAddrs().map(ma => ma.toString());\n    }\n\n    addrs = addrs.concat(this.addressManager.getObservedAddrs().map(ma => ma.toString()));\n    const announceFilter = this._options.addresses.announceFilter; // dedupe multiaddrs\n\n    const addrSet = new Set(addrs); // Create advertising list\n\n    return announceFilter(Array.from(addrSet).map(str => new Multiaddr(str)));\n  }\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n   * @returns {Promise<void>}\n   */\n\n\n  hangUp(peer) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        id\n      } = getPeer(peer);\n\n      const connections = _this6.connectionManager.connections.get(id.toB58String());\n\n      if (!connections) {\n        return;\n      }\n\n      yield Promise.all(connections.map(connection => {\n        return connection.close();\n      }));\n    })();\n  }\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to ping\n   * @returns {Promise<number>}\n   */\n\n\n  ping(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer); // If received multiaddr, ping it\n\n    if (multiaddrs) {\n      return ping(this, multiaddrs[0]);\n    }\n\n    return ping(this, id);\n  }\n  /**\n   * Registers the `handler` for each protocol\n   *\n   * @param {string[]|string} protocols\n   * @param {(props: HandlerProps) => void} handler\n   */\n\n\n  handle(protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler);\n    }); // Add new protocols to self protocols in the Protobook\n\n    this.peerStore.protoBook.add(this.peerId, protocols);\n  }\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @param {string[]|string} protocols\n   */\n\n\n  unhandle(protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol);\n    }); // Remove protocols from self protocols in the Protobook\n\n    this.peerStore.protoBook.remove(this.peerId, protocols);\n  }\n\n  _onStarting() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      // Listen on the provided transports for the provided addresses\n      const addrs = _this7.addressManager.getListenAddrs();\n\n      yield _this7.transportManager.listen(addrs); // Manage your NATs\n\n      _this7.natManager.start(); // Start PeerStore\n\n\n      yield _this7.peerStore.start();\n\n      if (_this7._config.pubsub.enabled) {\n        _this7.pubsub && _this7.pubsub.start();\n      } // DHT subsystem\n\n\n      if (_this7._config.dht.enabled) {\n        _this7._dht && _this7._dht.start(); // TODO: this should be modified once random-walk is used as\n        // the other discovery modules\n\n        _this7._dht.on('peer', _this7._onDiscoveryPeer);\n      } // Start metrics if present\n\n\n      _this7.metrics && _this7.metrics.start();\n    })();\n  }\n  /**\n   * Called when libp2p has started and before it returns\n   *\n   * @private\n   */\n\n\n  _onDidStart() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      _this8._isStarted = true;\n\n      _this8.peerStore.on('peer', peerId => {\n        _this8.emit('peer:discovery', peerId);\n\n        _this8._maybeConnect(peerId);\n      }); // Once we start, emit any peers we may have already discovered\n      // TODO: this should be removed, as we already discovered these peers in the past\n\n\n      for (const peer of _this8.peerStore.peers.values()) {\n        _this8.emit('peer:discovery', peer.id);\n      }\n\n      _this8.connectionManager.start(); // Peer discovery\n\n\n      yield _this8._setupPeerDiscovery(); // Relay\n\n      _this8.relay && _this8.relay.start();\n\n      _this8.peerRouting.start();\n    })();\n  }\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   *\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n   */\n\n\n  _onDiscoveryPeer(peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);\n  }\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   *\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _maybeConnect(peerId) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      // If auto dialing is on and we have no connection to the peer, check if we should dial\n      if (_this9._config.peerDiscovery.autoDial === true && !_this9.connectionManager.get(peerId)) {\n        const minConnections = _this9._options.connectionManager.minConnections || 0;\n\n        if (minConnections > _this9.connectionManager.size) {\n          log('connecting to discovered peer %s', peerId.toB58String());\n\n          try {\n            yield _this9.dialer.connectToPeer(peerId);\n          } catch (err) {\n            log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`);\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n\n\n  _setupPeerDiscovery() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      /**\n       * @param {PeerDiscoveryFactory} DiscoveryService\n       */\n      const setupService = DiscoveryService => {\n        let config = {\n          enabled: true // on by default\n\n        };\n\n        if (DiscoveryService.tag && _this10._config.peerDiscovery && _this10._config.peerDiscovery[DiscoveryService.tag]) {\n          // @ts-ignore PeerDiscovery not understood as an Object for spread\n          config = { ...config,\n            ..._this10._config.peerDiscovery[DiscoveryService.tag]\n          };\n        }\n\n        if (config.enabled && !_this10._discovery.has(DiscoveryService.tag)) {\n          // not already added\n          let discoveryService;\n\n          if (typeof DiscoveryService === 'function') {\n            // @ts-ignore DiscoveryService has no constructor type inferred\n            discoveryService = new DiscoveryService(Object.assign({}, config, {\n              peerId: _this10.peerId,\n              libp2p: _this10\n            }));\n          } else {\n            discoveryService = DiscoveryService;\n          }\n\n          discoveryService.on('peer', _this10._onDiscoveryPeer);\n\n          _this10._discovery.set(DiscoveryService.tag, discoveryService);\n        }\n      }; // Discovery modules\n\n\n      for (const DiscoveryService of _this10._modules.peerDiscovery || []) {\n        setupService(DiscoveryService);\n      } // Transport modules with discovery\n\n\n      for (const Transport of _this10.transportManager.getTransports()) {\n        // @ts-ignore Transport interface does not include discovery\n        if (Transport.discovery) {\n          // @ts-ignore Transport interface does not include discovery\n          setupService(Transport.discovery);\n        }\n      }\n\n      yield Promise.all(Array.from(_this10._discovery.values(), d => d.start()));\n    })();\n  }\n\n}\n\nmodule.exports = Libp2p;","map":null,"metadata":{},"sourceType":"script"}