{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updated = void 0;\n\nconst path = __importStar(require(\"path\"));\n\nconst fs = __importStar(require(\"fs\"));\n\nfunction updated({\n  paths,\n  contractsBuildDirectory\n}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const sourceFilesArtifacts = readAndParseArtifactFiles(paths, contractsBuildDirectory);\n    const sourceFilesArtifactsUpdatedTimes = minimumUpdatedTimePerSource(sourceFilesArtifacts);\n    return findUpdatedFiles(sourceFilesArtifacts, sourceFilesArtifactsUpdatedTimes);\n  });\n}\n\nexports.updated = updated;\n\nfunction readAndParseArtifactFiles(paths, contracts_build_directory) {\n  const sourceFilesArtifacts = {}; // Get all the source files and create an object out of them.\n\n  paths.forEach(sourceFile => {\n    sourceFilesArtifacts[sourceFile] = [];\n  }); // Get all the artifact files, and read them, parsing them as JSON\n\n  let buildFiles;\n\n  try {\n    buildFiles = fs.readdirSync(contracts_build_directory);\n  } catch (error) {\n    // The build directory may not always exist.\n    if (error.message.includes(\"ENOENT: no such file or directory\")) {\n      // Ignore it.\n      buildFiles = [];\n    } else {\n      throw error;\n    }\n  }\n\n  buildFiles = buildFiles.filter(file => path.extname(file) === \".json\");\n  const jsonData = buildFiles.map(file => {\n    const body = fs.readFileSync(path.join(contracts_build_directory, file), \"utf8\");\n    return {\n      file,\n      body\n    };\n  });\n\n  for (let i = 0; i < jsonData.length; i++) {\n    try {\n      const data = JSON.parse(jsonData[i].body); // In case there are artifacts from other source locations.\n\n      if (sourceFilesArtifacts[data.sourcePath] == null) {\n        sourceFilesArtifacts[data.sourcePath] = [];\n      }\n\n      sourceFilesArtifacts[data.sourcePath].push(data);\n    } catch (error) {\n      // JSON.parse throws SyntaxError objects\n      if (error instanceof SyntaxError) {\n        throw new Error(\"Problem parsing artifact: \" + jsonData[i].file);\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  return sourceFilesArtifacts;\n}\n\nfunction findUpdatedFiles(sourceFilesArtifacts, sourceFilesArtifactsUpdatedTimes) {\n  // Stat all the source files, getting there updated times, and comparing them to\n  // the artifact updated times.\n  const sourceFiles = Object.keys(sourceFilesArtifacts);\n  let sourceFileStats;\n  sourceFileStats = sourceFiles.map(file => {\n    try {\n      return fs.statSync(file);\n    } catch (error) {\n      // Ignore it. This means the source file was removed\n      // but the artifact file possibly exists. Return null\n      // to signfy that we should ignore it.\n      return null;\n    }\n  });\n  return sourceFiles.map((sourceFile, index) => {\n    const sourceFileStat = sourceFileStats[index]; // Ignore updating artifacts if source file has been removed.\n\n    if (sourceFileStat == null) return;\n    const artifactsUpdatedTime = sourceFilesArtifactsUpdatedTimes[sourceFile] || 0;\n    const sourceFileUpdatedTime = (sourceFileStat.mtime || sourceFileStat.ctime).getTime();\n    if (sourceFileUpdatedTime > artifactsUpdatedTime) return sourceFile;\n  }).filter(file => file);\n}\n\nfunction minimumUpdatedTimePerSource(sourceFilesArtifacts) {\n  let sourceFilesArtifactsUpdatedTimes = {}; // Get the minimum updated time for all of a source file's artifacts\n  // (note: one source file might have multiple artifacts).\n\n  for (const sourceFile of Object.keys(sourceFilesArtifacts)) {\n    const artifacts = sourceFilesArtifacts[sourceFile];\n    sourceFilesArtifactsUpdatedTimes[sourceFile] = artifacts.reduce((minimum, current) => {\n      const updatedAt = new Date(current.updatedAt).getTime();\n\n      if (updatedAt < minimum) {\n        return updatedAt;\n      }\n\n      return minimum;\n    }, Number.MAX_SAFE_INTEGER); // Empty array?\n\n    if (sourceFilesArtifactsUpdatedTimes[sourceFile] === Number.MAX_SAFE_INTEGER) {\n      sourceFilesArtifactsUpdatedTimes[sourceFile] = 0;\n    }\n  }\n\n  return sourceFilesArtifactsUpdatedTimes;\n} //# sourceMappingURL=updated.js.map","map":null,"metadata":{},"sourceType":"script"}