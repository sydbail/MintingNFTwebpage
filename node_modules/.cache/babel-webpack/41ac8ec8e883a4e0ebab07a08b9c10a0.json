{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst PeerId = require('peer-id');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst defer = require('p-defer');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p-delegated-peer-routing');\nlog.error = debug('libp2p-delegated-peer-routing:error');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor(client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    });\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);\n  }\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  findPeer(id, options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let idStr = id;\n\n      if (PeerId.isPeerId(idStr)) {\n        idStr = id.toB58String();\n      }\n\n      log('findPeer starts: ' + id);\n      options.timeout = options.timeout || DEFAULT_TIMEOUT;\n\n      try {\n        return yield _this2._httpQueue.add( /*#__PURE__*/_asyncToGenerator(function* () {\n          const {\n            addrs\n          } = yield _this2._client.dht.findPeer(idStr, {\n            timeout: options.timeout\n          });\n          return {\n            id,\n            multiaddrs: addrs\n          };\n        }));\n      } catch (err) {\n        if (err.message.includes('not found')) {\n          return undefined;\n        }\n\n        throw err;\n      } finally {\n        log('findPeer finished: ' + id);\n      }\n    })();\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  getClosestPeers(key, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const keyStr = base58btc.encode(key).substring(1);\n      log('getClosestPeers starts:', keyStr);\n      options.timeout = options.timeout || DEFAULT_TIMEOUT;\n      const onStart = defer();\n      const onFinish = defer();\n\n      _this._httpQueue.add(() => {\n        onStart.resolve();\n        return onFinish.promise;\n      });\n\n      try {\n        yield _awaitAsyncGenerator(onStart.promise);\n        const peers = new Map();\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(_this._client.dht.query(keyStr, {\n            timeout: options.timeout\n          })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const result = _value;\n\n            switch (result.type) {\n              case 1:\n                // Found Closer\n                // Track the addresses, so we can yield them when done\n                result.responses.forEach(response => {\n                  peers.set(response.id, {\n                    id: PeerId.parse(response.id),\n                    multiaddrs: response.addrs\n                  });\n                });\n                break;\n\n              case 2:\n                // Final Peer\n                yield peers.get(result.id.string) || {\n                  id: PeerId.createFromCID(result.id),\n                  multiaddrs: []\n                };\n                break;\n\n              default:\n                log('getClosestPeers unhandled response', result);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } catch (err) {\n        log.error('getClosestPeers errored:', err);\n        throw err;\n      } finally {\n        onFinish.resolve();\n        log('getClosestPeers finished:', keyStr);\n      }\n    })();\n  }\n\n}\n\nmodule.exports = DelegatedPeerRouting;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-delegated-peer-routing/src/index.js"],"names":["PeerId","require","base58btc","default","PQueue","defer","debug","log","error","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","DelegatedPeerRouting","constructor","client","Error","_client","_httpQueue","concurrency","protocol","host","port","getEndpointConfig","findPeer","id","options","idStr","isPeerId","toB58String","timeout","add","addrs","dht","multiaddrs","err","message","includes","undefined","getClosestPeers","key","keyStr","encode","substring","onStart","onFinish","resolve","promise","peers","Map","query","result","type","responses","forEach","response","set","parse","get","string","createFromCID","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { default: PQueue } = require('p-queue')\nconst defer = require('p-defer')\nconst debug = require('debug')\n\nconst log = debug('libp2p-delegated-peer-routing')\nlog.error = debug('libp2p-delegated-peer-routing:error')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor (client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this._client = client\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    })\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`)\n  }\n\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async findPeer (id, options = {}) {\n    let idStr = id\n    if (PeerId.isPeerId(idStr)) {\n      idStr = id.toB58String()\n    }\n\n    log('findPeer starts: ' + id)\n\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    try {\n      return await this._httpQueue.add(async () => {\n        const { addrs } = await this._client.dht.findPeer(idStr, {\n          timeout: options.timeout\n        })\n\n        return {\n          id,\n          multiaddrs: addrs\n        }\n      })\n    } catch (err) {\n      if (err.message.includes('not found')) {\n        return undefined\n      }\n\n      throw err\n    } finally {\n      log('findPeer finished: ' + id)\n    }\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * getClosestPeers (key, options = {}) {\n    const keyStr = base58btc.encode(key).substring(1)\n\n    log('getClosestPeers starts:', keyStr)\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    const onStart = defer()\n    const onFinish = defer()\n\n    this._httpQueue.add(() => {\n      onStart.resolve()\n      return onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      const peers = new Map()\n\n      for await (const result of this._client.dht.query(keyStr, {\n        timeout: options.timeout\n      })) {\n        switch (result.type) {\n          case 1: // Found Closer\n            // Track the addresses, so we can yield them when done\n            result.responses.forEach(response => {\n              peers.set(response.id, {\n                id: PeerId.parse(response.id),\n                multiaddrs: response.addrs\n              })\n            })\n            break\n          case 2: // Final Peer\n            yield peers.get(result.id.string) || {\n              id: PeerId.createFromCID(result.id),\n              multiaddrs: []\n            }\n            break\n          default:\n            log('getClosestPeers unhandled response', result)\n        }\n      }\n    } catch (err) {\n      log.error('getClosestPeers errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log('getClosestPeers finished:', keyStr)\n    }\n  }\n}\n\nmodule.exports = DelegatedPeerRouting\n"]},"metadata":{},"sourceType":"script"}