{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Profiler = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"compile-common:profiler\");\n\nconst findContracts = require(\"@truffle/contract-sources\");\n\nconst expect = require(\"@truffle/expect\");\n\nconst updated_1 = require(\"./updated\");\n\nconst requiredSources_1 = require(\"./requiredSources\");\n\nconst convertToAbsolutePaths_1 = require(\"./convertToAbsolutePaths\");\n\nclass Profiler {\n  constructor(config) {\n    this.config = config;\n  }\n\n  updated(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      expect.options(options, [\"contracts_directory\", \"contracts_build_directory\"]);\n      const {\n        contracts_directory: contractsDirectory,\n        contracts_build_directory: contractsBuildDirectory\n      } = options;\n      const paths = options.files ? options.files : yield findContracts(contractsDirectory);\n      return yield updated_1.updated({\n        paths,\n        contractsBuildDirectory\n      });\n    });\n  }\n\n  requiredSources(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      expect.options(options, [\"paths\", \"base_path\", \"resolver\", \"contracts_directory\"]);\n      const {\n        resolver,\n        paths,\n        base_path: basePath,\n        contracts_directory: contractsDirectory\n      } = options;\n      debug(\"paths: %O\", paths);\n\n      const resolve = ({\n        filePath,\n        importedFrom\n      }) => __awaiter(this, void 0, void 0, function* () {\n        //we want to allow resolution failure here.  so, if a source can't\n        //be resolved, it will show up as a compile error rather than a Truffle\n        //error.\n        try {\n          return yield resolver.resolve(filePath, importedFrom);\n        } catch (error) {\n          //resolver doesn't throw structured errors at the moment,\n          //so we'll check the messag to see whether this is an expected error\n          //(kind of a HACK)\n          if (error.message.startsWith(\"Could not find \")) {\n            return undefined;\n          } else {\n            //rethrow unexpected errors\n            throw error;\n          }\n        }\n      });\n\n      const updatedPaths = convertToAbsolutePaths_1.convertToAbsolutePaths(paths, basePath);\n      const allPaths = convertToAbsolutePaths_1.convertToAbsolutePaths(yield findContracts(contractsDirectory), basePath);\n      debug(\"invoking requiredSources\");\n      return yield requiredSources_1.requiredSources({\n        resolve,\n        parseImports: this.config.parseImports,\n        shouldIncludePath: this.config.shouldIncludePath,\n        updatedPaths,\n        allPaths\n      });\n    });\n  }\n\n  requiredSourcesForSingleFile(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      expect.options(options, [\"path\", \"base_path\", \"resolver\"]);\n      const {\n        resolver,\n        path,\n        base_path: basePath\n      } = options;\n\n      const resolve = ({\n        filePath,\n        importedFrom\n      }) => resolver.resolve(filePath, importedFrom);\n\n      const allPaths = convertToAbsolutePaths_1.convertToAbsolutePaths([path], basePath);\n      const updatedPaths = allPaths;\n      return yield requiredSources_1.requiredSources({\n        resolve,\n        parseImports: this.config.parseImports,\n        shouldIncludePath: this.config.shouldIncludePath,\n        updatedPaths,\n        allPaths\n      });\n    });\n  }\n\n}\n\nexports.Profiler = Profiler; //# sourceMappingURL=profiler.js.map","map":null,"metadata":{},"sourceType":"script"}