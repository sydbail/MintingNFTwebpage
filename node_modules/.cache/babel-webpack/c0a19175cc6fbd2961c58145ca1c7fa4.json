{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst isBuffer = require('is-buffer');\n\nconst Shake = require('it-handshake');\n\nconst lp = require('it-length-prefixed');\n\nmodule.exports = (duplex, opts = {}) => {\n  const shake = Shake(duplex);\n  const lpReader = lp.decode.fromReader(shake.reader, opts);\n  let isDone = false;\n  const W = {\n    read: function () {\n      var _ref = _asyncToGenerator(function* (bytes) {\n        // just read\n        const {\n          value,\n          done\n        } = yield shake.reader.next(bytes);\n\n        if (done && value.length < bytes) {\n          throw new Error('Couldn\\'t read enough bytes');\n        }\n\n        isDone = done;\n\n        if (!value) {\n          throw new Error('Value is null');\n        }\n\n        return value;\n      });\n\n      return function read(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }(),\n    readLP: function () {\n      var _ref2 = _asyncToGenerator(function* () {\n        // read, decode\n        const {\n          value,\n          done\n        } = yield lpReader.next();\n        isDone = done;\n\n        if (!value) {\n          throw new Error('Value is null');\n        }\n\n        return value;\n      });\n\n      return function readLP() {\n        return _ref2.apply(this, arguments);\n      };\n    }(),\n    readPB: function () {\n      var _ref3 = _asyncToGenerator(function* (proto) {\n        // readLP, decode\n        const value = yield W.readLP();\n\n        if (!value) {\n          throw new Error('Value is null');\n        } // Is this a buffer?\n\n\n        const buf = isBuffer(value) ? value : value.slice();\n        return proto.decode(buf);\n      });\n\n      return function readPB(_x2) {\n        return _ref3.apply(this, arguments);\n      };\n    }(),\n    write: data => {\n      // just write\n      shake.writer.push(data);\n    },\n    writeLP: data => {\n      // encode, write\n      W.write(lp.encode.single(data, opts));\n    },\n    writePB: (data, proto) => {\n      // encode, writeLP\n      W.writeLP(proto.encode(data));\n    },\n    pb: proto => {\n      return {\n        read: () => W.readPB(proto),\n        write: d => W.writePB(d, proto)\n      };\n    },\n    unwrap: () => {\n      // returns vanilla duplex again, terminates all reads/writes from this object\n      shake.rest();\n      return shake.stream;\n    }\n  };\n  return W;\n};","map":null,"metadata":{},"sourceType":"script"}