{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  BlockstoreAdapter\n} = require('interface-blockstore');\n\nconst merge = require('it-merge');\n\nconst pushable = require('it-pushable');\n\nconst filter = require('it-filter');\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-bitswap').IPFSBitswap} Bitswap\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/block').RmOptions} RmOptions\n */\n\n/**\n * BlockStorage is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n *\n * @implements {Blockstore}\n */\n\n\nclass BlockStorage extends BlockstoreAdapter {\n  /**\n   * Create a new BlockStorage\n   *\n   * @param {Blockstore} blockstore\n   * @param {Bitswap} bitswap\n   */\n  constructor(blockstore, bitswap) {\n    super();\n    this.child = blockstore;\n    this.bitswap = bitswap;\n  }\n\n  open() {\n    return this.child.open();\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n  unwrap() {\n    return this.child;\n  }\n  /**\n   * Put a block to the underlying datastore\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {AbortOptions} [options]\n   */\n\n\n  put(cid, block, options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (yield _this6.has(cid)) {\n        return;\n      }\n\n      if (_this6.bitswap.isStarted()) {\n        yield _this6.bitswap.put(cid, block, options);\n      } else {\n        yield _this6.child.put(cid, block, options);\n      }\n    })();\n  }\n  /**\n   * Put a multiple blocks to the underlying datastore\n   *\n   * @param {AsyncIterable<{ key: CID, value: Uint8Array }> | Iterable<{ key: CID, value: Uint8Array }>} blocks\n   * @param {AbortOptions} [options]\n   */\n\n\n  putMany(blocks, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const missingBlocks = filter(blocks, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* ({\n          key\n        }) {\n          return !(yield _this.has(key));\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n\n      if (_this.bitswap.isStarted()) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(_this.bitswap.putMany(missingBlocks, options)), _awaitAsyncGenerator);\n      } else {\n        yield* _asyncGeneratorDelegate(_asyncIterator(_this.child.putMany(missingBlocks, options)), _awaitAsyncGenerator);\n      }\n    })();\n  }\n  /**\n   * Get a block by cid\n   *\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n\n\n  get(cid, options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(yield _this7.has(cid)) && _this7.bitswap.isStarted()) {\n        return _this7.bitswap.get(cid, options);\n      } else {\n        return _this7.child.get(cid, options);\n      }\n    })();\n  }\n  /**\n   * Get multiple blocks back from an array of cids\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {AbortOptions} [options]\n   */\n\n\n  getMany(cids, options = {}) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const getFromBitswap = pushable();\n      const getFromChild = pushable();\n      Promise.resolve().then( /*#__PURE__*/_asyncToGenerator(function* () {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(cids), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const cid = _value;\n\n            if (!(yield _this2.has(cid)) && _this2.bitswap.isStarted()) {\n              getFromBitswap.push(cid);\n            } else {\n              getFromChild.push(cid);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        getFromBitswap.end();\n        getFromChild.end();\n      }));\n      yield* _asyncGeneratorDelegate(_asyncIterator(merge(_this2.bitswap.getMany(getFromBitswap, options), _this2.child.getMany(getFromChild, options))), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * Delete a block from the blockstore\n   *\n   * @param {CID} cid\n   * @param {RmOptions} [options]\n   */\n\n\n  delete(cid, options) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this8.child.delete(cid, options);\n    })();\n  }\n  /**\n   * Delete multiple blocks from the blockstore\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {RmOptions} [options]\n   */\n\n\n  deleteMany(cids, options) {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this3.child.deleteMany(cids, options)), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n\n\n  has(cid, options = {}) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this9.child.has(cid, options);\n    })();\n  }\n  /**\n   * @param {Query} q\n   * @param {AbortOptions} options\n   */\n\n\n  query(q, options = {}) {\n    var _this4 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this4.child.query(q, options)), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {AbortOptions} options\n   */\n\n\n  queryKeys(q, options = {}) {\n    var _this5 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this5.child.queryKeys(q, options)), _awaitAsyncGenerator);\n    })();\n  }\n\n}\n\nmodule.exports = BlockStorage;","map":null,"metadata":{},"sourceType":"script"}