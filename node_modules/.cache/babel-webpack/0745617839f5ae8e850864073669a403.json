{"ast":null,"code":"'use strict'; // @ts-ignore\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst SparseArray = require('sparse-array');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\n\n\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor(options, parent, posAtParent = 0) {\n    this._options = options;\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n\n    this._children = new SparseArray();\n    /** @type {string | null} */\n\n    this.key = null;\n  }\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n\n\n  put(key, value) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const place = yield _this._findNewBucketAndPos(key);\n      yield place.bucket._putAt(place, key, value);\n    })();\n  }\n  /**\n   * @param {string} key\n   */\n\n\n  get(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const child = yield _this2._findChild(key);\n\n      if (child) {\n        return child.value;\n      }\n    })();\n  }\n  /**\n   * @param {string} key\n   */\n\n\n  del(key) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const place = yield _this3._findPlace(key);\n\n      const child = place.bucket._at(place.pos);\n\n      if (child && child.key === key) {\n        place.bucket._delAt(place.pos);\n      }\n    })();\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  leafCount() {\n    const children = this._children.compactArray();\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount();\n      }\n\n      return acc + 1;\n    }, 0);\n  }\n\n  childrenCount() {\n    return this._children.length;\n  }\n\n  onlyChild() {\n    return this._children.get(0);\n  }\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n\n\n  *eachLeafSeries() {\n    const children = this._children.compactArray();\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield* child.eachLeafSeries();\n      } else {\n        yield child;\n      }\n    } // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n\n\n    return [];\n  }\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n\n\n  serialize(map, reduce) {\n    /** @type {T[]} */\n    const acc = []; // serialize to a custom non-sparse representation\n\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce));\n        } else {\n          acc.push(map(child, index));\n        }\n      }\n\n      return acc;\n    }, acc));\n  }\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n\n\n  asyncTransform(asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce);\n  }\n\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, '  ');\n  }\n\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n\n\n  _findChild(key) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield _this4._findPlace(key);\n\n      const child = result.bucket._at(result.pos);\n\n      if (child instanceof Bucket) {\n        // should not be possible, this._findPlace should always\n        // return a location for a child, not a bucket\n        return undefined;\n      }\n\n      if (child && child.key === key) {\n        return child;\n      }\n    })();\n  }\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n\n\n  _findPlace(key) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const hashValue = _this5._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);\n\n      const index = yield hashValue.take(_this5._options.bits);\n\n      const child = _this5._children.get(index);\n\n      if (child instanceof Bucket) {\n        return child._findPlace(hashValue);\n      }\n\n      return {\n        bucket: _this5,\n        pos: index,\n        hash: hashValue,\n        existingChild: child\n      };\n    })();\n  }\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n\n\n  _findNewBucketAndPos(key) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const place = yield _this6._findPlace(key);\n\n      if (place.existingChild && place.existingChild.key !== key) {\n        // conflict\n        const bucket = new Bucket(_this6._options, place.bucket, place.pos);\n\n        place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n        const newPlace = yield bucket._findPlace(place.existingChild.hash);\n\n        newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n\n        return bucket._findNewBucketAndPos(place.hash);\n      } // no conflict, we found the place\n\n\n      return place;\n    })();\n  }\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n\n\n  _putAt(place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    });\n  }\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n\n\n  _putObjectAt(pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++;\n    }\n\n    this._children.set(pos, object);\n  }\n  /**\n   * @param {number} pos\n   */\n\n\n  _delAt(pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position');\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--;\n    }\n\n    this._children.unset(pos);\n\n    this._level();\n  }\n\n  _level() {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists);\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash;\n          hash.untake(this._options.bits);\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          };\n\n          this._parent._putAt(place, onlyChild.key, onlyChild.value);\n        }\n      } else {\n        this._parent._delAt(this._posAtParent);\n      }\n    }\n  }\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n\n\n  _at(index) {\n    return this._children.get(index);\n  }\n\n}\n/**\n * @param {any} o\n */\n\n\nfunction exists(o) {\n  return Boolean(o);\n}\n/**\n *\n * @param {*} node\n * @param {number} index\n */\n\n\nfunction mapNode(node, index) {\n  return node.key;\n}\n/**\n * @param {*} nodes\n */\n\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\n\n\nfunction asyncTransformBucket(_x, _x2, _x3) {\n  return _asyncTransformBucket.apply(this, arguments);\n}\n\nfunction _asyncTransformBucket() {\n  _asyncTransformBucket = _asyncToGenerator(function* (bucket, asyncMap, asyncReduce) {\n    const output = [];\n\n    for (const child of bucket._children.compactArray()) {\n      if (child instanceof Bucket) {\n        yield asyncTransformBucket(child, asyncMap, asyncReduce);\n      } else {\n        const mappedChildren = yield asyncMap(child);\n        output.push({\n          bitField: bucket._children.bitField(),\n          children: mappedChildren\n        });\n      }\n    }\n\n    return asyncReduce(output);\n  });\n  return _asyncTransformBucket.apply(this, arguments);\n}\n\nmodule.exports = Bucket;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/hamt-sharding/src/bucket.js"],"names":["SparseArray","require","fromString","uint8ArrayFromString","Bucket","constructor","options","parent","posAtParent","_options","_popCount","_parent","_posAtParent","_children","key","put","value","place","_findNewBucketAndPos","bucket","_putAt","get","child","_findChild","del","_findPlace","_at","pos","_delAt","leafCount","children","compactArray","reduce","acc","childrenCount","length","onlyChild","eachLeafSeries","serialize","map","index","push","asyncTransform","asyncMap","asyncReduce","asyncTransformBucket","toJSON","mapNode","reduceNodes","prettyPrint","JSON","stringify","tableSize","Math","pow","bits","result","undefined","hashValue","hash","take","existingChild","_putObjectAt","newPlace","object","set","Error","unset","_level","find","exists","untake","o","Boolean","node","nodes","output","mappedChildren","bitField","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// @ts-ignore\nconst SparseArray = require('sparse-array')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor (options, parent, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray()\n\n    /** @type {string | null} */\n    this.key = null\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount () {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return []\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize (map, reduce) {\n    /** @type {T[]} */\n    const acc = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace (key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt (pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists (o) {\n  return Boolean(o)\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode (node, index) {\n  return node.key\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n\nmodule.exports = Bucket\n"]},"metadata":{},"sourceType":"script"}