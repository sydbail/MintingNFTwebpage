{"ast":null,"code":"\"use strict\";\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptStream = exports.encryptStream = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst constants_1 = require(\"./constants\"); // Returns generator that encrypts payload from the user\n\n\nfunction encryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const chunk = _value;\n          const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n          for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n            let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n            if (end > chunkBuffer.length) {\n              end = chunkBuffer.length;\n            }\n\n            const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n            yield data;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nexports.encryptStream = encryptStream; // Decrypt received payload to the user\n\nfunction decryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const chunk = _value2;\n          const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n          for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {\n            let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n\n            if (end > chunkBuffer.length) {\n              end = chunkBuffer.length;\n            }\n\n            const chunk = chunkBuffer.slice(i, end);\n            const {\n              plaintext: decrypted,\n              valid\n            } = yield _awaitAsyncGenerator(handshake.decrypt(chunk, handshake.session));\n\n            if (!valid) {\n              throw new Error('Failed to validate decrypted chunk');\n            }\n\n            yield decrypted;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\n\nexports.decryptStream = decryptStream; //# sourceMappingURL=crypto.js.map","map":null,"metadata":{},"sourceType":"script"}