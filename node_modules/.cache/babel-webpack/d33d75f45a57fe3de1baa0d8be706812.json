{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  Buffer\n} = require('buffer'); // @ts-ignore\n\n\nconst BufferList = require('bl/BufferList');\n\nconst varintEncode = require('./varint-encode');\n\nconst MIN_POOL_SIZE = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n\nconst DEFAULT_POOL_SIZE = 10 * 1024;\n/**\n * @param {import('./types').EncoderOptions} [options]\n */\n\nfunction encode(options) {\n  options = options || {};\n  const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE);\n  const encodeLength = options.lengthEncoder || varintEncode;\n  /**\n   * @param {AsyncIterable<BufferList>} source\n   */\n\n  const encoder = /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator(function* (source) {\n      let pool = Buffer.alloc(poolSize);\n      let poolOffset = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const chunk = _value;\n          encodeLength(chunk.length, pool, poolOffset);\n          const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes);\n          poolOffset += encodeLength.bytes;\n\n          if (pool.length - poolOffset < MIN_POOL_SIZE) {\n            pool = Buffer.alloc(poolSize);\n            poolOffset = 0;\n          }\n\n          yield new BufferList().append(encodedLength).append(chunk); // yield Buffer.concat([encodedLength, chunk])\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    });\n\n    return function encoder(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return encoder;\n}\n/**\n * @param {BufferList | Buffer} chunk\n * @param {import('./types').EncoderOptions} [options]\n */\n\n\nencode.single = (chunk, options) => {\n  options = options || {};\n  const encodeLength = options.lengthEncoder || varintEncode;\n  return new BufferList([encodeLength(chunk.length), chunk.slice()]);\n};\n\nmodule.exports = encode;\nmodule.exports.MIN_POOL_SIZE = MIN_POOL_SIZE;\nmodule.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE;","map":null,"metadata":{},"sourceType":"script"}