{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst PeerId = require('peer-id'); // @ts-ignore no types\n\n\nconst isDomain = require('is-domain-name');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst log = Object.assign(debug('ipfs:name:resolve'), {\n  error: debug('ipfs:name:resolve:error')\n});\n\nconst {\n  OFFLINE_ERROR\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\n\n\nconst appendRemainder = (result, remainder) => remainder.length > 0 ? result + '/' + remainder.join('/') : result;\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('ipfs-core-types/src/root').API[\"dns\"]} config.dns\n * @param {import('../ipns')} config.ipns\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\n\n\nmodule.exports = ({\n  dns,\n  ipns,\n  peerId,\n  isOnline,\n  options: {\n    offline\n  }\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"resolve\"]}\n   */\n  function resolve(_x) {\n    return _resolve.apply(this, arguments);\n  }\n\n  function _resolve() {\n    _resolve = _wrapAsyncGenerator(function* (name, options = {}) {\n      // eslint-disable-line require-await\n      options = mergeOptions({\n        nocache: false,\n        recursive: true\n      }, options); // TODO: params related logic should be in the core implementation\n\n      if (offline && options && options.nocache) {\n        throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n      } // Set node id as name for being resolved, if it is not received\n\n\n      if (!name) {\n        name = peerId.toB58String();\n      }\n\n      if (!name.startsWith('/ipns/')) {\n        name = `/ipns/${name}`;\n      }\n\n      const [namespace, hash, ...remainder] = name.slice(1).split('/');\n\n      try {\n        if (hash.substring(0, 1) === '1') {\n          PeerId.parse(hash);\n        } else {\n          CID.parse(hash);\n        }\n      } catch (err) {\n        // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n        if (isDomain(hash)) {\n          yield appendRemainder(yield _awaitAsyncGenerator(dns(hash, options)), remainder);\n          return;\n        }\n\n        log.error(err);\n        throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n      } // multihash is valid lets resolve with IPNS\n      // IPNS resolve needs a online daemon\n\n\n      if (!isOnline() && !offline) {\n        throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n      } // TODO: convert ipns.resolve to return an iterator\n\n\n      const value = yield _awaitAsyncGenerator(ipns.resolve(`/${namespace}/${hash}`, options));\n      yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder);\n    });\n    return _resolve.apply(this, arguments);\n  }\n\n  return withTimeoutOption(resolve);\n};","map":null,"metadata":{},"sourceType":"script"}