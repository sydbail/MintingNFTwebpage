{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst Reader = require('it-reader');\n\nconst log = require('debug')('it-multistream-select:ls');\n\nconst multistream = require('./multistream');\n\nconst handshake = require('it-handshake');\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (stream) {\n    const {\n      reader,\n      writer,\n      rest,\n      stream: shakeStream\n    } = handshake(stream);\n    log('write \"ls\"');\n    multistream.write(writer, 'ls');\n    rest(); // Next message from remote will be (e.g. for 2 protocols):\n    // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n\n    const res = yield multistream.read(reader); // After reading response we have:\n    // <varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n\n    const protocolsReader = Reader([res]);\n    const protocols = []; // Decode each of the protocols from the reader\n\n    yield pipe(protocolsReader, lp.decode(), /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (source) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const protocol = _value;\n            // Remove the newline\n            protocols.push(protocol.shallowSlice(0, -1).toString());\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    return {\n      stream: shakeStream,\n      protocols\n    };\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}