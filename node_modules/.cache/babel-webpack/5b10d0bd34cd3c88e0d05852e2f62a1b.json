{"ast":null,"code":"'use strict';\n\nconst encodings = require('./lib/encodings');\n\nconst rangeOptions = new Set(['lt', 'gt', 'lte', 'gte']);\nmodule.exports = Codec;\n\nfunction Codec(opts) {\n  if (!(this instanceof Codec)) {\n    return new Codec(opts);\n  }\n\n  this.opts = opts || {};\n  this.encodings = encodings;\n}\n\nCodec.prototype._encoding = function (encoding) {\n  if (typeof encoding === 'string') encoding = encodings[encoding];\n  if (!encoding) encoding = encodings.id;\n  return encoding;\n};\n\nCodec.prototype._keyEncoding = function (opts, batchOpts) {\n  return this._encoding(batchOpts && batchOpts.keyEncoding || opts && opts.keyEncoding || this.opts.keyEncoding);\n};\n\nCodec.prototype._valueEncoding = function (opts, batchOpts) {\n  return this._encoding(batchOpts && (batchOpts.valueEncoding || batchOpts.encoding) || opts && (opts.valueEncoding || opts.encoding) || this.opts.valueEncoding || this.opts.encoding);\n};\n\nCodec.prototype.encodeKey = function (key, opts, batchOpts) {\n  return this._keyEncoding(opts, batchOpts).encode(key);\n};\n\nCodec.prototype.encodeValue = function (value, opts, batchOpts) {\n  return this._valueEncoding(opts, batchOpts).encode(value);\n};\n\nCodec.prototype.decodeKey = function (key, opts) {\n  return this._keyEncoding(opts).decode(key);\n};\n\nCodec.prototype.decodeValue = function (value, opts) {\n  return this._valueEncoding(opts).decode(value);\n};\n\nCodec.prototype.encodeBatch = function (ops, opts) {\n  return ops.map(_op => {\n    const op = {\n      type: _op.type,\n      key: this.encodeKey(_op.key, opts, _op)\n    };\n    if (this.keyAsBuffer(opts, _op)) op.keyEncoding = 'binary';\n    if (_op.prefix) op.prefix = _op.prefix;\n\n    if ('value' in _op) {\n      op.value = this.encodeValue(_op.value, opts, _op);\n      if (this.valueAsBuffer(opts, _op)) op.valueEncoding = 'binary';\n    }\n\n    return op;\n  });\n};\n\nCodec.prototype.encodeLtgt = function (ltgt) {\n  const ret = {};\n\n  for (const key of Object.keys(ltgt)) {\n    if (key === 'start' || key === 'end') {\n      throw new Error('Legacy range options (\"start\" and \"end\") have been removed');\n    }\n\n    ret[key] = rangeOptions.has(key) ? this.encodeKey(ltgt[key], ltgt) : ltgt[key];\n  }\n\n  return ret;\n};\n\nCodec.prototype.createStreamDecoder = function (opts) {\n  if (opts.keys && opts.values) {\n    return (key, value) => {\n      return {\n        key: this.decodeKey(key, opts),\n        value: this.decodeValue(value, opts)\n      };\n    };\n  } else if (opts.keys) {\n    return key => {\n      return this.decodeKey(key, opts);\n    };\n  } else if (opts.values) {\n    return (_, value) => {\n      return this.decodeValue(value, opts);\n    };\n  } else {\n    return function () {};\n  }\n};\n\nCodec.prototype.keyAsBuffer = function (opts) {\n  return this._keyEncoding(opts).buffer;\n};\n\nCodec.prototype.valueAsBuffer = function (opts) {\n  return this._valueEncoding(opts).buffer;\n};","map":null,"metadata":{},"sourceType":"script"}