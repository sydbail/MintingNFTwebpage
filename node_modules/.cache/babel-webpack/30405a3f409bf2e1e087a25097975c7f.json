{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logLike64 = exports.halve64 = exports.add64 = exports.negative64 = exports.substract64 = exports.clone64 = exports.isStrictlySmaller64 = exports.isEqual64 = exports.isStrictlyPositive64 = exports.isStrictlyNegative64 = exports.isZero64 = exports.Unit64 = exports.Zero64 = void 0;\nexports.Zero64 = {\n  sign: 1,\n  data: [0, 0]\n};\nexports.Unit64 = {\n  sign: 1,\n  data: [0, 1]\n};\n\nfunction isZero64(a) {\n  return a.data[0] === 0 && a.data[1] === 0;\n}\n\nexports.isZero64 = isZero64;\n\nfunction isStrictlyNegative64(a) {\n  return a.sign === -1 && !isZero64(a);\n}\n\nexports.isStrictlyNegative64 = isStrictlyNegative64;\n\nfunction isStrictlyPositive64(a) {\n  return a.sign === 1 && !isZero64(a);\n}\n\nexports.isStrictlyPositive64 = isStrictlyPositive64;\n\nfunction isEqual64(a, b) {\n  if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) {\n    return a.sign === b.sign || a.data[0] === 0 && a.data[1] === 0;\n  }\n\n  return false;\n}\n\nexports.isEqual64 = isEqual64;\n\nfunction isStrictlySmaller64Internal(a, b) {\n  return a[0] < b[0] || a[0] === b[0] && a[1] < b[1];\n}\n\nfunction isStrictlySmaller64(a, b) {\n  if (a.sign === b.sign) {\n    return a.sign === 1 ? isStrictlySmaller64Internal(a.data, b.data) : isStrictlySmaller64Internal(b.data, a.data);\n  }\n\n  return a.sign === -1 && (!isZero64(a) || !isZero64(b));\n}\n\nexports.isStrictlySmaller64 = isStrictlySmaller64;\n\nfunction clone64(a) {\n  return {\n    sign: a.sign,\n    data: [a.data[0], a.data[1]]\n  };\n}\n\nexports.clone64 = clone64;\n\nfunction substract64DataInternal(a, b) {\n  let reminderLow = 0;\n  let low = a[1] - b[1];\n\n  if (low < 0) {\n    reminderLow = 1;\n    low = low >>> 0;\n  }\n\n  return [a[0] - b[0] - reminderLow, low];\n}\n\nfunction substract64Internal(a, b) {\n  if (a.sign === 1 && b.sign === -1) {\n    const low = a.data[1] + b.data[1];\n    const high = a.data[0] + b.data[0] + (low > 0xffffffff ? 1 : 0);\n    return {\n      sign: 1,\n      data: [high >>> 0, low >>> 0]\n    };\n  }\n\n  return {\n    sign: 1,\n    data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data)\n  };\n}\n\nfunction substract64(arrayIntA, arrayIntB) {\n  if (isStrictlySmaller64(arrayIntA, arrayIntB)) {\n    const out = substract64Internal(arrayIntB, arrayIntA);\n    out.sign = -1;\n    return out;\n  }\n\n  return substract64Internal(arrayIntA, arrayIntB);\n}\n\nexports.substract64 = substract64;\n\nfunction negative64(arrayIntA) {\n  return {\n    sign: -arrayIntA.sign,\n    data: [arrayIntA.data[0], arrayIntA.data[1]]\n  };\n}\n\nexports.negative64 = negative64;\n\nfunction add64(arrayIntA, arrayIntB) {\n  if (isZero64(arrayIntB)) {\n    if (isZero64(arrayIntA)) {\n      return clone64(exports.Zero64);\n    }\n\n    return clone64(arrayIntA);\n  }\n\n  return substract64(arrayIntA, negative64(arrayIntB));\n}\n\nexports.add64 = add64;\n\nfunction halve64(a) {\n  return {\n    sign: a.sign,\n    data: [Math.floor(a.data[0] / 2), (a.data[0] % 2 === 1 ? 0x80000000 : 0) + Math.floor(a.data[1] / 2)]\n  };\n}\n\nexports.halve64 = halve64;\n\nfunction logLike64(a) {\n  return {\n    sign: a.sign,\n    data: [0, Math.floor(Math.log(a.data[0] * 0x100000000 + a.data[1]) / Math.log(2))]\n  };\n}\n\nexports.logLike64 = logLike64;","map":null,"metadata":{},"sourceType":"script"}