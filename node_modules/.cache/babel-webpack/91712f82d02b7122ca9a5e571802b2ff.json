{"ast":null,"code":"'use strict'; // @ts-ignore no types\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst toUri = require('multiaddr-to-uri');\n\nconst debug = require('debug');\n\nconst shuffle = require('array-shuffle');\n\nconst {\n  AbortController\n} = require('native-abort-controller');\n\nconst preload = require('./runtime/preload-nodejs');\n/** @type {typeof import('hashlru').default} */\n// @ts-ignore - hashlru has incorrect typedefs\n\n\nconst hashlru = require('hashlru');\n\nconst log = Object.assign(debug('ipfs:preload'), {\n  error: debug('ipfs:preload:error')\n});\n/**\n * @param {import('./types').PreloadOptions} [options]\n */\n\nconst createPreloader = (options = {}) => {\n  options.enabled = Boolean(options.enabled);\n  options.addresses = options.addresses || [];\n  options.cache = options.cache || 1000;\n\n  if (!options.enabled || !options.addresses.length) {\n    log('preload disabled');\n\n    const api = () => {};\n\n    return Object.assign(api, {\n      start: () => {},\n      stop: () => {}\n    });\n  }\n\n  let stopped = true;\n  /** @type {AbortController[]} */\n\n  let requests = [];\n  const apiUris = options.addresses.map(toUri); // Avoid preloading the same CID over and over again\n\n  const cache = hashlru(options.cache);\n  /**\n   * @type {import('./types').Preload}\n   */\n\n  const api = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (cid) {\n      try {\n        if (stopped) {\n          throw new Error(`preload ${cid} but preloader is not started`);\n        }\n\n        const path = cid.toString();\n\n        if (cache.has(path)) {\n          // we've preloaded this recently, don't preload it again\n          return;\n        } // make sure we don't preload this again any time soon\n\n\n        cache.set(path, true);\n        const fallbackApiUris = shuffle(apiUris);\n        let success = false;\n        const now = Date.now();\n\n        for (const uri of fallbackApiUris) {\n          if (stopped) throw new Error(`preload aborted for ${path}`);\n          /** @type {AbortController} */\n\n          let controller;\n\n          try {\n            controller = new AbortController();\n            requests = requests.concat(controller);\n            yield preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path)}`, {\n              signal: controller.signal\n            });\n            success = true;\n          } catch (err) {\n            if (err.type !== 'aborted') log.error(err);\n          } finally {\n            requests = requests.filter(r => r !== controller);\n          }\n\n          if (success) break;\n        }\n\n        log(`${success ? '' : 'un'}successfully preloaded ${path} in ${Date.now() - now}ms`);\n      } catch (err) {\n        log.error(err);\n      }\n    });\n\n    return function api(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * @returns {void}\n   */\n\n\n  api.start = () => {\n    stopped = false;\n  };\n  /**\n   * @returns {void}\n   */\n\n\n  api.stop = () => {\n    stopped = true;\n    log(`aborting ${requests.length} pending preload request(s)`);\n    requests.forEach(r => r.abort());\n    requests = [];\n  };\n\n  return api;\n};\n\nmodule.exports = createPreloader;","map":null,"metadata":{},"sourceType":"script"}