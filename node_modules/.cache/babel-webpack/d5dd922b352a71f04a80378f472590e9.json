{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\n\nconst hkdf_1 = require(\"@stablelib/hkdf\");\n\nconst sha256_1 = require(\"@stablelib/sha256\");\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\n\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\n\nconst payload_1 = require(\"./proto/payload\");\n\nconst equals_1 = require(\"uint8arrays/equals\");\n\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\n\nfunction generateKeypair() {\n  const keypair = x25519.generateKeyPair();\n  return {\n    publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n    privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n  };\n}\n\nexports.generateKeypair = generateKeypair;\n\nfunction getPayload(_x, _x2, _x3) {\n  return _getPayload.apply(this, arguments);\n}\n\nfunction _getPayload() {\n  _getPayload = _asyncToGenerator(function* (localPeer, staticPublicKey, earlyData) {\n    const signedPayload = yield signPayload(localPeer, getHandshakePayload(staticPublicKey));\n    const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n    return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n  });\n  return _getPayload.apply(this, arguments);\n}\n\nexports.getPayload = getPayload;\n\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n    identitySig: signedPayload,\n    data: earlyData !== null && earlyData !== void 0 ? earlyData : null\n  });\n  return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\n\nexports.createHandshakePayload = createHandshakePayload;\n\nfunction signPayload(_x4, _x5) {\n  return _signPayload.apply(this, arguments);\n}\n\nfunction _signPayload() {\n  _signPayload = _asyncToGenerator(function* (peerId, payload) {\n    return buffer_1.Buffer.from(yield peerId.privKey.sign(payload));\n  });\n  return _signPayload.apply(this, arguments);\n}\n\nexports.signPayload = signPayload;\n\nfunction getPeerIdFromPayload(_x6) {\n  return _getPeerIdFromPayload.apply(this, arguments);\n}\n\nfunction _getPeerIdFromPayload() {\n  _getPeerIdFromPayload = _asyncToGenerator(function* (payload) {\n    return yield peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n  });\n  return _getPeerIdFromPayload.apply(this, arguments);\n}\n\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\n\nfunction decodePayload(payload) {\n  return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\n\nexports.decodePayload = decodePayload;\n\nfunction getHandshakePayload(publicKey) {\n  return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\n\nexports.getHandshakePayload = getHandshakePayload;\n\nfunction isValidPeerId(_x7, _x8) {\n  return _isValidPeerId.apply(this, arguments);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\n\n\nfunction _isValidPeerId() {\n  _isValidPeerId = _asyncToGenerator(function* (peerId, publicKeyProtobuf) {\n    const generatedPeerId = yield peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n    return equals_1.equals(generatedPeerId.id, peerId);\n  });\n  return _isValidPeerId.apply(this, arguments);\n}\n\nfunction verifySignedPayload(_x9, _x10, _x11) {\n  return _verifySignedPayload.apply(this, arguments);\n}\n\nfunction _verifySignedPayload() {\n  _verifySignedPayload = _asyncToGenerator(function* (noiseStaticKey, payload, remotePeer) {\n    const identityKey = buffer_1.Buffer.from(payload.identityKey);\n\n    if (!(yield isValidPeerId(remotePeer.id, identityKey))) {\n      throw new Error(\"Peer ID doesn't match libp2p public key.\");\n    }\n\n    const generatedPayload = getHandshakePayload(noiseStaticKey); // Unmarshaling from PublicKey protobuf\n\n    const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey); // TODO remove this after libp2p-crypto ships proper types\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n    if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {\n      throw new Error(\"Static key doesn't match to peer that signed payload!\");\n    }\n\n    return yield peer_id_1.default.createFromPubKey(identityKey);\n  });\n  return _verifySignedPayload.apply(this, arguments);\n}\n\nexports.verifySignedPayload = verifySignedPayload;\n\nfunction getHkdf(ck, ikm) {\n  const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);\n  const okmU8Array = hkdf.expand(96);\n  const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);\n  const k1 = okm.slice(0, 32);\n  const k2 = okm.slice(32, 64);\n  const k3 = okm.slice(64, 96);\n  return [k1, k2, k3];\n}\n\nexports.getHkdf = getHkdf;\n\nfunction isValidPublicKey(pk) {\n  if (!buffer_1.Buffer.isBuffer(pk)) {\n    return false;\n  }\n\n  if (pk.length !== 32) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isValidPublicKey = isValidPublicKey; //# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"script"}