{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.one = exports.options = exports.has = void 0;\n/**\n * Asserts at runtime that `options` contains `key`\n */\n\nfunction has(options, key) {\n  // @ts-ignore to get around the fact that we know nothing about O\n  if (options[key] == null) {\n    throw new Error(`Expected parameter '${key}' not passed to function.`);\n  }\n}\n\nexports.has = has;\n/**\n * Asserts at runtime that `options` contains all `expectedKeys`\n */\n\nfunction options(options, expectedKeys) {\n  for (const key of expectedKeys) {\n    has(options, key);\n  }\n}\n\nexports.options = options;\n/**\n * Asserts at runtime that `options` contains at least one of `expectedKeys`\n *\n * Post-condition: this narrows type of `options` to include _exactly one_ of\n * `expectedKeys`, even though at runtime this accepts more than one key.\n */\n\nfunction one(options, expectedKeys) {\n  const found = expectedKeys.some(key => {\n    try {\n      has(options, key);\n      return true;\n    } catch (error) {\n      if (!error.message.includes(`Expected parameter '${key}' not passed to function.`)) {\n        throw error;\n      }\n\n      return false;\n    }\n  }); // If this doesn't work in all cases, perhaps we should\n  // create an expect.onlyOne() function.\n\n  if (!found) {\n    throw new Error(`Expected one of the following parameters, but found none: ${expectedKeys.join(\", \")}`);\n  }\n}\n\nexports.one = one; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script"}