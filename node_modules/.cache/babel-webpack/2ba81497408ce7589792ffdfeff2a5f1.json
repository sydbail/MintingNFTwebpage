{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst getIterator = require('get-iterator');\n\nmodule.exports = writable => /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (source) {\n    source = getIterator(source);\n\n    const maybeEndSource = source => {\n      if (typeof source.return === 'function') source.return();\n    };\n\n    let error = null;\n    let errCb = null;\n\n    const errorHandler = err => {\n      error = err;\n      if (errCb) errCb(err); // When the writable errors, try to end the source to exit iteration early\n\n      maybeEndSource(source);\n    };\n\n    let closeCb = null;\n    let closed = false;\n\n    const closeHandler = () => {\n      closed = true;\n      if (closeCb) closeCb();\n    };\n\n    let finishCb = null;\n    let finished = false;\n\n    const finishHandler = () => {\n      finished = true;\n      if (finishCb) finishCb();\n    };\n\n    let drainCb = null;\n\n    const drainHandler = () => {\n      if (drainCb) drainCb();\n    };\n\n    const waitForDrainOrClose = () => {\n      return new Promise((resolve, reject) => {\n        closeCb = drainCb = resolve;\n        errCb = reject;\n        writable.once('drain', drainHandler);\n      });\n    };\n\n    const waitForDone = () => {\n      // Immediately try to end the source\n      maybeEndSource(source);\n      return new Promise((resolve, reject) => {\n        if (closed || finished || error) return resolve();\n        finishCb = closeCb = resolve;\n        errCb = reject;\n      });\n    };\n\n    const cleanup = () => {\n      writable.removeListener('error', errorHandler);\n      writable.removeListener('close', closeHandler);\n      writable.removeListener('finish', finishHandler);\n      writable.removeListener('drain', drainHandler);\n    };\n\n    writable.once('error', errorHandler);\n    writable.once('close', closeHandler);\n    writable.once('finish', finishHandler);\n\n    try {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const value = _value;\n          if (!writable.writable || writable.destroyed || error) break;\n\n          if (writable.write(value) === false) {\n            yield waitForDrainOrClose();\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } catch (err) {\n      // error is set by stream error handler so only destroy stream if source threw\n      if (!error) {\n        writable.destroy();\n      } // could we be obscuring an error here?\n\n\n      error = err;\n    }\n\n    try {\n      // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n      if (writable.writable) {\n        writable.end();\n      } // Wait until we close or finish. This supports halfClosed streams\n\n\n      yield waitForDone(); // Notify the user an error occurred\n\n      if (error) throw error;\n    } finally {\n      // Clean up listeners\n      cleanup();\n    }\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}