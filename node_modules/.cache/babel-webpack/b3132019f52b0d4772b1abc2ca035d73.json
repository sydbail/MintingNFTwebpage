{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst pushable = require('it-pushable');\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n *\n * @template T\n * @param {...AsyncIterable<T>|Iterable<T>} sources\n * @returns {AsyncIterable<T>}\n */\n\n\nconst merge = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (...sources) {\n    const output = pushable();\n    setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n      try {\n        yield Promise.all(sources.map( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (source) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n\n            var _iteratorError;\n\n            try {\n              for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n                const item = _value;\n                output.push(item);\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          });\n\n          return function (_x) {\n            return _ref3.apply(this, arguments);\n          };\n        }()));\n        output.end();\n      } catch (err) {\n        output.end(err);\n      }\n    }), 0);\n    yield* _asyncGeneratorDelegate(_asyncIterator(output), _awaitAsyncGenerator);\n  });\n\n  return function merge() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = merge;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/it-merge/index.js"],"names":["pushable","require","merge","sources","output","setTimeout","Promise","all","map","source","item","push","end","err","module","exports"],"mappings":"AAAA;;;;;;;;;;;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,aAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,KAAK;AAAA,iCAAG,WAAkB,GAAGC,OAArB,EAA8B;AAC1C,UAAMC,MAAM,GAAGJ,QAAQ,EAAvB;AAEAK,IAAAA,UAAU,iCAAC,aAAY;AACrB,UAAI;AACF,cAAMC,OAAO,CAACC,GAAR,CACJJ,OAAO,CAACK,GAAR;AAAA,wCAAY,WAAOC,MAAP,EAAkB;AAAA;AAAA;;AAAA;;AAAA;AAC5B,kDAAyBA,MAAzB,oLAAiC;AAAA,sBAAhBC,IAAgB;AAC/BN,gBAAAA,MAAM,CAACO,IAAP,CAAYD,IAAZ;AACD;AAH2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAI7B,WAJD;;AAAA;AAAA;AAAA;AAAA,YADI,CAAN;AAQAN,QAAAA,MAAM,CAACQ,GAAP;AACD,OAVD,CAUE,OAAOC,GAAP,EAAY;AACZT,QAAAA,MAAM,CAACQ,GAAP,CAAWC,GAAX;AACD;AACF,KAdS,GAcP,CAdO,CAAV;AAgBA,kDAAQT,MAAR;AACD,GApBU;;AAAA,kBAALF,KAAK;AAAA;AAAA;AAAA,GAAX;;AAsBAY,MAAM,CAACC,OAAP,GAAiBb,KAAjB","sourcesContent":["'use strict'\n\nconst pushable = require('it-pushable')\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n *\n * @template T\n * @param {...AsyncIterable<T>|Iterable<T>} sources\n * @returns {AsyncIterable<T>}\n */\nconst merge = async function * (...sources) {\n  const output = pushable()\n\n  setTimeout(async () => {\n    try {\n      await Promise.all(\n        sources.map(async (source) => {\n          for await (const item of source) {\n            output.push(item)\n          }\n        })\n      )\n\n      output.end()\n    } catch (err) {\n      output.end(err)\n    }\n  }, 0)\n\n  yield * output\n}\n\nmodule.exports = merge\n"]},"metadata":{},"sourceType":"script"}