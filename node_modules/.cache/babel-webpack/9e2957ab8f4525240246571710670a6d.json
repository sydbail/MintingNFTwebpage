{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst errCode = require('err-code');\n\nconst {\n  parallelMap,\n  filter\n} = require('streaming-iterables');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  cleanCid\n} = require('./utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst BLOCK_RM_CONCURRENCY = 8;\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\nmodule.exports = ({\n  repo\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/block').API[\"rm\"]}\n   */\n  function rm(_x) {\n    return _rm.apply(this, arguments);\n  }\n\n  function _rm() {\n    _rm = _wrapAsyncGenerator(function* (cids, options = {}) {\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      } // We need to take a write lock here to ensure that adding and removing\n      // blocks are exclusive operations\n\n\n      const release = yield _awaitAsyncGenerator(repo.gcLock.writeLock());\n\n      try {\n        yield* _asyncGeneratorDelegate(_asyncIterator(pipe(cids, parallelMap(BLOCK_RM_CONCURRENCY, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (cid) {\n            cid = cleanCid(cid);\n            /** @type {import('ipfs-core-types/src/block').RmResult} */\n\n            const result = {\n              cid\n            };\n\n            try {\n              const has = yield repo.blocks.has(cid);\n\n              if (!has) {\n                throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');\n              }\n\n              yield repo.blocks.delete(cid);\n            } catch (err) {\n              if (!options.force) {\n                err.message = `cannot remove ${cid}: ${err.message}`;\n                result.error = err;\n              }\n            }\n\n            return result;\n          });\n\n          return function (_x2) {\n            return _ref.apply(this, arguments);\n          };\n        }()), filter(() => !options.quiet))), _awaitAsyncGenerator);\n      } finally {\n        release();\n      }\n    });\n    return _rm.apply(this, arguments);\n  }\n\n  return withTimeoutOption(rm);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/components/block/rm.js"],"names":["errCode","require","parallelMap","filter","pipe","cleanCid","withTimeoutOption","BLOCK_RM_CONCURRENCY","module","exports","repo","rm","cids","options","Array","isArray","release","gcLock","writeLock","cid","result","has","blocks","Error","delete","err","force","message","error","quiet"],"mappings":"AAAA;;;;;;;;;;;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA,WAAF;AAAeC,EAAAA;AAAf,IAA0BF,OAAO,CAAC,qBAAD,CAAvC;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAWH,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAeJ,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAMK,iBAAiB,GAAGL,OAAO,CAAC,yCAAD,CAAjC;;AAEA,MAAMM,oBAAoB,GAAG,CAA7B;AAEA;AACA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAAc;AAC7B;AACF;AACA;AAH+B,WAIZC,EAJY;AAAA;AAAA;;AAAA;AAAA,8BAI7B,WAAqBC,IAArB,EAA2BC,OAAO,GAAG,EAArC,EAAyC;AACvC,UAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,IAAd,CAAL,EAA0B;AACxBA,QAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD,OAHsC,CAKvC;AACA;;;AACA,YAAMI,OAAO,8BAASN,IAAI,CAACO,MAAL,CAAYC,SAAZ,EAAT,CAAb;;AAEA,UAAI;AACF,sDAAQd,IAAI,CACVQ,IADU,EAEVV,WAAW,CAACK,oBAAD;AAAA,uCAAuB,WAAMY,GAAN,EAAa;AAC7CA,YAAAA,GAAG,GAAGd,QAAQ,CAACc,GAAD,CAAd;AAEA;;AACA,kBAAMC,MAAM,GAAG;AAAED,cAAAA;AAAF,aAAf;;AAEA,gBAAI;AACF,oBAAME,GAAG,SAASX,IAAI,CAACY,MAAL,CAAYD,GAAZ,CAAgBF,GAAhB,CAAlB;;AAEA,kBAAI,CAACE,GAAL,EAAU;AACR,sBAAMrB,OAAO,CAAC,IAAIuB,KAAJ,CAAU,iBAAV,CAAD,EAA+B,qBAA/B,CAAb;AACD;;AAED,oBAAMb,IAAI,CAACY,MAAL,CAAYE,MAAZ,CAAmBL,GAAnB,CAAN;AACD,aARD,CAQE,OAAOM,GAAP,EAAY;AACZ,kBAAI,CAACZ,OAAO,CAACa,KAAb,EAAoB;AAClBD,gBAAAA,GAAG,CAACE,OAAJ,GAAe,iBAAgBR,GAAI,KAAIM,GAAG,CAACE,OAAQ,EAAnD;AACAP,gBAAAA,MAAM,CAACQ,KAAP,GAAeH,GAAf;AACD;AACF;;AAED,mBAAOL,MAAP;AACD,WAtBU;;AAAA;AAAA;AAAA;AAAA,YAFD,EAyBVjB,MAAM,CAAC,MAAM,CAACU,OAAO,CAACgB,KAAhB,CAzBI,CAAZ;AA2BD,OA5BD,SA4BU;AACRb,QAAAA,OAAO;AACR;AACF,KA5C4B;AAAA;AAAA;;AA8C7B,SAAOV,iBAAiB,CAACK,EAAD,CAAxB;AACD,CA/CD","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { parallelMap, filter } = require('streaming-iterables')\nconst { pipe } = require('it-pipe')\nconst { cleanCid } = require('./utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\nconst BLOCK_RM_CONCURRENCY = 8\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ repo }) => {\n  /**\n   * @type {import('ipfs-core-types/src/block').API[\"rm\"]}\n   */\n  async function * rm (cids, options = {}) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n    const release = await repo.gcLock.writeLock()\n\n    try {\n      yield * pipe(\n        cids,\n        parallelMap(BLOCK_RM_CONCURRENCY, async cid => {\n          cid = cleanCid(cid)\n\n          /** @type {import('ipfs-core-types/src/block').RmResult} */\n          const result = { cid }\n\n          try {\n            const has = await repo.blocks.has(cid)\n\n            if (!has) {\n              throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND')\n            }\n\n            await repo.blocks.delete(cid)\n          } catch (err) {\n            if (!options.force) {\n              err.message = `cannot remove ${cid}: ${err.message}`\n              result.error = err\n            }\n          }\n\n          return result\n        }),\n        filter(() => !options.quiet)\n      )\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(rm)\n}\n"]},"metadata":{},"sourceType":"script"}