{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require(\"debug\")(\"contract:manual-send\");\n\nconst ethers = require(\"ethers\");\n\nconst Utils = require(\"./utils\");\n\nconst {\n  formatters\n} = require(\"web3-core-helpers\"); //used for reproducing web3's behavior\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\n\n\nfunction sendTransactionManual(_x, _x2, _x3) {\n  return _sendTransactionManual.apply(this, arguments);\n}\n\nfunction _sendTransactionManual() {\n  _sendTransactionManual = _asyncToGenerator(function* (web3, params, promiEvent) {\n    debug(\"executing manually!\"); //set up ethers provider\n\n    const ethersProvider = new ethers.providers.Web3Provider(web3.currentProvider); //let's clone params and set it up properly\n\n    const {\n      transaction,\n      from\n    } = setUpParameters(params, web3); //now: if the from address is in the wallet, web3 will sign the transaction before\n    //sending, so we have to account for that\n\n    const account = web3.eth.accounts.wallet[from];\n    const ethersSigner = account ? new ethers.Wallet(account.privateKey, ethersProvider) : ethersProvider.getSigner(from);\n    debug(\"got signer\");\n    let txHash, receipt, ethersResponse;\n\n    try {\n      //note: the following code won't work with ethers v5.\n      //wth ethers v5, in the getSigner() case, you'll need to\n      //use sendUncheckedTransaction instead of sendTransaction.\n      //I don't know why.\n      ethersResponse = yield ethersSigner.sendTransaction(transaction);\n      txHash = ethersResponse.hash;\n      receipt = yield ethersProvider.waitForTransaction(txHash);\n      debug(\"no error\");\n    } catch (error) {\n      ({\n        txHash,\n        receipt\n      } = handleError(error));\n\n      if (!receipt) {\n        receipt = yield ethersProvider.waitForTransaction(txHash);\n      }\n    }\n\n    debug(\"txHash: %s\", txHash);\n    receipt = translateReceipt(receipt);\n    promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n\n    return yield handleResult(receipt, transaction.to == null);\n  });\n  return _sendTransactionManual.apply(this, arguments);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n\n  if (error.data && Object.keys(error.data).length === 3) {\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(key => key !== \"stack\" && key !== \"name\");\n    return {\n      txHash: transactionHash\n    };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nfunction handleResult(_x4, _x5) {\n  return _handleResult.apply(this, arguments);\n}\n\nfunction _handleResult() {\n  _handleResult = _asyncToGenerator(function* (receipt, isDeployment) {\n    const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n\n    if (receipt.status) {\n      if (isDeployment) {\n        //in the deployment case, web3 might error even when technically successful @_@\n        if ((yield web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n          throw new Error(deploymentFailedMessage);\n        }\n      }\n\n      return receipt;\n    } else {\n      //otherwise: we have to mimic web3's errors @_@\n      if (isDeployment) {\n        //deployment case\n        throw new Error(deploymentFailedMessage);\n      }\n\n      throw new Error(\"Transaction has been reverted by the EVM:\" + \"\\n\" + JSON.stringify(receipt));\n    }\n  });\n  return _handleResult.apply(this, arguments);\n}\n\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from = transaction.from != undefined ? transaction.from : web3.eth.defaultAccount; //now let's have web3 check our inputs\n\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas; //also, it insists \"from\" be kept separate\n\n  const {\n    from\n  } = transaction;\n  delete transaction.from;\n  return {\n    transaction,\n    from\n  };\n} //translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\n\n\nfunction translateReceipt(receipt) {\n  return Object.assign({}, ...Object.entries(receipt).map(([key, value]) => ({\n    [key]: Utils.is_big_number(value) ? value.toNumber() : value\n  })));\n}\n\nmodule.exports = {\n  sendTransactionManual\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/@truffle/contract/lib/manual-send.js"],"names":["debug","require","ethers","Utils","formatters","sendTransactionManual","web3","params","promiEvent","ethersProvider","providers","Web3Provider","currentProvider","transaction","from","setUpParameters","account","eth","accounts","wallet","ethersSigner","Wallet","privateKey","getSigner","txHash","receipt","ethersResponse","sendTransaction","hash","waitForTransaction","error","handleError","translateReceipt","setTransactionHash","handleResult","to","data","Object","keys","length","transactionHash","find","key","isDeployment","deploymentFailedMessage","status","getCode","contractAddress","Error","JSON","stringify","assign","undefined","defaultAccount","inputTransactionFormatter","gasLimit","gas","entries","map","value","is_big_number","toNumber","module","exports"],"mappings":"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","sourcesContent":["const debug = require(\"debug\")(\"contract:manual-send\");\nconst ethers = require(\"ethers\");\nconst Utils = require (\"./utils\");\nconst { formatters } = require(\"web3-core-helpers\"); //used for reproducing web3's behavior\n\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\nasync function sendTransactionManual(web3, params, promiEvent) {\n  debug(\"executing manually!\");\n  //set up ethers provider\n  const ethersProvider = new ethers.providers.Web3Provider(\n    web3.currentProvider\n  );\n  //let's clone params and set it up properly\n  const { transaction, from } = setUpParameters(params, web3);\n  //now: if the from address is in the wallet, web3 will sign the transaction before\n  //sending, so we have to account for that\n  const account = web3.eth.accounts.wallet[from];\n  const ethersSigner = account\n    ? new ethers.Wallet(account.privateKey, ethersProvider)\n    : ethersProvider.getSigner(from);\n  debug(\"got signer\");\n  let txHash, receipt, ethersResponse;\n  try {\n    //note: the following code won't work with ethers v5.\n    //wth ethers v5, in the getSigner() case, you'll need to\n    //use sendUncheckedTransaction instead of sendTransaction.\n    //I don't know why.\n    ethersResponse = await ethersSigner.sendTransaction(transaction);\n    txHash = ethersResponse.hash;\n    receipt = await ethersProvider.waitForTransaction(txHash);\n    debug(\"no error\");\n  } catch (error) {\n    ({ txHash, receipt } = handleError(error));\n    if (!receipt) {\n      receipt = await ethersProvider.waitForTransaction(txHash);\n    }\n  }\n  debug(\"txHash: %s\", txHash);\n  receipt = translateReceipt(receipt);\n  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n  return await handleResult(receipt, transaction.to == null);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n  if (error.data && Object.keys(error.data).length === 3) {\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(\n      key => key !== \"stack\" && key !== \"name\"\n    );\n    return { txHash: transactionHash };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nasync function handleResult(receipt, isDeployment) {\n  const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n  if (receipt.status) {\n    if (isDeployment) {\n      //in the deployment case, web3 might error even when technically successful @_@\n      if ((await web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n        throw new Error(deploymentFailedMessage);\n      }\n    }\n    return receipt;\n  } else {\n    //otherwise: we have to mimic web3's errors @_@\n    if (isDeployment) {\n      //deployment case\n      throw new Error(deploymentFailedMessage);\n    }\n    throw new Error(\n      \"Transaction has been reverted by the EVM:\" +\n        \"\\n\" +\n        JSON.stringify(receipt)\n    );\n  }\n}\n\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from =\n    transaction.from != undefined\n      ? transaction.from\n      : web3.eth.defaultAccount;\n  //now let's have web3 check our inputs\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas;\n  //also, it insists \"from\" be kept separate\n  const { from } = transaction;\n  delete transaction.from;\n  return { transaction, from }\n}\n\n//translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\nfunction translateReceipt(receipt) {\n  return Object.assign({},\n    ...Object.entries(receipt).map(([key, value]) => ({\n      [key]: Utils.is_big_number(value)\n        ? value.toNumber()\n        : value\n    }))\n  );\n}\n\nmodule.exports = {\n  sendTransactionManual\n}\n"]},"metadata":{},"sourceType":"script"}