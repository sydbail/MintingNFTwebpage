{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { CID } from 'multiformats/cid';\nimport { createEncoder, createHeader } from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport { bytesReader, readHeader } from './decoder.js';\nexport class CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n\n  put(block) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n        throw new TypeError('Can only write {cid, bytes} objects');\n      }\n\n      if (_this._ended) {\n        throw new Error('Already closed');\n      }\n\n      const cid = CID.asCID(block.cid);\n\n      if (!cid) {\n        throw new TypeError('Can only write {cid, bytes} objects');\n      }\n\n      _this._mutex = _this._mutex.then(() => _this._encoder.writeBlock({\n        cid,\n        bytes: block.bytes\n      }));\n      return _this._mutex;\n    })();\n  }\n\n  close() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2._ended) {\n        throw new Error('Already closed');\n      }\n\n      yield _this2._mutex;\n      _this2._ended = true;\n      return _this2._encoder.close();\n    })();\n  }\n\n  static create(roots) {\n    roots = toRoots(roots);\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n\n  static createAppender() {\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n\n    encoder.setRoots = () => Promise.resolve();\n\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n\n  static updateRootsInBytes(bytes, roots) {\n    return _asyncToGenerator(function* () {\n      const reader = bytesReader(bytes);\n      yield readHeader(reader);\n      const newHeader = createHeader(roots);\n\n      if (reader.pos !== newHeader.length) {\n        throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);\n      }\n\n      bytes.set(newHeader, 0);\n      return bytes;\n    })();\n  }\n\n}\nexport class CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n\n    this._iterating = true;\n    return this._iterator;\n  }\n\n}\n\nfunction encodeWriter() {\n  const iw = iteratorChannel();\n  const {\n    writer,\n    iterator\n  } = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\n\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    return [cid];\n  }\n\n  const _roots = [];\n\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    _roots.push(_root);\n  }\n\n  return _roots;\n}\n\nexport const __browser = true;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/@ipld/car/esm/lib/writer-browser.js"],"names":["CID","createEncoder","createHeader","create","iteratorChannel","bytesReader","readHeader","CarWriter","constructor","roots","encoder","_encoder","_mutex","setRoots","_ended","put","block","bytes","Uint8Array","cid","TypeError","Error","asCID","then","writeBlock","close","toRoots","iterator","encodeWriter","writer","out","CarWriterOut","createAppender","Promise","resolve","updateRootsInBytes","reader","newHeader","pos","length","set","_iterator","Symbol","asyncIterator","_iterating","iw","undefined","Array","isArray","_roots","root","_root","push","__browser"],"mappings":"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","sourcesContent":["import { CID } from 'multiformats/cid';\nimport {\n  createEncoder,\n  createHeader\n} from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport {\n  bytesReader,\n  readHeader\n} from './decoder.js';\nexport class CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    const cid = CID.asCID(block.cid);\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n  static create(roots) {\n    roots = toRoots(roots);\n    const {encoder, iterator} = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static createAppender() {\n    const {encoder, iterator} = encodeWriter();\n    encoder.setRoots = () => Promise.resolve();\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = bytesReader(bytes);\n    await readHeader(reader);\n    const newHeader = createHeader(roots);\n    if (reader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${ reader.pos } bytes, new header is ${ newHeader.length } bytes)`);\n    }\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n}\nexport class CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n    this._iterating = true;\n    return this._iterator;\n  }\n}\nfunction encodeWriter() {\n  const iw = iteratorChannel();\n  const {writer, iterator} = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid];\n  }\n  const _roots = [];\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    _roots.push(_root);\n  }\n  return _roots;\n}\nexport const __browser = true;"]},"metadata":{},"sourceType":"module"}