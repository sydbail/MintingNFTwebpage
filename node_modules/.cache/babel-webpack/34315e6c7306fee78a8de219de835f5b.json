{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst batch = require('it-batch');\n/**\n * @template T\n * @typedef {{ok:true, value:T}} Success\n */\n\n/**\n * @typedef {{ok:false, err:Error}} Failure\n */\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n *\n * @template T\n * @param {AsyncIterable<() => Promise<T>>} source\n * @param {number} [size=1]\n * @returns {AsyncIterable<T>}\n */\n\n\nfunction parallelBatch(_x) {\n  return _parallelBatch.apply(this, arguments);\n}\n\nfunction _parallelBatch() {\n  _parallelBatch = _wrapAsyncGenerator(function* (source, size = 1) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(batch(source, size)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const tasks = _value;\n\n        /** @type {Promise<Success<T>|Failure>[]} */\n        const things = tasks.map(\n        /**\n         * @param {() => Promise<T>} p\n         */\n        p => {\n          return p().then(value => ({\n            ok: true,\n            value\n          }), err => ({\n            ok: false,\n            err\n          }));\n        });\n\n        for (let i = 0; i < things.length; i++) {\n          const result = yield _awaitAsyncGenerator(things[i]);\n\n          if (result.ok) {\n            yield result.value;\n          } else {\n            throw result.err;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return _parallelBatch.apply(this, arguments);\n}\n\nmodule.exports = parallelBatch;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/it-parallel-batch/index.js"],"names":["batch","require","parallelBatch","source","size","tasks","things","map","p","then","value","ok","err","i","length","result","module","exports"],"mappings":"AAAA;;;;;;;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAArB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACiBC,a;;;;;uCAAjB,WAAgCC,MAAhC,EAAwCC,IAAI,GAAG,CAA/C,EAAkD;AAAA;AAAA;;AAAA;;AAAA;AAChD,0CAA0BJ,KAAK,CAACG,MAAD,EAASC,IAAT,CAA/B,gOAA+C;AAAA,cAA9BC,KAA8B;;AAC7C;AACA,cAAMC,MAAM,GAAGD,KAAK,CAACE,GAAN;AACb;AACN;AACA;AACMC,QAAAA,CAAC,IAAI;AACH,iBAAOA,CAAC,GAAGC,IAAJ,CAASC,KAAK,KAAK;AAAEC,YAAAA,EAAE,EAAE,IAAN;AAAYD,YAAAA;AAAZ,WAAL,CAAd,EAAyCE,GAAG,KAAK;AAAED,YAAAA,EAAE,EAAE,KAAN;AAAaC,YAAAA;AAAb,WAAL,CAA5C,CAAP;AACD,SANY,CAAf;;AAQA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,MAAM,CAACQ,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,gBAAME,MAAM,8BAAST,MAAM,CAACO,CAAD,CAAf,CAAZ;;AAEA,cAAIE,MAAM,CAACJ,EAAX,EAAe;AACb,kBAAMI,MAAM,CAACL,KAAb;AACD,WAFD,MAEO;AACL,kBAAMK,MAAM,CAACH,GAAb;AACD;AACF;AACF;AApB+C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBjD,G;;;;AAEDI,MAAM,CAACC,OAAP,GAAiBf,aAAjB","sourcesContent":["'use strict'\n\nconst batch = require('it-batch')\n\n/**\n * @template T\n * @typedef {{ok:true, value:T}} Success\n */\n\n/**\n * @typedef {{ok:false, err:Error}} Failure\n */\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n *\n * @template T\n * @param {AsyncIterable<() => Promise<T>>} source\n * @param {number} [size=1]\n * @returns {AsyncIterable<T>}\n */\nasync function * parallelBatch (source, size = 1) {\n  for await (const tasks of batch(source, size)) {\n    /** @type {Promise<Success<T>|Failure>[]} */\n    const things = tasks.map(\n      /**\n       * @param {() => Promise<T>} p\n       */\n      p => {\n        return p().then(value => ({ ok: true, value }), err => ({ ok: false, err }))\n      })\n\n    for (let i = 0; i < things.length; i++) {\n      const result = await things[i]\n\n      if (result.ok) {\n        yield result.value\n      } else {\n        throw result.err\n      }\n    }\n  }\n}\n\nmodule.exports = parallelBatch\n"]},"metadata":{},"sourceType":"script"}