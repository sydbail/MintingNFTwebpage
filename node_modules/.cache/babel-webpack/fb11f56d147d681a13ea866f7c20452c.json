{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Web3Shim,\n  createInterfaceAdapter\n} = require(\"@truffle/interface-adapter\");\n\nconst utils = require(\"../utils\");\n\nconst execute = require(\"../execute\");\n\nconst bootstrap = require(\"./bootstrap\");\n\nconst debug = require(\"debug\")(\"contract:contract:constructorMethods\");\n\nconst OS = require(\"os\");\n\nmodule.exports = Contract => ({\n  configureNetwork({\n    networkType,\n    provider\n  } = {}) {\n    // otherwise use existing value as default (at most one of these)\n    networkType = networkType || this.networkType;\n    provider = provider || this.currentProvider; // recreate interfaceadapter\n\n    this.interfaceAdapter = createInterfaceAdapter({\n      networkType,\n      provider\n    });\n\n    if (this.web3) {\n      // update existing\n      this.web3.setNetworkType(networkType);\n      this.web3.setProvider(provider);\n    } else {\n      // create new\n      this.web3 = new Web3Shim({\n        networkType,\n        provider\n      });\n    } // save properties\n\n\n    this.currentProvider = provider;\n    this.networkType = networkType;\n  },\n\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(`Invalid provider passed to setProvider(); provider is ${provider}`);\n    }\n\n    this.configureNetwork({\n      provider\n    });\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(`${this.contractName} error: contract binary not set. Can't deploy new instance.\\n` + `This contract may be abstract, not implement an abstract parent's methods completely\\n` + `or not invoke an inherited contract's constructor correctly\\n`);\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  at(address) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (address == null || typeof address !== \"string\" || address.length !== 42) {\n        throw new Error(`Invalid address passed to ${_this.contractName}.at(): ${address}`);\n      }\n\n      yield _this.detectNetwork();\n      const onChainCode = yield _this.interfaceAdapter.getCode(address);\n      yield utils.checkCode(onChainCode, _this.contractName, address);\n      return new _this(address);\n    })();\n  },\n\n  deployed() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.reloadJson) {\n        _this2.reloadJson(); //truffle test monkey-patches in this method\n\n      }\n\n      utils.checkProvider(_this2);\n      yield _this2.detectNetwork();\n      utils.checkNetworkArtifactMatch(_this2);\n      utils.checkDeployment(_this2);\n      return new _this2(_this2.address);\n    })();\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  detectNetwork() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // if artifacts already have a network_id and network configuration synced,\n      // use that network and use latest block gasLimit\n      if (_this3.network_id && _this3.networks[_this3.network_id] != null) {\n        const {\n          gasLimit\n        } = yield _this3.interfaceAdapter.getBlock(\"latest\");\n        return {\n          id: _this3.network_id,\n          blockLimit: gasLimit\n        };\n      } // since artifacts don't have a network_id synced with a network configuration,\n      // poll chain for network_id and sync artifacts\n\n\n      const chainNetworkID = yield _this3.interfaceAdapter.getNetworkId();\n      const {\n        gasLimit\n      } = yield _this3.interfaceAdapter.getBlock(\"latest\");\n      return yield utils.setInstanceNetworkID(_this3, chainNetworkID, gasLimit);\n    })();\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n\n  setNetworkType(networkType = \"ethereum\") {\n    this.configureNetwork({\n      networkType\n    });\n  },\n\n  setWallet(wallet) {\n    this.configureNetwork();\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  // accepts 4 input formats\n  //  - (<name>, <address>)\n  //  - (<contractType>) - must have a deployed instance with an address\n  //  - (<contractInstance>)\n  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })\n  link(name, address) {\n    switch (typeof name) {\n      case \"string\":\n        // Case: Contract.link(<libraryName>, <address>)\n        if (this._json.networks[this.network_id] == null) {\n          this._json.networks[this.network_id] = {\n            events: {},\n            links: {}\n          };\n        }\n\n        this.network.links[name] = address;\n        return;\n\n      case \"function\":\n        // Case: Contract.link(<contractType>)\n        const contract = name;\n\n        if (contract.isDeployed() === false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n        Object.keys(contract.events).forEach(topic => {\n          this.network.events[topic] = contract.events[topic];\n        });\n        return;\n\n      case \"object\":\n        // 2 Cases:\n        //   - Contract.link({<libraryName>: <address>, ... })\n        //   - Contract.link(<instance>)\n        const obj = name;\n\n        if (obj.constructor && typeof obj.constructor.contractName === \"string\" && obj.address) {\n          // obj is a Truffle contract instance\n          this.link(obj.constructor.contractName, obj.address);\n        } else {\n          // obj is of the form { <libraryName>: <address>, ... }\n          Object.keys(obj).forEach(name => this.link(name, obj[name]));\n        }\n\n        return;\n\n      default:\n        const invalidInput = `Input to the link method is in the incorrect` + ` format. Input must be one of the following:${OS.EOL}` + `    - a library name and address                 > (\"MyLibrary\", ` + `\"0x123456789...\")${OS.EOL}` + `    - a contract type                            > ` + `(MyContract)${OS.EOL}` + `    - a contract instance                        > ` + `(myContract)${OS.EOL}` + `    - an object with library names and addresses > ({ <libName>: ` + `<address>, <libName2>: <address2>, ... })${OS.EOL}`;\n        throw new Error(invalidInput);\n    }\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n    let network_id; // If we have a network id passed\n\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n    temp._property_values = {};\n    temp._json = json;\n    bootstrap(temp);\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    }\n\n    if (this.currentProvider) {\n      temp.configureNetwork({\n        provider: this.currentProvider,\n        networkType: this.networkType\n      });\n    } // Copy over custom key/values to the contract class\n\n\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      } // If there's not a setter, then the property is immutable.\n\n\n      throw new Error(`${key} property is immutable`);\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/@truffle/contract/lib/contract/constructorMethods.js"],"names":["Web3Shim","createInterfaceAdapter","require","utils","execute","bootstrap","debug","OS","module","exports","Contract","configureNetwork","networkType","provider","currentProvider","interfaceAdapter","web3","setNetworkType","setProvider","Error","new","checkProvider","bytecode","contractName","constructorABI","abi","filter","i","type","deploy","call","arguments","at","address","length","detectNetwork","onChainCode","getCode","checkCode","deployed","reloadJson","checkNetworkArtifactMatch","checkDeployment","defaults","class_defaults","Object","keys","forEach","key","value","hasNetwork","network_id","_json","networks","isDeployed","network","gasLimit","getBlock","id","blockLimit","chainNetworkID","getNetworkId","setInstanceNetworkID","setNetwork","setWallet","wallet","eth","accounts","resetAddress","link","name","events","links","contract","topic","obj","constructor","invalidInput","EOL","clone","json","temp","TruffleContract","apply","prototype","create","merge","_constructorMethods","_properties","_property_values","indexOf","addProp","fn","getter","get","setter","val","set","definition","enumerable","configurable","defineProperty","toJSON","decodeLogs"],"mappings":"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","sourcesContent":["const {\n  Web3Shim,\n  createInterfaceAdapter\n} = require(\"@truffle/interface-adapter\");\nconst utils = require(\"../utils\");\nconst execute = require(\"../execute\");\nconst bootstrap = require(\"./bootstrap\");\nconst debug = require(\"debug\")(\"contract:contract:constructorMethods\");\nconst OS = require(\"os\");\n\nmodule.exports = Contract => ({\n  configureNetwork({ networkType, provider } = {}) {\n    // otherwise use existing value as default (at most one of these)\n    networkType = networkType || this.networkType;\n    provider = provider || this.currentProvider;\n\n    // recreate interfaceadapter\n    this.interfaceAdapter = createInterfaceAdapter({ networkType, provider });\n\n    if (this.web3) {\n      // update existing\n      this.web3.setNetworkType(networkType);\n      this.web3.setProvider(provider);\n    } else {\n      // create new\n      this.web3 = new Web3Shim({ networkType, provider });\n    }\n\n    // save properties\n    this.currentProvider = provider;\n    this.networkType = networkType;\n  },\n\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(\n        `Invalid provider passed to setProvider(); provider is ${provider}`\n      );\n    }\n\n    this.configureNetwork({ provider });\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(\n        `${this.contractName} error: contract binary not set. Can't deploy new instance.\\n` +\n          `This contract may be abstract, not implement an abstract parent's methods completely\\n` +\n          `or not invoke an inherited contract's constructor correctly\\n`\n      );\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  async at(address) {\n    if (\n      address == null ||\n      typeof address !== \"string\" ||\n      address.length !== 42\n    ) {\n      throw new Error(\n        `Invalid address passed to ${this.contractName}.at(): ${address}`\n      );\n    }\n\n    await this.detectNetwork();\n    const onChainCode = await this.interfaceAdapter.getCode(address);\n    await utils.checkCode(onChainCode, this.contractName, address);\n    return new this(address);\n  },\n\n  async deployed() {\n    if (this.reloadJson) {\n      this.reloadJson(); //truffle test monkey-patches in this method\n    }\n    utils.checkProvider(this);\n    await this.detectNetwork();\n    utils.checkNetworkArtifactMatch(this);\n    utils.checkDeployment(this);\n    return new this(this.address);\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n    if (this.network_id && this.networks[this.network_id] != null) {\n      const { gasLimit } = await this.interfaceAdapter.getBlock(\"latest\");\n      return { id: this.network_id, blockLimit: gasLimit };\n    }\n    // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n    const chainNetworkID = await this.interfaceAdapter.getNetworkId();\n    const { gasLimit } = await this.interfaceAdapter.getBlock(\"latest\");\n    return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n\n  setNetworkType(networkType = \"ethereum\") {\n    this.configureNetwork({ networkType });\n  },\n\n  setWallet(wallet) {\n    this.configureNetwork();\n\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  // accepts 4 input formats\n  //  - (<name>, <address>)\n  //  - (<contractType>) - must have a deployed instance with an address\n  //  - (<contractInstance>)\n  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })\n  link(name, address) {\n    switch (typeof name) {\n      case \"string\":\n        // Case: Contract.link(<libraryName>, <address>)\n        if (this._json.networks[this.network_id] == null) {\n          this._json.networks[this.network_id] = {\n            events: {},\n            links: {}\n          };\n        }\n\n        this.network.links[name] = address;\n        return;\n      case \"function\":\n        // Case: Contract.link(<contractType>)\n        const contract = name;\n\n        if (contract.isDeployed() === false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address);\n\n        // Merge events so this contract knows about library's events\n        Object.keys(contract.events).forEach(topic => {\n          this.network.events[topic] = contract.events[topic];\n        });\n        return;\n      case \"object\":\n        // 2 Cases:\n        //   - Contract.link({<libraryName>: <address>, ... })\n        //   - Contract.link(<instance>)\n        const obj = name;\n        if (\n          obj.constructor &&\n          typeof obj.constructor.contractName === \"string\" &&\n          obj.address\n        ) {\n          // obj is a Truffle contract instance\n          this.link(obj.constructor.contractName, obj.address);\n        } else {\n          // obj is of the form { <libraryName>: <address>, ... }\n          Object.keys(obj).forEach(name => this.link(name, obj[name]));\n        }\n        return;\n      default:\n        const invalidInput =\n          `Input to the link method is in the incorrect` +\n          ` format. Input must be one of the following:${OS.EOL}` +\n          `    - a library name and address                 > (\"MyLibrary\", ` +\n          `\"0x123456789...\")${OS.EOL}` +\n          `    - a contract type                            > ` +\n          `(MyContract)${OS.EOL}` +\n          `    - a contract instance                        > ` +\n          `(myContract)${OS.EOL}` +\n          `    - an object with library names and addresses > ({ <libName>: ` +\n          `<address>, <libName2>: <address2>, ... })${OS.EOL}`;\n        throw new Error(invalidInput);\n    }\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n\n    let network_id;\n\n    // If we have a network id passed\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n\n    temp._property_values = {};\n    temp._json = json;\n\n    bootstrap(temp);\n\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    }\n\n    if (this.currentProvider) {\n      temp.configureNetwork({\n        provider: this.currentProvider,\n        networkType: this.networkType\n      });\n    }\n\n    // Copy over custom key/values to the contract class\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      }\n\n      // If there's not a setter, then the property is immutable.\n      throw new Error(`${key} property is immutable`);\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});\n"]},"metadata":{},"sourceType":"script"}