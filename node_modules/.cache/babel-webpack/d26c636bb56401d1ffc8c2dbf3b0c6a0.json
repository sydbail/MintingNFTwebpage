{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst PeerId = require('peer-id');\n/** @type {{success:true, time:0, text: ''}} */\n\n\nconst basePacket = {\n  success: true,\n  time: 0,\n  text: ''\n};\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n */\n\n\nmodule.exports = ({\n  network\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"ping\"]}\n   */\n  function ping(_x) {\n    return _ping.apply(this, arguments);\n  }\n\n  function _ping() {\n    _ping = _wrapAsyncGenerator(function* (peerId, options = {}) {\n      const {\n        libp2p\n      } = yield _awaitAsyncGenerator(network.use());\n      options.count = options.count || 10;\n      const peer = PeerId.createFromB58String(peerId);\n      const storedPeer = libp2p.peerStore.get(peer);\n      let id = storedPeer && storedPeer.id;\n\n      if (!id) {\n        yield { ...basePacket,\n          text: `Looking up peer ${peerId}`\n        };\n        const remotePeer = yield _awaitAsyncGenerator(libp2p.peerRouting.findPeer(peer));\n        id = remotePeer && remotePeer.id;\n      }\n\n      if (!id) {\n        throw new Error('Peer was not found');\n      }\n\n      yield { ...basePacket,\n        text: `PING ${id.toB58String()}`\n      };\n      let packetCount = 0;\n      let totalTime = 0;\n\n      for (let i = 0; i < options.count; i++) {\n        try {\n          const time = yield _awaitAsyncGenerator(libp2p.ping(id));\n          totalTime += time;\n          packetCount++;\n          yield { ...basePacket,\n            time\n          };\n        } catch (err) {\n          yield { ...basePacket,\n            success: false,\n            text: err.toString()\n          };\n        }\n      }\n\n      if (packetCount) {\n        const average = totalTime / packetCount;\n        yield { ...basePacket,\n          text: `Average latency: ${average}ms`\n        };\n      }\n    });\n    return _ping.apply(this, arguments);\n  }\n\n  return withTimeoutOption(ping);\n};\n/**\n * @typedef {Pong|PingFailure|StatusUpdate} Packet\n * Note that not all ping response objects are \"pongs\".\n * A \"pong\" message can be identified by a truthy success property and an empty\n * text property. Other ping responses are failures or status updates.\n *\n * @typedef {Object} Pong\n * @property {true} success\n * @property {number} time\n * @property {''} text\n *\n * @typedef {Object} PingFailure\n * @property {false} success\n * @property {number} time\n * @property {string} text\n *\n * @typedef {Object} StatusUpdate\n * @property {true} success\n * @property {0} time\n * @property {string} text\n *\n * @typedef {PingSettings & AbortOptions} PingOptions\n *\n * @typedef {Object} PingSettings\n * @property {number} [count=10] - The number of ping messages to send\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}