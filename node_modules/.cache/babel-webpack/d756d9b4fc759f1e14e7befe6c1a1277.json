{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n});\n\nconst errCode = require('err-code'); // @ts-ignore multistream-select does not export types\n\n\nconst Multistream = require('multistream-select');\n\nconst {\n  Connection\n} = require('libp2p-interfaces/src/connection');\n\nconst PeerId = require('peer-id');\n\nconst {\n  pipe\n} = require('it-pipe'); // @ts-ignore mutable-proxy does not export types\n\n\nconst mutableProxy = require('mutable-proxy');\n\nconst {\n  codes\n} = require('./errors');\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor({\n    localPeer,\n    metrics,\n    cryptos = new Map(),\n    muxers = new Map(),\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos;\n    this.muxers = muxers;\n    /** @type {import(\"./pnet\") | null} */\n\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  upgradeInbound(maConn) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let encryptedConn;\n      let remotePeer;\n      let upgradedConn;\n      let Muxer;\n      let cryptoProtocol;\n      let setPeer;\n      let proxyPeer;\n\n      if (_this.metrics) {\n        ({\n          setTarget: setPeer,\n          proxy: proxyPeer\n        } = mutableProxy());\n        const idString = (Math.random() * 1e9).toString(36) + Date.now();\n        setPeer({\n          toB58String: () => idString\n        });\n        maConn = _this.metrics.trackStream({\n          stream: maConn,\n          remotePeer: proxyPeer\n        });\n      }\n\n      log('Starting the inbound connection upgrade'); // Protect\n\n      let protectedConn = maConn;\n\n      if (_this.protector) {\n        protectedConn = yield _this.protector.protect(maConn);\n      }\n\n      try {\n        // Encrypt the connection\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = yield _this._encryptInbound(_this.localPeer, protectedConn, _this.cryptos)); // Multiplex the connection\n\n        if (_this.muxers.size) {\n          ({\n            stream: upgradedConn,\n            Muxer\n          } = yield _this._multiplexInbound(encryptedConn, _this.muxers));\n        } else {\n          upgradedConn = encryptedConn;\n        }\n      } catch (err) {\n        log.error('Failed to upgrade inbound connection', err);\n        yield maConn.close(err);\n        throw err;\n      }\n\n      if (_this.metrics) {\n        _this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n\n        setPeer(remotePeer);\n      }\n\n      log('Successfully upgraded inbound connection');\n      return _this._createConnection({\n        cryptoProtocol,\n        direction: 'inbound',\n        maConn,\n        upgradedConn,\n        Muxer,\n        remotePeer\n      });\n    })();\n  }\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  upgradeOutbound(maConn) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const idStr = maConn.remoteAddr.getPeerId();\n\n      if (!idStr) {\n        throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n      }\n\n      const remotePeerId = PeerId.createFromB58String(idStr);\n      let encryptedConn;\n      let remotePeer;\n      let upgradedConn;\n      let cryptoProtocol;\n      let Muxer;\n      let setPeer;\n      let proxyPeer;\n\n      if (_this2.metrics) {\n        ({\n          setTarget: setPeer,\n          proxy: proxyPeer\n        } = mutableProxy());\n        const idString = (Math.random() * 1e9).toString(36) + Date.now();\n        setPeer({\n          toB58String: () => idString\n        });\n        maConn = _this2.metrics.trackStream({\n          stream: maConn,\n          remotePeer: proxyPeer\n        });\n      }\n\n      log('Starting the outbound connection upgrade'); // Protect\n\n      let protectedConn = maConn;\n\n      if (_this2.protector) {\n        protectedConn = yield _this2.protector.protect(maConn);\n      }\n\n      try {\n        // Encrypt the connection\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = yield _this2._encryptOutbound(_this2.localPeer, protectedConn, remotePeerId, _this2.cryptos)); // Multiplex the connection\n\n        if (_this2.muxers.size) {\n          ({\n            stream: upgradedConn,\n            Muxer\n          } = yield _this2._multiplexOutbound(encryptedConn, _this2.muxers));\n        } else {\n          upgradedConn = encryptedConn;\n        }\n      } catch (err) {\n        log.error('Failed to upgrade outbound connection', err);\n        yield maConn.close(err);\n        throw err;\n      }\n\n      if (_this2.metrics) {\n        _this2.metrics.updatePlaceholder(proxyPeer, remotePeer);\n\n        setPeer(remotePeer);\n      }\n\n      log('Successfully upgraded outbound connection');\n      return _this2._createConnection({\n        cryptoProtocol,\n        direction: 'outbound',\n        maConn,\n        upgradedConn,\n        Muxer,\n        remotePeer\n      });\n    })();\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n\n\n  _createConnection({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    var _this3 = this;\n\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer;\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n\n    let newStream;\n    /** @type {Connection} */\n\n    let connection; // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: function () {\n          var _ref = _asyncToGenerator(function* (muxedStream) {\n            if (!connection) return;\n            const mss = new Multistream.Listener(muxedStream);\n\n            try {\n              const {\n                stream,\n                protocol\n              } = yield mss.handle(Array.from(_this3.protocols.keys()));\n              log('%s: incoming stream opened on %s', direction, protocol);\n              if (_this3.metrics) _this3.metrics.trackStream({\n                stream,\n                remotePeer,\n                protocol\n              });\n              connection.addStream(muxedStream, {\n                protocol\n              });\n\n              _this3._onStream({\n                connection,\n                stream: { ...muxedStream,\n                  ...stream\n                },\n                protocol\n              });\n            } catch (err) {\n              log.error(err);\n            }\n          });\n\n          return function onStream(_x) {\n            return _ref.apply(this, arguments);\n          };\n        }(),\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id);\n        }\n      });\n\n      newStream = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (protocols) {\n          log('%s: starting new stream on %s', direction, protocols);\n          const muxedStream = muxer.newStream();\n          const mss = new Multistream.Dialer(muxedStream);\n\n          try {\n            const {\n              stream,\n              protocol\n            } = yield mss.select(protocols);\n            if (_this3.metrics) _this3.metrics.trackStream({\n              stream,\n              remotePeer,\n              protocol\n            });\n            return {\n              stream: { ...muxedStream,\n                ...stream\n              },\n              protocol\n            };\n          } catch (err) {\n            log.error('could not create new stream', err);\n            throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n          }\n        });\n\n        return function newStream(_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }(); // Pipe all data through the muxer\n\n\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n    }\n\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          _asyncToGenerator(function* () {\n            try {\n              if (connection.stat.status === 'open') {\n                yield connection.close();\n              }\n            } catch (err) {\n              log.error(err);\n            } finally {\n              _this3.onConnectionEnd(connection);\n            }\n          })();\n        }\n\n        return Reflect.set(...args);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');\n    }; // Create the connection\n\n\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: function () {\n        var _ref4 = _asyncToGenerator(function* () {\n          yield maConn.close(); // Ensure remaining streams are aborted\n\n          if (muxer) {\n            muxer.streams.map(stream => stream.abort());\n          }\n        });\n\n        return function close() {\n          return _ref4.apply(this, arguments);\n        };\n      }()\n    });\n    this.onConnection(connection);\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n\n\n  _onStream({\n    connection,\n    stream,\n    protocol\n  }) {\n    const handler = this.protocols.get(protocol);\n    handler({\n      connection,\n      stream,\n      protocol\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  _encryptInbound(localPeer, connection, cryptos) {\n    return _asyncToGenerator(function* () {\n      const mss = new Multistream.Listener(connection);\n      const protocols = Array.from(cryptos.keys());\n      log('handling inbound crypto protocol selection', protocols);\n\n      try {\n        const {\n          stream,\n          protocol\n        } = yield mss.handle(protocols);\n        const crypto = cryptos.get(protocol);\n        log('encrypting inbound connection...');\n\n        if (!crypto) {\n          throw new Error(`no crypto module found for ${protocol}`);\n        }\n\n        return { ...(yield crypto.secureInbound(localPeer, stream)),\n          protocol\n        };\n      } catch (err) {\n        throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n      }\n    })();\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {\n    return _asyncToGenerator(function* () {\n      const mss = new Multistream.Dialer(connection);\n      const protocols = Array.from(cryptos.keys());\n      log('selecting outbound crypto protocol', protocols);\n\n      try {\n        const {\n          stream,\n          protocol\n        } = yield mss.select(protocols);\n        const crypto = cryptos.get(protocol);\n        log('encrypting outbound connection to %j', remotePeerId);\n\n        if (!crypto) {\n          throw new Error(`no crypto module found for ${protocol}`);\n        }\n\n        return { ...(yield crypto.secureOutbound(localPeer, stream, remotePeerId)),\n          protocol\n        };\n      } catch (err) {\n        throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n      }\n    })();\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  _multiplexOutbound(connection, muxers) {\n    return _asyncToGenerator(function* () {\n      const dialer = new Multistream.Dialer(connection);\n      const protocols = Array.from(muxers.keys());\n      log('outbound selecting muxer %s', protocols);\n\n      try {\n        const {\n          stream,\n          protocol\n        } = yield dialer.select(protocols);\n        log('%s selected as muxer protocol', protocol);\n        const Muxer = muxers.get(protocol);\n        return {\n          stream,\n          Muxer\n        };\n      } catch (err) {\n        throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n      }\n    })();\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  _multiplexInbound(connection, muxers) {\n    return _asyncToGenerator(function* () {\n      const listener = new Multistream.Listener(connection);\n      const protocols = Array.from(muxers.keys());\n      log('inbound handling muxers %s', protocols);\n\n      try {\n        const {\n          stream,\n          protocol\n        } = yield listener.handle(protocols);\n        const Muxer = muxers.get(protocol);\n        return {\n          stream,\n          Muxer\n        };\n      } catch (err) {\n        throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n      }\n    })();\n  }\n\n}\n\nmodule.exports = Upgrader;","map":null,"metadata":{},"sourceType":"script"}