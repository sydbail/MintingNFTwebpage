{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAllSources = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"compile-common:profiler:resolveAllSources\");\n\nconst getImports_1 = require(\"./getImports\"); // Resolves sources in several async passes. For each resolved set it detects unknown\n// imports from external packages and adds them to the set of files to resolve.\n\n\nfunction resolveAllSources({\n  resolve,\n  paths,\n  shouldIncludePath,\n  parseImports\n}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const mapping = {};\n    const allPaths = paths.slice();\n    debug(\"resolveAllSources called\"); // Begin generateMapping\n\n    function generateMapping() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const promises = []; // Dequeue all the known paths, generating resolver promises,\n        // We'll add paths if we discover external package imports.\n\n        while (allPaths.length) {\n          let filePath;\n          let importedFrom = null;\n          const candidate = allPaths.shift(); // Some paths will have been extracted as imports from a file\n          // and have information about their parent location we need to track.\n\n          if (typeof candidate === \"object\") {\n            filePath = candidate.filePath;\n            importedFrom = candidate.importedFrom;\n          } else {\n            filePath = candidate;\n          }\n\n          promises.push(resolve({\n            filePath,\n            importedFrom\n          }));\n        } // Resolve everything known and add it to the map, then inspect each file's\n        // imports and add those to the list of paths to resolve if we don't have it.\n\n\n        const results = yield Promise.all(promises); // Queue unknown imports for the next resolver cycle\n\n        while (results.length) {\n          const source = results.shift();\n\n          if (!source || mapping[source.filePath]) {\n            //skip ones that couldn't be resolved, or are already recorded\n            continue;\n          }\n\n          const imports = shouldIncludePath(source.filePath) ? yield getImports_1.getImports({\n            source,\n            parseImports,\n            shouldIncludePath\n          }) : [];\n          debug(\"imports: %O\", imports); // Generate the sources mapping\n\n          mapping[source.filePath] = Object.assign(Object.assign({}, source), {\n            imports\n          }); // Detect unknown external packages / add them to the list of files to resolve\n          // Keep track of location of this import because we need to report that.\n\n          for (const item of imports) {\n            if (!mapping[item]) {\n              allPaths.push({\n                filePath: item,\n                importedFrom: source.filePath\n              });\n            }\n          }\n        }\n      });\n    } // End generateMapping\n\n\n    while (allPaths.length) {\n      yield generateMapping();\n    }\n\n    return mapping;\n  });\n}\n\nexports.resolveAllSources = resolveAllSources; //# sourceMappingURL=resolveAllSources.js.map","map":null,"metadata":{},"sourceType":"script"}