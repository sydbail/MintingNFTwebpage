{"ast":null,"code":"'use strict'; // @ts-ignore\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst KBucket = require('k-bucket');\n\nconst utils = require('./utils');\n/**\n * @typedef {import('peer-id')} PeerId\n *\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n */\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\n\nclass RoutingTable {\n  /**\n   * @param {PeerId} self\n   * @param {number} kBucketSize\n   */\n  constructor(self, kBucketSize) {\n    this.self = self;\n    this._onPing = this._onPing.bind(this);\n\n    this._onInit(kBucketSize);\n  }\n  /**\n   * @param {number} kBucketSize\n   */\n\n\n  _onInit(kBucketSize) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const selfKey = yield utils.convertPeerId(_this.self);\n      _this.kb = new KBucket({\n        localNodeId: selfKey,\n        numberOfNodesPerKBucket: kBucketSize,\n        numberOfNodesToPing: 1\n      });\n\n      _this.kb.on('ping', _this._onPing);\n    })();\n  }\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without actually pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n\n\n  _onPing(oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0];\n\n    if (oldest) {\n      // remove the oldest one\n      this.kb.remove(oldest.id);\n    } // add the new one\n\n\n    this.kb.add(newContact);\n  } // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n\n\n  get size() {\n    return this.kb.count();\n  }\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<PeerId | undefined>}\n   */\n\n\n  find(peer) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = yield utils.convertPeerId(peer);\n\n      const closest = _this2.closestPeer(key);\n\n      if (closest && peer.equals(closest)) {\n        return closest;\n      }\n    })();\n  }\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  closestPeer(key) {\n    const res = this.closestPeers(key, 1);\n\n    if (res.length > 0) {\n      return res[0];\n    }\n  }\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} count\n   */\n\n\n  closestPeers(key, count) {\n    /** @type {KBucketPeer[]} */\n    const closest = this.kb.closest(key, count);\n    return closest.map(p => p.peer);\n  }\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  add(peer) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const id = yield utils.convertPeerId(peer);\n\n      _this3.kb.add({\n        id: id,\n        peer: peer\n      });\n    })();\n  }\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  remove(peer) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const id = yield utils.convertPeerId(peer);\n\n      _this4.kb.remove(id);\n    })();\n  }\n\n}\n\nmodule.exports = RoutingTable;","map":null,"metadata":{},"sourceType":"script"}