{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst xx_1 = require(\"./handshakes/xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n  } // stage 0\n\n\n  propose() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      logger_1.logLocalStaticKeys(_this.session.hs.s);\n\n      if (_this.isInitiator) {\n        logger_1.logger('Stage 0 - Initiator starting to send first message.');\n\n        const messageBuffer = _this.xx.sendMessage(_this.session, buffer_1.Buffer.alloc(0));\n\n        _this.connection.writeLP(encoder_1.encode0(messageBuffer));\n\n        logger_1.logger('Stage 0 - Initiator finished sending first message.');\n        logger_1.logLocalEphemeralKeys(_this.session.hs.e);\n      } else {\n        logger_1.logger('Stage 0 - Responder waiting to receive first message...');\n        const receivedMessageBuffer = encoder_1.decode0((yield _this.connection.readLP()).slice());\n\n        const {\n          valid\n        } = _this.xx.recvMessage(_this.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('xx handshake stage 0 validation fail');\n        }\n\n        logger_1.logger('Stage 0 - Responder received first message.');\n        logger_1.logRemoteEphemeralKey(_this.session.hs.re);\n      }\n    })();\n  } // stage 1\n\n\n  exchange() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isInitiator) {\n        logger_1.logger('Stage 1 - Initiator waiting to receive first message from responder...');\n        const receivedMessageBuffer = encoder_1.decode1((yield _this2.connection.readLP()).slice());\n\n        const {\n          plaintext,\n          valid\n        } = _this2.xx.recvMessage(_this2.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('xx handshake stage 1 validation fail');\n        }\n\n        logger_1.logger('Stage 1 - Initiator received the message.');\n        logger_1.logRemoteEphemeralKey(_this2.session.hs.re);\n        logger_1.logRemoteStaticKey(_this2.session.hs.rs);\n        logger_1.logger(\"Initiator going to check remote's signature...\");\n\n        try {\n          const decodedPayload = yield utils_1.decodePayload(plaintext);\n          _this2.remotePeer = _this2.remotePeer || (yield utils_1.getPeerIdFromPayload(decodedPayload));\n          _this2.remotePeer = yield utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, _this2.remotePeer);\n\n          _this2.setRemoteEarlyData(decodedPayload.data);\n        } catch (e) {\n          const err = e;\n          throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n        }\n\n        logger_1.logger('All good with the signature!');\n      } else {\n        logger_1.logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n\n        const messageBuffer = _this2.xx.sendMessage(_this2.session, _this2.payload);\n\n        _this2.connection.writeLP(encoder_1.encode1(messageBuffer));\n\n        logger_1.logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n        logger_1.logLocalEphemeralKeys(_this2.session.hs.e);\n      }\n    })();\n  } // stage 2\n\n\n  finish() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3.isInitiator) {\n        logger_1.logger('Stage 2 - Initiator sending third handshake message.');\n\n        const messageBuffer = _this3.xx.sendMessage(_this3.session, _this3.payload);\n\n        _this3.connection.writeLP(encoder_1.encode2(messageBuffer));\n\n        logger_1.logger('Stage 2 - Initiator sent message with signed payload.');\n      } else {\n        logger_1.logger('Stage 2 - Responder waiting for third handshake message...');\n        const receivedMessageBuffer = encoder_1.decode2((yield _this3.connection.readLP()).slice());\n\n        const {\n          plaintext,\n          valid\n        } = _this3.xx.recvMessage(_this3.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('xx handshake stage 2 validation fail');\n        }\n\n        logger_1.logger('Stage 2 - Responder received the message, finished handshake.');\n\n        try {\n          const decodedPayload = yield utils_1.decodePayload(plaintext);\n          _this3.remotePeer = _this3.remotePeer || (yield utils_1.getPeerIdFromPayload(decodedPayload));\n          yield utils_1.verifySignedPayload(_this3.session.hs.rs, decodedPayload, _this3.remotePeer);\n\n          _this3.setRemoteEarlyData(decodedPayload.data);\n        } catch (e) {\n          const err = e;\n          throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n        }\n      }\n\n      logger_1.logCipherState(_this3.session);\n    })();\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n  }\n\n  getRemoteStaticKey() {\n    return this.session.hs.rs;\n  }\n\n  getCS(session, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}\n\nexports.XXHandshake = XXHandshake; //# sourceMappingURL=handshake-xx.js.map","map":null,"metadata":{},"sourceType":"script"}