{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst PeerId = require('peer-id');\n\nconst {\n  RPC\n} = require('./rpc');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst SignPrefix = uint8ArrayFromString('libp2p-pubsub:');\n\nconst {\n  normalizeOutRpcMessage\n} = require('../utils');\n/**\n * @typedef {import('..').InMessage}\n */\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {InMessage} message\n * @returns {Promise<InMessage>}\n */\n\n\nfunction signMessage(_x, _x2) {\n  return _signMessage.apply(this, arguments);\n}\n/**\n * Verifies the signature of the given message\n *\n * @param {InMessage} message\n * @returns {Promise<boolean>}\n */\n\n\nfunction _signMessage() {\n  _signMessage = _asyncToGenerator(function* (peerId, message) {\n    // Get the message in bytes, and prepend with the pubsub prefix\n    const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(normalizeOutRpcMessage(message)).finish()]);\n    const signature = yield peerId.privKey.sign(bytes);\n    return { ...message,\n      signature: signature,\n      key: peerId.pubKey.bytes\n    };\n  });\n  return _signMessage.apply(this, arguments);\n}\n\nfunction verifySignature(_x3) {\n  return _verifySignature.apply(this, arguments);\n}\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\n\n\nfunction _verifySignature() {\n  _verifySignature = _asyncToGenerator(function* (message) {\n    if (!message.signature) {\n      throw new Error('Message must contain a signature to be verified');\n    }\n\n    if (!message.from) {\n      throw new Error('Message must contain a from property to be verified');\n    } // Get message sans the signature\n\n\n    const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode({ ...message,\n      from: PeerId.createFromB58String(message.from).toBytes(),\n      signature: undefined,\n      key: undefined\n    }).finish()]); // Get the public key\n\n    const pubKey = yield messagePublicKey(message); // verify the base message\n\n    return pubKey.verify(bytes, message.signature);\n  });\n  return _verifySignature.apply(this, arguments);\n}\n\nfunction messagePublicKey(_x4) {\n  return _messagePublicKey.apply(this, arguments);\n}\n/**\n * @typedef {import('..').InMessage} InMessage\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n */\n\n\nfunction _messagePublicKey() {\n  _messagePublicKey = _asyncToGenerator(function* (message) {\n    // should be available in the from property of the message (peer id)\n    if (!message.from) {\n      throw new Error('Could not get the public key from the originator id');\n    }\n\n    const from = PeerId.createFromB58String(message.from);\n\n    if (message.key) {\n      const keyPeerId = yield PeerId.createFromPubKey(message.key); // the key belongs to the sender, return the key\n\n      if (keyPeerId.equals(from)) return keyPeerId.pubKey; // We couldn't validate pubkey is from the originator, error\n\n      throw new Error('Public Key does not match the originator');\n    } else if (from.pubKey) {\n      return from.pubKey;\n    } else {\n      throw new Error('Could not get the public key from the originator id');\n    }\n  });\n  return _messagePublicKey.apply(this, arguments);\n}\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n};","map":null,"metadata":{},"sourceType":"script"}