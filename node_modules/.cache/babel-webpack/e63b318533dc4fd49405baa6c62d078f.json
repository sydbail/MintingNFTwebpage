{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.streamingIterables = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function _batch(_x, _x2) {\n    return _batch2.apply(this, arguments);\n  }\n\n  function _batch2() {\n    _batch2 = _wrapAsyncGenerator(function* (size, iterable) {\n      let dataBatch = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(iterable), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const data = _value;\n          dataBatch.push(data);\n\n          if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (dataBatch.length > 0) {\n        yield dataBatch;\n      }\n    });\n    return _batch2.apply(this, arguments);\n  }\n\n  function* _syncBatch(size, iterable) {\n    let dataBatch = [];\n\n    for (const data of iterable) {\n      dataBatch.push(data);\n\n      if (dataBatch.length === size) {\n        yield dataBatch;\n        dataBatch = [];\n      }\n    }\n\n    if (dataBatch.length > 0) {\n      yield dataBatch;\n    }\n  }\n\n  function batch(size, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => batch(size, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _batch(size, iterable);\n    }\n\n    return _syncBatch(size, iterable);\n  }\n\n  function getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n      return iterable;\n    }\n\n    if (typeof iterable[Symbol.iterator] === 'function') {\n      return iterable[Symbol.iterator]();\n    }\n\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n      return iterable[Symbol.asyncIterator]();\n    }\n\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n  }\n\n  function defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n      resolve = resolveFunc;\n      reject = rejectFunc;\n    });\n    return {\n      promise,\n      reject,\n      resolve\n    };\n  } /// <reference lib=\"esnext.asynciterable\" />\n\n\n  function _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const readDeferred = readQueue.shift();\n        const {\n          error,\n          value\n        } = resultQueue.shift();\n\n        if (error) {\n          readDeferred.reject(error);\n        } else {\n          readDeferred.resolve({\n            done: false,\n            value\n          });\n        }\n      }\n\n      while (readQueue.length > 0 && ended) {\n        const {\n          resolve\n        } = readQueue.shift();\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n\n    function fillQueue() {\n      return _fillQueue.apply(this, arguments);\n    }\n\n    function _fillQueue() {\n      _fillQueue = _asyncToGenerator(function* () {\n        if (ended) {\n          return;\n        }\n\n        if (reading) {\n          return;\n        }\n\n        if (resultQueue.length >= size) {\n          return;\n        }\n\n        reading = true;\n\n        try {\n          const {\n            done,\n            value\n          } = yield iterator.next();\n\n          if (done) {\n            ended = true;\n          } else {\n            resultQueue.push({\n              value\n            });\n          }\n        } catch (error) {\n          ended = true;\n          resultQueue.push({\n            error\n          });\n        }\n\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n      });\n      return _fillQueue.apply(this, arguments);\n    }\n\n    function next() {\n      return _next.apply(this, arguments);\n    }\n\n    function _next() {\n      _next = _asyncToGenerator(function* () {\n        if (resultQueue.length > 0) {\n          const {\n            error,\n            value\n          } = resultQueue.shift();\n\n          if (error) {\n            throw error;\n          }\n\n          fillQueue();\n          return {\n            done: false,\n            value\n          };\n        }\n\n        if (ended) {\n          return {\n            done: true,\n            value: undefined\n          }; // stupid ts\n        }\n\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n      });\n      return _next.apply(this, arguments);\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n\n    try {\n      for (const value of iterable) {\n        valueQueue.push(value);\n\n        if (valueQueue.length <= size) {\n          continue;\n        }\n\n        yield valueQueue.shift();\n      }\n    } catch (error) {\n      e = error;\n    }\n\n    for (const value of valueQueue) {\n      yield value;\n    }\n\n    if (e) {\n      throw e;\n    }\n  }\n\n  function buffer(size, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => buffer(size, curriedIterable);\n    }\n\n    if (size === 0) {\n      return iterable;\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _buffer(size, iterable);\n    }\n\n    return syncBuffer(size, iterable);\n  }\n\n  function _collect(_x20) {\n    return _collect2.apply(this, arguments);\n  }\n\n  function _collect2() {\n    _collect2 = _asyncToGenerator(function* (iterable) {\n      const values = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(iterable), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const value = _value2;\n          values.push(value);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return values;\n    });\n    return _collect2.apply(this, arguments);\n  }\n\n  function collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n      return _collect(iterable);\n    }\n\n    return Array.from(iterable);\n  }\n\n  function _concat(_x3) {\n    return _concat2.apply(this, arguments);\n  }\n\n  function _concat2() {\n    _concat2 = _wrapAsyncGenerator(function* (iterables) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(iterables), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const iterable = _value3;\n          yield* _asyncGeneratorDelegate(_asyncIterator(iterable), _awaitAsyncGenerator);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            yield _awaitAsyncGenerator(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    });\n    return _concat2.apply(this, arguments);\n  }\n\n  function* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n      yield* iterable;\n    }\n  }\n\n  function concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n    if (hasAnyAsync) {\n      return _concat(iterables);\n    } else {\n      return _syncConcat(iterables);\n    }\n  }\n\n  function _consume(_x21) {\n    return _consume2.apply(this, arguments);\n  }\n\n  function _consume2() {\n    _consume2 = _asyncToGenerator(function* (iterable) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n\n      var _iteratorError4;\n\n      try {\n        for (var _iterator4 = _asyncIterator(iterable), _step4, _value4; _step4 = yield _iterator4.next(), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _step4.value, !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {// do nothing\n\n          const val = _value4;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            yield _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    });\n    return _consume2.apply(this, arguments);\n  }\n\n  function consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n      return _consume(iterable);\n    }\n\n    for (const val of iterable) {// do nothing\n    }\n  }\n\n  function _filter(_x4, _x5) {\n    return _filter2.apply(this, arguments);\n  }\n\n  function _filter2() {\n    _filter2 = _wrapAsyncGenerator(function* (filterFunc, iterable) {\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n\n      var _iteratorError5;\n\n      try {\n        for (var _iterator5 = _asyncIterator(iterable), _step5, _value5; _step5 = yield _awaitAsyncGenerator(_iterator5.next()), _iteratorNormalCompletion5 = _step5.done, _value5 = yield _awaitAsyncGenerator(_step5.value), !_iteratorNormalCompletion5; _iteratorNormalCompletion5 = true) {\n          const data = _value5;\n\n          if (yield _awaitAsyncGenerator(filterFunc(data))) {\n            yield data;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            yield _awaitAsyncGenerator(_iterator5.return());\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    });\n    return _filter2.apply(this, arguments);\n  }\n\n  function filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _filter(filterFunc, curriedIterable);\n    }\n\n    return _filter(filterFunc, iterable);\n  }\n\n  function flatten(_x6) {\n    return _flatten.apply(this, arguments);\n  }\n\n  function _flatten() {\n    _flatten = _wrapAsyncGenerator(function* (iterable) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n\n      var _iteratorError6;\n\n      try {\n        for (var _iterator6 = _asyncIterator(iterable), _step6, _value6; _step6 = yield _awaitAsyncGenerator(_iterator6.next()), _iteratorNormalCompletion6 = _step6.done, _value6 = yield _awaitAsyncGenerator(_step6.value), !_iteratorNormalCompletion6; _iteratorNormalCompletion6 = true) {\n          const maybeItr = _value6;\n\n          if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* _asyncGeneratorDelegate(_asyncIterator(flatten(maybeItr)), _awaitAsyncGenerator);\n          } else {\n            yield maybeItr;\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            yield _awaitAsyncGenerator(_iterator6.return());\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    });\n    return _flatten.apply(this, arguments);\n  }\n\n  function _map(_x7, _x8) {\n    return _map2.apply(this, arguments);\n  }\n\n  function _map2() {\n    _map2 = _wrapAsyncGenerator(function* (func, iterable) {\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n\n      var _iteratorError7;\n\n      try {\n        for (var _iterator7 = _asyncIterator(iterable), _step7, _value7; _step7 = yield _awaitAsyncGenerator(_iterator7.next()), _iteratorNormalCompletion7 = _step7.done, _value7 = yield _awaitAsyncGenerator(_step7.value), !_iteratorNormalCompletion7; _iteratorNormalCompletion7 = true) {\n          const val = _value7;\n          yield func(val);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            yield _awaitAsyncGenerator(_iterator7.return());\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    });\n    return _map2.apply(this, arguments);\n  }\n\n  function map(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _map(func, curriedIterable);\n    }\n\n    return _map(func, iterable);\n  }\n\n  function flatMap(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => flatMap(func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n  }\n\n  function _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const {\n          resolve\n        } = readQueue.shift();\n        const value = resultQueue.shift();\n        resolve({\n          done: false,\n          value\n        });\n      }\n\n      while (readQueue.length > 0 && inflightCount === 0 && ended) {\n        const {\n          resolve,\n          reject\n        } = readQueue.shift();\n\n        if (lastError) {\n          reject(lastError);\n          lastError = null;\n        } else {\n          resolve({\n            done: true,\n            value: undefined\n          });\n        }\n      }\n    }\n\n    function fillQueue() {\n      return _fillQueue2.apply(this, arguments);\n    }\n\n    function _fillQueue2() {\n      _fillQueue2 = _asyncToGenerator(function* () {\n        if (ended) {\n          fulfillReadQueue();\n          return;\n        }\n\n        if (reading) {\n          return;\n        }\n\n        if (inflightCount + resultQueue.length >= concurrency) {\n          return;\n        }\n\n        reading = true;\n        inflightCount++;\n\n        try {\n          const {\n            done,\n            value\n          } = yield iterator.next();\n\n          if (done) {\n            ended = true;\n            inflightCount--;\n            fulfillReadQueue();\n          } else {\n            mapAndQueue(value);\n          }\n        } catch (error) {\n          ended = true;\n          inflightCount--;\n          lastError = error;\n          fulfillReadQueue();\n        }\n\n        reading = false;\n        fillQueue();\n      });\n      return _fillQueue2.apply(this, arguments);\n    }\n\n    function mapAndQueue(_x22) {\n      return _mapAndQueue.apply(this, arguments);\n    }\n\n    function _mapAndQueue() {\n      _mapAndQueue = _asyncToGenerator(function* (itrValue) {\n        try {\n          const value = yield func(itrValue);\n\n          if (value && value[Symbol.asyncIterator]) {\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n\n            var _iteratorError8;\n\n            try {\n              for (var _iterator8 = _asyncIterator(value), _step8, _value8; _step8 = yield _iterator8.next(), _iteratorNormalCompletion8 = _step8.done, _value8 = yield _step8.value, !_iteratorNormalCompletion8; _iteratorNormalCompletion8 = true) {\n                const asyncVal = _value8;\n                resultQueue.push(asyncVal);\n              }\n            } catch (err) {\n              _didIteratorError8 = true;\n              _iteratorError8 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                  yield _iterator8.return();\n                }\n              } finally {\n                if (_didIteratorError8) {\n                  throw _iteratorError8;\n                }\n              }\n            }\n          } else {\n            resultQueue.push(value);\n          }\n        } catch (error) {\n          ended = true;\n          lastError = error;\n        }\n\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n      });\n      return _mapAndQueue.apply(this, arguments);\n    }\n\n    function next() {\n      return _next2.apply(this, arguments);\n    }\n\n    function _next2() {\n      _next2 = _asyncToGenerator(function* () {\n        if (resultQueue.length === 0) {\n          const deferred = defer();\n          readQueue.push(deferred);\n          fillQueue();\n          return deferred.promise;\n        }\n\n        const value = resultQueue.shift();\n        fillQueue();\n        return {\n          done: false,\n          value\n        };\n      });\n      return _next2.apply(this, arguments);\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n  }\n\n  function onceReadable(_x23) {\n    return _onceReadable.apply(this, arguments);\n  }\n\n  function _onceReadable() {\n    _onceReadable = _asyncToGenerator(function* (stream) {\n      return new Promise(resolve => {\n        stream.once('readable', () => {\n          resolve();\n        });\n      });\n    });\n    return _onceReadable.apply(this, arguments);\n  }\n\n  function _fromStream(_x9) {\n    return _fromStream2.apply(this, arguments);\n  }\n\n  function _fromStream2() {\n    _fromStream2 = _wrapAsyncGenerator(function* (stream) {\n      while (true) {\n        const data = stream.read();\n\n        if (data !== null) {\n          yield data;\n          continue;\n        }\n\n        if (stream._readableState.ended) {\n          break;\n        }\n\n        yield _awaitAsyncGenerator(onceReadable(stream));\n      }\n    });\n    return _fromStream2.apply(this, arguments);\n  }\n\n  function fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n      return stream;\n    }\n\n    return _fromStream(stream);\n  }\n\n  function merge() {\n    return _merge.apply(this, arguments);\n  }\n\n  function _merge() {\n    _merge = _wrapAsyncGenerator(function* (...iterables) {\n      const sources = new Set(iterables.map(getIterator));\n\n      while (sources.size > 0) {\n        for (const iterator of sources) {\n          const nextVal = yield _awaitAsyncGenerator(iterator.next());\n\n          if (nextVal.done) {\n            sources.delete(iterator);\n          } else {\n            yield nextVal.value;\n          }\n        }\n      }\n    });\n    return _merge.apply(this, arguments);\n  }\n\n  function pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n\n    for (const func of fns) {\n      previousFn = func(previousFn);\n    }\n\n    return previousFn;\n  }\n\n  function _parallelMap(_x10, _x11, _x12) {\n    return _parallelMap2.apply(this, arguments);\n  }\n\n  function _parallelMap2() {\n    _parallelMap2 = _wrapAsyncGenerator(function* (concurrency, func, iterable) {\n      let transformError = null;\n\n      const wrapFunc = value => ({\n        value: func(value)\n      });\n\n      const stopOnError = /*#__PURE__*/function () {\n        var _ref = _wrapAsyncGenerator(function* (source) {\n          var _iteratorNormalCompletion13 = true;\n          var _didIteratorError13 = false;\n\n          var _iteratorError13;\n\n          try {\n            for (var _iterator13 = _asyncIterator(source), _step13, _value13; _step13 = yield _awaitAsyncGenerator(_iterator13.next()), _iteratorNormalCompletion13 = _step13.done, _value13 = yield _awaitAsyncGenerator(_step13.value), !_iteratorNormalCompletion13; _iteratorNormalCompletion13 = true) {\n              const value = _value13;\n\n              if (transformError) {\n                return;\n              }\n\n              yield value;\n            }\n          } catch (err) {\n            _didIteratorError13 = true;\n            _iteratorError13 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n                yield _awaitAsyncGenerator(_iterator13.return());\n              }\n            } finally {\n              if (_didIteratorError13) {\n                throw _iteratorError13;\n              }\n            }\n          }\n        });\n\n        return function stopOnError(_x19) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n      const itr = getIterator(output);\n\n      while (true) {\n        const {\n          value,\n          done\n        } = yield _awaitAsyncGenerator(itr.next());\n\n        if (done) {\n          break;\n        }\n\n        try {\n          const val = yield _awaitAsyncGenerator(value.value);\n\n          if (!transformError) {\n            yield val;\n          }\n        } catch (error) {\n          transformError = error;\n        }\n      }\n\n      if (transformError) {\n        throw transformError;\n      }\n    });\n    return _parallelMap2.apply(this, arguments);\n  }\n\n  function parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n\n    if (concurrency === 1) {\n      return map(func, iterable);\n    }\n\n    return _parallelMap(concurrency, func, iterable);\n  }\n\n  function parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n  } /// <reference lib=\"esnext.asynciterable\" />\n\n\n  function parallelMerge() {\n    return _parallelMerge.apply(this, arguments);\n  }\n\n  function _parallelMerge() {\n    _parallelMerge = _wrapAsyncGenerator(function* (...iterables) {\n      const inputs = iterables.map(getIterator);\n      const concurrentWork = new Set();\n      const values = new Map();\n      let lastError = null;\n      let errCb = null;\n      let valueCb = null;\n\n      const notifyError = err => {\n        lastError = err;\n\n        if (errCb) {\n          errCb(err);\n        }\n      };\n\n      const notifyDone = value => {\n        if (valueCb) {\n          valueCb(value);\n        }\n      };\n\n      const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n          reject(lastError);\n        }\n\n        if (values.size > 0) {\n          return resolve();\n        }\n\n        valueCb = resolve;\n        errCb = reject;\n      });\n\n      const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* ({\n            done,\n            value\n          }) {\n            if (!done) {\n              values.set(input, value);\n            }\n\n            concurrentWork.delete(nextVal);\n          });\n\n          return function (_x24) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n      };\n\n      for (const input of inputs) {\n        queueNext(input);\n      }\n\n      while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n          return;\n        }\n\n        yield _awaitAsyncGenerator(waitForQueue());\n\n        for (const [input, value] of values) {\n          values.delete(input);\n          yield value;\n          queueNext(input);\n        }\n      }\n    });\n    return _parallelMerge.apply(this, arguments);\n  }\n\n  function _reduce(_x25, _x26, _x27) {\n    return _reduce2.apply(this, arguments);\n  }\n\n  function _reduce2() {\n    _reduce2 = _asyncToGenerator(function* (func, start, iterable) {\n      let value = start;\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n\n      var _iteratorError9;\n\n      try {\n        for (var _iterator9 = _asyncIterator(iterable), _step9, _value9; _step9 = yield _iterator9.next(), _iteratorNormalCompletion9 = _step9.done, _value9 = yield _step9.value, !_iteratorNormalCompletion9; _iteratorNormalCompletion9 = true) {\n          const nextItem = _value9;\n          value = yield func(value, nextItem);\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            yield _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      return value;\n    });\n    return _reduce2.apply(this, arguments);\n  }\n\n  function reduce(func, start, iterable) {\n    if (start === undefined) {\n      return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => reduce(func, start, curriedIterable);\n    }\n\n    return _reduce(func, start, iterable);\n  }\n\n  function _take(_x13, _x14) {\n    return _take2.apply(this, arguments);\n  }\n\n  function _take2() {\n    _take2 = _wrapAsyncGenerator(function* (count, iterable) {\n      let taken = 0;\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n\n      var _iteratorError10;\n\n      try {\n        for (var _iterator10 = _asyncIterator(iterable), _step10, _value10; _step10 = yield _awaitAsyncGenerator(_iterator10.next()), _iteratorNormalCompletion10 = _step10.done, _value10 = yield _awaitAsyncGenerator(_step10.value), !_iteratorNormalCompletion10; _iteratorNormalCompletion10 = true) {\n          const val = _value10;\n          yield val;\n          taken++;\n\n          if (taken >= count) {\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            yield _awaitAsyncGenerator(_iterator10.return());\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    });\n    return _take2.apply(this, arguments);\n  }\n\n  function* _syncTake(count, iterable) {\n    let taken = 0;\n\n    for (const val of iterable) {\n      yield val;\n      taken++;\n\n      if (taken >= count) {\n        break;\n      }\n    }\n  }\n\n  function take(count, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => take(count, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _take(count, iterable);\n    }\n\n    return _syncTake(count, iterable);\n  }\n\n  function _asyncTap(_x15, _x16) {\n    return _asyncTap2.apply(this, arguments);\n  }\n\n  function _asyncTap2() {\n    _asyncTap2 = _wrapAsyncGenerator(function* (func, iterable) {\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n\n      var _iteratorError11;\n\n      try {\n        for (var _iterator11 = _asyncIterator(iterable), _step11, _value11; _step11 = yield _awaitAsyncGenerator(_iterator11.next()), _iteratorNormalCompletion11 = _step11.done, _value11 = yield _awaitAsyncGenerator(_step11.value), !_iteratorNormalCompletion11; _iteratorNormalCompletion11 = true) {\n          const val = _value11;\n          yield _awaitAsyncGenerator(func(val));\n          yield val;\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n            yield _awaitAsyncGenerator(_iterator11.return());\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n    });\n    return _asyncTap2.apply(this, arguments);\n  }\n\n  function tap(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _asyncTap(func, curriedIterable);\n    }\n\n    return _asyncTap(func, iterable);\n  }\n\n  function addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n\n    if (nanoseconds >= 1000000000) {\n      const remainder = nanoseconds % 1000000000;\n      seconds += (nanoseconds - remainder) / 1000000000;\n      nanoseconds = remainder;\n    }\n\n    return [seconds, nanoseconds];\n  }\n\n  function _asyncTime(_x17, _x18) {\n    return _asyncTime2.apply(this, arguments);\n  }\n\n  function _asyncTime2() {\n    _asyncTime2 = _wrapAsyncGenerator(function* (config, iterable) {\n      const itr = iterable[Symbol.asyncIterator]();\n      let total = [0, 0];\n\n      while (true) {\n        const start = process.hrtime();\n        const {\n          value,\n          done\n        } = yield _awaitAsyncGenerator(itr.next());\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n\n        if (config.progress) {\n          config.progress(delta, total);\n        }\n\n        if (done) {\n          if (config.total) {\n            config.total(total);\n          }\n\n          return value;\n        }\n\n        yield value;\n      }\n    });\n    return _asyncTime2.apply(this, arguments);\n  }\n\n  function* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n\n    while (true) {\n      const start = process.hrtime();\n      const {\n        value,\n        done\n      } = itr.next();\n      const delta = process.hrtime(start);\n      total = addTime(total, delta);\n\n      if (config.progress) {\n        config.progress(delta, total);\n      }\n\n      if (done) {\n        if (config.total) {\n          config.total(total);\n        }\n\n        return value;\n      }\n\n      yield value;\n    }\n  }\n\n  function time(config = {}, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => time(config, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n      return _asyncTime(config, iterable);\n    } else {\n      return _syncTime(config, iterable);\n    }\n  }\n\n  function _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const {\n          resolve\n        } = readQueue.shift();\n        const value = resultQueue.shift();\n        resolve({\n          done: false,\n          value\n        });\n      }\n\n      while (readQueue.length > 0 && inflightCount === 0 && ended) {\n        const {\n          resolve,\n          reject\n        } = readQueue.shift();\n\n        if (lastError) {\n          reject(lastError);\n          lastError = null;\n        } else {\n          resolve({\n            done: true,\n            value: undefined\n          });\n        }\n      }\n    }\n\n    function fillQueue() {\n      return _fillQueue3.apply(this, arguments);\n    }\n\n    function _fillQueue3() {\n      _fillQueue3 = _asyncToGenerator(function* () {\n        if (ended) {\n          fulfillReadQueue();\n          return;\n        }\n\n        if (reading) {\n          return;\n        }\n\n        if (inflightCount + resultQueue.length >= concurrency) {\n          return;\n        }\n\n        reading = true;\n        inflightCount++;\n\n        try {\n          const {\n            done,\n            value\n          } = yield iterator.next();\n\n          if (done) {\n            ended = true;\n            inflightCount--;\n            fulfillReadQueue();\n          } else {\n            mapAndQueue(value);\n          }\n        } catch (error) {\n          ended = true;\n          inflightCount--;\n          lastError = error;\n          fulfillReadQueue();\n        }\n\n        reading = false;\n        fillQueue();\n      });\n      return _fillQueue3.apply(this, arguments);\n    }\n\n    function mapAndQueue(_x28) {\n      return _mapAndQueue2.apply(this, arguments);\n    }\n\n    function _mapAndQueue2() {\n      _mapAndQueue2 = _asyncToGenerator(function* (itrValue) {\n        try {\n          const value = yield func(itrValue);\n          resultQueue.push(value);\n        } catch (error) {\n          ended = true;\n          lastError = error;\n        }\n\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n      });\n      return _mapAndQueue2.apply(this, arguments);\n    }\n\n    function next() {\n      return _next3.apply(this, arguments);\n    }\n\n    function _next3() {\n      _next3 = _asyncToGenerator(function* () {\n        if (resultQueue.length === 0) {\n          const deferred = defer();\n          readQueue.push(deferred);\n          fillQueue();\n          return deferred.promise;\n        }\n\n        const value = resultQueue.shift();\n        fillQueue();\n        return {\n          done: false,\n          value\n        };\n      });\n      return _next3.apply(this, arguments);\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function transform(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => transform(concurrency, func, curriedIterable);\n    }\n\n    return _transform(concurrency, func, iterable);\n  }\n\n  function _writeToStream(_x29, _x30) {\n    return _writeToStream2.apply(this, arguments);\n  }\n\n  function _writeToStream2() {\n    _writeToStream2 = _asyncToGenerator(function* (stream, iterable) {\n      let lastError = null;\n      let errCb = null;\n      let drainCb = null;\n\n      const notifyError = err => {\n        lastError = err;\n\n        if (errCb) {\n          errCb(err);\n        }\n      };\n\n      const notifyDrain = () => {\n        if (drainCb) {\n          drainCb();\n        }\n      };\n\n      const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n      };\n\n      stream.once('error', notifyError);\n\n      const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n          return reject(lastError);\n        }\n\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n      });\n\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n\n      var _iteratorError12;\n\n      try {\n        for (var _iterator12 = _asyncIterator(iterable), _step12, _value12; _step12 = yield _iterator12.next(), _iteratorNormalCompletion12 = _step12.done, _value12 = yield _step12.value, !_iteratorNormalCompletion12; _iteratorNormalCompletion12 = true) {\n          const value = _value12;\n\n          if (stream.write(value) === false) {\n            yield waitForDrain();\n          }\n\n          if (lastError) {\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            yield _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n\n      cleanup();\n\n      if (lastError) {\n        throw lastError;\n      }\n    });\n    return _writeToStream2.apply(this, arguments);\n  }\n\n  function writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _writeToStream(stream, curriedIterable);\n    }\n\n    return _writeToStream(stream, iterable);\n  }\n\n  exports.batch = batch;\n  exports.buffer = buffer;\n  exports.collect = collect;\n  exports.concat = concat;\n  exports.consume = consume;\n  exports.filter = filter;\n  exports.flatMap = flatMap;\n  exports.flatTransform = flatTransform;\n  exports.flatten = flatten;\n  exports.fromStream = fromStream;\n  exports.getIterator = getIterator;\n  exports.map = map;\n  exports.merge = merge;\n  exports.parallelFlatMap = parallelFlatMap;\n  exports.parallelMap = parallelMap;\n  exports.parallelMerge = parallelMerge;\n  exports.pipeline = pipeline;\n  exports.reduce = reduce;\n  exports.take = take;\n  exports.tap = tap;\n  exports.time = time;\n  exports.transform = transform;\n  exports.writeToStream = writeToStream;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/streaming-iterables/dist/index.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","streamingIterables","_batch","size","iterable","dataBatch","data","push","length","_syncBatch","batch","undefined","curriedIterable","Symbol","asyncIterator","getIterator","next","iterator","TypeError","defer","reject","resolve","promise","Promise","resolveFunc","rejectFunc","_buffer","resultQueue","readQueue","reading","ended","fulfillReadQueue","readDeferred","shift","error","value","done","fillQueue","deferred","asyncIterableIterator","syncBuffer","valueQueue","e","buffer","_collect","values","collect","Array","from","_concat","iterables","_syncConcat","concat","hasAnyAsync","find","itr","_consume","val","consume","_filter","filterFunc","filter","flatten","maybeItr","_map","func","map","flatMap","i","_flatTransform","concurrency","inflightCount","lastError","mapAndQueue","itrValue","asyncVal","flatTransform","curriedFunc","onceReadable","stream","once","_fromStream","read","_readableState","fromStream","merge","sources","Set","nextVal","delete","pipeline","firstFn","fns","previousFn","_parallelMap","transformError","wrapFunc","stopOnError","source","output","parallelMap","parallelFlatMap","parallelMerge","inputs","concurrentWork","Map","errCb","valueCb","notifyError","err","notifyDone","waitForQueue","queueNext","input","then","set","add","_reduce","start","nextItem","reduce","curriedStart","_take","count","taken","_syncTake","take","_asyncTap","tap","addTime","a","b","seconds","nanoseconds","remainder","_asyncTime","config","total","process","hrtime","delta","progress","_syncTime","time","_transform","transform","_writeToStream","drainCb","notifyDrain","cleanup","removeListener","waitForDrain","write","writeToStream","Object","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.streamingIterables = {}));\n}(this, (function (exports) { 'use strict';\n\n    async function* _batch(size, iterable) {\n        let dataBatch = [];\n        for await (const data of iterable) {\n            dataBatch.push(data);\n            if (dataBatch.length === size) {\n                yield dataBatch;\n                dataBatch = [];\n            }\n        }\n        if (dataBatch.length > 0) {\n            yield dataBatch;\n        }\n    }\n    function* _syncBatch(size, iterable) {\n        let dataBatch = [];\n        for (const data of iterable) {\n            dataBatch.push(data);\n            if (dataBatch.length === size) {\n                yield dataBatch;\n                dataBatch = [];\n            }\n        }\n        if (dataBatch.length > 0) {\n            yield dataBatch;\n        }\n    }\n    function batch(size, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => batch(size, curriedIterable);\n        }\n        if (iterable[Symbol.asyncIterator]) {\n            return _batch(size, iterable);\n        }\n        return _syncBatch(size, iterable);\n    }\n\n    function getIterator(iterable) {\n        if (typeof iterable.next === 'function') {\n            return iterable;\n        }\n        if (typeof iterable[Symbol.iterator] === 'function') {\n            return iterable[Symbol.iterator]();\n        }\n        if (typeof iterable[Symbol.asyncIterator] === 'function') {\n            return iterable[Symbol.asyncIterator]();\n        }\n        throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n    }\n\n    function defer() {\n        let reject;\n        let resolve;\n        const promise = new Promise((resolveFunc, rejectFunc) => {\n            resolve = resolveFunc;\n            reject = rejectFunc;\n        });\n        return {\n            promise,\n            reject,\n            resolve,\n        };\n    }\n\n    /// <reference lib=\"esnext.asynciterable\" />\n    function _buffer(size, iterable) {\n        const iterator = getIterator(iterable);\n        const resultQueue = [];\n        const readQueue = [];\n        let reading = false;\n        let ended = false;\n        function fulfillReadQueue() {\n            while (readQueue.length > 0 && resultQueue.length > 0) {\n                const readDeferred = readQueue.shift();\n                const { error, value } = resultQueue.shift();\n                if (error) {\n                    readDeferred.reject(error);\n                }\n                else {\n                    readDeferred.resolve({ done: false, value });\n                }\n            }\n            while (readQueue.length > 0 && ended) {\n                const { resolve } = readQueue.shift();\n                resolve({ done: true, value: undefined });\n            }\n        }\n        async function fillQueue() {\n            if (ended) {\n                return;\n            }\n            if (reading) {\n                return;\n            }\n            if (resultQueue.length >= size) {\n                return;\n            }\n            reading = true;\n            try {\n                const { done, value } = await iterator.next();\n                if (done) {\n                    ended = true;\n                }\n                else {\n                    resultQueue.push({ value });\n                }\n            }\n            catch (error) {\n                ended = true;\n                resultQueue.push({ error });\n            }\n            fulfillReadQueue();\n            reading = false;\n            fillQueue();\n        }\n        async function next() {\n            if (resultQueue.length > 0) {\n                const { error, value } = resultQueue.shift();\n                if (error) {\n                    throw error;\n                }\n                fillQueue();\n                return { done: false, value };\n            }\n            if (ended) {\n                return { done: true, value: undefined }; // stupid ts\n            }\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const asyncIterableIterator = {\n            next,\n            [Symbol.asyncIterator]: () => asyncIterableIterator,\n        };\n        return asyncIterableIterator;\n    }\n    function* syncBuffer(size, iterable) {\n        const valueQueue = [];\n        let e;\n        try {\n            for (const value of iterable) {\n                valueQueue.push(value);\n                if (valueQueue.length <= size) {\n                    continue;\n                }\n                yield valueQueue.shift();\n            }\n        }\n        catch (error) {\n            e = error;\n        }\n        for (const value of valueQueue) {\n            yield value;\n        }\n        if (e) {\n            throw e;\n        }\n    }\n    function buffer(size, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => buffer(size, curriedIterable);\n        }\n        if (size === 0) {\n            return iterable;\n        }\n        if (iterable[Symbol.asyncIterator]) {\n            return _buffer(size, iterable);\n        }\n        return syncBuffer(size, iterable);\n    }\n\n    async function _collect(iterable) {\n        const values = [];\n        for await (const value of iterable) {\n            values.push(value);\n        }\n        return values;\n    }\n    function collect(iterable) {\n        if (iterable[Symbol.asyncIterator]) {\n            return _collect(iterable);\n        }\n        return Array.from(iterable);\n    }\n\n    async function* _concat(iterables) {\n        for await (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    function* _syncConcat(iterables) {\n        for (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    function concat(...iterables) {\n        const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n        if (hasAnyAsync) {\n            return _concat(iterables);\n        }\n        else {\n            return _syncConcat(iterables);\n        }\n    }\n\n    async function _consume(iterable) {\n        for await (const val of iterable) {\n            // do nothing\n        }\n    }\n    function consume(iterable) {\n        if (iterable[Symbol.asyncIterator]) {\n            return _consume(iterable);\n        }\n        for (const val of iterable) {\n            // do nothing\n        }\n    }\n\n    async function* _filter(filterFunc, iterable) {\n        for await (const data of iterable) {\n            if (await filterFunc(data)) {\n                yield data;\n            }\n        }\n    }\n    function filter(filterFunc, iterable) {\n        if (iterable === undefined) {\n            return (curriedIterable) => _filter(filterFunc, curriedIterable);\n        }\n        return _filter(filterFunc, iterable);\n    }\n\n    async function* flatten(iterable) {\n        for await (const maybeItr of iterable) {\n            if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n                yield* flatten(maybeItr);\n            }\n            else {\n                yield maybeItr;\n            }\n        }\n    }\n\n    async function* _map(func, iterable) {\n        for await (const val of iterable) {\n            yield await func(val);\n        }\n    }\n    function map(func, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => _map(func, curriedIterable);\n        }\n        return _map(func, iterable);\n    }\n\n    function flatMap(func, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => flatMap(func, curriedIterable);\n        }\n        return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n    }\n\n    function _flatTransform(concurrency, func, iterable) {\n        const iterator = getIterator(iterable);\n        const resultQueue = [];\n        const readQueue = [];\n        let ended = false;\n        let reading = false;\n        let inflightCount = 0;\n        let lastError = null;\n        function fulfillReadQueue() {\n            while (readQueue.length > 0 && resultQueue.length > 0) {\n                const { resolve } = readQueue.shift();\n                const value = resultQueue.shift();\n                resolve({ done: false, value });\n            }\n            while (readQueue.length > 0 && inflightCount === 0 && ended) {\n                const { resolve, reject } = readQueue.shift();\n                if (lastError) {\n                    reject(lastError);\n                    lastError = null;\n                }\n                else {\n                    resolve({ done: true, value: undefined });\n                }\n            }\n        }\n        async function fillQueue() {\n            if (ended) {\n                fulfillReadQueue();\n                return;\n            }\n            if (reading) {\n                return;\n            }\n            if (inflightCount + resultQueue.length >= concurrency) {\n                return;\n            }\n            reading = true;\n            inflightCount++;\n            try {\n                const { done, value } = await iterator.next();\n                if (done) {\n                    ended = true;\n                    inflightCount--;\n                    fulfillReadQueue();\n                }\n                else {\n                    mapAndQueue(value);\n                }\n            }\n            catch (error) {\n                ended = true;\n                inflightCount--;\n                lastError = error;\n                fulfillReadQueue();\n            }\n            reading = false;\n            fillQueue();\n        }\n        async function mapAndQueue(itrValue) {\n            try {\n                const value = await func(itrValue);\n                if (value && value[Symbol.asyncIterator]) {\n                    for await (const asyncVal of value) {\n                        resultQueue.push(asyncVal);\n                    }\n                }\n                else {\n                    resultQueue.push(value);\n                }\n            }\n            catch (error) {\n                ended = true;\n                lastError = error;\n            }\n            inflightCount--;\n            fulfillReadQueue();\n            fillQueue();\n        }\n        async function next() {\n            if (resultQueue.length === 0) {\n                const deferred = defer();\n                readQueue.push(deferred);\n                fillQueue();\n                return deferred.promise;\n            }\n            const value = resultQueue.shift();\n            fillQueue();\n            return { done: false, value };\n        }\n        const asyncIterableIterator = {\n            next,\n            [Symbol.asyncIterator]: () => asyncIterableIterator,\n        };\n        return asyncIterableIterator;\n    }\n    function flatTransform(concurrency, func, iterable) {\n        if (func === undefined) {\n            return (curriedFunc, curriedIterable) => curriedIterable\n                ? flatTransform(concurrency, curriedFunc, curriedIterable)\n                : flatTransform(concurrency, curriedFunc);\n        }\n        if (iterable === undefined) {\n            return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n        }\n        return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n    }\n\n    async function onceReadable(stream) {\n        return new Promise(resolve => {\n            stream.once('readable', () => {\n                resolve();\n            });\n        });\n    }\n    async function* _fromStream(stream) {\n        while (true) {\n            const data = stream.read();\n            if (data !== null) {\n                yield data;\n                continue;\n            }\n            if (stream._readableState.ended) {\n                break;\n            }\n            await onceReadable(stream);\n        }\n    }\n    function fromStream(stream) {\n        if (typeof stream[Symbol.asyncIterator] === 'function') {\n            return stream;\n        }\n        return _fromStream(stream);\n    }\n\n    async function* merge(...iterables) {\n        const sources = new Set(iterables.map(getIterator));\n        while (sources.size > 0) {\n            for (const iterator of sources) {\n                const nextVal = await iterator.next();\n                if (nextVal.done) {\n                    sources.delete(iterator);\n                }\n                else {\n                    yield nextVal.value;\n                }\n            }\n        }\n    }\n\n    function pipeline(firstFn, ...fns) {\n        let previousFn = firstFn();\n        for (const func of fns) {\n            previousFn = func(previousFn);\n        }\n        return previousFn;\n    }\n\n    async function* _parallelMap(concurrency, func, iterable) {\n        let transformError = null;\n        const wrapFunc = value => ({\n            value: func(value),\n        });\n        const stopOnError = async function* (source) {\n            for await (const value of source) {\n                if (transformError) {\n                    return;\n                }\n                yield value;\n            }\n        };\n        const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n        const itr = getIterator(output);\n        while (true) {\n            const { value, done } = await itr.next();\n            if (done) {\n                break;\n            }\n            try {\n                const val = await value.value;\n                if (!transformError) {\n                    yield val;\n                }\n            }\n            catch (error) {\n                transformError = error;\n            }\n        }\n        if (transformError) {\n            throw transformError;\n        }\n    }\n    function parallelMap(concurrency, func, iterable) {\n        if (func === undefined) {\n            return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n        }\n        if (iterable === undefined) {\n            return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n        }\n        if (concurrency === 1) {\n            return map(func, iterable);\n        }\n        return _parallelMap(concurrency, func, iterable);\n    }\n\n    function parallelFlatMap(concurrency, func, iterable) {\n        if (func === undefined) {\n            return (curriedFunc, curriedIterable) => curriedIterable\n                ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n                : parallelFlatMap(concurrency, curriedFunc);\n        }\n        if (iterable === undefined) {\n            return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n        }\n        return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n    }\n\n    /// <reference lib=\"esnext.asynciterable\" />\n    async function* parallelMerge(...iterables) {\n        const inputs = iterables.map(getIterator);\n        const concurrentWork = new Set();\n        const values = new Map();\n        let lastError = null;\n        let errCb = null;\n        let valueCb = null;\n        const notifyError = err => {\n            lastError = err;\n            if (errCb) {\n                errCb(err);\n            }\n        };\n        const notifyDone = value => {\n            if (valueCb) {\n                valueCb(value);\n            }\n        };\n        const waitForQueue = () => new Promise((resolve, reject) => {\n            if (lastError) {\n                reject(lastError);\n            }\n            if (values.size > 0) {\n                return resolve();\n            }\n            valueCb = resolve;\n            errCb = reject;\n        });\n        const queueNext = input => {\n            const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n                if (!done) {\n                    values.set(input, value);\n                }\n                concurrentWork.delete(nextVal);\n            });\n            concurrentWork.add(nextVal);\n            nextVal.then(notifyDone, notifyError);\n        };\n        for (const input of inputs) {\n            queueNext(input);\n        }\n        while (true) {\n            // We technically don't have to check `values.size` as the for loop should have emptied it\n            // However I haven't yet found specs verifying that behavior, only tests\n            // the guard in waitForQueue() checking for values is in place for the same reason\n            if (concurrentWork.size === 0 && values.size === 0) {\n                return;\n            }\n            await waitForQueue();\n            for (const [input, value] of values) {\n                values.delete(input);\n                yield value;\n                queueNext(input);\n            }\n        }\n    }\n\n    async function _reduce(func, start, iterable) {\n        let value = start;\n        for await (const nextItem of iterable) {\n            value = await func(value, nextItem);\n        }\n        return value;\n    }\n    function reduce(func, start, iterable) {\n        if (start === undefined) {\n            return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n        }\n        if (iterable === undefined) {\n            return (curriedIterable) => reduce(func, start, curriedIterable);\n        }\n        return _reduce(func, start, iterable);\n    }\n\n    async function* _take(count, iterable) {\n        let taken = 0;\n        for await (const val of iterable) {\n            yield await val;\n            taken++;\n            if (taken >= count) {\n                break;\n            }\n        }\n    }\n    function* _syncTake(count, iterable) {\n        let taken = 0;\n        for (const val of iterable) {\n            yield val;\n            taken++;\n            if (taken >= count) {\n                break;\n            }\n        }\n    }\n    function take(count, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => take(count, curriedIterable);\n        }\n        if (iterable[Symbol.asyncIterator]) {\n            return _take(count, iterable);\n        }\n        return _syncTake(count, iterable);\n    }\n\n    async function* _asyncTap(func, iterable) {\n        for await (const val of iterable) {\n            await func(val);\n            yield val;\n        }\n    }\n    function tap(func, iterable) {\n        if (iterable === undefined) {\n            return (curriedIterable) => _asyncTap(func, curriedIterable);\n        }\n        return _asyncTap(func, iterable);\n    }\n\n    function addTime(a, b) {\n        let seconds = a[0] + b[0];\n        let nanoseconds = a[1] + b[1];\n        if (nanoseconds >= 1000000000) {\n            const remainder = nanoseconds % 1000000000;\n            seconds += (nanoseconds - remainder) / 1000000000;\n            nanoseconds = remainder;\n        }\n        return [seconds, nanoseconds];\n    }\n    async function* _asyncTime(config, iterable) {\n        const itr = iterable[Symbol.asyncIterator]();\n        let total = [0, 0];\n        while (true) {\n            const start = process.hrtime();\n            const { value, done } = await itr.next();\n            const delta = process.hrtime(start);\n            total = addTime(total, delta);\n            if (config.progress) {\n                config.progress(delta, total);\n            }\n            if (done) {\n                if (config.total) {\n                    config.total(total);\n                }\n                return value;\n            }\n            yield value;\n        }\n    }\n    function* _syncTime(config, iterable) {\n        const itr = iterable[Symbol.iterator]();\n        let total = [0, 0];\n        while (true) {\n            const start = process.hrtime();\n            const { value, done } = itr.next();\n            const delta = process.hrtime(start);\n            total = addTime(total, delta);\n            if (config.progress) {\n                config.progress(delta, total);\n            }\n            if (done) {\n                if (config.total) {\n                    config.total(total);\n                }\n                return value;\n            }\n            yield value;\n        }\n    }\n    function time(config = {}, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => time(config, curriedIterable);\n        }\n        if (iterable[Symbol.asyncIterator] !== undefined) {\n            return _asyncTime(config, iterable);\n        }\n        else {\n            return _syncTime(config, iterable);\n        }\n    }\n\n    function _transform(concurrency, func, iterable) {\n        const iterator = getIterator(iterable);\n        const resultQueue = [];\n        const readQueue = [];\n        let ended = false;\n        let reading = false;\n        let inflightCount = 0;\n        let lastError = null;\n        function fulfillReadQueue() {\n            while (readQueue.length > 0 && resultQueue.length > 0) {\n                const { resolve } = readQueue.shift();\n                const value = resultQueue.shift();\n                resolve({ done: false, value });\n            }\n            while (readQueue.length > 0 && inflightCount === 0 && ended) {\n                const { resolve, reject } = readQueue.shift();\n                if (lastError) {\n                    reject(lastError);\n                    lastError = null;\n                }\n                else {\n                    resolve({ done: true, value: undefined });\n                }\n            }\n        }\n        async function fillQueue() {\n            if (ended) {\n                fulfillReadQueue();\n                return;\n            }\n            if (reading) {\n                return;\n            }\n            if (inflightCount + resultQueue.length >= concurrency) {\n                return;\n            }\n            reading = true;\n            inflightCount++;\n            try {\n                const { done, value } = await iterator.next();\n                if (done) {\n                    ended = true;\n                    inflightCount--;\n                    fulfillReadQueue();\n                }\n                else {\n                    mapAndQueue(value);\n                }\n            }\n            catch (error) {\n                ended = true;\n                inflightCount--;\n                lastError = error;\n                fulfillReadQueue();\n            }\n            reading = false;\n            fillQueue();\n        }\n        async function mapAndQueue(itrValue) {\n            try {\n                const value = await func(itrValue);\n                resultQueue.push(value);\n            }\n            catch (error) {\n                ended = true;\n                lastError = error;\n            }\n            inflightCount--;\n            fulfillReadQueue();\n            fillQueue();\n        }\n        async function next() {\n            if (resultQueue.length === 0) {\n                const deferred = defer();\n                readQueue.push(deferred);\n                fillQueue();\n                return deferred.promise;\n            }\n            const value = resultQueue.shift();\n            fillQueue();\n            return { done: false, value };\n        }\n        const asyncIterableIterator = {\n            next,\n            [Symbol.asyncIterator]: () => asyncIterableIterator,\n        };\n        return asyncIterableIterator;\n    }\n    function transform(concurrency, func, iterable) {\n        if (func === undefined) {\n            return (curriedFunc, curriedIterable) => curriedIterable\n                ? transform(concurrency, curriedFunc, curriedIterable)\n                : transform(concurrency, curriedFunc);\n        }\n        if (iterable === undefined) {\n            return (curriedIterable) => transform(concurrency, func, curriedIterable);\n        }\n        return _transform(concurrency, func, iterable);\n    }\n\n    async function _writeToStream(stream, iterable) {\n        let lastError = null;\n        let errCb = null;\n        let drainCb = null;\n        const notifyError = err => {\n            lastError = err;\n            if (errCb) {\n                errCb(err);\n            }\n        };\n        const notifyDrain = () => {\n            if (drainCb) {\n                drainCb();\n            }\n        };\n        const cleanup = () => {\n            stream.removeListener('error', notifyError);\n            stream.removeListener('drain', notifyDrain);\n        };\n        stream.once('error', notifyError);\n        const waitForDrain = () => new Promise((resolve, reject) => {\n            if (lastError) {\n                return reject(lastError);\n            }\n            stream.once('drain', notifyDrain);\n            drainCb = resolve;\n            errCb = reject;\n        });\n        for await (const value of iterable) {\n            if (stream.write(value) === false) {\n                await waitForDrain();\n            }\n            if (lastError) {\n                break;\n            }\n        }\n        cleanup();\n        if (lastError) {\n            throw lastError;\n        }\n    }\n    function writeToStream(stream, iterable) {\n        if (iterable === undefined) {\n            return (curriedIterable) => _writeToStream(stream, curriedIterable);\n        }\n        return _writeToStream(stream, iterable);\n    }\n\n    exports.batch = batch;\n    exports.buffer = buffer;\n    exports.collect = collect;\n    exports.concat = concat;\n    exports.consume = consume;\n    exports.filter = filter;\n    exports.flatMap = flatMap;\n    exports.flatTransform = flatTransform;\n    exports.flatten = flatten;\n    exports.fromStream = fromStream;\n    exports.getIterator = getIterator;\n    exports.map = map;\n    exports.merge = merge;\n    exports.parallelFlatMap = parallelFlatMap;\n    exports.parallelMap = parallelMap;\n    exports.parallelMerge = parallelMerge;\n    exports.pipeline = pipeline;\n    exports.reduce = reduce;\n    exports.take = take;\n    exports.tap = tap;\n    exports.time = time;\n    exports.transform = transform;\n    exports.writeToStream = writeToStream;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}