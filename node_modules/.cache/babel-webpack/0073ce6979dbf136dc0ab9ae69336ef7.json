{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-identify\"] || ($protobuf.roots[\"libp2p-identify\"] = {});\n\n$root.Identify = function () {\n  /**\n   * Properties of an Identify.\n   * @exports IIdentify\n   * @interface IIdentify\n   * @property {string|null} [protocolVersion] Identify protocolVersion\n   * @property {string|null} [agentVersion] Identify agentVersion\n   * @property {Uint8Array|null} [publicKey] Identify publicKey\n   * @property {Array.<Uint8Array>|null} [listenAddrs] Identify listenAddrs\n   * @property {Uint8Array|null} [observedAddr] Identify observedAddr\n   * @property {Array.<string>|null} [protocols] Identify protocols\n   * @property {Uint8Array|null} [signedPeerRecord] Identify signedPeerRecord\n   */\n\n  /**\n   * Constructs a new Identify.\n   * @exports Identify\n   * @classdesc Represents an Identify.\n   * @implements IIdentify\n   * @constructor\n   * @param {IIdentify=} [p] Properties to set\n   */\n  function Identify(p) {\n    this.listenAddrs = [];\n    this.protocols = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Identify protocolVersion.\n   * @member {string} protocolVersion\n   * @memberof Identify\n   * @instance\n   */\n\n\n  Identify.prototype.protocolVersion = \"\";\n  /**\n   * Identify agentVersion.\n   * @member {string} agentVersion\n   * @memberof Identify\n   * @instance\n   */\n\n  Identify.prototype.agentVersion = \"\";\n  /**\n   * Identify publicKey.\n   * @member {Uint8Array} publicKey\n   * @memberof Identify\n   * @instance\n   */\n\n  Identify.prototype.publicKey = $util.newBuffer([]);\n  /**\n   * Identify listenAddrs.\n   * @member {Array.<Uint8Array>} listenAddrs\n   * @memberof Identify\n   * @instance\n   */\n\n  Identify.prototype.listenAddrs = $util.emptyArray;\n  /**\n   * Identify observedAddr.\n   * @member {Uint8Array} observedAddr\n   * @memberof Identify\n   * @instance\n   */\n\n  Identify.prototype.observedAddr = $util.newBuffer([]);\n  /**\n   * Identify protocols.\n   * @member {Array.<string>} protocols\n   * @memberof Identify\n   * @instance\n   */\n\n  Identify.prototype.protocols = $util.emptyArray;\n  /**\n   * Identify signedPeerRecord.\n   * @member {Uint8Array} signedPeerRecord\n   * @memberof Identify\n   * @instance\n   */\n\n  Identify.prototype.signedPeerRecord = $util.newBuffer([]);\n  /**\n   * Encodes the specified Identify message. Does not implicitly {@link Identify.verify|verify} messages.\n   * @function encode\n   * @memberof Identify\n   * @static\n   * @param {IIdentify} m Identify message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Identify.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.publicKey != null && Object.hasOwnProperty.call(m, \"publicKey\")) w.uint32(10).bytes(m.publicKey);\n\n    if (m.listenAddrs != null && m.listenAddrs.length) {\n      for (var i = 0; i < m.listenAddrs.length; ++i) w.uint32(18).bytes(m.listenAddrs[i]);\n    }\n\n    if (m.protocols != null && m.protocols.length) {\n      for (var i = 0; i < m.protocols.length; ++i) w.uint32(26).string(m.protocols[i]);\n    }\n\n    if (m.observedAddr != null && Object.hasOwnProperty.call(m, \"observedAddr\")) w.uint32(34).bytes(m.observedAddr);\n    if (m.protocolVersion != null && Object.hasOwnProperty.call(m, \"protocolVersion\")) w.uint32(42).string(m.protocolVersion);\n    if (m.agentVersion != null && Object.hasOwnProperty.call(m, \"agentVersion\")) w.uint32(50).string(m.agentVersion);\n    if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, \"signedPeerRecord\")) w.uint32(66).bytes(m.signedPeerRecord);\n    return w;\n  };\n  /**\n   * Decodes an Identify message from the specified reader or buffer.\n   * @function decode\n   * @memberof Identify\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Identify} Identify\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Identify.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Identify();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 5:\n          m.protocolVersion = r.string();\n          break;\n\n        case 6:\n          m.agentVersion = r.string();\n          break;\n\n        case 1:\n          m.publicKey = r.bytes();\n          break;\n\n        case 2:\n          if (!(m.listenAddrs && m.listenAddrs.length)) m.listenAddrs = [];\n          m.listenAddrs.push(r.bytes());\n          break;\n\n        case 4:\n          m.observedAddr = r.bytes();\n          break;\n\n        case 3:\n          if (!(m.protocols && m.protocols.length)) m.protocols = [];\n          m.protocols.push(r.string());\n          break;\n\n        case 8:\n          m.signedPeerRecord = r.bytes();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates an Identify message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Identify\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Identify} Identify\n   */\n\n\n  Identify.fromObject = function fromObject(d) {\n    if (d instanceof $root.Identify) return d;\n    var m = new $root.Identify();\n\n    if (d.protocolVersion != null) {\n      m.protocolVersion = String(d.protocolVersion);\n    }\n\n    if (d.agentVersion != null) {\n      m.agentVersion = String(d.agentVersion);\n    }\n\n    if (d.publicKey != null) {\n      if (typeof d.publicKey === \"string\") $util.base64.decode(d.publicKey, m.publicKey = $util.newBuffer($util.base64.length(d.publicKey)), 0);else if (d.publicKey.length) m.publicKey = d.publicKey;\n    }\n\n    if (d.listenAddrs) {\n      if (!Array.isArray(d.listenAddrs)) throw TypeError(\".Identify.listenAddrs: array expected\");\n      m.listenAddrs = [];\n\n      for (var i = 0; i < d.listenAddrs.length; ++i) {\n        if (typeof d.listenAddrs[i] === \"string\") $util.base64.decode(d.listenAddrs[i], m.listenAddrs[i] = $util.newBuffer($util.base64.length(d.listenAddrs[i])), 0);else if (d.listenAddrs[i].length) m.listenAddrs[i] = d.listenAddrs[i];\n      }\n    }\n\n    if (d.observedAddr != null) {\n      if (typeof d.observedAddr === \"string\") $util.base64.decode(d.observedAddr, m.observedAddr = $util.newBuffer($util.base64.length(d.observedAddr)), 0);else if (d.observedAddr.length) m.observedAddr = d.observedAddr;\n    }\n\n    if (d.protocols) {\n      if (!Array.isArray(d.protocols)) throw TypeError(\".Identify.protocols: array expected\");\n      m.protocols = [];\n\n      for (var i = 0; i < d.protocols.length; ++i) {\n        m.protocols[i] = String(d.protocols[i]);\n      }\n    }\n\n    if (d.signedPeerRecord != null) {\n      if (typeof d.signedPeerRecord === \"string\") $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);else if (d.signedPeerRecord.length) m.signedPeerRecord = d.signedPeerRecord;\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from an Identify message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Identify\n   * @static\n   * @param {Identify} m Identify\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Identify.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.arrays || o.defaults) {\n      d.listenAddrs = [];\n      d.protocols = [];\n    }\n\n    if (o.defaults) {\n      if (o.bytes === String) d.publicKey = \"\";else {\n        d.publicKey = [];\n        if (o.bytes !== Array) d.publicKey = $util.newBuffer(d.publicKey);\n      }\n      if (o.bytes === String) d.observedAddr = \"\";else {\n        d.observedAddr = [];\n        if (o.bytes !== Array) d.observedAddr = $util.newBuffer(d.observedAddr);\n      }\n      d.protocolVersion = \"\";\n      d.agentVersion = \"\";\n      if (o.bytes === String) d.signedPeerRecord = \"\";else {\n        d.signedPeerRecord = [];\n        if (o.bytes !== Array) d.signedPeerRecord = $util.newBuffer(d.signedPeerRecord);\n      }\n    }\n\n    if (m.publicKey != null && m.hasOwnProperty(\"publicKey\")) {\n      d.publicKey = o.bytes === String ? $util.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;\n    }\n\n    if (m.listenAddrs && m.listenAddrs.length) {\n      d.listenAddrs = [];\n\n      for (var j = 0; j < m.listenAddrs.length; ++j) {\n        d.listenAddrs[j] = o.bytes === String ? $util.base64.encode(m.listenAddrs[j], 0, m.listenAddrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.listenAddrs[j]) : m.listenAddrs[j];\n      }\n    }\n\n    if (m.protocols && m.protocols.length) {\n      d.protocols = [];\n\n      for (var j = 0; j < m.protocols.length; ++j) {\n        d.protocols[j] = m.protocols[j];\n      }\n    }\n\n    if (m.observedAddr != null && m.hasOwnProperty(\"observedAddr\")) {\n      d.observedAddr = o.bytes === String ? $util.base64.encode(m.observedAddr, 0, m.observedAddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.observedAddr) : m.observedAddr;\n    }\n\n    if (m.protocolVersion != null && m.hasOwnProperty(\"protocolVersion\")) {\n      d.protocolVersion = m.protocolVersion;\n    }\n\n    if (m.agentVersion != null && m.hasOwnProperty(\"agentVersion\")) {\n      d.agentVersion = m.agentVersion;\n    }\n\n    if (m.signedPeerRecord != null && m.hasOwnProperty(\"signedPeerRecord\")) {\n      d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Identify to JSON.\n   * @function toJSON\n   * @memberof Identify\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Identify.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Identify;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}