{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key,\n  Errors,\n  Adapter,\n  utils: {\n    sortAll\n  }\n} = require('interface-datastore');\n\nconst filter = require('it-filter');\n\nconst map = require('it-map');\n\nconst take = require('it-take');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} QueryOptions\n */\n\n/**\n * A datastore backed by leveldb.\n *\n * @implements {Datastore}\n */\n\n\nclass LevelDatastore extends Adapter {\n  /**\n   * @param {any} path\n   * @param {Object} [opts]\n   * @param {any} [opts.db] - level db reference\n   * @param {boolean} [opts.createIfMissing]\n   * @param {boolean} [opts.errorIfExists]\n   * @param {string} [opts.prefix] - level-js option\n   * @param {number} [opts.version] - level-js option\n   * @param {number} [opts.cacheSize] - leveldown option\n   * @param {number} [opts.writeBufferSize] - leveldown option\n   * @param {number} [opts.blockSize] - leveldown option\n   * @param {number} [opts.maxOpenFiles] - leveldown option\n   * @param {number} [opts.blockRestartInterval] - leveldown option\n   * @param {number} [opts.maxFileSize] - leveldown option\n   */\n  constructor(path, opts) {\n    super();\n    this.path = path;\n    this.opts = opts;\n\n    if (opts && opts.db) {\n      this.database = opts.db;\n      delete opts.db;\n    } else {\n      // @ts-ignore\n      this.database = require('level');\n    }\n  }\n\n  _initDb() {\n    return new Promise((resolve, reject) => {\n      this.db = this.database(this.path, { ...this.opts,\n        valueEncoding: 'binary',\n        compression: false // same default as go\n\n      },\n      /** @param {Error}  [err] */\n      err => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(this.db);\n      });\n    });\n  }\n\n  open() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        if (_this.db) {\n          yield _this.db.open();\n        } else {\n          _this.db = yield _this._initDb();\n        }\n      } catch (err) {\n        throw Errors.dbOpenFailedError(err);\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n\n\n  put(key, value) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this2.db.put(key.toString(), value);\n      } catch (err) {\n        throw Errors.dbWriteFailedError(err);\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  get(key) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let data;\n\n      try {\n        data = yield _this3.db.get(key.toString());\n      } catch (err) {\n        if (err.notFound) throw Errors.notFoundError(err);\n        throw Errors.dbWriteFailedError(err);\n      }\n\n      return data;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<boolean>}\n   */\n\n\n  has(key) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this4.db.get(key.toString());\n      } catch (err) {\n        if (err.notFound) return false;\n        throw err;\n      }\n\n      return true;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<void>}\n   */\n\n\n  delete(key) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this5.db.del(key.toString());\n      } catch (err) {\n        throw Errors.dbDeleteFailedError(err);\n      }\n    })();\n  }\n\n  close() {\n    return this.db && this.db.close();\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    /** @type {{ type: string; key: string; value?: Uint8Array; }[]} */\n    const ops = [];\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        });\n      },\n      delete: key => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        });\n      },\n      commit: () => {\n        return this.db.batch(ops);\n      }\n    };\n  }\n  /**\n   * @param {Query} q\n   */\n\n\n  query(q) {\n    let it = this._query({\n      values: true,\n      prefix: q.prefix\n    });\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    const {\n      offset,\n      limit\n    } = q;\n\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n\n    if (limit) {\n      it = take(it, limit);\n    }\n\n    return it;\n  }\n  /**\n   * @param {KeyQuery} q\n   */\n\n\n  queryKeys(q) {\n    let it = map(this._query({\n      values: false,\n      prefix: q.prefix\n    }), ({\n      key\n    }) => key);\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    const {\n      offset,\n      limit\n    } = q;\n\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n\n    if (limit) {\n      it = take(it, limit);\n    }\n\n    return it;\n  }\n  /**\n   * @param {object} opts\n   * @param {boolean} opts.values\n   * @param {string} [opts.prefix]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  _query(opts) {\n    const iteratorOpts = {\n      keys: true,\n      keyAsBuffer: true,\n      values: opts.values\n    }; // Let the db do the prefix matching\n\n    if (opts.prefix != null) {\n      const prefix = opts.prefix.toString(); // Match keys greater than or equal to `prefix` and\n      // @ts-ignore\n\n      iteratorOpts.gte = prefix; // less than `prefix` + \\xFF (hex escape sequence)\n      // @ts-ignore\n\n      iteratorOpts.lt = prefix + '\\xFF';\n    }\n\n    return levelIteratorToIterator(this.db.iterator(iteratorOpts));\n  }\n\n}\n/**\n * @typedef {Object} LevelIterator\n * @property {(cb: (err: Error, key: string | Uint8Array | null, value: any)=> void)=>void} next\n * @property {(cb: (err: Error) => void) => void } end\n */\n\n/**\n * @param {LevelIterator} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\n\n\nfunction levelIteratorToIterator(li) {\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next: () => new Promise((resolve, reject) => {\n          li.next((err, key, value) => {\n            if (err) return reject(err);\n\n            if (key == null) {\n              return li.end(err => {\n                if (err) return reject(err);\n                resolve({\n                  done: true,\n                  value: undefined\n                });\n              });\n            }\n\n            resolve({\n              done: false,\n              value: {\n                key: new Key(key, false),\n                value\n              }\n            });\n          });\n        }),\n        return: () => new Promise((resolve, reject) => {\n          li.end(err => {\n            if (err) return reject(err);\n            resolve({\n              done: true,\n              value: undefined\n            });\n          });\n        })\n      };\n    }\n\n  };\n}\n\nmodule.exports = LevelDatastore;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/datastore-level/src/index.js"],"names":["Key","Errors","Adapter","utils","sortAll","require","filter","map","take","LevelDatastore","constructor","path","opts","db","database","_initDb","Promise","resolve","reject","valueEncoding","compression","err","open","dbOpenFailedError","put","key","value","toString","dbWriteFailedError","get","data","notFound","notFoundError","has","delete","del","dbDeleteFailedError","close","batch","ops","push","type","commit","query","q","it","_query","values","prefix","Array","isArray","filters","reduce","f","orders","offset","limit","i","queryKeys","iteratorOpts","keys","keyAsBuffer","gte","lt","levelIteratorToIterator","iterator","li","Symbol","asyncIterator","next","end","done","undefined","return","module","exports"],"mappings":"AAAA;;;;AAEA,MAAM;AACJA,EAAAA,GADI;AACCC,EAAAA,MADD;AACSC,EAAAA,OADT;AAEJC,EAAAA,KAAK,EAAE;AACLC,IAAAA;AADK;AAFH,IAKFC,OAAO,CAAC,qBAAD,CALX;;AAMA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,SAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,cAAN,SAA6BP,OAA7B,CAAqC;AACnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEQ,EAAAA,WAAW,CAAEC,IAAF,EAAQC,IAAR,EAAc;AACvB;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,IAAL,GAAYA,IAAZ;;AAEA,QAAIA,IAAI,IAAIA,IAAI,CAACC,EAAjB,EAAqB;AACnB,WAAKC,QAAL,GAAgBF,IAAI,CAACC,EAArB;AACA,aAAOD,IAAI,CAACC,EAAZ;AACD,KAHD,MAGO;AACL;AACA,WAAKC,QAAL,GAAgBT,OAAO,CAAC,OAAD,CAAvB;AACD;AACF;;AAEDU,EAAAA,OAAO,GAAI;AACT,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKL,EAAL,GAAU,KAAKC,QAAL,CACR,KAAKH,IADG,EAER,EACE,GAAG,KAAKC,IADV;AAEEO,QAAAA,aAAa,EAAE,QAFjB;AAGEC,QAAAA,WAAW,EAAE,KAHf,CAGqB;;AAHrB,OAFQ;AAOR;AACCC,MAAAA,GAAD,IAAS;AACP,YAAIA,GAAJ,EAAS;AACP,iBAAOH,MAAM,CAACG,GAAD,CAAb;AACD;;AACDJ,QAAAA,OAAO,CAAC,KAAKJ,EAAN,CAAP;AACD,OAbO,CAAV;AAeD,KAhBM,CAAP;AAiBD;;AAEKS,EAAAA,IAAI,GAAI;AAAA;;AAAA;AACZ,UAAI;AACF,YAAI,KAAI,CAACT,EAAT,EAAa;AACX,gBAAM,KAAI,CAACA,EAAL,CAAQS,IAAR,EAAN;AACD,SAFD,MAEO;AACL,UAAA,KAAI,CAACT,EAAL,SAAgB,KAAI,CAACE,OAAL,EAAhB;AACD;AACF,OAND,CAME,OAAOM,GAAP,EAAY;AACZ,cAAMpB,MAAM,CAACsB,iBAAP,CAAyBF,GAAzB,CAAN;AACD;AATW;AAUb;AAED;AACF;AACA;AACA;;;AACQG,EAAAA,GAAG,CAAEC,GAAF,EAAOC,KAAP,EAAc;AAAA;;AAAA;AACrB,UAAI;AACF,cAAM,MAAI,CAACb,EAAL,CAAQW,GAAR,CAAYC,GAAG,CAACE,QAAJ,EAAZ,EAA4BD,KAA5B,CAAN;AACD,OAFD,CAEE,OAAOL,GAAP,EAAY;AACZ,cAAMpB,MAAM,CAAC2B,kBAAP,CAA0BP,GAA1B,CAAN;AACD;AALoB;AAMtB;AAED;AACF;AACA;AACA;;;AACQQ,EAAAA,GAAG,CAAEJ,GAAF,EAAO;AAAA;;AAAA;AACd,UAAIK,IAAJ;;AACA,UAAI;AACFA,QAAAA,IAAI,SAAS,MAAI,CAACjB,EAAL,CAAQgB,GAAR,CAAYJ,GAAG,CAACE,QAAJ,EAAZ,CAAb;AACD,OAFD,CAEE,OAAON,GAAP,EAAY;AACZ,YAAIA,GAAG,CAACU,QAAR,EAAkB,MAAM9B,MAAM,CAAC+B,aAAP,CAAqBX,GAArB,CAAN;AAClB,cAAMpB,MAAM,CAAC2B,kBAAP,CAA0BP,GAA1B,CAAN;AACD;;AACD,aAAOS,IAAP;AARc;AASf;AAED;AACF;AACA;AACA;;;AACQG,EAAAA,GAAG,CAAER,GAAF,EAAO;AAAA;;AAAA;AACd,UAAI;AACF,cAAM,MAAI,CAACZ,EAAL,CAAQgB,GAAR,CAAYJ,GAAG,CAACE,QAAJ,EAAZ,CAAN;AACD,OAFD,CAEE,OAAON,GAAP,EAAY;AACZ,YAAIA,GAAG,CAACU,QAAR,EAAkB,OAAO,KAAP;AAClB,cAAMV,GAAN;AACD;;AACD,aAAO,IAAP;AAPc;AAQf;AAED;AACF;AACA;AACA;;;AACQa,EAAAA,MAAM,CAAET,GAAF,EAAO;AAAA;;AAAA;AACjB,UAAI;AACF,cAAM,MAAI,CAACZ,EAAL,CAAQsB,GAAR,CAAYV,GAAG,CAACE,QAAJ,EAAZ,CAAN;AACD,OAFD,CAEE,OAAON,GAAP,EAAY;AACZ,cAAMpB,MAAM,CAACmC,mBAAP,CAA2Bf,GAA3B,CAAN;AACD;AALgB;AAMlB;;AAEDgB,EAAAA,KAAK,GAAI;AACP,WAAO,KAAKxB,EAAL,IAAW,KAAKA,EAAL,CAAQwB,KAAR,EAAlB;AACD;AAED;AACF;AACA;;;AACEC,EAAAA,KAAK,GAAI;AACP;AACA,UAAMC,GAAG,GAAG,EAAZ;AACA,WAAO;AACLf,MAAAA,GAAG,EAAE,CAACC,GAAD,EAAMC,KAAN,KAAgB;AACnBa,QAAAA,GAAG,CAACC,IAAJ,CAAS;AACPC,UAAAA,IAAI,EAAE,KADC;AAEPhB,UAAAA,GAAG,EAAEA,GAAG,CAACE,QAAJ,EAFE;AAGPD,UAAAA,KAAK,EAAEA;AAHA,SAAT;AAKD,OAPI;AAQLQ,MAAAA,MAAM,EAAGT,GAAD,IAAS;AACfc,QAAAA,GAAG,CAACC,IAAJ,CAAS;AACPC,UAAAA,IAAI,EAAE,KADC;AAEPhB,UAAAA,GAAG,EAAEA,GAAG,CAACE,QAAJ;AAFE,SAAT;AAID,OAbI;AAcLe,MAAAA,MAAM,EAAE,MAAM;AACZ,eAAO,KAAK7B,EAAL,CAAQyB,KAAR,CAAcC,GAAd,CAAP;AACD;AAhBI,KAAP;AAkBD;AAED;AACF;AACA;;;AACEI,EAAAA,KAAK,CAAEC,CAAF,EAAK;AACR,QAAIC,EAAE,GAAG,KAAKC,MAAL,CAAY;AACnBC,MAAAA,MAAM,EAAE,IADW;AAEnBC,MAAAA,MAAM,EAAEJ,CAAC,CAACI;AAFS,KAAZ,CAAT;;AAKA,QAAIC,KAAK,CAACC,OAAN,CAAcN,CAAC,CAACO,OAAhB,CAAJ,EAA8B;AAC5BN,MAAAA,EAAE,GAAGD,CAAC,CAACO,OAAF,CAAUC,MAAV,CAAiB,CAACP,EAAD,EAAKQ,CAAL,KAAW/C,MAAM,CAACuC,EAAD,EAAKQ,CAAL,CAAlC,EAA2CR,EAA3C,CAAL;AACD;;AAED,QAAII,KAAK,CAACC,OAAN,CAAcN,CAAC,CAACU,MAAhB,CAAJ,EAA6B;AAC3BT,MAAAA,EAAE,GAAGD,CAAC,CAACU,MAAF,CAASF,MAAT,CAAgB,CAACP,EAAD,EAAKQ,CAAL,KAAWjD,OAAO,CAACyC,EAAD,EAAKQ,CAAL,CAAlC,EAA2CR,EAA3C,CAAL;AACD;;AAED,UAAM;AAAEU,MAAAA,MAAF;AAAUC,MAAAA;AAAV,QAAoBZ,CAA1B;;AACA,QAAIW,MAAJ,EAAY;AACV,UAAIE,CAAC,GAAG,CAAR;AACAZ,MAAAA,EAAE,GAAGvC,MAAM,CAACuC,EAAD,EAAK,MAAMY,CAAC,MAAMF,MAAlB,CAAX;AACD;;AAED,QAAIC,KAAJ,EAAW;AACTX,MAAAA,EAAE,GAAGrC,IAAI,CAACqC,EAAD,EAAKW,KAAL,CAAT;AACD;;AAED,WAAOX,EAAP;AACD;AAED;AACF;AACA;;;AACEa,EAAAA,SAAS,CAAEd,CAAF,EAAK;AACZ,QAAIC,EAAE,GAAGtC,GAAG,CAAC,KAAKuC,MAAL,CAAY;AACvBC,MAAAA,MAAM,EAAE,KADe;AAEvBC,MAAAA,MAAM,EAAEJ,CAAC,CAACI;AAFa,KAAZ,CAAD,EAGR,CAAC;AAAEvB,MAAAA;AAAF,KAAD,KAAaA,GAHL,CAAZ;;AAKA,QAAIwB,KAAK,CAACC,OAAN,CAAcN,CAAC,CAACO,OAAhB,CAAJ,EAA8B;AAC5BN,MAAAA,EAAE,GAAGD,CAAC,CAACO,OAAF,CAAUC,MAAV,CAAiB,CAACP,EAAD,EAAKQ,CAAL,KAAW/C,MAAM,CAACuC,EAAD,EAAKQ,CAAL,CAAlC,EAA2CR,EAA3C,CAAL;AACD;;AAED,QAAII,KAAK,CAACC,OAAN,CAAcN,CAAC,CAACU,MAAhB,CAAJ,EAA6B;AAC3BT,MAAAA,EAAE,GAAGD,CAAC,CAACU,MAAF,CAASF,MAAT,CAAgB,CAACP,EAAD,EAAKQ,CAAL,KAAWjD,OAAO,CAACyC,EAAD,EAAKQ,CAAL,CAAlC,EAA2CR,EAA3C,CAAL;AACD;;AAED,UAAM;AAAEU,MAAAA,MAAF;AAAUC,MAAAA;AAAV,QAAoBZ,CAA1B;;AACA,QAAIW,MAAJ,EAAY;AACV,UAAIE,CAAC,GAAG,CAAR;AACAZ,MAAAA,EAAE,GAAGvC,MAAM,CAACuC,EAAD,EAAK,MAAMY,CAAC,MAAMF,MAAlB,CAAX;AACD;;AAED,QAAIC,KAAJ,EAAW;AACTX,MAAAA,EAAE,GAAGrC,IAAI,CAACqC,EAAD,EAAKW,KAAL,CAAT;AACD;;AAED,WAAOX,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,MAAM,CAAElC,IAAF,EAAQ;AACZ,UAAM+C,YAAY,GAAG;AACnBC,MAAAA,IAAI,EAAE,IADa;AAEnBC,MAAAA,WAAW,EAAE,IAFM;AAGnBd,MAAAA,MAAM,EAAEnC,IAAI,CAACmC;AAHM,KAArB,CADY,CAOZ;;AACA,QAAInC,IAAI,CAACoC,MAAL,IAAe,IAAnB,EAAyB;AACvB,YAAMA,MAAM,GAAGpC,IAAI,CAACoC,MAAL,CAAYrB,QAAZ,EAAf,CADuB,CAEvB;AACA;;AACAgC,MAAAA,YAAY,CAACG,GAAb,GAAmBd,MAAnB,CAJuB,CAKvB;AACA;;AACAW,MAAAA,YAAY,CAACI,EAAb,GAAkBf,MAAM,GAAG,MAA3B;AACD;;AAED,WAAOgB,uBAAuB,CAAC,KAAKnD,EAAL,CAAQoD,QAAR,CAAiBN,YAAjB,CAAD,CAA9B;AACD;;AAtOkC;AAyOrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,SAASK,uBAAT,CAAkCE,EAAlC,EAAsC;AACpC,SAAO;AACL,KAACC,MAAM,CAACC,aAAR,IAA0B;AACxB,aAAO;AACLC,QAAAA,IAAI,EAAE,MAAM,IAAIrD,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC3CgD,UAAAA,EAAE,CAACG,IAAH,CAAQ,CAAChD,GAAD,EAAMI,GAAN,EAAWC,KAAX,KAAqB;AAC3B,gBAAIL,GAAJ,EAAS,OAAOH,MAAM,CAACG,GAAD,CAAb;;AACT,gBAAII,GAAG,IAAI,IAAX,EAAiB;AACf,qBAAOyC,EAAE,CAACI,GAAH,CAAOjD,GAAG,IAAI;AACnB,oBAAIA,GAAJ,EAAS,OAAOH,MAAM,CAACG,GAAD,CAAb;AACTJ,gBAAAA,OAAO,CAAC;AAAEsD,kBAAAA,IAAI,EAAE,IAAR;AAAc7C,kBAAAA,KAAK,EAAE8C;AAArB,iBAAD,CAAP;AACD,eAHM,CAAP;AAID;;AACDvD,YAAAA,OAAO,CAAC;AAAEsD,cAAAA,IAAI,EAAE,KAAR;AAAe7C,cAAAA,KAAK,EAAE;AAAED,gBAAAA,GAAG,EAAE,IAAIzB,GAAJ,CAAQyB,GAAR,EAAa,KAAb,CAAP;AAA4BC,gBAAAA;AAA5B;AAAtB,aAAD,CAAP;AACD,WATD;AAUD,SAXW,CADP;AAaL+C,QAAAA,MAAM,EAAE,MAAM,IAAIzD,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC7CgD,UAAAA,EAAE,CAACI,GAAH,CAAOjD,GAAG,IAAI;AACZ,gBAAIA,GAAJ,EAAS,OAAOH,MAAM,CAACG,GAAD,CAAb;AACTJ,YAAAA,OAAO,CAAC;AAAEsD,cAAAA,IAAI,EAAE,IAAR;AAAc7C,cAAAA,KAAK,EAAE8C;AAArB,aAAD,CAAP;AACD,WAHD;AAID,SALa;AAbT,OAAP;AAoBD;;AAtBI,GAAP;AAwBD;;AAEDE,MAAM,CAACC,OAAP,GAAiBlE,cAAjB","sourcesContent":["'use strict'\n\nconst {\n  Key, Errors, Adapter,\n  utils: {\n    sortAll\n  }\n} = require('interface-datastore')\nconst filter = require('it-filter')\nconst map = require('it-map')\nconst take = require('it-take')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} QueryOptions\n */\n\n/**\n * A datastore backed by leveldb.\n *\n * @implements {Datastore}\n */\nclass LevelDatastore extends Adapter {\n  /**\n   * @param {any} path\n   * @param {Object} [opts]\n   * @param {any} [opts.db] - level db reference\n   * @param {boolean} [opts.createIfMissing]\n   * @param {boolean} [opts.errorIfExists]\n   * @param {string} [opts.prefix] - level-js option\n   * @param {number} [opts.version] - level-js option\n   * @param {number} [opts.cacheSize] - leveldown option\n   * @param {number} [opts.writeBufferSize] - leveldown option\n   * @param {number} [opts.blockSize] - leveldown option\n   * @param {number} [opts.maxOpenFiles] - leveldown option\n   * @param {number} [opts.blockRestartInterval] - leveldown option\n   * @param {number} [opts.maxFileSize] - leveldown option\n   */\n  constructor (path, opts) {\n    super()\n    this.path = path\n    this.opts = opts\n\n    if (opts && opts.db) {\n      this.database = opts.db\n      delete opts.db\n    } else {\n      // @ts-ignore\n      this.database = require('level')\n    }\n  }\n\n  _initDb () {\n    return new Promise((resolve, reject) => {\n      this.db = this.database(\n        this.path,\n        {\n          ...this.opts,\n          valueEncoding: 'binary',\n          compression: false // same default as go\n        },\n        /** @param {Error}  [err] */\n        (err) => {\n          if (err) {\n            return reject(err)\n          }\n          resolve(this.db)\n        }\n      )\n    })\n  }\n\n  async open () {\n    try {\n      if (this.db) {\n        await this.db.open()\n      } else {\n        this.db = await this._initDb()\n      }\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n  async put (key, value) {\n    try {\n      await this.db.put(key.toString(), value)\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<Uint8Array>}\n   */\n  async get (key) {\n    let data\n    try {\n      data = await this.db.get(key.toString())\n    } catch (err) {\n      if (err.notFound) throw Errors.notFoundError(err)\n      throw Errors.dbWriteFailedError(err)\n    }\n    return data\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    try {\n      await this.db.get(key.toString())\n    } catch (err) {\n      if (err.notFound) return false\n      throw err\n    }\n    return true\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<void>}\n   */\n  async delete (key) {\n    try {\n      await this.db.del(key.toString())\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  close () {\n    return this.db && this.db.close()\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    /** @type {{ type: string; key: string; value?: Uint8Array; }[]} */\n    const ops = []\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        })\n      },\n      delete: (key) => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        })\n      },\n      commit: () => {\n        return this.db.batch(ops)\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   */\n  query (q) {\n    let it = this._query({\n      values: true,\n      prefix: q.prefix\n    })\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it)\n    }\n\n    const { offset, limit } = q\n    if (offset) {\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (limit) {\n      it = take(it, limit)\n    }\n\n    return it\n  }\n\n  /**\n   * @param {KeyQuery} q\n   */\n  queryKeys (q) {\n    let it = map(this._query({\n      values: false,\n      prefix: q.prefix\n    }), ({ key }) => key)\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it)\n    }\n\n    const { offset, limit } = q\n    if (offset) {\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (limit) {\n      it = take(it, limit)\n    }\n\n    return it\n  }\n\n  /**\n   * @param {object} opts\n   * @param {boolean} opts.values\n   * @param {string} [opts.prefix]\n   * @returns {AsyncIterable<Pair>}\n   */\n  _query (opts) {\n    const iteratorOpts = {\n      keys: true,\n      keyAsBuffer: true,\n      values: opts.values\n    }\n\n    // Let the db do the prefix matching\n    if (opts.prefix != null) {\n      const prefix = opts.prefix.toString()\n      // Match keys greater than or equal to `prefix` and\n      // @ts-ignore\n      iteratorOpts.gte = prefix\n      // less than `prefix` + \\xFF (hex escape sequence)\n      // @ts-ignore\n      iteratorOpts.lt = prefix + '\\xFF'\n    }\n\n    return levelIteratorToIterator(this.db.iterator(iteratorOpts))\n  }\n}\n\n/**\n * @typedef {Object} LevelIterator\n * @property {(cb: (err: Error, key: string | Uint8Array | null, value: any)=> void)=>void} next\n * @property {(cb: (err: Error) => void) => void } end\n */\n\n/**\n * @param {LevelIterator} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\nfunction levelIteratorToIterator (li) {\n  return {\n    [Symbol.asyncIterator] () {\n      return {\n        next: () => new Promise((resolve, reject) => {\n          li.next((err, key, value) => {\n            if (err) return reject(err)\n            if (key == null) {\n              return li.end(err => {\n                if (err) return reject(err)\n                resolve({ done: true, value: undefined })\n              })\n            }\n            resolve({ done: false, value: { key: new Key(key, false), value } })\n          })\n        }),\n        return: () => new Promise((resolve, reject) => {\n          li.end(err => {\n            if (err) return reject(err)\n            resolve({ done: true, value: undefined })\n          })\n        })\n      }\n    }\n  }\n}\n\nmodule.exports = LevelDatastore\n"]},"metadata":{},"sourceType":"script"}