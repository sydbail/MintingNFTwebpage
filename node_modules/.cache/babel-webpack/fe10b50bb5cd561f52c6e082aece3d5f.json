{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst {\n  default: parseDuration\n} = require('parse-duration');\n\nconst crypto = require('libp2p-crypto');\n\nconst errcode = require('err-code');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n});\n\nconst {\n  OFFLINE_ERROR,\n  normalizePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  resolvePath\n} = require('./utils');\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\n\n\nmodule.exports = ({\n  ipns,\n  repo,\n  codecs,\n  peerId,\n  isOnline,\n  keychain\n}) => {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (keyName) {\n      if (keyName === 'self') {\n        return peerId.privKey;\n      }\n\n      try {\n        // We're exporting and immediately importing the key, so we can just use a throw away password\n        const pem = yield keychain.exportKey(keyName, 'temp');\n        const privateKey = yield crypto.keys.import(pem, 'temp');\n        return privateKey;\n      } catch (err) {\n        log.error(err);\n        throw errcode(err, 'ERR_CANNOT_GET_KEY');\n      }\n    });\n\n    return function lookupKey(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n\n\n  function publish(_x2) {\n    return _publish.apply(this, arguments);\n  }\n\n  function _publish() {\n    _publish = _asyncToGenerator(function* (value, options = {}) {\n      const resolve = !(options.resolve === false);\n      const lifetime = options.lifetime || '24h';\n      const key = options.key || 'self';\n\n      if (!isOnline()) {\n        throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n      } // TODO: params related logic should be in the core implementation\n      // Normalize path value\n\n\n      try {\n        value = normalizePath(value);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n\n      let pubLifetime = 0;\n\n      try {\n        pubLifetime = parseDuration(lifetime) || 0; // Calculate lifetime with nanoseconds precision\n\n        pubLifetime = parseFloat(pubLifetime.toFixed(6));\n      } catch (err) {\n        log.error(err);\n        throw err;\n      } // TODO: ttl human for cache\n\n\n      const results = yield Promise.all([// verify if the path exists, if not, an error will stop the execution\n      lookupKey(key), // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({\n        ipns,\n        repo,\n        codecs\n      }, value) : Promise.resolve()]);\n      const bytes = uint8ArrayFromString(value); // Start publishing process\n\n      const result = yield ipns.publish(results[0], bytes, pubLifetime);\n      return {\n        name: result.name,\n        value: uint8ArrayToString(result.value)\n      };\n    });\n    return _publish.apply(this, arguments);\n  }\n\n  return withTimeoutOption(publish);\n};","map":null,"metadata":{},"sourceType":"script"}