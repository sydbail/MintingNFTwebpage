{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.streamingIterables = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function _batch(_x, _x2) {\n    return _batch2.apply(this, arguments);\n  }\n\n  function _batch2() {\n    _batch2 = _wrapAsyncGenerator(function* (size, iterable) {\n      let dataBatch = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(iterable), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const data = _value;\n          dataBatch.push(data);\n\n          if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (dataBatch.length > 0) {\n        yield dataBatch;\n      }\n    });\n    return _batch2.apply(this, arguments);\n  }\n\n  function* _syncBatch(size, iterable) {\n    let dataBatch = [];\n\n    for (const data of iterable) {\n      dataBatch.push(data);\n\n      if (dataBatch.length === size) {\n        yield dataBatch;\n        dataBatch = [];\n      }\n    }\n\n    if (dataBatch.length > 0) {\n      yield dataBatch;\n    }\n  }\n\n  function batch(size, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => batch(size, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _batch(size, iterable);\n    }\n\n    return _syncBatch(size, iterable);\n  }\n\n  function getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n      return iterable;\n    }\n\n    if (typeof iterable[Symbol.iterator] === 'function') {\n      return iterable[Symbol.iterator]();\n    }\n\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n      return iterable[Symbol.asyncIterator]();\n    }\n\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n  }\n\n  function defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n      resolve = resolveFunc;\n      reject = rejectFunc;\n    });\n    return {\n      promise,\n      reject,\n      resolve\n    };\n  } /// <reference lib=\"esnext.asynciterable\" />\n\n\n  function _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const readDeferred = readQueue.shift();\n        const {\n          error,\n          value\n        } = resultQueue.shift();\n\n        if (error) {\n          readDeferred.reject(error);\n        } else {\n          readDeferred.resolve({\n            done: false,\n            value\n          });\n        }\n      }\n\n      while (readQueue.length > 0 && ended) {\n        const {\n          resolve\n        } = readQueue.shift();\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n\n    function fillQueue() {\n      return _fillQueue.apply(this, arguments);\n    }\n\n    function _fillQueue() {\n      _fillQueue = _asyncToGenerator(function* () {\n        if (ended) {\n          return;\n        }\n\n        if (reading) {\n          return;\n        }\n\n        if (resultQueue.length >= size) {\n          return;\n        }\n\n        reading = true;\n\n        try {\n          const {\n            done,\n            value\n          } = yield iterator.next();\n\n          if (done) {\n            ended = true;\n          } else {\n            resultQueue.push({\n              value\n            });\n          }\n        } catch (error) {\n          ended = true;\n          resultQueue.push({\n            error\n          });\n        }\n\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n      });\n      return _fillQueue.apply(this, arguments);\n    }\n\n    function next() {\n      return _next.apply(this, arguments);\n    }\n\n    function _next() {\n      _next = _asyncToGenerator(function* () {\n        if (resultQueue.length > 0) {\n          const {\n            error,\n            value\n          } = resultQueue.shift();\n\n          if (error) {\n            throw error;\n          }\n\n          fillQueue();\n          return {\n            done: false,\n            value\n          };\n        }\n\n        if (ended) {\n          return {\n            done: true,\n            value: undefined\n          }; // stupid ts\n        }\n\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n      });\n      return _next.apply(this, arguments);\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n\n    try {\n      for (const value of iterable) {\n        valueQueue.push(value);\n\n        if (valueQueue.length <= size) {\n          continue;\n        }\n\n        yield valueQueue.shift();\n      }\n    } catch (error) {\n      e = error;\n    }\n\n    for (const value of valueQueue) {\n      yield value;\n    }\n\n    if (e) {\n      throw e;\n    }\n  }\n\n  function buffer(size, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => buffer(size, curriedIterable);\n    }\n\n    if (size === 0) {\n      return iterable;\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _buffer(size, iterable);\n    }\n\n    return syncBuffer(size, iterable);\n  }\n\n  function _collect(_x20) {\n    return _collect2.apply(this, arguments);\n  }\n\n  function _collect2() {\n    _collect2 = _asyncToGenerator(function* (iterable) {\n      const values = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(iterable), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const value = _value2;\n          values.push(value);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return values;\n    });\n    return _collect2.apply(this, arguments);\n  }\n\n  function collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n      return _collect(iterable);\n    }\n\n    return Array.from(iterable);\n  }\n\n  function _concat(_x3) {\n    return _concat2.apply(this, arguments);\n  }\n\n  function _concat2() {\n    _concat2 = _wrapAsyncGenerator(function* (iterables) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(iterables), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const iterable = _value3;\n          yield* _asyncGeneratorDelegate(_asyncIterator(iterable), _awaitAsyncGenerator);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            yield _awaitAsyncGenerator(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    });\n    return _concat2.apply(this, arguments);\n  }\n\n  function* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n      yield* iterable;\n    }\n  }\n\n  function concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n    if (hasAnyAsync) {\n      return _concat(iterables);\n    } else {\n      return _syncConcat(iterables);\n    }\n  }\n\n  function _consume(_x21) {\n    return _consume2.apply(this, arguments);\n  }\n\n  function _consume2() {\n    _consume2 = _asyncToGenerator(function* (iterable) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n\n      var _iteratorError4;\n\n      try {\n        for (var _iterator4 = _asyncIterator(iterable), _step4, _value4; _step4 = yield _iterator4.next(), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _step4.value, !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {// do nothing\n\n          const val = _value4;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            yield _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    });\n    return _consume2.apply(this, arguments);\n  }\n\n  function consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n      return _consume(iterable);\n    }\n\n    for (const val of iterable) {// do nothing\n    }\n  }\n\n  function _filter(_x4, _x5) {\n    return _filter2.apply(this, arguments);\n  }\n\n  function _filter2() {\n    _filter2 = _wrapAsyncGenerator(function* (filterFunc, iterable) {\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n\n      var _iteratorError5;\n\n      try {\n        for (var _iterator5 = _asyncIterator(iterable), _step5, _value5; _step5 = yield _awaitAsyncGenerator(_iterator5.next()), _iteratorNormalCompletion5 = _step5.done, _value5 = yield _awaitAsyncGenerator(_step5.value), !_iteratorNormalCompletion5; _iteratorNormalCompletion5 = true) {\n          const data = _value5;\n\n          if (yield _awaitAsyncGenerator(filterFunc(data))) {\n            yield data;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            yield _awaitAsyncGenerator(_iterator5.return());\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    });\n    return _filter2.apply(this, arguments);\n  }\n\n  function filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _filter(filterFunc, curriedIterable);\n    }\n\n    return _filter(filterFunc, iterable);\n  }\n\n  function flatten(_x6) {\n    return _flatten.apply(this, arguments);\n  }\n\n  function _flatten() {\n    _flatten = _wrapAsyncGenerator(function* (iterable) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n\n      var _iteratorError6;\n\n      try {\n        for (var _iterator6 = _asyncIterator(iterable), _step6, _value6; _step6 = yield _awaitAsyncGenerator(_iterator6.next()), _iteratorNormalCompletion6 = _step6.done, _value6 = yield _awaitAsyncGenerator(_step6.value), !_iteratorNormalCompletion6; _iteratorNormalCompletion6 = true) {\n          const maybeItr = _value6;\n\n          if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* _asyncGeneratorDelegate(_asyncIterator(flatten(maybeItr)), _awaitAsyncGenerator);\n          } else {\n            yield maybeItr;\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            yield _awaitAsyncGenerator(_iterator6.return());\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    });\n    return _flatten.apply(this, arguments);\n  }\n\n  function _map(_x7, _x8) {\n    return _map2.apply(this, arguments);\n  }\n\n  function _map2() {\n    _map2 = _wrapAsyncGenerator(function* (func, iterable) {\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n\n      var _iteratorError7;\n\n      try {\n        for (var _iterator7 = _asyncIterator(iterable), _step7, _value7; _step7 = yield _awaitAsyncGenerator(_iterator7.next()), _iteratorNormalCompletion7 = _step7.done, _value7 = yield _awaitAsyncGenerator(_step7.value), !_iteratorNormalCompletion7; _iteratorNormalCompletion7 = true) {\n          const val = _value7;\n          yield func(val);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            yield _awaitAsyncGenerator(_iterator7.return());\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    });\n    return _map2.apply(this, arguments);\n  }\n\n  function map(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _map(func, curriedIterable);\n    }\n\n    return _map(func, iterable);\n  }\n\n  function flatMap(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => flatMap(func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n  }\n\n  function _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const {\n          resolve\n        } = readQueue.shift();\n        const value = resultQueue.shift();\n        resolve({\n          done: false,\n          value\n        });\n      }\n\n      while (readQueue.length > 0 && inflightCount === 0 && ended) {\n        const {\n          resolve,\n          reject\n        } = readQueue.shift();\n\n        if (lastError) {\n          reject(lastError);\n          lastError = null;\n        } else {\n          resolve({\n            done: true,\n            value: undefined\n          });\n        }\n      }\n    }\n\n    function fillQueue() {\n      return _fillQueue2.apply(this, arguments);\n    }\n\n    function _fillQueue2() {\n      _fillQueue2 = _asyncToGenerator(function* () {\n        if (ended) {\n          fulfillReadQueue();\n          return;\n        }\n\n        if (reading) {\n          return;\n        }\n\n        if (inflightCount + resultQueue.length >= concurrency) {\n          return;\n        }\n\n        reading = true;\n        inflightCount++;\n\n        try {\n          const {\n            done,\n            value\n          } = yield iterator.next();\n\n          if (done) {\n            ended = true;\n            inflightCount--;\n            fulfillReadQueue();\n          } else {\n            mapAndQueue(value);\n          }\n        } catch (error) {\n          ended = true;\n          inflightCount--;\n          lastError = error;\n          fulfillReadQueue();\n        }\n\n        reading = false;\n        fillQueue();\n      });\n      return _fillQueue2.apply(this, arguments);\n    }\n\n    function mapAndQueue(_x22) {\n      return _mapAndQueue.apply(this, arguments);\n    }\n\n    function _mapAndQueue() {\n      _mapAndQueue = _asyncToGenerator(function* (itrValue) {\n        try {\n          const value = yield func(itrValue);\n\n          if (value && value[Symbol.asyncIterator]) {\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n\n            var _iteratorError8;\n\n            try {\n              for (var _iterator8 = _asyncIterator(value), _step8, _value8; _step8 = yield _iterator8.next(), _iteratorNormalCompletion8 = _step8.done, _value8 = yield _step8.value, !_iteratorNormalCompletion8; _iteratorNormalCompletion8 = true) {\n                const asyncVal = _value8;\n                resultQueue.push(asyncVal);\n              }\n            } catch (err) {\n              _didIteratorError8 = true;\n              _iteratorError8 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                  yield _iterator8.return();\n                }\n              } finally {\n                if (_didIteratorError8) {\n                  throw _iteratorError8;\n                }\n              }\n            }\n          } else {\n            resultQueue.push(value);\n          }\n        } catch (error) {\n          ended = true;\n          lastError = error;\n        }\n\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n      });\n      return _mapAndQueue.apply(this, arguments);\n    }\n\n    function next() {\n      return _next2.apply(this, arguments);\n    }\n\n    function _next2() {\n      _next2 = _asyncToGenerator(function* () {\n        if (resultQueue.length === 0) {\n          const deferred = defer();\n          readQueue.push(deferred);\n          fillQueue();\n          return deferred.promise;\n        }\n\n        const value = resultQueue.shift();\n        fillQueue();\n        return {\n          done: false,\n          value\n        };\n      });\n      return _next2.apply(this, arguments);\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n  }\n\n  function onceReadable(_x23) {\n    return _onceReadable.apply(this, arguments);\n  }\n\n  function _onceReadable() {\n    _onceReadable = _asyncToGenerator(function* (stream) {\n      return new Promise(resolve => {\n        stream.once('readable', () => {\n          resolve();\n        });\n      });\n    });\n    return _onceReadable.apply(this, arguments);\n  }\n\n  function _fromStream(_x9) {\n    return _fromStream2.apply(this, arguments);\n  }\n\n  function _fromStream2() {\n    _fromStream2 = _wrapAsyncGenerator(function* (stream) {\n      while (true) {\n        const data = stream.read();\n\n        if (data !== null) {\n          yield data;\n          continue;\n        }\n\n        if (stream._readableState.ended) {\n          break;\n        }\n\n        yield _awaitAsyncGenerator(onceReadable(stream));\n      }\n    });\n    return _fromStream2.apply(this, arguments);\n  }\n\n  function fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n      return stream;\n    }\n\n    return _fromStream(stream);\n  }\n\n  function merge() {\n    return _merge.apply(this, arguments);\n  }\n\n  function _merge() {\n    _merge = _wrapAsyncGenerator(function* (...iterables) {\n      const sources = new Set(iterables.map(getIterator));\n\n      while (sources.size > 0) {\n        for (const iterator of sources) {\n          const nextVal = yield _awaitAsyncGenerator(iterator.next());\n\n          if (nextVal.done) {\n            sources.delete(iterator);\n          } else {\n            yield nextVal.value;\n          }\n        }\n      }\n    });\n    return _merge.apply(this, arguments);\n  }\n\n  function pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n\n    for (const func of fns) {\n      previousFn = func(previousFn);\n    }\n\n    return previousFn;\n  }\n\n  function _parallelMap(_x10, _x11, _x12) {\n    return _parallelMap2.apply(this, arguments);\n  }\n\n  function _parallelMap2() {\n    _parallelMap2 = _wrapAsyncGenerator(function* (concurrency, func, iterable) {\n      let transformError = null;\n\n      const wrapFunc = value => ({\n        value: func(value)\n      });\n\n      const stopOnError = /*#__PURE__*/function () {\n        var _ref = _wrapAsyncGenerator(function* (source) {\n          var _iteratorNormalCompletion13 = true;\n          var _didIteratorError13 = false;\n\n          var _iteratorError13;\n\n          try {\n            for (var _iterator13 = _asyncIterator(source), _step13, _value13; _step13 = yield _awaitAsyncGenerator(_iterator13.next()), _iteratorNormalCompletion13 = _step13.done, _value13 = yield _awaitAsyncGenerator(_step13.value), !_iteratorNormalCompletion13; _iteratorNormalCompletion13 = true) {\n              const value = _value13;\n\n              if (transformError) {\n                return;\n              }\n\n              yield value;\n            }\n          } catch (err) {\n            _didIteratorError13 = true;\n            _iteratorError13 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n                yield _awaitAsyncGenerator(_iterator13.return());\n              }\n            } finally {\n              if (_didIteratorError13) {\n                throw _iteratorError13;\n              }\n            }\n          }\n        });\n\n        return function stopOnError(_x19) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n      const itr = getIterator(output);\n\n      while (true) {\n        const {\n          value,\n          done\n        } = yield _awaitAsyncGenerator(itr.next());\n\n        if (done) {\n          break;\n        }\n\n        try {\n          const val = yield _awaitAsyncGenerator(value.value);\n\n          if (!transformError) {\n            yield val;\n          }\n        } catch (error) {\n          transformError = error;\n        }\n      }\n\n      if (transformError) {\n        throw transformError;\n      }\n    });\n    return _parallelMap2.apply(this, arguments);\n  }\n\n  function parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n\n    if (concurrency === 1) {\n      return map(func, iterable);\n    }\n\n    return _parallelMap(concurrency, func, iterable);\n  }\n\n  function parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n  } /// <reference lib=\"esnext.asynciterable\" />\n\n\n  function parallelMerge() {\n    return _parallelMerge.apply(this, arguments);\n  }\n\n  function _parallelMerge() {\n    _parallelMerge = _wrapAsyncGenerator(function* (...iterables) {\n      const inputs = iterables.map(getIterator);\n      const concurrentWork = new Set();\n      const values = new Map();\n      let lastError = null;\n      let errCb = null;\n      let valueCb = null;\n\n      const notifyError = err => {\n        lastError = err;\n\n        if (errCb) {\n          errCb(err);\n        }\n      };\n\n      const notifyDone = value => {\n        if (valueCb) {\n          valueCb(value);\n        }\n      };\n\n      const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n          reject(lastError);\n        }\n\n        if (values.size > 0) {\n          return resolve();\n        }\n\n        valueCb = resolve;\n        errCb = reject;\n      });\n\n      const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* ({\n            done,\n            value\n          }) {\n            if (!done) {\n              values.set(input, value);\n            }\n\n            concurrentWork.delete(nextVal);\n          });\n\n          return function (_x24) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n      };\n\n      for (const input of inputs) {\n        queueNext(input);\n      }\n\n      while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n          return;\n        }\n\n        yield _awaitAsyncGenerator(waitForQueue());\n\n        for (const [input, value] of values) {\n          values.delete(input);\n          yield value;\n          queueNext(input);\n        }\n      }\n    });\n    return _parallelMerge.apply(this, arguments);\n  }\n\n  function _reduce(_x25, _x26, _x27) {\n    return _reduce2.apply(this, arguments);\n  }\n\n  function _reduce2() {\n    _reduce2 = _asyncToGenerator(function* (func, start, iterable) {\n      let value = start;\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n\n      var _iteratorError9;\n\n      try {\n        for (var _iterator9 = _asyncIterator(iterable), _step9, _value9; _step9 = yield _iterator9.next(), _iteratorNormalCompletion9 = _step9.done, _value9 = yield _step9.value, !_iteratorNormalCompletion9; _iteratorNormalCompletion9 = true) {\n          const nextItem = _value9;\n          value = yield func(value, nextItem);\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            yield _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      return value;\n    });\n    return _reduce2.apply(this, arguments);\n  }\n\n  function reduce(func, start, iterable) {\n    if (start === undefined) {\n      return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => reduce(func, start, curriedIterable);\n    }\n\n    return _reduce(func, start, iterable);\n  }\n\n  function _take(_x13, _x14) {\n    return _take2.apply(this, arguments);\n  }\n\n  function _take2() {\n    _take2 = _wrapAsyncGenerator(function* (count, iterable) {\n      let taken = 0;\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n\n      var _iteratorError10;\n\n      try {\n        for (var _iterator10 = _asyncIterator(iterable), _step10, _value10; _step10 = yield _awaitAsyncGenerator(_iterator10.next()), _iteratorNormalCompletion10 = _step10.done, _value10 = yield _awaitAsyncGenerator(_step10.value), !_iteratorNormalCompletion10; _iteratorNormalCompletion10 = true) {\n          const val = _value10;\n          yield val;\n          taken++;\n\n          if (taken >= count) {\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            yield _awaitAsyncGenerator(_iterator10.return());\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    });\n    return _take2.apply(this, arguments);\n  }\n\n  function* _syncTake(count, iterable) {\n    let taken = 0;\n\n    for (const val of iterable) {\n      yield val;\n      taken++;\n\n      if (taken >= count) {\n        break;\n      }\n    }\n  }\n\n  function take(count, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => take(count, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _take(count, iterable);\n    }\n\n    return _syncTake(count, iterable);\n  }\n\n  function _asyncTap(_x15, _x16) {\n    return _asyncTap2.apply(this, arguments);\n  }\n\n  function _asyncTap2() {\n    _asyncTap2 = _wrapAsyncGenerator(function* (func, iterable) {\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n\n      var _iteratorError11;\n\n      try {\n        for (var _iterator11 = _asyncIterator(iterable), _step11, _value11; _step11 = yield _awaitAsyncGenerator(_iterator11.next()), _iteratorNormalCompletion11 = _step11.done, _value11 = yield _awaitAsyncGenerator(_step11.value), !_iteratorNormalCompletion11; _iteratorNormalCompletion11 = true) {\n          const val = _value11;\n          yield _awaitAsyncGenerator(func(val));\n          yield val;\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n            yield _awaitAsyncGenerator(_iterator11.return());\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n    });\n    return _asyncTap2.apply(this, arguments);\n  }\n\n  function tap(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _asyncTap(func, curriedIterable);\n    }\n\n    return _asyncTap(func, iterable);\n  }\n\n  function addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n\n    if (nanoseconds >= 1000000000) {\n      const remainder = nanoseconds % 1000000000;\n      seconds += (nanoseconds - remainder) / 1000000000;\n      nanoseconds = remainder;\n    }\n\n    return [seconds, nanoseconds];\n  }\n\n  function _asyncTime(_x17, _x18) {\n    return _asyncTime2.apply(this, arguments);\n  }\n\n  function _asyncTime2() {\n    _asyncTime2 = _wrapAsyncGenerator(function* (config, iterable) {\n      const itr = iterable[Symbol.asyncIterator]();\n      let total = [0, 0];\n\n      while (true) {\n        const start = process.hrtime();\n        const {\n          value,\n          done\n        } = yield _awaitAsyncGenerator(itr.next());\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n\n        if (config.progress) {\n          config.progress(delta, total);\n        }\n\n        if (done) {\n          if (config.total) {\n            config.total(total);\n          }\n\n          return value;\n        }\n\n        yield value;\n      }\n    });\n    return _asyncTime2.apply(this, arguments);\n  }\n\n  function* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n\n    while (true) {\n      const start = process.hrtime();\n      const {\n        value,\n        done\n      } = itr.next();\n      const delta = process.hrtime(start);\n      total = addTime(total, delta);\n\n      if (config.progress) {\n        config.progress(delta, total);\n      }\n\n      if (done) {\n        if (config.total) {\n          config.total(total);\n        }\n\n        return value;\n      }\n\n      yield value;\n    }\n  }\n\n  function time(config = {}, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => time(config, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n      return _asyncTime(config, iterable);\n    } else {\n      return _syncTime(config, iterable);\n    }\n  }\n\n  function _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const {\n          resolve\n        } = readQueue.shift();\n        const value = resultQueue.shift();\n        resolve({\n          done: false,\n          value\n        });\n      }\n\n      while (readQueue.length > 0 && inflightCount === 0 && ended) {\n        const {\n          resolve,\n          reject\n        } = readQueue.shift();\n\n        if (lastError) {\n          reject(lastError);\n          lastError = null;\n        } else {\n          resolve({\n            done: true,\n            value: undefined\n          });\n        }\n      }\n    }\n\n    function fillQueue() {\n      return _fillQueue3.apply(this, arguments);\n    }\n\n    function _fillQueue3() {\n      _fillQueue3 = _asyncToGenerator(function* () {\n        if (ended) {\n          fulfillReadQueue();\n          return;\n        }\n\n        if (reading) {\n          return;\n        }\n\n        if (inflightCount + resultQueue.length >= concurrency) {\n          return;\n        }\n\n        reading = true;\n        inflightCount++;\n\n        try {\n          const {\n            done,\n            value\n          } = yield iterator.next();\n\n          if (done) {\n            ended = true;\n            inflightCount--;\n            fulfillReadQueue();\n          } else {\n            mapAndQueue(value);\n          }\n        } catch (error) {\n          ended = true;\n          inflightCount--;\n          lastError = error;\n          fulfillReadQueue();\n        }\n\n        reading = false;\n        fillQueue();\n      });\n      return _fillQueue3.apply(this, arguments);\n    }\n\n    function mapAndQueue(_x28) {\n      return _mapAndQueue2.apply(this, arguments);\n    }\n\n    function _mapAndQueue2() {\n      _mapAndQueue2 = _asyncToGenerator(function* (itrValue) {\n        try {\n          const value = yield func(itrValue);\n          resultQueue.push(value);\n        } catch (error) {\n          ended = true;\n          lastError = error;\n        }\n\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n      });\n      return _mapAndQueue2.apply(this, arguments);\n    }\n\n    function next() {\n      return _next3.apply(this, arguments);\n    }\n\n    function _next3() {\n      _next3 = _asyncToGenerator(function* () {\n        if (resultQueue.length === 0) {\n          const deferred = defer();\n          readQueue.push(deferred);\n          fillQueue();\n          return deferred.promise;\n        }\n\n        const value = resultQueue.shift();\n        fillQueue();\n        return {\n          done: false,\n          value\n        };\n      });\n      return _next3.apply(this, arguments);\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function transform(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => transform(concurrency, func, curriedIterable);\n    }\n\n    return _transform(concurrency, func, iterable);\n  }\n\n  function _writeToStream(_x29, _x30) {\n    return _writeToStream2.apply(this, arguments);\n  }\n\n  function _writeToStream2() {\n    _writeToStream2 = _asyncToGenerator(function* (stream, iterable) {\n      let lastError = null;\n      let errCb = null;\n      let drainCb = null;\n\n      const notifyError = err => {\n        lastError = err;\n\n        if (errCb) {\n          errCb(err);\n        }\n      };\n\n      const notifyDrain = () => {\n        if (drainCb) {\n          drainCb();\n        }\n      };\n\n      const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n      };\n\n      stream.once('error', notifyError);\n\n      const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n          return reject(lastError);\n        }\n\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n      });\n\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n\n      var _iteratorError12;\n\n      try {\n        for (var _iterator12 = _asyncIterator(iterable), _step12, _value12; _step12 = yield _iterator12.next(), _iteratorNormalCompletion12 = _step12.done, _value12 = yield _step12.value, !_iteratorNormalCompletion12; _iteratorNormalCompletion12 = true) {\n          const value = _value12;\n\n          if (stream.write(value) === false) {\n            yield waitForDrain();\n          }\n\n          if (lastError) {\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            yield _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n\n      cleanup();\n\n      if (lastError) {\n        throw lastError;\n      }\n    });\n    return _writeToStream2.apply(this, arguments);\n  }\n\n  function writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _writeToStream(stream, curriedIterable);\n    }\n\n    return _writeToStream(stream, iterable);\n  }\n\n  exports.batch = batch;\n  exports.buffer = buffer;\n  exports.collect = collect;\n  exports.concat = concat;\n  exports.consume = consume;\n  exports.filter = filter;\n  exports.flatMap = flatMap;\n  exports.flatTransform = flatTransform;\n  exports.flatten = flatten;\n  exports.fromStream = fromStream;\n  exports.getIterator = getIterator;\n  exports.map = map;\n  exports.merge = merge;\n  exports.parallelFlatMap = parallelFlatMap;\n  exports.parallelMap = parallelMap;\n  exports.parallelMerge = parallelMerge;\n  exports.pipeline = pipeline;\n  exports.reduce = reduce;\n  exports.take = take;\n  exports.tap = tap;\n  exports.time = time;\n  exports.transform = transform;\n  exports.writeToStream = writeToStream;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}