{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  createFromPrivKey\n} = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns'), {\n  error: debug('ipfs:ipns:error')\n});\n\nconst IpnsPublisher = require('./publisher');\n\nconst IpnsRepublisher = require('./republisher');\n\nconst IpnsResolver = require('./resolver');\n\nconst TLRU = require('../utils/tlru');\n\nconst defaultRecordTtl = 60 * 1000;\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('peer-id')} PeerId\n */\n\n\nclass IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('libp2p/src/keychain')} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor(routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  }\n  /**\n   * Publish\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  publish(privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const peerId = yield createFromPrivKey(privKey.bytes);\n        yield _this.publisher.publishWithEOL(privKey, value, lifetime);\n        log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`); // // Add to cache\n\n        const id = peerId.toB58String(); // @ts-ignore - parseFloat expects string\n\n        const ttEol = parseFloat(lifetime);\n        const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n\n        _this.cache.set(id, value, ttl);\n\n        log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`);\n        return {\n          name: id,\n          value: value\n        };\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   */\n\n\n  resolve(name, options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof name !== 'string') {\n        throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n      } // If recursive, we should not try to get the cached value\n\n\n      if (!options.nocache && !options.recursive) {\n        // Try to get the record from cache\n        const id = name.split('/')[2];\n\n        const result = _this2.cache.get(id);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      try {\n        const result = yield _this2.resolver.resolve(name, options);\n        log(`IPNS record from ${name} was resolved correctly`);\n        return result;\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n\n\n  initializeKeyspace(privKey, value) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      return _this3.publish(privKey, value, IpnsPublisher.defaultRecordLifetime);\n    })();\n  }\n\n}\n\nmodule.exports = IPNS;","map":null,"metadata":{},"sourceType":"script"}