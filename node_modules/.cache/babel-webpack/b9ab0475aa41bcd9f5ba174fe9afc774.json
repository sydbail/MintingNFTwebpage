{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport persist from '../../utils/persist.js';\nimport { encode, prepare } from '@ipld/dag-pb';\nimport parallelBatch from 'it-parallel-batch';\nimport * as rawCodec from 'multiformats/codecs/raw';\nimport * as dagPb from '@ipld/dag-pb';\nimport dagFlat from './flat.js';\nimport dagBalanced from './balanced.js';\nimport dagTrickle from './trickle.js';\nconst dagBuilders = {\n  flat: dagFlat,\n  balanced: dagBalanced,\n  trickle: dagTrickle\n};\n\nfunction buildFileBatch(_x, _x2, _x3) {\n  return _buildFileBatch.apply(this, arguments);\n}\n\nfunction _buildFileBatch() {\n  _buildFileBatch = _wrapAsyncGenerator(function* (file, blockstore, options) {\n    let count = -1;\n    let previous;\n    let bufferImporter;\n\n    if (typeof options.bufferImporter === 'function') {\n      bufferImporter = options.bufferImporter;\n    } else {\n      bufferImporter = (yield _awaitAsyncGenerator(import('./buffer-importer.js'))).default;\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(parallelBatch(bufferImporter(file, blockstore, options), options.blockWriteConcurrency)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const entry = _value;\n        count++;\n\n        if (count === 0) {\n          previous = entry;\n          continue;\n        } else if (count === 1 && previous) {\n          yield previous;\n          previous = null;\n        }\n\n        yield entry;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (previous) {\n      previous.single = true;\n      yield previous;\n    }\n  });\n  return _buildFileBatch.apply(this, arguments);\n}\n\nconst reduce = (file, blockstore, options) => {\n  function reducer(_x4) {\n    return _reducer.apply(this, arguments);\n  }\n\n  function _reducer() {\n    _reducer = _asyncToGenerator(function* (leaves) {\n      if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {\n        const leaf = leaves[0];\n\n        if (leaf.cid.code === rawCodec.code && (file.mtime !== undefined || file.mode !== undefined)) {\n          let buffer = yield blockstore.get(leaf.cid);\n          leaf.unixfs = new UnixFS({\n            type: 'file',\n            mtime: file.mtime,\n            mode: file.mode,\n            data: buffer\n          });\n          buffer = encode(prepare({\n            Data: leaf.unixfs.marshal()\n          }));\n          leaf.cid = yield persist(buffer, blockstore, { ...options,\n            codec: dagPb,\n            hasher: options.hasher,\n            cidVersion: options.cidVersion\n          });\n          leaf.size = buffer.length;\n        }\n\n        return {\n          cid: leaf.cid,\n          path: file.path,\n          unixfs: leaf.unixfs,\n          size: leaf.size\n        };\n      }\n\n      const f = new UnixFS({\n        type: 'file',\n        mtime: file.mtime,\n        mode: file.mode\n      });\n      const links = leaves.filter(leaf => {\n        if (leaf.cid.code === rawCodec.code && leaf.size) {\n          return true;\n        }\n\n        if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {\n          return true;\n        }\n\n        return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);\n      }).map(leaf => {\n        if (leaf.cid.code === rawCodec.code) {\n          f.addBlockSize(leaf.size);\n          return {\n            Name: '',\n            Tsize: leaf.size,\n            Hash: leaf.cid\n          };\n        }\n\n        if (!leaf.unixfs || !leaf.unixfs.data) {\n          f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);\n        } else {\n          f.addBlockSize(leaf.unixfs.data.length);\n        }\n\n        return {\n          Name: '',\n          Tsize: leaf.size,\n          Hash: leaf.cid\n        };\n      });\n      const node = {\n        Data: f.marshal(),\n        Links: links\n      };\n      const buffer = encode(prepare(node));\n      const cid = yield persist(buffer, blockstore, options);\n      return {\n        cid,\n        path: file.path,\n        unixfs: f,\n        size: buffer.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)\n      };\n    });\n    return _reducer.apply(this, arguments);\n  }\n\n  return reducer;\n};\n\nfunction fileBuilder(file, block, options) {\n  const dagBuilder = dagBuilders[options.strategy];\n\n  if (!dagBuilder) {\n    throw errCode(new Error(`Unknown importer build strategy name: ${options.strategy}`), 'ERR_BAD_STRATEGY');\n  }\n\n  return dagBuilder(buildFileBatch(file, block, options), reduce(file, block, options), options);\n}\n\nexport default fileBuilder;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js"],"names":["errCode","UnixFS","persist","encode","prepare","parallelBatch","rawCodec","dagPb","dagFlat","dagBalanced","dagTrickle","dagBuilders","flat","balanced","trickle","buildFileBatch","file","blockstore","options","count","previous","bufferImporter","default","blockWriteConcurrency","entry","single","reduce","reducer","leaves","length","reduceSingleLeafToSelf","leaf","cid","code","mtime","undefined","mode","buffer","get","unixfs","type","data","Data","marshal","codec","hasher","cidVersion","size","path","f","links","filter","fileSize","Boolean","map","addBlockSize","Name","Tsize","Hash","node","Links","acc","curr","fileBuilder","block","dagBuilder","strategy","Error"],"mappings":"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","sourcesContent":["import errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport persist from '../../utils/persist.js';\nimport {\n  encode,\n  prepare\n} from '@ipld/dag-pb';\nimport parallelBatch from 'it-parallel-batch';\nimport * as rawCodec from 'multiformats/codecs/raw';\nimport * as dagPb from '@ipld/dag-pb';\nimport dagFlat from './flat.js';\nimport dagBalanced from './balanced.js';\nimport dagTrickle from './trickle.js';\nconst dagBuilders = {\n  flat: dagFlat,\n  balanced: dagBalanced,\n  trickle: dagTrickle\n};\nasync function* buildFileBatch(file, blockstore, options) {\n  let count = -1;\n  let previous;\n  let bufferImporter;\n  if (typeof options.bufferImporter === 'function') {\n    bufferImporter = options.bufferImporter;\n  } else {\n    bufferImporter = (await import('./buffer-importer.js')).default;\n  }\n  for await (const entry of parallelBatch(bufferImporter(file, blockstore, options), options.blockWriteConcurrency)) {\n    count++;\n    if (count === 0) {\n      previous = entry;\n      continue;\n    } else if (count === 1 && previous) {\n      yield previous;\n      previous = null;\n    }\n    yield entry;\n  }\n  if (previous) {\n    previous.single = true;\n    yield previous;\n  }\n}\nconst reduce = (file, blockstore, options) => {\n  async function reducer(leaves) {\n    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {\n      const leaf = leaves[0];\n      if (leaf.cid.code === rawCodec.code && (file.mtime !== undefined || file.mode !== undefined)) {\n        let buffer = await blockstore.get(leaf.cid);\n        leaf.unixfs = new UnixFS({\n          type: 'file',\n          mtime: file.mtime,\n          mode: file.mode,\n          data: buffer\n        });\n        buffer = encode(prepare({ Data: leaf.unixfs.marshal() }));\n        leaf.cid = await persist(buffer, blockstore, {\n          ...options,\n          codec: dagPb,\n          hasher: options.hasher,\n          cidVersion: options.cidVersion\n        });\n        leaf.size = buffer.length;\n      }\n      return {\n        cid: leaf.cid,\n        path: file.path,\n        unixfs: leaf.unixfs,\n        size: leaf.size\n      };\n    }\n    const f = new UnixFS({\n      type: 'file',\n      mtime: file.mtime,\n      mode: file.mode\n    });\n    const links = leaves.filter(leaf => {\n      if (leaf.cid.code === rawCodec.code && leaf.size) {\n        return true;\n      }\n      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {\n        return true;\n      }\n      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);\n    }).map(leaf => {\n      if (leaf.cid.code === rawCodec.code) {\n        f.addBlockSize(leaf.size);\n        return {\n          Name: '',\n          Tsize: leaf.size,\n          Hash: leaf.cid\n        };\n      }\n      if (!leaf.unixfs || !leaf.unixfs.data) {\n        f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);\n      } else {\n        f.addBlockSize(leaf.unixfs.data.length);\n      }\n      return {\n        Name: '',\n        Tsize: leaf.size,\n        Hash: leaf.cid\n      };\n    });\n    const node = {\n      Data: f.marshal(),\n      Links: links\n    };\n    const buffer = encode(prepare(node));\n    const cid = await persist(buffer, blockstore, options);\n    return {\n      cid,\n      path: file.path,\n      unixfs: f,\n      size: buffer.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)\n    };\n  }\n  return reducer;\n};\nfunction fileBuilder(file, block, options) {\n  const dagBuilder = dagBuilders[options.strategy];\n  if (!dagBuilder) {\n    throw errCode(new Error(`Unknown importer build strategy name: ${ options.strategy }`), 'ERR_BAD_STRATEGY');\n  }\n  return dagBuilder(buildFileBatch(file, block, options), reduce(file, block, options), options);\n}\nexport default fileBuilder;"]},"metadata":{},"sourceType":"module"}