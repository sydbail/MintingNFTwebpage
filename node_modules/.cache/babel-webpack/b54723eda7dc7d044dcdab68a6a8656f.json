{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { bytes as binary, CID } from './index.js';\n\nconst readonly = ({\n  enumerable = true,\n  configurable = false\n} = {}) => ({\n  enumerable,\n  configurable,\n  writable: false\n});\n\nconst links = function* (source, base) {\n  if (source == null) return;\n  if (source instanceof Uint8Array) return;\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element);\n\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  }\n};\n\nconst tree = function* (source, base) {\n  if (source == null) return;\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n    yield path.join('/');\n\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          yield elementPath.join('/');\n\n          if (typeof element === 'object' && !CID.asCID(element)) {\n            yield* tree(element, elementPath);\n          }\n        }\n      } else {\n        yield* tree(value, path);\n      }\n    }\n  }\n};\n\nconst get = (source, path) => {\n  let node = source;\n\n  for (const [index, key] of path.entries()) {\n    node = node[key];\n\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`);\n    }\n\n    const cid = CID.asCID(node);\n\n    if (cid) {\n      return {\n        value: cid,\n        remaining: path.slice(index + 1).join('/')\n      };\n    }\n  }\n\n  return {\n    value: node\n  };\n};\n\nclass Block {\n  constructor({\n    cid,\n    bytes,\n    value\n  }) {\n    if (!cid || !bytes || typeof value === 'undefined') throw new Error('Missing required argument');\n    this.cid = cid;\n    this.bytes = bytes;\n    this.value = value;\n    this.asBlock = this;\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    });\n  }\n\n  links() {\n    return links(this.value, []);\n  }\n\n  tree() {\n    return tree(this.value, []);\n  }\n\n  get(path = '/') {\n    return get(this.value, path.split('/').filter(Boolean));\n  }\n\n}\n\nconst encode = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    value,\n    codec,\n    hasher\n  }) {\n    if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"');\n    if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher');\n    const bytes = codec.encode(value);\n    const hash = yield hasher.digest(bytes);\n    const cid = CID.create(1, codec.code, hash);\n    return new Block({\n      value,\n      bytes,\n      cid\n    });\n  });\n\n  return function encode(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst decode = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* ({\n    bytes,\n    codec,\n    hasher\n  }) {\n    if (!bytes) throw new Error('Missing required argument \"bytes\"');\n    if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher');\n    const value = codec.decode(bytes);\n    const hash = yield hasher.digest(bytes);\n    const cid = CID.create(1, codec.code, hash);\n    return new Block({\n      value,\n      bytes,\n      cid\n    });\n  });\n\n  return function decode(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst createUnsafe = ({\n  bytes,\n  cid,\n  value: maybeValue,\n  codec\n}) => {\n  const value = maybeValue !== undefined ? maybeValue : codec && codec.decode(bytes);\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"');\n  return new Block({\n    cid,\n    bytes,\n    value\n  });\n};\n\nconst create = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* ({\n    bytes,\n    cid,\n    hasher,\n    codec\n  }) {\n    if (!bytes) throw new Error('Missing required argument \"bytes\"');\n    if (!hasher) throw new Error('Missing required argument \"hasher\"');\n    const value = codec.decode(bytes);\n    const hash = yield hasher.digest(bytes);\n\n    if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n      throw new Error('CID hash does not match bytes');\n    }\n\n    return createUnsafe({\n      bytes,\n      cid,\n      value,\n      codec\n    });\n  });\n\n  return function create(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexport { encode, decode, create, createUnsafe, Block };","map":null,"metadata":{},"sourceType":"module"}