{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nconst Message = require('./types/message');\n\nconst CONSTANTS = require('./constants');\n\nconst logger = require('./utils').logger;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {Object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {Object} Stream\n * @property {AsyncIterable<Uint8Array>} source\n * @property {(output:AsyncIterable<Uint8Array>) => Promise<void>} sink\n */\n\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nclass Network {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {import('./bitswap')} bitswap\n   * @param {import('./stats')} stats\n   * @param {Object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor(libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110);\n\n      this._protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashers = options.hashers || {};\n  }\n\n  start() {\n    this._running = true;\n\n    this._libp2p.handle(this._protocols, this._onConnection); // register protocol with topology\n\n\n    const topology = new MulticodecTopology({\n      multicodecs: this._protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    });\n    this._registrarId = this._libp2p.registrar.register(topology); // All existing connections are like new ones for us\n\n    for (const peer of this._libp2p.peerStore.peers.values()) {\n      const conn = this._libp2p.connectionManager.get(peer.id);\n\n      conn && this._onPeerConnect(conn.remotePeer);\n    }\n  }\n\n  stop() {\n    this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n    this._libp2p.unhandle(this._protocols); // unregister protocol and handlers\n\n\n    if (this._registrarId != null) {\n      this._libp2p.registrar.unregister(this._registrarId);\n    }\n  }\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {string} connection.protocol - The protocol the stream is running\n   * @param {MuxedStream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n\n\n  _onConnection({\n    protocol,\n    stream,\n    connection\n  }) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this._running) {\n        return;\n      }\n\n      _this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n      try {\n        yield pipe(stream, lp.decode(),\n        /*#__PURE__*/\n\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        function () {\n          var _ref = _asyncToGenerator(function* (source) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n\n            var _iteratorError;\n\n            try {\n              for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n                const data = _value;\n\n                try {\n                  const message = yield Message.deserialize(data.slice(), _this._hashers);\n                  yield _this._bitswap._receiveMessage(connection.remotePeer, message);\n                } catch (err) {\n                  _this._bitswap._receiveError(err);\n\n                  break;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      } catch (err) {\n        _this._log(err);\n      }\n    })();\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerConnect(peerId) {\n    this._bitswap._onPeerConnected(peerId);\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerDisconnect(peerId) {\n    this._bitswap._onPeerDisconnected(peerId);\n  }\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n\n\n  findProviders(cid, maxProviders, options = {}) {\n    return this._libp2p.contentRouting.findProviders(cid, {\n      timeout: CONSTANTS.providerRequestTimeout,\n      maxNumProviders: maxProviders\n    });\n  }\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  findAndConnect(cid, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const connectAttempts = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this2.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const provider = _value2;\n\n          _this2._log(`connecting to provider ${provider.id}`);\n\n          connectAttempts.push(_this2.connectTo(provider.id, options).catch(err => {\n            // Prevent unhandled promise rejection\n            _this2._log.error(err);\n          }));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      yield Promise.all(connectAttempts);\n    })();\n  }\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  provide(cid, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // @ts-expect-error - contentRouting takes no options\n      yield _this3._libp2p.contentRouting.provide(cid, options);\n    })();\n  }\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n\n\n  sendMessage(peer, msg) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this4._running) throw new Error('network isn\\'t running');\n      const stringId = peer.toB58String();\n\n      _this4._log('sendMessage to %s', stringId, msg);\n\n      const connection = yield _this4._libp2p.dial(peer);\n      const {\n        stream,\n        protocol\n      } = yield connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);\n      /** @type {Uint8Array} */\n\n      let serialized;\n\n      switch (protocol) {\n        case BITSWAP100:\n          serialized = msg.serializeToBitswap100();\n          break;\n\n        case BITSWAP110:\n        case BITSWAP120:\n          serialized = msg.serializeToBitswap110();\n          break;\n\n        default:\n          throw new Error('Unknown protocol: ' + protocol);\n      } // Note: Don't wait for writeMessage() to complete\n\n\n      writeMessage(stream, serialized, _this4._log);\n\n      _this4._updateSentStats(peer, msg.blocks);\n    })();\n  }\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  connectTo(peer, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (!_this5._running) {\n        throw new Error('network isn\\'t running');\n      }\n\n      return _this5._libp2p.dial(peer, options);\n    })();\n  }\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n\n\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toB58String();\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length);\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n\n}\n/**\n *\n * @param {MuxedStream} stream\n * @param {Uint8Array} msg\n * @param {*} log\n */\n\n\nfunction writeMessage(_x2, _x3, _x4) {\n  return _writeMessage.apply(this, arguments);\n}\n\nfunction _writeMessage() {\n  _writeMessage = _asyncToGenerator(function* (stream, msg, log) {\n    try {\n      yield pipe([msg], lp.encode(), stream);\n    } catch (err) {\n      log(err);\n    }\n  });\n  return _writeMessage.apply(this, arguments);\n}\n\nmodule.exports = Network;","map":null,"metadata":{},"sourceType":"script"}