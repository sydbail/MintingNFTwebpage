{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst configure = require('../lib/configure');\n\nconst resolve = require('../lib/resolve');\n\nconst first = require('it-first');\n\nconst last = require('it-last');\n\nconst errCode = require('err-code');\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {import('../types').Options} options\n */\n\n\nmodule.exports = (codecs, options) => {\n  const fn = configure((api, opts) => {\n    const getBlock = require('../block/get')(opts);\n    /**\n     * @type {DAGAPI[\"get\"]}\n     */\n\n\n    const get = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (cid, options = {}) {\n        if (options.path) {\n          const entry = options.localResolve ? yield first(resolve(cid, options.path, codecs, getBlock, options)) : yield last(resolve(cid, options.path, codecs, getBlock, options));\n          /** @type {import('ipfs-core-types/src/dag').GetResult} - first and last will return undefined when empty */\n\n          const result = entry;\n\n          if (!result) {\n            throw errCode(new Error('Not found'), 'ERR_NOT_FOUND');\n          }\n\n          return result;\n        }\n\n        const codec = yield codecs.getCodec(cid.code);\n        const block = yield getBlock(cid, options);\n        const node = codec.decode(block);\n        return {\n          value: node,\n          remainderPath: ''\n        };\n      });\n\n      return function get(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    return get;\n  });\n  return fn(options);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-http-client/src/dag/get.js"],"names":["configure","require","resolve","first","last","errCode","module","exports","codecs","options","fn","api","opts","getBlock","get","cid","path","entry","localResolve","result","Error","codec","getCodec","code","block","node","decode","value","remainderPath"],"mappings":"AAAA;;;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,kBAAD,CAAzB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,UAAD,CAArB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,SAAD,CAApB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAAvB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACAK,MAAM,CAACC,OAAP,GAAiB,CAACC,MAAD,EAASC,OAAT,KAAqB;AACpC,QAAMC,EAAE,GAAGV,SAAS,CAAC,CAACW,GAAD,EAAMC,IAAN,KAAe;AAClC,UAAMC,QAAQ,GAAGZ,OAAO,CAAC,cAAD,CAAP,CAAwBW,IAAxB,CAAjB;AAEA;AACJ;AACA;;;AACI,UAAME,GAAG;AAAA,mCAAG,WAAOC,GAAP,EAAYN,OAAO,GAAG,EAAtB,EAA6B;AACvC,YAAIA,OAAO,CAACO,IAAZ,EAAkB;AAChB,gBAAMC,KAAK,GAAGR,OAAO,CAACS,YAAR,SACJf,KAAK,CAACD,OAAO,CAACa,GAAD,EAAMN,OAAO,CAACO,IAAd,EAAoBR,MAApB,EAA4BK,QAA5B,EAAsCJ,OAAtC,CAAR,CADD,SAEJL,IAAI,CAACF,OAAO,CAACa,GAAD,EAAMN,OAAO,CAACO,IAAd,EAAoBR,MAApB,EAA4BK,QAA5B,EAAsCJ,OAAtC,CAAR,CAFd;AAGA;;AACA,gBAAMU,MAAM,GAAIF,KAAhB;;AAEA,cAAI,CAACE,MAAL,EAAa;AACX,kBAAMd,OAAO,CAAC,IAAIe,KAAJ,CAAU,WAAV,CAAD,EAAyB,eAAzB,CAAb;AACD;;AAED,iBAAOD,MAAP;AACD;;AAED,cAAME,KAAK,SAASb,MAAM,CAACc,QAAP,CAAgBP,GAAG,CAACQ,IAApB,CAApB;AACA,cAAMC,KAAK,SAASX,QAAQ,CAACE,GAAD,EAAMN,OAAN,CAA5B;AACA,cAAMgB,IAAI,GAAGJ,KAAK,CAACK,MAAN,CAAaF,KAAb,CAAb;AAEA,eAAO;AACLG,UAAAA,KAAK,EAAEF,IADF;AAELG,UAAAA,aAAa,EAAE;AAFV,SAAP;AAID,OAvBQ;;AAAA,sBAAHd,GAAG;AAAA;AAAA;AAAA,OAAT;;AAyBA,WAAOA,GAAP;AACD,GAhCmB,CAApB;AAkCA,SAAOJ,EAAE,CAACD,OAAD,CAAT;AACD,CApCD","sourcesContent":["'use strict'\n\nconst configure = require('../lib/configure')\nconst resolve = require('../lib/resolve')\nconst first = require('it-first')\nconst last = require('it-last')\nconst errCode = require('err-code')\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {import('../types').Options} options\n */\nmodule.exports = (codecs, options) => {\n  const fn = configure((api, opts) => {\n    const getBlock = require('../block/get')(opts)\n\n    /**\n     * @type {DAGAPI[\"get\"]}\n     */\n    const get = async (cid, options = {}) => {\n      if (options.path) {\n        const entry = options.localResolve\n          ? await first(resolve(cid, options.path, codecs, getBlock, options))\n          : await last(resolve(cid, options.path, codecs, getBlock, options))\n        /** @type {import('ipfs-core-types/src/dag').GetResult} - first and last will return undefined when empty */\n        const result = (entry)\n\n        if (!result) {\n          throw errCode(new Error('Not found'), 'ERR_NOT_FOUND')\n        }\n\n        return result\n      }\n\n      const codec = await codecs.getCodec(cid.code)\n      const block = await getBlock(cid, options)\n      const node = codec.decode(block)\n\n      return {\n        value: node,\n        remainderPath: ''\n      }\n    }\n\n    return get\n  })\n\n  return fn(options)\n}\n"]},"metadata":{},"sourceType":"script"}