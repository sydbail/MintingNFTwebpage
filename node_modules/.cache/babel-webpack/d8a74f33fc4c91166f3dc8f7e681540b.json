{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst intervals = new Map();\n\nconst _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1000000)}`;\n/**\n * Run a given task each {interval} ms\n *\n * @param {() => Promise} task\n * @param {number} interval\n * @param {string} id\n */\n\n\nfunction _runPeriodically(_x, _x2, _x3) {\n  return _runPeriodically2.apply(this, arguments);\n}\n/**\n * Asynchronous setInterval that is properly delayed using promises and can be delayed on boot.\n *\n * @param {() => Promise} task\n * @param {number} interval\n * @param {number} [delay = interval]\n * @returns {string}\n */\n\n\nfunction _runPeriodically2() {\n  _runPeriodically2 = _asyncToGenerator(function* (task, interval, id) {\n    while (intervals.get(id)) {\n      try {\n        yield task();\n      } catch (err) {\n        // Throw global context error if handler throws\n        setTimeout(() => {\n          throw err;\n        }, 1);\n        break;\n      }\n\n      if (!intervals.get(id)) {\n        break;\n      }\n\n      yield new Promise(resolve => {\n        const _timeout = setTimeout(resolve, interval);\n\n        intervals.set(id, _timeout);\n      });\n    }\n  });\n  return _runPeriodically2.apply(this, arguments);\n}\n\nfunction setDelayedInterval(task, interval, delay) {\n  delay = delay || interval;\n\n  const id = _generateId();\n\n  const _timeout = setTimeout(() => {\n    _runPeriodically(task, interval, id);\n  }, delay);\n\n  intervals.set(id, _timeout);\n  return id;\n}\n/**\n * Clear delayed interval.\n *\n * @param {string} id\n */\n\n\nfunction clearDelayedInterval(id) {\n  const _timeout = intervals.get(id);\n\n  if (_timeout) {\n    clearTimeout(_timeout);\n    intervals.delete(id);\n  }\n}\n\nmodule.exports = {\n  setDelayedInterval,\n  clearDelayedInterval\n};","map":null,"metadata":{},"sourceType":"script"}