{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst log = require('debug')('ipfs:components:peer:storage');\n\nconst createRepo = require('../runtime/repo-nodejs');\n\nconst getDefaultConfig = require('../runtime/config-nodejs');\n\nconst {\n  ERR_REPO_NOT_INITIALIZED\n} = require('ipfs-repo').errors;\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst PeerId = require('peer-id');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst configService = require('./config');\n\nconst {\n  NotEnabledError,\n  NotInitializedError\n} = require('../errors');\n\nconst createLibP2P = require('./libp2p');\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n\n\n  static start(print, codecs, options) {\n    return _asyncToGenerator(function* () {\n      const {\n        repoAutoMigrate,\n        repo: inputRepo,\n        onMigrationProgress\n      } = options;\n      const repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      }) : inputRepo;\n      const {\n        peerId,\n        keychain,\n        isNew\n      } = yield loadRepo(print, repo, options); // TODO: throw error?\n      // @ts-ignore On start, keychain will always be available\n\n      return new Storage(peerId, keychain, repo, print, isNew);\n    })();\n  }\n\n}\n\nmodule.exports = Storage;\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\n\nconst loadRepo = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (print, repo, options) {\n    if (!repo.closed) {\n      return { ...(yield configureRepo(repo, options)),\n        isNew: false\n      };\n    }\n\n    try {\n      yield repo.open();\n      return { ...(yield configureRepo(repo, options)),\n        isNew: false\n      };\n    } catch (err) {\n      if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n        throw err;\n      }\n\n      if (options.init && options.init.allowNew === false) {\n        throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n      }\n\n      return { ...(yield initRepo(print, repo, options)),\n        isNew: true\n      };\n    }\n  });\n\n  return function loadRepo(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst initRepo = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (print, repo, options) {\n    const initOptions = options.init || {}; // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n\n    const exists = yield repo.exists();\n    log('repo exists?', exists);\n\n    if (exists === true) {\n      throw new Error('repo already exists');\n    } // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n\n\n    const peerId = initOptions.privateKey ? yield decodePeerId(initOptions.privateKey) : yield initPeerId(print, initOptions);\n    const identity = peerIdToIdentity(peerId);\n    log('peer identity: %s', identity.PeerID); // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n\n    const config = { ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n      Identity: identity\n    };\n    yield repo.init(config); // 4. Open initialized repo.\n\n    yield repo.open();\n    log('repo opened');\n    /** @type {import('./libp2p').KeychainConfig} */\n\n    const keychainConfig = {\n      pass: options.pass\n    };\n\n    try {\n      keychainConfig.dek = yield repo.config.get('Keychain.DEK');\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    } // Create libp2p for Keychain creation\n\n\n    const libp2p = yield createLibP2P({\n      options: undefined,\n      multiaddrs: undefined,\n      peerId,\n      repo,\n      config,\n      keychainConfig\n    });\n\n    if (libp2p.keychain && libp2p.keychain.opts) {\n      yield libp2p.loadKeychain();\n      yield repo.config.set('Keychain', {\n        DEK: libp2p.keychain.opts.dek\n      });\n    }\n\n    return {\n      peerId,\n      keychain: libp2p.keychain\n    };\n  });\n\n  return function initRepo(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\n\n\nconst decodePeerId = peerId => {\n  log('using user-supplied private-key');\n  return typeof peerId === 'object' ? peerId : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'));\n};\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\n\n\nconst initPeerId = (print, {\n  algorithm = 'Ed25519',\n  bits = 2048\n}) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm);\n  return PeerId.create({\n    keyType: algorithm,\n    bits\n  });\n};\n/**\n * @param {PeerId} peerId\n */\n\n\nconst peerIdToIdentity = peerId => ({\n  PeerID: peerId.toB58String(),\n\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n});\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst configureRepo = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (repo, options) {\n    const config = options.config;\n    const profiles = options.init && options.init.profiles || [];\n    const pass = options.pass;\n    const original = yield repo.config.getAll();\n    const changed = mergeConfigs(applyProfiles(original, profiles), config);\n\n    if (original !== changed) {\n      yield repo.config.replace(changed);\n    }\n\n    if (!changed.Identity || !changed.Identity.PrivKey) {\n      throw new NotInitializedError('No private key was found in the config, please intialize the repo');\n    }\n\n    const peerId = yield PeerId.createFromPrivKey(changed.Identity.PrivKey);\n    const libp2p = yield createLibP2P({\n      options: undefined,\n      multiaddrs: undefined,\n      peerId,\n      repo,\n      config: changed,\n      keychainConfig: {\n        pass,\n        ...changed.Keychain\n      }\n    });\n\n    if (libp2p.keychain) {\n      yield libp2p.loadKeychain();\n    }\n\n    return {\n      peerId,\n      keychain: libp2p.keychain\n    };\n  });\n\n  return function configureRepo(_x7, _x8) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\n\n\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\n\n\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name];\n\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`);\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/components/storage.js"],"names":["log","require","createRepo","getDefaultConfig","ERR_REPO_NOT_INITIALIZED","errors","fromString","uint8ArrayFromString","toString","uint8ArrayToString","PeerId","mergeOptions","bind","ignoreUndefined","configService","NotEnabledError","NotInitializedError","createLibP2P","Storage","constructor","peerId","keychain","repo","print","isNew","start","codecs","options","repoAutoMigrate","inputRepo","onMigrationProgress","path","autoMigrate","loadRepo","module","exports","closed","configureRepo","open","err","code","init","allowNew","initRepo","initOptions","exists","Error","privateKey","decodePeerId","initPeerId","identity","peerIdToIdentity","PeerID","config","applyProfiles","profiles","Identity","keychainConfig","pass","dek","get","libp2p","undefined","multiaddrs","opts","loadKeychain","set","DEK","createFromPrivKey","algorithm","bits","create","keyType","toB58String","PrivKey","privKey","bytes","original","getAll","changed","mergeConfigs","replace","Keychain","changes","reduce","name","profile","transform"],"mappings":"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","sourcesContent":["'use strict'\n\nconst log = require('debug')('ipfs:components:peer:storage')\nconst createRepo = require('../runtime/repo-nodejs')\nconst getDefaultConfig = require('../runtime/config-nodejs')\nconst { ERR_REPO_NOT_INITIALIZED } = require('ipfs-repo').errors\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst PeerId = require('peer-id')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst configService = require('./config')\nconst { NotEnabledError, NotInitializedError } = require('../errors')\nconst createLibP2P = require('./libp2p')\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor (peerId, keychain, repo, print, isNew) {\n    this.print = print\n    this.peerId = peerId\n    this.keychain = keychain\n    this.repo = repo\n    this.print = print\n    this.isNew = isNew\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n  static async start (print, codecs, options) {\n    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options\n\n    const repo = (typeof inputRepo === 'string' || inputRepo == null)\n      ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      })\n      : inputRepo\n\n    const { peerId, keychain, isNew } = await loadRepo(print, repo, options)\n\n    // TODO: throw error?\n    // @ts-ignore On start, keychain will always be available\n    return new Storage(peerId, keychain, repo, print, isNew)\n  }\n}\nmodule.exports = Storage\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...await configureRepo(repo, options), isNew: false }\n  }\n\n  try {\n    await repo.open()\n\n    return { ...await configureRepo(repo, options), isNew: false }\n  } catch (err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')\n    }\n\n    return { ...await initRepo(print, repo, options), isNew: true }\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}\n\n  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n  const exists = await repo.exists()\n  log('repo exists?', exists)\n\n  if (exists === true) {\n    throw new Error('repo already exists')\n  }\n\n  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n  const peerId = initOptions.privateKey\n    ? await decodePeerId(initOptions.privateKey)\n    : await initPeerId(print, initOptions)\n\n  const identity = peerIdToIdentity(peerId)\n\n  log('peer identity: %s', identity.PeerID)\n\n  // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  }\n  await repo.init(config)\n\n  // 4. Open initialized repo.\n  await repo.open()\n\n  log('repo opened')\n\n  /** @type {import('./libp2p').KeychainConfig} */\n  const keychainConfig = {\n    pass: options.pass\n  }\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK')\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  // Create libp2p for Keychain creation\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  })\n\n  if (libp2p.keychain && libp2p.keychain.opts) {\n    await libp2p.loadKeychain()\n\n    await repo.config.set('Keychain', {\n      DEK: libp2p.keychain.opts.dek\n    })\n  }\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\nconst decodePeerId = (peerId) => {\n  log('using user-supplied private-key')\n  return typeof peerId === 'object'\n    ? peerId\n    : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'))\n}\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nconst initPeerId = (print, { algorithm = 'Ed25519', bits = 2048 }) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm)\n  return PeerId.create({ keyType: algorithm, bits })\n}\n\n/**\n * @param {PeerId} peerId\n */\nconst peerIdToIdentity = (peerId) => ({\n  PeerID: peerId.toB58String(),\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n})\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst configureRepo = async (repo, options) => {\n  const config = options.config\n  const profiles = (options.init && options.init.profiles) || []\n  const pass = options.pass\n  const original = await repo.config.getAll()\n  const changed = mergeConfigs(applyProfiles(original, profiles), config)\n\n  if (original !== changed) {\n    await repo.config.replace(changed)\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo')\n  }\n\n  const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey)\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  })\n\n  if (libp2p.keychain) {\n    await libp2p.loadKeychain()\n  }\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nconst mergeConfigs = (config, changes) =>\n  changes ? mergeOptions(config, changes) : config\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name]\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`)\n    }\n    log('applying profile %s', name)\n    return profile.transform(config)\n  }, config)\n}\n"]},"metadata":{},"sourceType":"script"}