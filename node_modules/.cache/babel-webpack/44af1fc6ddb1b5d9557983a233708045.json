{"ast":null,"code":"import _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport BufferList from 'bl/BufferList.js';\nimport { create } from 'rabin-wasm';\nimport errcode from 'err-code';\n\nfunction rabinChunker(_x, _x2) {\n  return _rabinChunker.apply(this, arguments);\n}\n\nfunction _rabinChunker() {\n  _rabinChunker = _wrapAsyncGenerator(function* (source, options) {\n    let min, max, avg;\n\n    if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n      avg = options.avgChunkSize;\n      min = options.minChunkSize;\n      max = options.maxChunkSize;\n    } else if (!options.avgChunkSize) {\n      throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n    } else {\n      avg = options.avgChunkSize;\n      min = avg / 3;\n      max = avg + avg / 2;\n    }\n\n    if (min < 16) {\n      throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n    }\n\n    if (max < min) {\n      max = min;\n    }\n\n    if (avg < min) {\n      avg = min;\n    }\n\n    const sizepow = Math.floor(Math.log2(avg));\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(rabin(source, {\n        min: min,\n        max: max,\n        bits: sizepow,\n        window: options.window,\n        polynomial: options.polynomial\n      })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const chunk = _value;\n        yield chunk;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return _rabinChunker.apply(this, arguments);\n}\n\nexport default rabinChunker;\n\nfunction rabin(_x3, _x4) {\n  return _rabin.apply(this, arguments);\n}\n\nfunction _rabin() {\n  _rabin = _wrapAsyncGenerator(function* (source, options) {\n    const r = yield _awaitAsyncGenerator(create(options.bits, options.min, options.max, options.window));\n    const buffers = new BufferList();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n\n    var _iteratorError2;\n\n    try {\n      for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n        const chunk = _value2;\n        buffers.append(chunk);\n        const sizes = r.fingerprint(chunk);\n\n        for (let i = 0; i < sizes.length; i++) {\n          const size = sizes[i];\n          const buf = buffers.slice(0, size);\n          buffers.consume(size);\n          yield buf;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          yield _awaitAsyncGenerator(_iterator2.return());\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    if (buffers.length) {\n      yield buffers.slice(0);\n    }\n  });\n  return _rabin.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js"],"names":["BufferList","create","errcode","rabinChunker","source","options","min","max","avg","minChunkSize","maxChunkSize","avgChunkSize","Error","sizepow","Math","floor","log2","rabin","bits","window","polynomial","chunk","r","buffers","append","sizes","fingerprint","i","length","size","buf","slice","consume"],"mappings":"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","sourcesContent":["import BufferList from 'bl/BufferList.js';\nimport { create } from 'rabin-wasm';\nimport errcode from 'err-code';\nasync function* rabinChunker(source, options) {\n  let min, max, avg;\n  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n    avg = options.avgChunkSize;\n    min = options.minChunkSize;\n    max = options.maxChunkSize;\n  } else if (!options.avgChunkSize) {\n    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n  } else {\n    avg = options.avgChunkSize;\n    min = avg / 3;\n    max = avg + avg / 2;\n  }\n  if (min < 16) {\n    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n  }\n  if (max < min) {\n    max = min;\n  }\n  if (avg < min) {\n    avg = min;\n  }\n  const sizepow = Math.floor(Math.log2(avg));\n  for await (const chunk of rabin(source, {\n      min: min,\n      max: max,\n      bits: sizepow,\n      window: options.window,\n      polynomial: options.polynomial\n    })) {\n    yield chunk;\n  }\n}\nexport default rabinChunker;\nasync function* rabin(source, options) {\n  const r = await create(options.bits, options.min, options.max, options.window);\n  const buffers = new BufferList();\n  for await (const chunk of source) {\n    buffers.append(chunk);\n    const sizes = r.fingerprint(chunk);\n    for (let i = 0; i < sizes.length; i++) {\n      const size = sizes[i];\n      const buf = buffers.slice(0, size);\n      buffers.consume(size);\n      yield buf;\n    }\n  }\n  if (buffers.length) {\n    yield buffers.slice(0);\n  }\n}"]},"metadata":{},"sourceType":"module"}