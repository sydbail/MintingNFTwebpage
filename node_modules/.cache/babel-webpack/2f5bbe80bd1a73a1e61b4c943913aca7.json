{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractHandshake = exports.MIN_NONCE = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst SHA256 = __importStar(require(\"@stablelib/sha256\"));\n\nconst chacha20poly1305_1 = require(\"@stablelib/chacha20poly1305\");\n\nconst utils_1 = require(\"../utils\");\n\nconst logger_1 = require(\"../logger\");\n\nexports.MIN_NONCE = 0;\n\nclass AbstractHandshake {\n  encryptWithAd(cs, ad, plaintext) {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return e;\n  }\n\n  decryptWithAd(cs, ad, ciphertext) {\n    const {\n      plaintext,\n      valid\n    } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return {\n      plaintext,\n      valid\n    };\n  } // Cipher state related\n\n\n  hasKey(cs) {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  setNonce(cs, nonce) {\n    cs.n = nonce;\n  }\n\n  createEmptyKey() {\n    return buffer_1.Buffer.alloc(32);\n  }\n\n  isEmptyKey(k) {\n    const emptyKey = this.createEmptyKey();\n    return emptyKey.equals(k);\n  }\n\n  incrementNonce(n) {\n    return n + 1;\n  }\n\n  nonceToBytes(n) {\n    const nonce = buffer_1.Buffer.alloc(12);\n    nonce.writeUInt32LE(n, 4);\n    return nonce;\n  }\n\n  encrypt(k, n, ad, plaintext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);\n    const encryptedMessage = ctx.seal(nonce, plaintext, ad);\n    return buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length);\n  }\n\n  encryptAndHash(ss, plaintext) {\n    let ciphertext;\n\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  decrypt(k, n, ad, ciphertext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);\n    const encryptedMessage = ctx.open(nonce, ciphertext, ad);\n\n    if (encryptedMessage) {\n      return {\n        plaintext: buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length),\n        valid: true\n      };\n    } else {\n      return {\n        plaintext: buffer_1.Buffer.from(''),\n        valid: false\n      };\n    }\n  }\n\n  decryptAndHash(ss, ciphertext) {\n    let plaintext;\n    let valid = true;\n\n    if (this.hasKey(ss.cs)) {\n      ({\n        plaintext,\n        valid\n      } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n  dh(privateKey, publicKey) {\n    try {\n      const derivedU8 = x25519.sharedKey(privateKey, publicKey);\n      const derived = buffer_1.Buffer.from(derivedU8.buffer, derivedU8.byteOffset, derivedU8.length);\n      const result = buffer_1.Buffer.alloc(32);\n      derived.copy(result);\n      return result;\n    } catch (e) {\n      logger_1.logger(e.message);\n      return buffer_1.Buffer.alloc(32);\n    }\n  }\n\n  mixHash(ss, data) {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  getHash(a, b) {\n    const hash = SHA256.hash(buffer_1.Buffer.from([...a, ...b]));\n    return buffer_1.Buffer.from(hash.buffer, hash.byteOffset, hash.length);\n  }\n\n  mixKey(ss, ikm) {\n    const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);\n    ss.cs = this.initializeKey(tempK);\n    ss.ck = ck;\n  }\n\n  initializeKey(k) {\n    const n = exports.MIN_NONCE;\n    return {\n      k,\n      n\n    };\n  } // Symmetric state related\n\n\n  initializeSymmetric(protocolName) {\n    const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs = this.initializeKey(key);\n    return {\n      cs,\n      ck,\n      h\n    };\n  }\n\n  hashProtocolName(protocolName) {\n    if (protocolName.length <= 32) {\n      const h = buffer_1.Buffer.alloc(32);\n      protocolName.copy(h);\n      return h;\n    } else {\n      return this.getHash(protocolName, buffer_1.Buffer.alloc(0));\n    }\n  }\n\n  split(ss) {\n    const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n    return {\n      cs1,\n      cs2\n    };\n  }\n\n  writeMessageRegular(cs, payload) {\n    const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = buffer_1.Buffer.alloc(0);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  readMessageRegular(cs, message) {\n    return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);\n  }\n\n}\n\nexports.AbstractHandshake = AbstractHandshake; //# sourceMappingURL=abstract-handshake.js.map","map":null,"metadata":{},"sourceType":"script"}