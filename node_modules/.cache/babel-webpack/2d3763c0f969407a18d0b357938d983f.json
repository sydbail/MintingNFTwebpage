{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport errCode from 'err-code';\nimport extractDataFromBlock from '../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js';\nimport * as mh from 'multiformats/hashes/digest';\n\nconst rawContent = node => {\n  function contentGenerator() {\n    return _contentGenerator.apply(this, arguments);\n  }\n\n  function _contentGenerator() {\n    _contentGenerator = _wrapAsyncGenerator(function* (options = {}) {\n      const {\n        offset,\n        length\n      } = validateOffsetAndLength(node.length, options.offset, options.length);\n      yield extractDataFromBlock(node, 0, offset, offset + length);\n    });\n    return _contentGenerator.apply(this, arguments);\n  }\n\n  return contentGenerator;\n};\n\nconst resolve = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (cid, name, path, toResolve, _resolve, depth, blockstore, options) {\n    if (toResolve.length) {\n      throw errCode(new Error(`No link named ${path} found in raw node ${cid}`), 'ERR_NOT_FOUND');\n    }\n\n    const buf = yield mh.decode(cid.multihash.bytes);\n    return {\n      entry: {\n        type: 'identity',\n        name,\n        path,\n        cid,\n        content: rawContent(buf.digest),\n        depth,\n        size: buf.digest.length,\n        node: buf.digest\n      }\n    };\n  });\n\n  return function resolve(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport default resolve;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/identity.js"],"names":["errCode","extractDataFromBlock","validateOffsetAndLength","mh","rawContent","node","contentGenerator","options","offset","length","resolve","cid","name","path","toResolve","depth","blockstore","Error","buf","decode","multihash","bytes","entry","type","content","digest","size"],"mappings":";;;AAAA,OAAOA,OAAP,MAAoB,UAApB;AACA,OAAOC,oBAAP,MAAiC,qCAAjC;AACA,OAAOC,uBAAP,MAAoC,wCAApC;AACA,OAAO,KAAKC,EAAZ,MAAoB,4BAApB;;AACA,MAAMC,UAAU,GAAGC,IAAI,IAAI;AAAA,WACTC,gBADS;AAAA;AAAA;;AAAA;AAAA,4CACzB,WAAiCC,OAAO,GAAG,EAA3C,EAA+C;AAC7C,YAAM;AAACC,QAAAA,MAAD;AAASC,QAAAA;AAAT,UAAmBP,uBAAuB,CAACG,IAAI,CAACI,MAAN,EAAcF,OAAO,CAACC,MAAtB,EAA8BD,OAAO,CAACE,MAAtC,CAAhD;AACA,YAAMR,oBAAoB,CAACI,IAAD,EAAO,CAAP,EAAUG,MAAV,EAAkBA,MAAM,GAAGC,MAA3B,CAA1B;AACD,KAJwB;AAAA;AAAA;;AAKzB,SAAOH,gBAAP;AACD,CAND;;AAOA,MAAMI,OAAO;AAAA,+BAAG,WAAOC,GAAP,EAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCJ,QAAnC,EAA4CK,KAA5C,EAAmDC,UAAnD,EAA+DT,OAA/D,EAA2E;AACzF,QAAIO,SAAS,CAACL,MAAd,EAAsB;AACpB,YAAMT,OAAO,CAAC,IAAIiB,KAAJ,CAAW,iBAAiBJ,IAAM,sBAAsBF,GAAK,EAA7D,CAAD,EAAkE,eAAlE,CAAb;AACD;;AACD,UAAMO,GAAG,SAASf,EAAE,CAACgB,MAAH,CAAUR,GAAG,CAACS,SAAJ,CAAcC,KAAxB,CAAlB;AACA,WAAO;AACLC,MAAAA,KAAK,EAAE;AACLC,QAAAA,IAAI,EAAE,UADD;AAELX,QAAAA,IAFK;AAGLC,QAAAA,IAHK;AAILF,QAAAA,GAJK;AAKLa,QAAAA,OAAO,EAAEpB,UAAU,CAACc,GAAG,CAACO,MAAL,CALd;AAMLV,QAAAA,KANK;AAOLW,QAAAA,IAAI,EAAER,GAAG,CAACO,MAAJ,CAAWhB,MAPZ;AAQLJ,QAAAA,IAAI,EAAEa,GAAG,CAACO;AARL;AADF,KAAP;AAYD,GAjBY;;AAAA;AAAA;AAAA;AAAA,GAAb;;AAkBA,eAAef,OAAf","sourcesContent":["import errCode from 'err-code';\nimport extractDataFromBlock from '../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js';\nimport * as mh from 'multiformats/hashes/digest';\nconst rawContent = node => {\n  async function* contentGenerator(options = {}) {\n    const {offset, length} = validateOffsetAndLength(node.length, options.offset, options.length);\n    yield extractDataFromBlock(node, 0, offset, offset + length);\n  }\n  return contentGenerator;\n};\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length) {\n    throw errCode(new Error(`No link named ${ path } found in raw node ${ cid }`), 'ERR_NOT_FOUND');\n  }\n  const buf = await mh.decode(cid.multihash.bytes);\n  return {\n    entry: {\n      type: 'identity',\n      name,\n      path,\n      cid,\n      content: rawContent(buf.digest),\n      depth,\n      size: buf.digest.length,\n      node: buf.digest\n    }\n  };\n};\nexport default resolve;"]},"metadata":{},"sourceType":"module"}