{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  PinTypes\n} = require('ipfs-repo');\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\n\n\nmodule.exports = ({\n  repo,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"rmAll\"]}\n   */\n  function rmAll(_x) {\n    return _rmAll.apply(this, arguments);\n  }\n\n  function _rmAll() {\n    _rmAll = _wrapAsyncGenerator(function* (source, _options = {}) {\n      const release = yield _awaitAsyncGenerator(repo.gcLock.readLock());\n\n      try {\n        // verify that each hash can be unpinned\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(normaliseInput(source)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const {\n              path,\n              recursive\n            } = _value;\n            const {\n              cid\n            } = yield _awaitAsyncGenerator(resolvePath(repo, codecs, path));\n            const {\n              pinned,\n              reason\n            } = yield _awaitAsyncGenerator(repo.pins.isPinnedWithType(cid, PinTypes.all));\n\n            if (!pinned) {\n              throw new Error(`${cid} is not pinned`);\n            }\n\n            switch (reason) {\n              case PinTypes.recursive:\n                if (!recursive) {\n                  throw new Error(`${cid} is pinned recursively`);\n                }\n\n                yield _awaitAsyncGenerator(repo.pins.unpin(cid));\n                yield cid;\n                break;\n\n              case PinTypes.direct:\n                yield _awaitAsyncGenerator(repo.pins.unpin(cid));\n                yield cid;\n                break;\n\n              default:\n                throw new Error(`${cid} is pinned indirectly under ${reason}`);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } finally {\n        release();\n      }\n    });\n    return _rmAll.apply(this, arguments);\n  }\n\n  return withTimeoutOption(rmAll);\n};","map":null,"metadata":{},"sourceType":"script"}