{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require(\"debug\")(\"contract:handlers\");\n\nconst StatusError = require(\"./statuserror\");\n\nconst Utils = require(\"./utils\");\n\nconst Reason = require(\"./reason\");\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\n\n\nconst handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n  maxConfirmations: 24,\n  // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50,\n  // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\",\n  // Substring of web3 timeout error.\n  defaultWeb3Error: \"please check your gas limit\",\n\n  // Substring of default Web3 error\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash web3 timeout errors at user's request.\n   * @param  {Object} contract contract instance\n   * @param  {Object} message  error message\n   * @return {Boolean}\n   */\n  ignoreTimeoutError({\n    contract\n  }, {\n    message\n  }) {\n    const timedOut = message && message.includes(handlers.timeoutMessage);\n    const shouldWait = contract && contract.timeoutBlocks && contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n    const waitForTxPropagation = message && message.includes(handlers.defaultWeb3Error);\n    return shouldWait && (timedOut || waitForTxPropagation);\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function (emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context)); // web3 block polls if the confirmation listener is enabled so we want to\n    // give users a way of opting out of this behavior - it causes problems in testing\n\n    if (!context.contract.disableConfirmationListener) {\n      emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    }\n\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n  // -----------------------------------  Handlers -------------------------------------------------\n\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function (context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function (context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n  confirmation: function (context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt); // Per web3: initial confirmation index is 0\n\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: function () {\n    var _ref = _asyncToGenerator(function* (context, _receipt) {\n      // keep around the raw (not decoded) logs in the raw logs field as a\n      // stopgap until we can get the ABI for all events, not just the current\n      // contract\n      _receipt.rawLogs = _receipt.logs; // Decode logs, use as receipt.logs for ease of use.\n\n      try {\n        _receipt.logs = _receipt.logs ? Utils.decodeLogs.call(context.contract, _receipt.logs) : [];\n      } catch (error) {\n        return context.promiEvent.reject(error);\n      } // Emit receipt\n\n\n      context.promiEvent.eventEmitter.emit(\"receipt\", _receipt); // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n\n      if (context.onlyEmitReceipt) {\n        context.receipt = _receipt;\n        return;\n      } // .method(): resolve/reject receipt in handler\n\n\n      if (_receipt.status !== undefined && !_receipt.status) {\n        const reason = yield Reason.get(context.params, context.contract.web3, context.contract.interfaceAdapter);\n        const error = new StatusError(context.params, _receipt.transactionHash, _receipt, reason);\n        return context.promiEvent.reject(error);\n      } // This object has some duplicate data but is backward compatible.\n\n\n      context.promiEvent.resolve({\n        tx: _receipt.transactionHash,\n        receipt: _receipt,\n        logs: _receipt.logs\n      }); //HACK: adding this conditional for when the handler is invoked\n      //manually during stacktracing\n\n      if (this.removeListener) {\n        this.removeListener(\"receipt\", handlers.receipt);\n      }\n    });\n\n    return function receipt(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }()\n};\nmodule.exports = handlers;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/@truffle/contract/lib/handlers.js"],"names":["debug","require","StatusError","Utils","Reason","handlers","maxConfirmations","defaultTimeoutBlocks","timeoutMessage","defaultWeb3Error","ignoreTimeoutError","contract","message","timedOut","includes","shouldWait","timeoutBlocks","waitForTxPropagation","setup","emitter","context","on","error","bind","hash","disableConfirmationListener","confirmation","receipt","promiEvent","eventEmitter","emit","removeListener","transactionHash","number","rawLogs","logs","decodeLogs","call","reject","onlyEmitReceipt","status","undefined","reason","get","params","web3","interfaceAdapter","resolve","tx","module","exports"],"mappings":"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","sourcesContent":["const debug = require(\"debug\")(\"contract:handlers\");\nconst StatusError = require(\"./statuserror\");\nconst Utils = require(\"./utils\");\nconst Reason = require(\"./reason\");\n\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\nconst handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n\n  maxConfirmations: 24, // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50, // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\", // Substring of web3 timeout error.\n  defaultWeb3Error: \"please check your gas limit\", // Substring of default Web3 error\n\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash web3 timeout errors at user's request.\n   * @param  {Object} contract contract instance\n   * @param  {Object} message  error message\n   * @return {Boolean}\n   */\n  ignoreTimeoutError({ contract }, { message }) {\n    const timedOut = message && message.includes(handlers.timeoutMessage);\n\n    const shouldWait =\n      contract &&\n      contract.timeoutBlocks &&\n      contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n\n    const waitForTxPropagation =\n      message && message.includes(handlers.defaultWeb3Error);\n\n    return shouldWait && (timedOut || waitForTxPropagation);\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function(emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    // web3 block polls if the confirmation listener is enabled so we want to\n    // give users a way of opting out of this behavior - it causes problems in testing\n    if (!context.contract.disableConfirmationListener) {\n      emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    }\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n\n  // -----------------------------------  Handlers -------------------------------------------------\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function(context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function(context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n\n  confirmation: function(context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt);\n\n    // Per web3: initial confirmation index is 0\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function(context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs;\n\n    // Decode logs, use as receipt.logs for ease of use.\n    try {\n      receipt.logs = receipt.logs\n        ? Utils.decodeLogs.call(context.contract, receipt.logs)\n        : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    }\n\n    // Emit receipt\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt);\n\n    // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    }\n\n    // .method(): resolve/reject receipt in handler\n    if (receipt.status !== undefined && !receipt.status) {\n      const reason = await Reason.get(\n        context.params,\n        context.contract.web3,\n        context.contract.interfaceAdapter\n      );\n\n      const error = new StatusError(\n        context.params,\n        receipt.transactionHash,\n        receipt,\n        reason\n      );\n\n      return context.promiEvent.reject(error);\n    }\n\n    // This object has some duplicate data but is backward compatible.\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n\n    //HACK: adding this conditional for when the handler is invoked\n    //manually during stacktracing\n    if (this.removeListener) {\n      this.removeListener(\"receipt\", handlers.receipt);\n    }\n  }\n};\n\nmodule.exports = handlers;\n"]},"metadata":{},"sourceType":"script"}