{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst loadMfsRoot = require('./with-mfs-root');\n\nconst toPathComponents = require('./to-path-components');\n\nconst {\n  exporter\n} = require('ipfs-unixfs-exporter');\n\nconst errCode = require('err-code');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst IPFS_PREFIX = 'ipfs';\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\n\nconst toMfsPath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (context, path, options) {\n    const root = yield loadMfsRoot(context, options);\n    /** @type {MfsPath} */\n    // @ts-ignore fields get set later\n\n    let output = {\n      entryType: 'file'\n    };\n    let ipfsPath = '';\n\n    if (path instanceof CID) {\n      ipfsPath = `/ipfs/${path}`;\n    } else {\n      ipfsPath = path;\n    }\n\n    ipfsPath = ipfsPath.trim();\n    ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/');\n\n    if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n      ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n    }\n\n    if (!ipfsPath) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n    }\n\n    if (ipfsPath.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n      ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n    }\n\n    const pathComponents = toPathComponents(ipfsPath);\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory;\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `/${pathComponents.join('/')}`;\n      } else {\n        mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n      } // @ts-ignore fields being set\n\n\n      output = {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n        entryType: 'file',\n        mfsPath: `/${pathComponents.join('/')}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      };\n    } else {\n      const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`;\n      const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`; // @ts-ignore fields being set\n\n      output = {\n        type: 'mfs',\n        depth: pathComponents.length,\n        entryType: 'file',\n        mfsDirectory,\n        mfsPath,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      };\n    }\n\n    const cidPath = output.type === 'mfs' ? output.mfsPath : output.path;\n\n    try {\n      const res = yield exporter(cidPath, context.repo.blocks, options);\n      output.cid = res.cid;\n      output.mfsPath = `/ipfs/${res.path}`;\n      output.entryType = res.type;\n      output.content = res.content;\n\n      if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n        output.unixfs = res.unixfs;\n      }\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    }\n\n    output.exists = Boolean(output.cid);\n    return output;\n  });\n\n  return function toMfsPath(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = toMfsPath;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/ipfs-core/src/components/files/utils/to-mfs-path.js"],"names":["loadMfsRoot","require","toPathComponents","exporter","errCode","CID","IPFS_PREFIX","toMfsPath","context","path","options","root","output","entryType","ipfsPath","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","cidPath","res","repo","blocks","cid","content","unixfs","err","code","exists","Boolean","module","exports"],"mappings":"AAAA;;;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,iBAAD,CAA3B;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,sBAAD,CAAhC;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAeF,OAAO,CAAC,sBAAD,CAA5B;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAUJ,OAAO,CAAC,kBAAD,CAAvB;;AAEA,MAAMK,WAAW,GAAG,MAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,SAAS;AAAA,+BAAG,WAAOC,OAAP,EAAgBC,IAAhB,EAAsBC,OAAtB,EAAkC;AAClD,UAAMC,IAAI,SAASX,WAAW,CAACQ,OAAD,EAAUE,OAAV,CAA9B;AAEA;AACA;;AACA,QAAIE,MAAM,GAAG;AACXC,MAAAA,SAAS,EAAE;AADA,KAAb;AAIA,QAAIC,QAAQ,GAAG,EAAf;;AAEA,QAAIL,IAAI,YAAYJ,GAApB,EAAyB;AACvBS,MAAAA,QAAQ,GAAI,SAAQL,IAAK,EAAzB;AACD,KAFD,MAEO;AACLK,MAAAA,QAAQ,GAAGL,IAAX;AACD;;AAEDK,IAAAA,QAAQ,GAAGA,QAAQ,CAACC,IAAT,EAAX;AACAD,IAAAA,QAAQ,GAAGA,QAAQ,CAACE,OAAT,CAAiB,UAAjB,EAA6B,GAA7B,CAAX;;AAEA,QAAIF,QAAQ,CAACG,QAAT,CAAkB,GAAlB,KAA0BH,QAAQ,CAACI,MAAT,GAAkB,CAAhD,EAAmD;AACjDJ,MAAAA,QAAQ,GAAGA,QAAQ,CAACK,SAAT,CAAmB,CAAnB,EAAsBL,QAAQ,CAACI,MAAT,GAAkB,CAAxC,CAAX;AACD;;AAED,QAAI,CAACJ,QAAL,EAAe;AACb,YAAMV,OAAO,CAAC,IAAIgB,KAAJ,CAAU,yBAAV,CAAD,EAAuC,aAAvC,CAAb;AACD;;AAED,QAAIN,QAAQ,CAACK,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,MAA6B,GAAjC,EAAsC;AACpC,YAAMf,OAAO,CAAC,IAAIgB,KAAJ,CAAU,uCAAV,CAAD,EAAqD,kBAArD,CAAb;AACD;;AAED,QAAIN,QAAQ,CAACK,SAAT,CAAmBL,QAAQ,CAACI,MAAT,GAAkB,CAArC,MAA4C,GAAhD,EAAqD;AACnDJ,MAAAA,QAAQ,GAAGA,QAAQ,CAACK,SAAT,CAAmB,CAAnB,EAAsBL,QAAQ,CAACI,MAAT,GAAkB,CAAxC,CAAX;AACD;;AAED,UAAMG,cAAc,GAAGnB,gBAAgB,CAACY,QAAD,CAAvC;;AAEA,QAAIO,cAAc,CAAC,CAAD,CAAd,KAAsBf,WAA1B,EAAuC;AACrC;AACA,UAAIgB,YAAJ;;AAEA,UAAID,cAAc,CAACH,MAAf,KAA0B,CAA9B,EAAiC;AAC/BI,QAAAA,YAAY,GAAI,IAAGD,cAAc,CAACE,IAAf,CAAoB,GAApB,CAAyB,EAA5C;AACD,OAFD,MAEO;AACLD,QAAAA,YAAY,GAAI,IAAGD,cAAc,CAACG,KAAf,CAAqB,CAArB,EAAwBH,cAAc,CAACH,MAAf,GAAwB,CAAhD,EAAmDK,IAAnD,CAAwD,GAAxD,CAA6D,EAAhF;AACD,OARoC,CAUrC;;;AACAX,MAAAA,MAAM,GAAG;AACPa,QAAAA,IAAI,EAAE,MADC;AAEPC,QAAAA,KAAK,EAAEL,cAAc,CAACH,MAAf,GAAwB,CAFxB;AAGPL,QAAAA,SAAS,EAAE,MAHJ;AAKPc,QAAAA,OAAO,EAAG,IAAGN,cAAc,CAACE,IAAf,CAAoB,GAApB,CAAyB,EAL/B;AAMPD,QAAAA,YANO;AAOPM,QAAAA,KAAK,EAAEP,cAPA;AAQPZ,QAAAA,IAAI,EAAG,IAAGY,cAAc,CAACE,IAAf,CAAoB,GAApB,CAAyB,EAR5B;AASPM,QAAAA,IAAI,EAAER,cAAc,CAACA,cAAc,CAACH,MAAf,GAAwB,CAAzB;AATb,OAAT;AAWD,KAtBD,MAsBO;AACL,YAAMS,OAAO,GAAI,IAAGrB,WAAY,IAAGK,IAAK,GAAEU,cAAc,CAACH,MAAf,GAAwB,MAAMG,cAAc,CAACE,IAAf,CAAoB,GAApB,CAA9B,GAAyD,EAAG,EAAtG;AACA,YAAMD,YAAY,GAAI,IAAGhB,WAAY,IAAGK,IAAK,IAAGU,cAAc,CAACG,KAAf,CAAqB,CAArB,EAAwBH,cAAc,CAACH,MAAf,GAAwB,CAAhD,EAAmDK,IAAnD,CAAwD,GAAxD,CAA6D,EAA7G,CAFK,CAIL;;AACAX,MAAAA,MAAM,GAAG;AACPa,QAAAA,IAAI,EAAE,KADC;AAEPC,QAAAA,KAAK,EAAEL,cAAc,CAACH,MAFf;AAGPL,QAAAA,SAAS,EAAE,MAHJ;AAKPS,QAAAA,YALO;AAMPK,QAAAA,OANO;AAOPC,QAAAA,KAAK,EAAEP,cAPA;AAQPZ,QAAAA,IAAI,EAAG,IAAGY,cAAc,CAACE,IAAf,CAAoB,GAApB,CAAyB,EAR5B;AASPM,QAAAA,IAAI,EAAER,cAAc,CAACA,cAAc,CAACH,MAAf,GAAwB,CAAzB;AATb,OAAT;AAWD;;AAED,UAAMY,OAAO,GAAGlB,MAAM,CAACa,IAAP,KAAgB,KAAhB,GAAwBb,MAAM,CAACe,OAA/B,GAAyCf,MAAM,CAACH,IAAhE;;AAEA,QAAI;AACF,YAAMsB,GAAG,SAAS5B,QAAQ,CAAC2B,OAAD,EAAUtB,OAAO,CAACwB,IAAR,CAAaC,MAAvB,EAA+BvB,OAA/B,CAA1B;AAEAE,MAAAA,MAAM,CAACsB,GAAP,GAAaH,GAAG,CAACG,GAAjB;AACAtB,MAAAA,MAAM,CAACe,OAAP,GAAkB,SAAQI,GAAG,CAACtB,IAAK,EAAnC;AACAG,MAAAA,MAAM,CAACC,SAAP,GAAmBkB,GAAG,CAACN,IAAvB;AACAb,MAAAA,MAAM,CAACuB,OAAP,GAAiBJ,GAAG,CAACI,OAArB;;AAEA,UAAI,CAACvB,MAAM,CAACC,SAAP,KAAqB,MAArB,IAA+BD,MAAM,CAACC,SAAP,KAAqB,WAArD,MAAsEkB,GAAG,CAACN,IAAJ,KAAa,MAAb,IAAuBM,GAAG,CAACN,IAAJ,KAAa,WAA1G,CAAJ,EAA4H;AAC1Hb,QAAAA,MAAM,CAACwB,MAAP,GAAgBL,GAAG,CAACK,MAApB;AACD;AACF,KAXD,CAWE,OAAOC,GAAP,EAAY;AACZ,UAAIA,GAAG,CAACC,IAAJ,KAAa,eAAjB,EAAkC;AAChC,cAAMD,GAAN;AACD;AACF;;AAEDzB,IAAAA,MAAM,CAAC2B,MAAP,GAAgBC,OAAO,CAAC5B,MAAM,CAACsB,GAAR,CAAvB;AAEA,WAAOtB,MAAP;AACD,GApGc;;AAAA,kBAATL,SAAS;AAAA;AAAA;AAAA,GAAf;;AAsGAkC,MAAM,CAACC,OAAP,GAAiBnC,SAAjB","sourcesContent":["'use strict'\n\nconst loadMfsRoot = require('./with-mfs-root')\nconst toPathComponents = require('./to-path-components')\nconst { exporter } = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\nconst { CID } = require('multiformats/cid')\n\nconst IPFS_PREFIX = 'ipfs'\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nconst toMfsPath = async (context, path, options) => {\n  const root = await loadMfsRoot(context, options)\n\n  /** @type {MfsPath} */\n  // @ts-ignore fields get set later\n  let output = {\n    entryType: 'file'\n  }\n\n  let ipfsPath = ''\n\n  if (path instanceof CID) {\n    ipfsPath = `/ipfs/${path}`\n  } else {\n    ipfsPath = path\n  }\n\n  ipfsPath = ipfsPath.trim()\n  ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/')\n\n  if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1)\n  }\n\n  if (!ipfsPath) {\n    throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n  }\n\n  if (ipfsPath.substring(0, 1) !== '/') {\n    throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n  }\n\n  if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1)\n  }\n\n  const pathComponents = toPathComponents(ipfsPath)\n\n  if (pathComponents[0] === IPFS_PREFIX) {\n    // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n    let mfsDirectory\n\n    if (pathComponents.length === 2) {\n      mfsDirectory = `/${pathComponents.join('/')}`\n    } else {\n      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n    }\n\n    // @ts-ignore fields being set\n    output = {\n      type: 'ipfs',\n      depth: pathComponents.length - 2,\n      entryType: 'file',\n\n      mfsPath: `/${pathComponents.join('/')}`,\n      mfsDirectory,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  } else {\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n\n    // @ts-ignore fields being set\n    output = {\n      type: 'mfs',\n      depth: pathComponents.length,\n      entryType: 'file',\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  }\n\n  const cidPath = output.type === 'mfs' ? output.mfsPath : output.path\n\n  try {\n    const res = await exporter(cidPath, context.repo.blocks, options)\n\n    output.cid = res.cid\n    output.mfsPath = `/ipfs/${res.path}`\n    output.entryType = res.type\n    output.content = res.content\n\n    if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n      output.unixfs = res.unixfs\n    }\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  output.exists = Boolean(output.cid)\n\n  return output\n}\n\nmodule.exports = toMfsPath\n"]},"metadata":{},"sourceType":"script"}