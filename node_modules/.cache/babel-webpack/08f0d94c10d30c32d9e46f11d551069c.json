{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Client = require('../../lib/core');\n\nconst Service = require('./service');\n\nconst toUrlSearchParams = require('../../lib/to-url-search-params');\n/**\n * @typedef {import('../../types').Options} Options\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').Pin} Pin\n * @typedef {import('ipfs-core-types/src/pin/remote').AddOptions} AddOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').Query} Query\n * @typedef {import('ipfs-core-types/src/pin/remote').Status} Status\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI\n */\n\n\nclass Remote {\n  /**\n   * @param {Options} options\n   */\n  constructor(options) {\n    this.client = new Client(options);\n    /** @readonly */\n\n    this.service = new Service(options);\n  }\n\n}\n/**\n * @type {RemotePiningAPI[\"add\"]}\n */\n\n\nRemote.prototype.add = /*#__PURE__*/function () {\n  var _add = _asyncToGenerator(function* (cid, {\n    timeout,\n    signal,\n    headers,\n    ...query\n  }) {\n    const response = yield this.client.post('pin/remote/add', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeAddParams({\n        cid,\n        ...query\n      })\n    });\n    return decodePin(yield response.json());\n  });\n\n  function add(_x2, _x3) {\n    return _add.apply(this, arguments);\n  }\n\n  return add;\n}();\n/**\n * @type {RemotePiningAPI[\"ls\"]}\n */\n\n\nRemote.prototype.ls = /*#__PURE__*/function () {\n  var _ls = _wrapAsyncGenerator(function* ({\n    timeout,\n    signal,\n    headers,\n    ...query\n  }) {\n    const response = yield _awaitAsyncGenerator(this.client.post('pin/remote/ls', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeQuery(query)\n    }));\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(response.ndjson()), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const pin = _value;\n        yield decodePin(pin);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n\n  function ls(_x) {\n    return _ls.apply(this, arguments);\n  }\n\n  return ls;\n}();\n/**\n * @type {RemotePiningAPI[\"rm\"]}\n */\n\n\nRemote.prototype.rm = /*#__PURE__*/function () {\n  var _rm = _asyncToGenerator(function* ({\n    timeout,\n    signal,\n    headers,\n    ...query\n  }) {\n    yield this.client.post('pin/remote/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeQuery({ ...query,\n        all: false\n      })\n    });\n  });\n\n  function rm(_x4) {\n    return _rm.apply(this, arguments);\n  }\n\n  return rm;\n}();\n/**\n * @type {RemotePiningAPI[\"rmAll\"]}\n */\n\n\nRemote.prototype.rmAll = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    timeout,\n    signal,\n    headers,\n    ...query\n  }) {\n    yield this.client.post('pin/remote/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeQuery({ ...query,\n        all: true\n      })\n    });\n  });\n\n  return function (_x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {Object} json\n * @param {string} json.Name\n * @param {string} json.Cid\n * @param {Status} json.Status\n * @returns {Pin}\n */\n\n\nconst decodePin = ({\n  Name: name,\n  Status: status,\n  Cid: cid\n}) => {\n  return {\n    cid: CID.parse(cid),\n    name,\n    status\n  };\n};\n/**\n * @param {any} service\n * @returns {string}\n */\n\n\nconst encodeService = service => {\n  if (typeof service === 'string' && service !== '') {\n    return service;\n  } else {\n    throw new TypeError('service name must be passed');\n  }\n};\n/**\n * @param {any} cid\n * @returns {string}\n */\n\n\nconst encodeCID = cid => {\n  if (cid instanceof CID) {\n    return cid.toString();\n  } else {\n    throw new TypeError(`CID instance expected instead of ${typeof cid}`);\n  }\n};\n/**\n * @param {Query & { all?: boolean }} query\n * @returns {URLSearchParams}\n */\n\n\nconst encodeQuery = ({\n  service,\n  cid,\n  name,\n  status,\n  all\n}) => {\n  const query = toUrlSearchParams({\n    service: encodeService(service),\n    name,\n    force: all ? true : undefined\n  });\n\n  if (cid) {\n    for (const value of cid) {\n      query.append('cid', encodeCID(value));\n    }\n  }\n\n  if (status) {\n    for (const value of status) {\n      query.append('status', value);\n    }\n  }\n\n  return query;\n};\n/**\n * @param {AddOptions & {cid:CID}} options\n * @returns {URLSearchParams}\n */\n\n\nconst encodeAddParams = ({\n  cid,\n  service,\n  background,\n  name,\n  origins\n}) => {\n  const params = toUrlSearchParams({\n    arg: encodeCID(cid),\n    service: encodeService(service),\n    name,\n    background: background ? true : undefined\n  });\n\n  if (origins) {\n    for (const origin of origins) {\n      params.append('origin', origin.toString());\n    }\n  }\n\n  return params;\n};\n\nmodule.exports = Remote;","map":null,"metadata":{},"sourceType":"script"}