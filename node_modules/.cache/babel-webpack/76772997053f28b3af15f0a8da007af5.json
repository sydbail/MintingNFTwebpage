{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Adapter,\n  Key,\n  Errors,\n  utils: {\n    sortAll,\n    replaceStartWith\n  }\n} = require('interface-datastore');\n\nconst filter = require('it-filter');\n\nconst take = require('it-take');\n\nconst merge = require('it-merge');\n\nconst Keytransform = require('./keytransform');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\n\n\nclass MountDatastore extends Adapter {\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  constructor(mounts) {\n    super();\n    this.mounts = mounts.slice();\n  }\n\n  open() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield Promise.all(_this.mounts.map(m => m.datastore.open()));\n    })();\n  }\n  /**\n   * Lookup the matching datastore for the given key\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{datastore: Datastore, mountpoint: Key, rest: Key} | undefined}\n   */\n\n\n  _lookup(key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        const s = replaceStartWith(key.toString(), mount.prefix.toString());\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix,\n          rest: new Key(s)\n        };\n      }\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n\n\n  put(key, value, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.put(match.rest, value, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.get(match.rest, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      return Promise.resolve(false);\n    }\n\n    return match.datastore.has(match.rest, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.delete(match.rest, options);\n  }\n\n  close() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield Promise.all(_this2.mounts.map(m => {\n        return m.datastore.close();\n      }));\n    })();\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    /** @type {Record<string, Batch>} */\n    const batchMounts = {};\n    /**\n     * @param {Key} key\n     */\n\n    const lookup = key => {\n      const match = this._lookup(key);\n\n      if (match == null) {\n        throw new Error('No datastore mounted for this key');\n      }\n\n      const m = match.mountpoint.toString();\n\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch();\n      }\n\n      return {\n        batch: batchMounts[m],\n        rest: match.rest\n      };\n    };\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key);\n        match.batch.put(match.rest, value);\n      },\n      delete: key => {\n        const match = lookup(key);\n        match.batch.delete(match.rest);\n      },\n      commit: function () {\n        var _ref = _asyncToGenerator(function* (options) {\n          yield Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));\n        });\n\n        return function commit(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()\n    };\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: key => {\n          throw new Error('should never be called');\n        },\n        invert: key => {\n          return m.prefix.child(key);\n        }\n      });\n      let prefix;\n\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString());\n      }\n\n      return ks.query({\n        prefix: prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge(...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: key => {\n          throw new Error('should never be called');\n        },\n        invert: key => {\n          return m.prefix.child(key);\n        }\n      });\n      let prefix;\n\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString());\n      }\n\n      return ks.queryKeys({\n        prefix: prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge(...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n\n}\n\nmodule.exports = MountDatastore;","map":null,"metadata":{},"sourceType":"script"}