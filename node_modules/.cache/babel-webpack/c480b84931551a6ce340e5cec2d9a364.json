{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asyncStringify = exports.possiblyAsyncStringify = exports.stringify = exports.stringifyInternal = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = void 0;\nexports.toStringMethod = Symbol('fast-check/toStringMethod');\n\nfunction hasToStringMethod(instance) {\n  return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && exports.toStringMethod in instance && typeof instance[exports.toStringMethod] === 'function';\n}\n\nexports.hasToStringMethod = hasToStringMethod;\nexports.asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');\n\nfunction hasAsyncToStringMethod(instance) {\n  return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && exports.asyncToStringMethod in instance && typeof instance[exports.asyncToStringMethod] === 'function';\n}\n\nexports.hasAsyncToStringMethod = hasAsyncToStringMethod;\nconst findSymbolNameRegex = /^Symbol\\((.*)\\)$/;\n\nfunction getSymbolDescription(s) {\n  if (s.description !== undefined) return s.description;\n  const m = findSymbolNameRegex.exec(String(s));\n  return m && m[1].length ? m[1] : null;\n}\n\nfunction stringifyNumber(numValue) {\n  switch (numValue) {\n    case 0:\n      return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';\n\n    case Number.NEGATIVE_INFINITY:\n      return 'Number.NEGATIVE_INFINITY';\n\n    case Number.POSITIVE_INFINITY:\n      return 'Number.POSITIVE_INFINITY';\n\n    default:\n      return numValue === numValue ? String(numValue) : 'Number.NaN';\n  }\n}\n\nfunction isSparseArray(arr) {\n  let previousNumberedIndex = -1;\n\n  for (const index in arr) {\n    const numberedIndex = Number(index);\n    if (numberedIndex !== previousNumberedIndex + 1) return true;\n    previousNumberedIndex = numberedIndex;\n  }\n\n  return previousNumberedIndex + 1 !== arr.length;\n}\n\nfunction stringifyInternal(value, previousValues, getAsyncContent) {\n  const currentValues = previousValues.concat([value]);\n\n  if (typeof value === 'object') {\n    if (previousValues.indexOf(value) !== -1) {\n      return '[cyclic]';\n    }\n  }\n\n  if (hasAsyncToStringMethod(value)) {\n    const content = getAsyncContent(value);\n\n    if (content.state === 'fulfilled') {\n      return content.value;\n    }\n  }\n\n  if (hasToStringMethod(value)) {\n    try {\n      return value[exports.toStringMethod]();\n    } catch (err) {}\n  }\n\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Array]':\n      {\n        const arr = value;\n\n        if (arr.length >= 50 && isSparseArray(arr)) {\n          const assignments = [];\n\n          for (const index in arr) {\n            if (!Number.isNaN(Number(index))) assignments.push(`${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);\n          }\n\n          return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${assignments.join(',')}})` : `Array(${arr.length})`;\n        }\n\n        const stringifiedArray = arr.map(v => stringifyInternal(v, currentValues, getAsyncContent)).join(',');\n        return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;\n      }\n\n    case '[object BigInt]':\n      return `${value}n`;\n\n    case '[object Boolean]':\n      return typeof value === 'boolean' ? JSON.stringify(value) : `new Boolean(${JSON.stringify(value)})`;\n\n    case '[object Date]':\n      {\n        const d = value;\n        return Number.isNaN(d.getTime()) ? `new Date(NaN)` : `new Date(${JSON.stringify(d.toISOString())})`;\n      }\n\n    case '[object Map]':\n      return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;\n\n    case '[object Null]':\n      return `null`;\n\n    case '[object Number]':\n      return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;\n\n    case '[object Object]':\n      {\n        try {\n          const toStringAccessor = value.toString;\n\n          if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {\n            return value.toString();\n          }\n        } catch (err) {\n          return '[object Object]';\n        }\n\n        const mapper = k => `${k === '__proto__' ? '[\"__proto__\"]' : typeof k === 'symbol' ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : JSON.stringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;\n\n        const stringifiedProperties = [...Object.keys(value).map(mapper), ...Object.getOwnPropertySymbols(value).filter(s => {\n          const descriptor = Object.getOwnPropertyDescriptor(value, s);\n          return descriptor && descriptor.enumerable;\n        }).map(mapper)];\n        const rawRepr = '{' + stringifiedProperties.join(',') + '}';\n\n        if (Object.getPrototypeOf(value) === null) {\n          return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;\n        }\n\n        return rawRepr;\n      }\n\n    case '[object Set]':\n      return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;\n\n    case '[object String]':\n      return typeof value === 'string' ? JSON.stringify(value) : `new String(${JSON.stringify(value)})`;\n\n    case '[object Symbol]':\n      {\n        const s = value;\n\n        if (Symbol.keyFor(s) !== undefined) {\n          return `Symbol.for(${JSON.stringify(Symbol.keyFor(s))})`;\n        }\n\n        const desc = getSymbolDescription(s);\n\n        if (desc === null) {\n          return 'Symbol()';\n        }\n\n        const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];\n        return s === knownSymbol ? desc : `Symbol(${JSON.stringify(desc)})`;\n      }\n\n    case '[object Promise]':\n      {\n        const promiseContent = getAsyncContent(value);\n\n        switch (promiseContent.state) {\n          case 'fulfilled':\n            return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;\n\n          case 'rejected':\n            return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;\n\n          case 'pending':\n            return `new Promise(() => {/*pending*/})`;\n\n          case 'unknown':\n          default:\n            return `new Promise(() => {/*unknown*/})`;\n        }\n      }\n\n    case '[object Error]':\n      if (value instanceof Error) {\n        return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;\n      }\n\n      break;\n\n    case '[object Undefined]':\n      return `undefined`;\n\n    case '[object Int8Array]':\n    case '[object Uint8Array]':\n    case '[object Uint8ClampedArray]':\n    case '[object Int16Array]':\n    case '[object Uint16Array]':\n    case '[object Int32Array]':\n    case '[object Uint32Array]':\n    case '[object Float32Array]':\n    case '[object Float64Array]':\n    case '[object BigInt64Array]':\n    case '[object BigUint64Array]':\n      {\n        if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {\n          return `Buffer.from(${stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent)})`;\n        }\n\n        const valuePrototype = Object.getPrototypeOf(value);\n        const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;\n\n        if (typeof className === 'string') {\n          const typedArray = value;\n          const valuesFromTypedArr = typedArray.values();\n          return `${className}.from(${stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent)})`;\n        }\n\n        break;\n      }\n  }\n\n  try {\n    return value.toString();\n  } catch (_a) {\n    return Object.prototype.toString.call(value);\n  }\n}\n\nexports.stringifyInternal = stringifyInternal;\n\nfunction stringify(value) {\n  return stringifyInternal(value, [], () => ({\n    state: 'unknown',\n    value: undefined\n  }));\n}\n\nexports.stringify = stringify;\n\nfunction possiblyAsyncStringify(value) {\n  const stillPendingMarker = Symbol();\n  const pendingPromisesForCache = [];\n  const cache = new Map();\n\n  function createDelay0() {\n    let handleId = null;\n\n    const cancel = () => {\n      if (handleId !== null) {\n        clearTimeout(handleId);\n      }\n    };\n\n    const delay = new Promise(resolve => {\n      handleId = setTimeout(() => {\n        handleId = null;\n        resolve(stillPendingMarker);\n      }, 0);\n    });\n    return {\n      delay,\n      cancel\n    };\n  }\n\n  const unknownState = {\n    state: 'unknown',\n    value: undefined\n  };\n\n  const getAsyncContent = function getAsyncContent(data) {\n    const cacheKey = data;\n\n    if (cache.has(cacheKey)) {\n      return cache.get(cacheKey);\n    }\n\n    const delay0 = createDelay0();\n    const p = exports.asyncToStringMethod in data ? Promise.resolve().then(() => data[exports.asyncToStringMethod]()) : data;\n    p.catch(() => {});\n    pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then(successValue => {\n      if (successValue === stillPendingMarker) cache.set(cacheKey, {\n        state: 'pending',\n        value: undefined\n      });else cache.set(cacheKey, {\n        state: 'fulfilled',\n        value: successValue\n      });\n      delay0.cancel();\n    }, errorValue => {\n      cache.set(cacheKey, {\n        state: 'rejected',\n        value: errorValue\n      });\n      delay0.cancel();\n    }));\n    cache.set(cacheKey, unknownState);\n    return unknownState;\n  };\n\n  function loop() {\n    const stringifiedValue = stringifyInternal(value, [], getAsyncContent);\n\n    if (pendingPromisesForCache.length === 0) {\n      return stringifiedValue;\n    }\n\n    return Promise.all(pendingPromisesForCache.splice(0)).then(loop);\n  }\n\n  return loop();\n}\n\nexports.possiblyAsyncStringify = possiblyAsyncStringify;\n\nfunction asyncStringify(_x) {\n  return _asyncStringify.apply(this, arguments);\n}\n\nfunction _asyncStringify() {\n  _asyncStringify = _asyncToGenerator(function* (value) {\n    return Promise.resolve(possiblyAsyncStringify(value));\n  });\n  return _asyncStringify.apply(this, arguments);\n}\n\nexports.asyncStringify = asyncStringify;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/fast-check/lib/utils/stringify.js"],"names":["Object","defineProperty","exports","value","asyncStringify","possiblyAsyncStringify","stringify","stringifyInternal","hasAsyncToStringMethod","asyncToStringMethod","hasToStringMethod","toStringMethod","Symbol","instance","findSymbolNameRegex","getSymbolDescription","s","description","undefined","m","exec","String","length","stringifyNumber","numValue","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","isSparseArray","arr","previousNumberedIndex","index","numberedIndex","previousValues","getAsyncContent","currentValues","concat","indexOf","content","state","err","prototype","toString","call","assignments","isNaN","push","join","stringifiedArray","map","v","JSON","d","getTime","toISOString","Array","from","toStringAccessor","mapper","k","stringifiedProperties","keys","getOwnPropertySymbols","filter","descriptor","getOwnPropertyDescriptor","enumerable","rawRepr","getPrototypeOf","keyFor","desc","knownSymbol","startsWith","substring","promiseContent","Error","message","Buffer","isBuffer","values","valuePrototype","className","constructor","name","typedArray","valuesFromTypedArr","_a","stillPendingMarker","pendingPromisesForCache","cache","Map","createDelay0","handleId","cancel","clearTimeout","delay","Promise","resolve","setTimeout","unknownState","data","cacheKey","has","get","delay0","p","then","catch","race","successValue","set","errorValue","loop","stringifiedValue","all","splice"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asyncStringify = exports.possiblyAsyncStringify = exports.stringify = exports.stringifyInternal = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = void 0;\nexports.toStringMethod = Symbol('fast-check/toStringMethod');\nfunction hasToStringMethod(instance) {\n    return (instance !== null &&\n        (typeof instance === 'object' || typeof instance === 'function') &&\n        exports.toStringMethod in instance &&\n        typeof instance[exports.toStringMethod] === 'function');\n}\nexports.hasToStringMethod = hasToStringMethod;\nexports.asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');\nfunction hasAsyncToStringMethod(instance) {\n    return (instance !== null &&\n        (typeof instance === 'object' || typeof instance === 'function') &&\n        exports.asyncToStringMethod in instance &&\n        typeof instance[exports.asyncToStringMethod] === 'function');\n}\nexports.hasAsyncToStringMethod = hasAsyncToStringMethod;\nconst findSymbolNameRegex = /^Symbol\\((.*)\\)$/;\nfunction getSymbolDescription(s) {\n    if (s.description !== undefined)\n        return s.description;\n    const m = findSymbolNameRegex.exec(String(s));\n    return m && m[1].length ? m[1] : null;\n}\nfunction stringifyNumber(numValue) {\n    switch (numValue) {\n        case 0:\n            return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';\n        case Number.NEGATIVE_INFINITY:\n            return 'Number.NEGATIVE_INFINITY';\n        case Number.POSITIVE_INFINITY:\n            return 'Number.POSITIVE_INFINITY';\n        default:\n            return numValue === numValue ? String(numValue) : 'Number.NaN';\n    }\n}\nfunction isSparseArray(arr) {\n    let previousNumberedIndex = -1;\n    for (const index in arr) {\n        const numberedIndex = Number(index);\n        if (numberedIndex !== previousNumberedIndex + 1)\n            return true;\n        previousNumberedIndex = numberedIndex;\n    }\n    return previousNumberedIndex + 1 !== arr.length;\n}\nfunction stringifyInternal(value, previousValues, getAsyncContent) {\n    const currentValues = previousValues.concat([value]);\n    if (typeof value === 'object') {\n        if (previousValues.indexOf(value) !== -1) {\n            return '[cyclic]';\n        }\n    }\n    if (hasAsyncToStringMethod(value)) {\n        const content = getAsyncContent(value);\n        if (content.state === 'fulfilled') {\n            return content.value;\n        }\n    }\n    if (hasToStringMethod(value)) {\n        try {\n            return value[exports.toStringMethod]();\n        }\n        catch (err) {\n        }\n    }\n    switch (Object.prototype.toString.call(value)) {\n        case '[object Array]': {\n            const arr = value;\n            if (arr.length >= 50 && isSparseArray(arr)) {\n                const assignments = [];\n                for (const index in arr) {\n                    if (!Number.isNaN(Number(index)))\n                        assignments.push(`${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);\n                }\n                return assignments.length !== 0\n                    ? `Object.assign(Array(${arr.length}),{${assignments.join(',')}})`\n                    : `Array(${arr.length})`;\n            }\n            const stringifiedArray = arr.map((v) => stringifyInternal(v, currentValues, getAsyncContent)).join(',');\n            return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;\n        }\n        case '[object BigInt]':\n            return `${value}n`;\n        case '[object Boolean]':\n            return typeof value === 'boolean' ? JSON.stringify(value) : `new Boolean(${JSON.stringify(value)})`;\n        case '[object Date]': {\n            const d = value;\n            return Number.isNaN(d.getTime()) ? `new Date(NaN)` : `new Date(${JSON.stringify(d.toISOString())})`;\n        }\n        case '[object Map]':\n            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;\n        case '[object Null]':\n            return `null`;\n        case '[object Number]':\n            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;\n        case '[object Object]': {\n            try {\n                const toStringAccessor = value.toString;\n                if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {\n                    return value.toString();\n                }\n            }\n            catch (err) {\n                return '[object Object]';\n            }\n            const mapper = (k) => `${k === '__proto__'\n                ? '[\"__proto__\"]'\n                : typeof k === 'symbol'\n                    ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]`\n                    : JSON.stringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;\n            const stringifiedProperties = [\n                ...Object.keys(value).map(mapper),\n                ...Object.getOwnPropertySymbols(value)\n                    .filter((s) => {\n                    const descriptor = Object.getOwnPropertyDescriptor(value, s);\n                    return descriptor && descriptor.enumerable;\n                })\n                    .map(mapper),\n            ];\n            const rawRepr = '{' + stringifiedProperties.join(',') + '}';\n            if (Object.getPrototypeOf(value) === null) {\n                return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;\n            }\n            return rawRepr;\n        }\n        case '[object Set]':\n            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;\n        case '[object String]':\n            return typeof value === 'string' ? JSON.stringify(value) : `new String(${JSON.stringify(value)})`;\n        case '[object Symbol]': {\n            const s = value;\n            if (Symbol.keyFor(s) !== undefined) {\n                return `Symbol.for(${JSON.stringify(Symbol.keyFor(s))})`;\n            }\n            const desc = getSymbolDescription(s);\n            if (desc === null) {\n                return 'Symbol()';\n            }\n            const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];\n            return s === knownSymbol ? desc : `Symbol(${JSON.stringify(desc)})`;\n        }\n        case '[object Promise]': {\n            const promiseContent = getAsyncContent(value);\n            switch (promiseContent.state) {\n                case 'fulfilled':\n                    return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;\n                case 'rejected':\n                    return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;\n                case 'pending':\n                    return `new Promise(() => {/*pending*/})`;\n                case 'unknown':\n                default:\n                    return `new Promise(() => {/*unknown*/})`;\n            }\n        }\n        case '[object Error]':\n            if (value instanceof Error) {\n                return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;\n            }\n            break;\n        case '[object Undefined]':\n            return `undefined`;\n        case '[object Int8Array]':\n        case '[object Uint8Array]':\n        case '[object Uint8ClampedArray]':\n        case '[object Int16Array]':\n        case '[object Uint16Array]':\n        case '[object Int32Array]':\n        case '[object Uint32Array]':\n        case '[object Float32Array]':\n        case '[object Float64Array]':\n        case '[object BigInt64Array]':\n        case '[object BigUint64Array]': {\n            if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {\n                return `Buffer.from(${stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent)})`;\n            }\n            const valuePrototype = Object.getPrototypeOf(value);\n            const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;\n            if (typeof className === 'string') {\n                const typedArray = value;\n                const valuesFromTypedArr = typedArray.values();\n                return `${className}.from(${stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent)})`;\n            }\n            break;\n        }\n    }\n    try {\n        return value.toString();\n    }\n    catch (_a) {\n        return Object.prototype.toString.call(value);\n    }\n}\nexports.stringifyInternal = stringifyInternal;\nfunction stringify(value) {\n    return stringifyInternal(value, [], () => ({ state: 'unknown', value: undefined }));\n}\nexports.stringify = stringify;\nfunction possiblyAsyncStringify(value) {\n    const stillPendingMarker = Symbol();\n    const pendingPromisesForCache = [];\n    const cache = new Map();\n    function createDelay0() {\n        let handleId = null;\n        const cancel = () => {\n            if (handleId !== null) {\n                clearTimeout(handleId);\n            }\n        };\n        const delay = new Promise((resolve) => {\n            handleId = setTimeout(() => {\n                handleId = null;\n                resolve(stillPendingMarker);\n            }, 0);\n        });\n        return { delay, cancel };\n    }\n    const unknownState = { state: 'unknown', value: undefined };\n    const getAsyncContent = function getAsyncContent(data) {\n        const cacheKey = data;\n        if (cache.has(cacheKey)) {\n            return cache.get(cacheKey);\n        }\n        const delay0 = createDelay0();\n        const p = exports.asyncToStringMethod in data\n            ? Promise.resolve().then(() => data[exports.asyncToStringMethod]())\n            : data;\n        p.catch(() => { });\n        pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {\n            if (successValue === stillPendingMarker)\n                cache.set(cacheKey, { state: 'pending', value: undefined });\n            else\n                cache.set(cacheKey, { state: 'fulfilled', value: successValue });\n            delay0.cancel();\n        }, (errorValue) => {\n            cache.set(cacheKey, { state: 'rejected', value: errorValue });\n            delay0.cancel();\n        }));\n        cache.set(cacheKey, unknownState);\n        return unknownState;\n    };\n    function loop() {\n        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);\n        if (pendingPromisesForCache.length === 0) {\n            return stringifiedValue;\n        }\n        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);\n    }\n    return loop();\n}\nexports.possiblyAsyncStringify = possiblyAsyncStringify;\nasync function asyncStringify(value) {\n    return Promise.resolve(possiblyAsyncStringify(value));\n}\nexports.asyncStringify = asyncStringify;\n"]},"metadata":{},"sourceType":"script"}