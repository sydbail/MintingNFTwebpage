{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrayInt64 = void 0;\n\nconst Stream_1 = require(\"../../../stream/Stream\");\n\nconst Converters_1 = require(\"../definition/Converters\");\n\nconst NextArbitrary_1 = require(\"../definition/NextArbitrary\");\n\nconst NextValue_1 = require(\"../definition/NextValue\");\n\nconst ArrayInt64_1 = require(\"./ArrayInt64\");\n\nclass ArrayInt64Arbitrary extends NextArbitrary_1.NextArbitrary {\n  constructor(min, max) {\n    super();\n    this.min = min;\n    this.max = max;\n    this.biasedRanges = null;\n  }\n\n  generate(mrng, biasFactor) {\n    const range = this.computeGenerateRange(mrng, biasFactor);\n    const uncheckedValue = mrng.nextArrayInt(range.min, range.max);\n\n    if (uncheckedValue.data.length === 1) {\n      uncheckedValue.data.unshift(0);\n    }\n\n    return new NextValue_1.NextValue(uncheckedValue, undefined);\n  }\n\n  computeGenerateRange(mrng, biasFactor) {\n    if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n      return {\n        min: this.min,\n        max: this.max\n      };\n    }\n\n    const ranges = this.retrieveBiasedRanges();\n\n    if (ranges.length === 1) {\n      return ranges[0];\n    }\n\n    const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n    return id < 0 ? ranges[0] : ranges[id + 1];\n  }\n\n  canShrinkWithoutContext(value) {\n    const unsafeValue = value;\n    return typeof value === 'object' && value !== null && (unsafeValue.sign === -1 || unsafeValue.sign === 1) && Array.isArray(unsafeValue.data) && unsafeValue.data.length === 2 && (ArrayInt64_1.isStrictlySmaller64(this.min, unsafeValue) && ArrayInt64_1.isStrictlySmaller64(unsafeValue, this.max) || ArrayInt64_1.isEqual64(this.min, unsafeValue) || ArrayInt64_1.isEqual64(this.max, unsafeValue));\n  }\n\n  shrinkArrayInt64(value, target, tryTargetAsap) {\n    const realGap = ArrayInt64_1.substract64(value, target);\n\n    function* shrinkGen() {\n      let previous = tryTargetAsap ? undefined : target;\n      const gap = tryTargetAsap ? realGap : ArrayInt64_1.halve64(realGap);\n\n      for (let toremove = gap; !ArrayInt64_1.isZero64(toremove); toremove = ArrayInt64_1.halve64(toremove)) {\n        const next = ArrayInt64_1.substract64(value, toremove);\n        yield new NextValue_1.NextValue(next, previous);\n        previous = next;\n      }\n    }\n\n    return Stream_1.stream(shrinkGen());\n  }\n\n  shrink(current, context) {\n    if (!ArrayInt64Arbitrary.isValidContext(current, context)) {\n      const target = this.defaultTarget();\n      return this.shrinkArrayInt64(current, target, true);\n    }\n\n    if (this.isLastChanceTry(current, context)) {\n      return Stream_1.Stream.of(new NextValue_1.NextValue(context, undefined));\n    }\n\n    return this.shrinkArrayInt64(current, context, false);\n  }\n\n  defaultTarget() {\n    if (!ArrayInt64_1.isStrictlyPositive64(this.min) && !ArrayInt64_1.isStrictlyNegative64(this.max)) {\n      return ArrayInt64_1.Zero64;\n    }\n\n    return ArrayInt64_1.isStrictlyNegative64(this.min) ? this.max : this.min;\n  }\n\n  isLastChanceTry(current, context) {\n    if (ArrayInt64_1.isZero64(current)) {\n      return false;\n    }\n\n    if (current.sign === 1) {\n      return ArrayInt64_1.isEqual64(current, ArrayInt64_1.add64(context, ArrayInt64_1.Unit64)) && ArrayInt64_1.isStrictlyPositive64(ArrayInt64_1.substract64(current, this.min));\n    } else {\n      return ArrayInt64_1.isEqual64(current, ArrayInt64_1.substract64(context, ArrayInt64_1.Unit64)) && ArrayInt64_1.isStrictlyNegative64(ArrayInt64_1.substract64(current, this.max));\n    }\n  }\n\n  static isValidContext(_current, context) {\n    if (context === undefined) {\n      return false;\n    }\n\n    if (typeof context !== 'object' || context === null || !('sign' in context) || !('data' in context)) {\n      throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);\n    }\n\n    return true;\n  }\n\n  retrieveBiasedRanges() {\n    if (this.biasedRanges != null) {\n      return this.biasedRanges;\n    }\n\n    if (ArrayInt64_1.isEqual64(this.min, this.max)) {\n      this.biasedRanges = [{\n        min: this.min,\n        max: this.max\n      }];\n      return this.biasedRanges;\n    }\n\n    const minStrictlySmallerZero = ArrayInt64_1.isStrictlyNegative64(this.min);\n    const maxStrictlyGreaterZero = ArrayInt64_1.isStrictlyPositive64(this.max);\n\n    if (minStrictlySmallerZero && maxStrictlyGreaterZero) {\n      const logMin = ArrayInt64_1.logLike64(this.min);\n      const logMax = ArrayInt64_1.logLike64(this.max);\n      this.biasedRanges = [{\n        min: logMin,\n        max: logMax\n      }, {\n        min: ArrayInt64_1.substract64(this.max, logMax),\n        max: this.max\n      }, {\n        min: this.min,\n        max: ArrayInt64_1.substract64(this.min, logMin)\n      }];\n    } else {\n      const logGap = ArrayInt64_1.logLike64(ArrayInt64_1.substract64(this.max, this.min));\n      const arbCloseToMin = {\n        min: this.min,\n        max: ArrayInt64_1.add64(this.min, logGap)\n      };\n      const arbCloseToMax = {\n        min: ArrayInt64_1.substract64(this.max, logGap),\n        max: this.max\n      };\n      this.biasedRanges = minStrictlySmallerZero ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];\n    }\n\n    return this.biasedRanges;\n  }\n\n}\n\nfunction arrayInt64(min, max) {\n  const arb = new ArrayInt64Arbitrary(min, max);\n  return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\n\nexports.arrayInt64 = arrayInt64;","map":null,"metadata":{},"sourceType":"script"}