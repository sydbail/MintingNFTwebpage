{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  createFromPrivKey\n} = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns'), {\n  error: debug('ipfs:ipns:error')\n});\n\nconst IpnsPublisher = require('./publisher');\n\nconst IpnsRepublisher = require('./republisher');\n\nconst IpnsResolver = require('./resolver');\n\nconst TLRU = require('../utils/tlru');\n\nconst defaultRecordTtl = 60 * 1000;\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('peer-id')} PeerId\n */\n\n\nclass IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('libp2p/src/keychain')} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor(routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  }\n  /**\n   * Publish\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  publish(privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const peerId = yield createFromPrivKey(privKey.bytes);\n        yield _this.publisher.publishWithEOL(privKey, value, lifetime);\n        log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`); // // Add to cache\n\n        const id = peerId.toB58String(); // @ts-ignore - parseFloat expects string\n\n        const ttEol = parseFloat(lifetime);\n        const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n\n        _this.cache.set(id, value, ttl);\n\n        log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`);\n        return {\n          name: id,\n          value: value\n        };\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   */\n\n\n  resolve(name, options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof name !== 'string') {\n        throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n      } // If recursive, we should not try to get the cached value\n\n\n      if (!options.nocache && !options.recursive) {\n        // Try to get the record from cache\n        const id = name.split('/')[2];\n\n        const result = _this2.cache.get(id);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      try {\n        const result = yield _this2.resolver.resolve(name, options);\n        log(`IPNS record from ${name} was resolved correctly`);\n        return result;\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n\n\n  initializeKeyspace(privKey, value) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      return _this3.publish(privKey, value, IpnsPublisher.defaultRecordLifetime);\n    })();\n  }\n\n}\n\nmodule.exports = IPNS;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/ipns/index.js"],"names":["createFromPrivKey","require","errcode","debug","log","Object","assign","error","IpnsPublisher","IpnsRepublisher","IpnsResolver","TLRU","defaultRecordTtl","toString","uint8ArrayToString","IPNS","constructor","routing","datastore","peerId","keychain","options","publisher","republisher","resolver","cache","publish","privKey","value","lifetime","defaultRecordLifetime","bytes","publishWithEOL","id","toB58String","ttEol","parseFloat","ttl","set","name","err","resolve","Error","nocache","recursive","split","result","get","initializeKeyspace","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { createFromPrivKey } = require('peer-id')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns'), {\n  error: debug('ipfs:ipns:error')\n})\n\nconst IpnsPublisher = require('./publisher')\nconst IpnsRepublisher = require('./republisher')\nconst IpnsResolver = require('./resolver')\nconst TLRU = require('../utils/tlru')\nconst defaultRecordTtl = 60 * 1000\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('peer-id')} PeerId\n */\n\nclass IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('libp2p/src/keychain')} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore)\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options)\n    this.resolver = new IpnsResolver(routing)\n    this.cache = new TLRU(1000)\n    this.routing = routing\n  }\n\n  /**\n   * Publish\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n  async publish (privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {\n    try {\n      const peerId = await createFromPrivKey(privKey.bytes)\n      await this.publisher.publishWithEOL(privKey, value, lifetime)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`)\n\n      // // Add to cache\n      const id = peerId.toB58String()\n      // @ts-ignore - parseFloat expects string\n      const ttEol = parseFloat(lifetime)\n      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl\n\n      this.cache.set(id, value, ttl)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`)\n\n      return {\n        name: id,\n        value: value\n      }\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME')\n    }\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2]\n      const result = this.cache.get(id)\n\n      if (result) {\n        return result\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options)\n\n      log(`IPNS record from ${name} was resolved correctly`)\n\n      return result\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n  async initializeKeyspace (privKey, value) { // eslint-disable-line require-await\n    return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime)\n  }\n}\n\nmodule.exports = IPNS\n"]},"metadata":{},"sourceType":"script"}