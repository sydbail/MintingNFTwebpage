{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst {\n  default: parseDuration\n} = require('parse-duration');\n\nconst crypto = require('libp2p-crypto');\n\nconst errcode = require('err-code');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n});\n\nconst {\n  OFFLINE_ERROR,\n  normalizePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  resolvePath\n} = require('./utils');\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\n\n\nmodule.exports = ({\n  ipns,\n  repo,\n  codecs,\n  peerId,\n  isOnline,\n  keychain\n}) => {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (keyName) {\n      if (keyName === 'self') {\n        return peerId.privKey;\n      }\n\n      try {\n        // We're exporting and immediately importing the key, so we can just use a throw away password\n        const pem = yield keychain.exportKey(keyName, 'temp');\n        const privateKey = yield crypto.keys.import(pem, 'temp');\n        return privateKey;\n      } catch (err) {\n        log.error(err);\n        throw errcode(err, 'ERR_CANNOT_GET_KEY');\n      }\n    });\n\n    return function lookupKey(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n\n\n  function publish(_x2) {\n    return _publish.apply(this, arguments);\n  }\n\n  function _publish() {\n    _publish = _asyncToGenerator(function* (value, options = {}) {\n      const resolve = !(options.resolve === false);\n      const lifetime = options.lifetime || '24h';\n      const key = options.key || 'self';\n\n      if (!isOnline()) {\n        throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n      } // TODO: params related logic should be in the core implementation\n      // Normalize path value\n\n\n      try {\n        value = normalizePath(value);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n\n      let pubLifetime = 0;\n\n      try {\n        pubLifetime = parseDuration(lifetime) || 0; // Calculate lifetime with nanoseconds precision\n\n        pubLifetime = parseFloat(pubLifetime.toFixed(6));\n      } catch (err) {\n        log.error(err);\n        throw err;\n      } // TODO: ttl human for cache\n\n\n      const results = yield Promise.all([// verify if the path exists, if not, an error will stop the execution\n      lookupKey(key), // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({\n        ipns,\n        repo,\n        codecs\n      }, value) : Promise.resolve()]);\n      const bytes = uint8ArrayFromString(value); // Start publishing process\n\n      const result = yield ipns.publish(results[0], bytes, pubLifetime);\n      return {\n        name: result.name,\n        value: uint8ArrayToString(result.value)\n      };\n    });\n    return _publish.apply(this, arguments);\n  }\n\n  return withTimeoutOption(publish);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-core/src/components/name/publish.js"],"names":["debug","require","default","parseDuration","crypto","errcode","fromString","uint8ArrayFromString","toString","uint8ArrayToString","log","Object","assign","error","OFFLINE_ERROR","normalizePath","withTimeoutOption","resolvePath","module","exports","ipns","repo","codecs","peerId","isOnline","keychain","lookupKey","keyName","privKey","pem","exportKey","privateKey","keys","import","err","publish","value","options","resolve","lifetime","key","Error","pubLifetime","parseFloat","toFixed","results","Promise","all","bytes","result","name"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst { default: parseDuration } = require('parse-duration')\nconst crypto = require('libp2p-crypto')\nconst errcode = require('err-code')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n})\n\nconst { OFFLINE_ERROR, normalizePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { resolvePath } = require('./utils')\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\nmodule.exports = ({ ipns, repo, codecs, peerId, isOnline, keychain }) => {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey\n    }\n\n    try {\n      // We're exporting and immediately importing the key, so we can just use a throw away password\n      const pem = await keychain.exportKey(keyName, 'temp')\n      const privateKey = await crypto.keys.import(pem, 'temp')\n      return privateKey\n    } catch (err) {\n      log.error(err)\n      throw errcode(err, 'ERR_CANNOT_GET_KEY')\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n  async function publish (value, options = {}) {\n    const resolve = !(options.resolve === false)\n    const lifetime = options.lifetime || '24h'\n    const key = options.key || 'self'\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: params related logic should be in the core implementation\n    // Normalize path value\n    try {\n      value = normalizePath(value)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    let pubLifetime = 0\n    try {\n      pubLifetime = parseDuration(lifetime) || 0\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = parseFloat(pubLifetime.toFixed(6))\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n      // verify if the path exists, if not, an error will stop the execution\n      lookupKey(key),\n      // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({ ipns, repo, codecs }, value) : Promise.resolve()\n    ])\n\n    const bytes = uint8ArrayFromString(value)\n\n    // Start publishing process\n    const result = await ipns.publish(results[0], bytes, pubLifetime)\n\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    }\n  }\n\n  return withTimeoutOption(publish)\n}\n"]},"metadata":{},"sourceType":"script"}