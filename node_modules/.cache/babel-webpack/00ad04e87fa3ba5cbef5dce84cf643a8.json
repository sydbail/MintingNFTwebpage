{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst PeerId = require('peer-id'); // @ts-ignore no types\n\n\nconst isDomain = require('is-domain-name');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst log = Object.assign(debug('ipfs:name:resolve'), {\n  error: debug('ipfs:name:resolve:error')\n});\n\nconst {\n  OFFLINE_ERROR\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\n\n\nconst appendRemainder = (result, remainder) => remainder.length > 0 ? result + '/' + remainder.join('/') : result;\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('ipfs-core-types/src/root').API[\"dns\"]} config.dns\n * @param {import('../ipns')} config.ipns\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\n\n\nmodule.exports = ({\n  dns,\n  ipns,\n  peerId,\n  isOnline,\n  options: {\n    offline\n  }\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"resolve\"]}\n   */\n  function resolve(_x) {\n    return _resolve.apply(this, arguments);\n  }\n\n  function _resolve() {\n    _resolve = _wrapAsyncGenerator(function* (name, options = {}) {\n      // eslint-disable-line require-await\n      options = mergeOptions({\n        nocache: false,\n        recursive: true\n      }, options); // TODO: params related logic should be in the core implementation\n\n      if (offline && options && options.nocache) {\n        throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n      } // Set node id as name for being resolved, if it is not received\n\n\n      if (!name) {\n        name = peerId.toB58String();\n      }\n\n      if (!name.startsWith('/ipns/')) {\n        name = `/ipns/${name}`;\n      }\n\n      const [namespace, hash, ...remainder] = name.slice(1).split('/');\n\n      try {\n        if (hash.substring(0, 1) === '1') {\n          PeerId.parse(hash);\n        } else {\n          CID.parse(hash);\n        }\n      } catch (err) {\n        // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n        if (isDomain(hash)) {\n          yield appendRemainder(yield _awaitAsyncGenerator(dns(hash, options)), remainder);\n          return;\n        }\n\n        log.error(err);\n        throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n      } // multihash is valid lets resolve with IPNS\n      // IPNS resolve needs a online daemon\n\n\n      if (!isOnline() && !offline) {\n        throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n      } // TODO: convert ipns.resolve to return an iterator\n\n\n      const value = yield _awaitAsyncGenerator(ipns.resolve(`/${namespace}/${hash}`, options));\n      yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder);\n    });\n    return _resolve.apply(this, arguments);\n  }\n\n  return withTimeoutOption(resolve);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/components/name/resolve.js"],"names":["debug","require","errcode","mergeOptions","bind","ignoreUndefined","CID","PeerId","isDomain","toString","uint8ArrayToString","log","Object","assign","error","OFFLINE_ERROR","withTimeoutOption","appendRemainder","result","remainder","length","join","module","exports","dns","ipns","peerId","isOnline","options","offline","resolve","name","nocache","recursive","Error","toB58String","startsWith","namespace","hash","slice","split","substring","parse","err","value","Uint8Array"],"mappings":"AAAA;;;;;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,eAAD,CAAP,CAAyBG,IAAzB,CAA8B;AAAEC,EAAAA,eAAe,EAAE;AAAnB,CAA9B,CAArB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAUL,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMM,MAAM,GAAGN,OAAO,CAAC,SAAD,CAAtB,C,CACA;;;AACA,MAAMO,QAAQ,GAAGP,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAM;AAAEQ,EAAAA,QAAQ,EAAEC;AAAZ,IAAmCT,OAAO,CAAC,uBAAD,CAAhD;;AAEA,MAAMU,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcb,KAAK,CAAC,mBAAD,CAAnB,EAA0C;AACpDc,EAAAA,KAAK,EAAEd,KAAK,CAAC,yBAAD;AADwC,CAA1C,CAAZ;;AAIA,MAAM;AAAEe,EAAAA;AAAF,IAAoBd,OAAO,CAAC,aAAD,CAAjC;;AACA,MAAMe,iBAAiB,GAAGf,OAAO,CAAC,yCAAD,CAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMgB,eAAe,GAAG,CAACC,MAAD,EAASC,SAAT,KACtBA,SAAS,CAACC,MAAV,GAAmB,CAAnB,GACIF,MAAM,GAAG,GAAT,GAAeC,SAAS,CAACE,IAAV,CAAe,GAAf,CADnB,GAEIH,MAHN;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,GAAF;AAAOC,EAAAA,IAAP;AAAaC,EAAAA,MAAb;AAAqBC,EAAAA,QAArB;AAA+BC,EAAAA,OAAO,EAAE;AAAEC,IAAAA;AAAF;AAAxC,CAAD,KAA2D;AAC1E;AACF;AACA;AAH4E,WAIzDC,OAJyD;AAAA;AAAA;;AAAA;AAAA,mCAI1E,WAA0BC,IAA1B,EAAgCH,OAAO,GAAG,EAA1C,EAA8C;AAAE;AAC9CA,MAAAA,OAAO,GAAGzB,YAAY,CAAC;AACrB6B,QAAAA,OAAO,EAAE,KADY;AAErBC,QAAAA,SAAS,EAAE;AAFU,OAAD,EAGnBL,OAHmB,CAAtB,CAD4C,CAM5C;;AACA,UAAIC,OAAO,IAAID,OAAX,IAAsBA,OAAO,CAACI,OAAlC,EAA2C;AACzC,cAAM9B,OAAO,CAAC,IAAIgC,KAAJ,CAAU,yCAAV,CAAD,EAAuD,yBAAvD,CAAb;AACD,OAT2C,CAW5C;;;AACA,UAAI,CAACH,IAAL,EAAW;AACTA,QAAAA,IAAI,GAAGL,MAAM,CAACS,WAAP,EAAP;AACD;;AAED,UAAI,CAACJ,IAAI,CAACK,UAAL,CAAgB,QAAhB,CAAL,EAAgC;AAC9BL,QAAAA,IAAI,GAAI,SAAQA,IAAK,EAArB;AACD;;AAED,YAAM,CAACM,SAAD,EAAYC,IAAZ,EAAkB,GAAGnB,SAArB,IAAkCY,IAAI,CAACQ,KAAL,CAAW,CAAX,EAAcC,KAAd,CAAoB,GAApB,CAAxC;;AACA,UAAI;AACF,YAAIF,IAAI,CAACG,SAAL,CAAe,CAAf,EAAkB,CAAlB,MAAyB,GAA7B,EAAkC;AAChClC,UAAAA,MAAM,CAACmC,KAAP,CAAaJ,IAAb;AACD,SAFD,MAEO;AACLhC,UAAAA,GAAG,CAACoC,KAAJ,CAAUJ,IAAV;AACD;AACF,OAND,CAME,OAAOK,GAAP,EAAY;AACZ;AACA,YAAInC,QAAQ,CAAC8B,IAAD,CAAZ,EAAoB;AAClB,gBAAMrB,eAAe,4BAAOO,GAAG,CAACc,IAAD,EAAOV,OAAP,CAAV,GAA2BT,SAA3B,CAArB;AACA;AACD;;AAEDR,QAAAA,GAAG,CAACG,KAAJ,CAAU6B,GAAV;AACA,cAAMzC,OAAO,CAAC,IAAIgC,KAAJ,CAAU,mBAAV,CAAD,EAAiC,uBAAjC,CAAb;AACD,OApC2C,CAsC5C;AACA;;;AACA,UAAI,CAACP,QAAQ,EAAT,IAAe,CAACE,OAApB,EAA6B;AAC3B,cAAM3B,OAAO,CAAC,IAAIgC,KAAJ,CAAUnB,aAAV,CAAD,EAA2B,eAA3B,CAAb;AACD,OA1C2C,CA4C5C;;;AACA,YAAM6B,KAAK,8BAASnB,IAAI,CAACK,OAAL,CAAc,IAAGO,SAAU,IAAGC,IAAK,EAAnC,EAAsCV,OAAtC,CAAT,CAAX;AACA,YAAMX,eAAe,CAAC2B,KAAK,YAAYC,UAAjB,GAA8BnC,kBAAkB,CAACkC,KAAD,CAAhD,GAA0DA,KAA3D,EAAkEzB,SAAlE,CAArB;AACD,KAnDyE;AAAA;AAAA;;AAqD1E,SAAOH,iBAAiB,CAACc,OAAD,CAAxB;AACD,CAtDD","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst { CID } = require('multiformats/cid')\nconst PeerId = require('peer-id')\n// @ts-ignore no types\nconst isDomain = require('is-domain-name')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst log = Object.assign(debug('ipfs:name:resolve'), {\n  error: debug('ipfs:name:resolve:error')\n})\n\nconst { OFFLINE_ERROR } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\nconst appendRemainder = (result, remainder) =>\n  remainder.length > 0\n    ? result + '/' + remainder.join('/')\n    : result\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('ipfs-core-types/src/root').API[\"dns\"]} config.dns\n * @param {import('../ipns')} config.ipns\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\nmodule.exports = ({ dns, ipns, peerId, isOnline, options: { offline } }) => {\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"resolve\"]}\n   */\n  async function * resolve (name, options = {}) { // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options)\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n    }\n\n    // Set node id as name for being resolved, if it is not received\n    if (!name) {\n      name = peerId.toB58String()\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = `/ipns/${name}`\n    }\n\n    const [namespace, hash, ...remainder] = name.slice(1).split('/')\n    try {\n      if (hash.substring(0, 1) === '1') {\n        PeerId.parse(hash)\n      } else {\n        CID.parse(hash)\n      }\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder)\n        return\n      }\n\n      log.error(err)\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: convert ipns.resolve to return an iterator\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options)\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder)\n  }\n\n  return withTimeoutOption(resolve)\n}\n"]},"metadata":{},"sourceType":"script"}