{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst Reason = require(\"./reason\");\n\nconst handlers = require(\"./handlers\");\n\nconst override = {\n  timeoutMessage: \"not mined within\",\n  // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: function () {\n    var _ref = _asyncToGenerator(function* (context, web3Error) {\n      const constructor = this;\n      let currentBlock = override.defaultMaxBlocks; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n      if (!handlers.ignoreTimeoutError(context, web3Error)) {\n        // We might have been routed here in web3 >= beta.34 by their own status check\n        // error. We want to extract the receipt, emit a receipt event\n        // and reject it ourselves.\n        const receipt = override.extractReceipt(web3Error.message);\n\n        if (receipt) {\n          yield handlers.receipt(context, receipt);\n          return;\n        } // This will run if there's a reason and no status field\n        // e.g: revert with reason ganache-cli --vmErrorsOnRPCResponse=true\n\n\n        const reason = yield Reason.get(context.params, constructor.web3, constructor.interfaceAdapter);\n\n        if (reason) {\n          web3Error.reason = reason;\n          web3Error.message += ` -- Reason given: ${reason}.`;\n        }\n\n        return context.promiEvent.reject(web3Error);\n      } // This will run every block from now until contract.timeoutBlocks\n\n\n      const listener = function (pollID) {\n        currentBlock++;\n\n        if (currentBlock > constructor.timeoutBlocks) {\n          clearInterval(pollID);\n          return;\n        }\n\n        constructor.interfaceAdapter.getTransactionReceipt(context.transactionHash).then(result => {\n          if (!result) return; // make sure reporter receives tx receipt promievent\n\n          handlers.receipt(context, result);\n          result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n        }).catch(err => {\n          clearInterval(pollID);\n          context.promiEvent.reject(err);\n        });\n      }; // Start polling\n\n\n      let currentPollingBlock = yield constructor.interfaceAdapter.getBlockNumber();\n      const pollID = setInterval( /*#__PURE__*/_asyncToGenerator(function* () {\n        const newBlock = yield constructor.interfaceAdapter.getBlockNumber();\n\n        if (newBlock > currentPollingBlock) {\n          currentPollingBlock = newBlock;\n          listener(pollID);\n        }\n      }), override.pollingInterval);\n    });\n\n    return function start(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }()\n};\nmodule.exports = override;","map":null,"metadata":{},"sourceType":"script"}