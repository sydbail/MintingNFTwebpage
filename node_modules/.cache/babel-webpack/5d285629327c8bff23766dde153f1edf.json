{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errCode = require('err-code');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst removeLink = require('./utils/remove-link');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst toTrail = require('./utils/to-trail');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"rm\"]}\n   */\n  function mfsRm(_x) {\n    return _mfsRm.apply(this, arguments);\n  }\n\n  function _mfsRm() {\n    _mfsRm = _asyncToGenerator(function* (paths, opts = {}) {\n      /** @type {DefaultOptions} */\n      const options = mergeOptions(defaultOptions, opts);\n\n      if (!Array.isArray(paths)) {\n        paths = [paths];\n      }\n\n      const sources = yield Promise.all(paths.map(path => toMfsPath(context, path, options)));\n\n      if (!sources.length) {\n        throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n      }\n\n      sources.forEach(source => {\n        if (source.path === '/') {\n          throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n        }\n      });\n\n      for (const source of sources) {\n        yield removePath(context, source.path, options);\n      }\n    });\n    return _mfsRm.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsRm);\n};\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\n\n\nconst removePath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (context, path, options) {\n    const mfsPath = yield toMfsPath(context, path, options);\n    const trail = yield toTrail(context, mfsPath.mfsPath);\n    const child = trail[trail.length - 1];\n    trail.pop();\n    const parent = trail[trail.length - 1];\n\n    if (!parent) {\n      throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n    }\n\n    if (child.type === 'directory' && !options.recursive) {\n      throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR');\n    }\n\n    const {\n      cid\n    } = yield removeLink(context, {\n      parentCid: parent.cid,\n      name: child.name,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold\n    });\n    parent.cid = cid; // update the tree with the new child\n\n    const newRootCid = yield updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n    yield updateMfsRoot(context, newRootCid, options);\n  });\n\n  return function removePath(_x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}