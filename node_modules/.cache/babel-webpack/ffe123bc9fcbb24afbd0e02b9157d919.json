{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shuffledSubarray = exports.subarray = void 0;\n\nconst Stream_1 = require(\"../../stream/Stream\");\n\nconst Arbitrary_1 = require(\"./definition/Arbitrary\");\n\nconst BiasedArbitraryWrapper_1 = require(\"./definition/BiasedArbitraryWrapper\");\n\nconst Shrinkable_1 = require(\"./definition/Shrinkable\");\n\nconst integer_1 = require(\"../../arbitrary/integer\");\n\nconst LazyIterableIterator_1 = require(\"../../stream/LazyIterableIterator\");\n\nclass SubarrayArbitrary extends Arbitrary_1.Arbitrary {\n  constructor(originalArray, isOrdered, minLength, maxLength) {\n    super();\n    this.originalArray = originalArray;\n    this.isOrdered = isOrdered;\n    this.minLength = minLength;\n    this.maxLength = maxLength;\n    if (minLength < 0 || minLength > originalArray.length) throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array');\n    if (maxLength < 0 || maxLength > originalArray.length) throw new Error('fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array');\n    if (minLength > maxLength) throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length');\n    this.lengthArb = integer_1.integer(minLength, maxLength);\n  }\n\n  wrapper(items, itemsLengthContext) {\n    return new Shrinkable_1.Shrinkable(items, () => this.shrinkImpl(items, itemsLengthContext).map(contextualValue => this.wrapper(contextualValue[0], contextualValue[1])));\n  }\n\n  generate(mrng) {\n    const remainingElements = this.originalArray.map((_v, idx) => idx);\n    const size = this.lengthArb.generate(mrng).value;\n    const ids = [];\n\n    for (let idx = 0; idx !== size; ++idx) {\n      const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);\n      ids.push(remainingElements[selectedIdIndex]);\n      remainingElements.splice(selectedIdIndex, 1);\n    }\n\n    if (this.isOrdered) ids.sort((a, b) => a - b);\n    return this.wrapper(ids.map(i => this.originalArray[i]), undefined);\n  }\n\n  shrinkImpl(items, itemsLengthContext) {\n    if (items.length === 0) {\n      return Stream_1.Stream.nil();\n    }\n\n    return this.lengthArb.contextualShrink(items.length, itemsLengthContext).map(contextualValue => {\n      return [items.slice(items.length - contextualValue[0]), contextualValue[1]];\n    }).join(items.length > this.minLength ? LazyIterableIterator_1.makeLazy(() => this.shrinkImpl(items.slice(1), undefined).filter(contextualValue => this.minLength <= contextualValue[0].length + 1).map(contextualValue => [[items[0]].concat(contextualValue[0]), undefined])) : Stream_1.Stream.nil());\n  }\n\n  withBias(freq) {\n    return this.minLength !== this.maxLength ? BiasedArbitraryWrapper_1.biasWrapper(freq, this, originalArbitrary => {\n      return new SubarrayArbitrary(originalArbitrary.originalArray, originalArbitrary.isOrdered, originalArbitrary.minLength, originalArbitrary.minLength + Math.floor(Math.log(originalArbitrary.maxLength - originalArbitrary.minLength) / Math.log(2)));\n    }) : this;\n  }\n\n}\n\nfunction subarray(originalArray, ...args) {\n  if (typeof args[0] === 'number' && typeof args[1] === 'number') {\n    return new SubarrayArbitrary(originalArray, true, args[0], args[1]);\n  }\n\n  const ct = args[0];\n  const minLength = ct !== undefined && ct.minLength !== undefined ? ct.minLength : 0;\n  const maxLength = ct !== undefined && ct.maxLength !== undefined ? ct.maxLength : originalArray.length;\n  return new SubarrayArbitrary(originalArray, true, minLength, maxLength);\n}\n\nexports.subarray = subarray;\n\nfunction shuffledSubarray(originalArray, ...args) {\n  if (typeof args[0] === 'number' && typeof args[1] === 'number') {\n    return new SubarrayArbitrary(originalArray, false, args[0], args[1]);\n  }\n\n  const ct = args[0];\n  const minLength = ct !== undefined && ct.minLength !== undefined ? ct.minLength : 0;\n  const maxLength = ct !== undefined && ct.maxLength !== undefined ? ct.maxLength : originalArray.length;\n  return new SubarrayArbitrary(originalArray, false, minLength, maxLength);\n}\n\nexports.shuffledSubarray = shuffledSubarray;","map":null,"metadata":{},"sourceType":"script"}