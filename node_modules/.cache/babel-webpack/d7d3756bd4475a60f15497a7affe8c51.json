{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst {\n  encodeBase32\n} = require('./utils');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:offline-datastore'), {\n  error: debug('ipfs:ipns:offline-datastore:error')\n}); // Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\n\nclass OfflineDatastore {\n  /**\n   * @param {import('ipfs-repo').IPFSRepo} repo\n   */\n  constructor(repo) {\n    this._repo = repo;\n    /** @type {any[]} */\n\n    this.stores = [];\n  }\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n\n\n  put(key, value) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (!(key instanceof Uint8Array)) {\n        throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n      }\n\n      if (!(value instanceof Uint8Array)) {\n        throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE');\n      }\n\n      let routingKey;\n\n      try {\n        routingKey = _this._routingKey(key);\n      } catch (err) {\n        log.error(err);\n        throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n      } // Marshal to libp2p record as the DHT does\n\n\n      const record = new Record(key, value);\n      return _this._repo.datastore.put(routingKey, record.serialize());\n    })();\n  }\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   */\n\n\n  get(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(key instanceof Uint8Array)) {\n        throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n      }\n\n      let routingKey;\n\n      try {\n        routingKey = _this2._routingKey(key);\n      } catch (err) {\n        log.error(err);\n        throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n      }\n\n      const res = yield _this2._repo.datastore.get(routingKey); // Unmarshal libp2p record as the DHT does\n\n      let record;\n\n      try {\n        record = Record.deserialize(res);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n\n      return record.value;\n    })();\n  }\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  _routingKey(key) {\n    return new Key('/' + encodeBase32(key), false);\n  }\n\n}\n\nexports = module.exports = OfflineDatastore;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/ipns/routing/offline-datastore.js"],"names":["Key","require","Record","encodeBase32","errcode","debug","log","Object","assign","error","OfflineDatastore","constructor","repo","_repo","stores","put","key","value","Uint8Array","Error","routingKey","_routingKey","err","record","datastore","serialize","get","res","deserialize","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst { Record } = require('libp2p-record')\nconst { encodeBase32 } = require('./utils')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:offline-datastore'), {\n  error: debug('ipfs:ipns:offline-datastore:error')\n})\n\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\nclass OfflineDatastore {\n  /**\n   * @param {import('ipfs-repo').IPFSRepo} repo\n   */\n  constructor (repo) {\n    this._repo = repo\n    /** @type {any[]} */\n    this.stores = []\n  }\n\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n  async put (key, value) { // eslint-disable-line require-await\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    if (!(value instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    // Marshal to libp2p record as the DHT does\n    const record = new Record(key, value)\n\n    return this._repo.datastore.put(routingKey, record.serialize())\n  }\n\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   */\n  async get (key) {\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    const res = await this._repo.datastore.get(routingKey)\n\n    // Unmarshal libp2p record as the DHT does\n    let record\n    try {\n      record = Record.deserialize(res)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    return record.value\n  }\n\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n  _routingKey (key) {\n    return new Key('/' + encodeBase32(key), false)\n  }\n}\n\nexports = module.exports = OfflineDatastore\n"]},"metadata":{},"sourceType":"script"}