{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:persistent-peer-store'), {\n  error: debug('libp2p:persistent-peer-store:err')\n});\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst PeerStore = require('..');\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts');\n\nconst {\n  Addresses\n} = require('./pb/address-book');\n\nconst {\n  Protocols\n} = require('./pb/proto-book');\n/**\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('../address-book.js').Address} Address\n */\n\n/**\n * @typedef {Object} PersistentPeerStoreProperties\n * @property {PeerId} peerId\n * @property {import('interface-datastore').Datastore} datastore\n *\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.\n */\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\n\n\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @class\n   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties\n   */\n  constructor({\n    peerId,\n    datastore,\n    threshold = 5\n  }) {\n    super({\n      peerId\n    });\n    /**\n     * Backend datastore used to persist data.\n     */\n\n    this._datastore = datastore;\n    /**\n     * Peers modified after the latest data persisted.\n     */\n\n    this._dirtyPeers = new Set();\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this._dirtyMetadata = new Map();\n    this.threshold = threshold;\n    this._addDirtyPeer = this._addDirtyPeer.bind(this);\n  }\n  /**\n   * Start Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      log('PeerStore is starting'); // Handlers for dirty peers\n\n      _this.on('change:protocols', _this._addDirtyPeer);\n\n      _this.on('change:multiaddrs', _this._addDirtyPeer);\n\n      _this.on('change:pubkey', _this._addDirtyPeerKey);\n\n      _this.on('change:metadata', _this._addDirtyPeerMetadata); // Load data\n\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(_this._datastore.query({\n          prefix: NAMESPACE_COMMON\n        })), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const entry = _value;\n          yield _this._processDatastoreEntry(entry);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      log('PeerStore started');\n    })();\n  }\n  /**\n   * Stop Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      log('PeerStore is stopping');\n\n      _this2.removeAllListeners();\n\n      yield _this2._commitData();\n      log('PeerStore stopped');\n    })();\n  }\n  /**\n   * Add modified peer to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeer({\n    peerId\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified peer key to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeerKey({\n    peerId\n  }) {\n    // Not add if inline key available\n    if (peerId.hasInlinePublicKey()) {\n      return;\n    }\n\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer key', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified metadata peer to the set.\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n\n\n  _addDirtyPeerMetadata({\n    peerId,\n    metadata\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty metadata peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr); // Add dirty metadata key\n\n\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set();\n    mData.add(metadata);\n\n    this._dirtyMetadata.set(peerIdstr, mData);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   *\n   * @private\n   * @returns {Promise<void>}\n   */\n\n\n  _commitData() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const commitPeers = Array.from(_this3._dirtyPeers);\n\n      if (!commitPeers.length) {\n        return;\n      } // Clear Dirty Peers set\n\n\n      _this3._dirtyPeers.clear();\n\n      log('create batch commit');\n\n      const batch = _this3._datastore.batch();\n\n      for (const peerIdStr of commitPeers) {\n        // PeerId\n        const peerId = _this3.keyBook.data.get(peerIdStr) || PeerId.createFromB58String(peerIdStr); // Address Book\n\n        _this3._batchAddressBook(peerId, batch); // Key Book\n\n\n        !peerId.hasInlinePublicKey() && _this3._batchKeyBook(peerId, batch); // Metadata Book\n\n        _this3._batchMetadataBook(peerId, batch); // Proto Book\n\n\n        _this3._batchProtoBook(peerId, batch);\n      }\n\n      yield batch.commit();\n      log('batch committed');\n    })();\n  }\n  /**\n   * Add address book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchAddressBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`);\n    const entry = this.addressBook.data.get(peerId.toB58String());\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map(address => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certifiedRecord: entry.record ? {\n          seq: entry.record.seqNumber,\n          raw: entry.record.raw\n        } : undefined\n      }).finish();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add Key book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchKeyBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`);\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = peerId.marshalPubKey();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add metadata book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchMetadataBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];\n\n    try {\n      dirtyMetada.forEach((\n      /** @type {string} */\n      dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`);\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue);\n        } else {\n          batch.delete(key);\n        }\n      });\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add proto book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchProtoBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`);\n    const protocols = this.protoBook.get(peerId);\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Protocols.encode({\n        protocols\n      }).finish();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Process datastore entry and add its data to the correct book.\n   *\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key - datastore key\n   * @param {Uint8Array} params.value - datastore value stored\n   * @returns {Promise<void>}\n   */\n\n\n  _processDatastoreEntry({\n    key,\n    value\n  }) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const keyParts = key.toString().split('/');\n        const peerId = PeerId.createFromBytes(base32.decode(keyParts[3]));\n        let decoded;\n\n        switch (keyParts[2]) {\n          case 'addrs':\n            decoded = Addresses.decode(value); // @ts-ignore protected function\n\n            _this4.addressBook._setData(peerId, {\n              addresses: decoded.addrs.map(address => ({\n                multiaddr: new Multiaddr(address.multiaddr),\n                isCertified: Boolean(address.isCertified)\n              })),\n              record: decoded.certifiedRecord ? {\n                raw: decoded.certifiedRecord.raw,\n                seqNumber: decoded.certifiedRecord.seq\n              } : undefined\n            }, {\n              emit: false\n            });\n\n            break;\n\n          case 'keys':\n            decoded = yield PeerId.createFromPubKey(value); // @ts-ignore protected function\n\n            _this4.keyBook._setData(decoded, decoded, {\n              emit: false\n            });\n\n            break;\n\n          case 'metadata':\n            _this4.metadataBook._setValue(peerId, keyParts[4], value, {\n              emit: false\n            });\n\n            break;\n\n          case 'protos':\n            decoded = Protocols.decode(value); // @ts-ignore protected function\n\n            _this4.protoBook._setData(peerId, new Set(decoded.protocols), {\n              emit: false\n            });\n\n            break;\n\n          default:\n            log('invalid data persisted for: ', key.toString());\n        }\n      } catch (err) {\n        log.error(err);\n      }\n    })();\n  }\n\n}\n\nmodule.exports = PersistentPeerStore;","map":null,"metadata":{},"sourceType":"script"}