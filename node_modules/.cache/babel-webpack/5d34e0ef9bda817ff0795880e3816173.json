{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst ipns = require('ipns');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:republisher'), {\n  error: debug('ipfs:ipns:republisher:error')\n});\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n */\n\nconst minute = 60 * 1000;\nconst hour = 60 * minute;\nconst defaultBroadcastInterval = 4 * hour;\nconst defaultRecordLifetime = 24 * hour;\n\nclass IpnsRepublisher {\n  /**\n   * @param {import('./publisher')} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('libp2p/src/keychain')} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor(publisher, datastore, peerId, keychain, options = {\n    pass: ''\n  }) {\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (_this._republishHandle) {\n        throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n      } // TODO: this handler should be isolated in another module\n\n\n      const republishHandle = {\n        /** @type {null|(() => Promise<void>)} */\n        _task: null,\n\n        /** @type {null|Promise<void>} */\n        _inflightTask: null,\n\n        /** @type {null|NodeJS.Timeout} */\n        _timeoutId: null,\n\n        /**\n         * @param {function(): number} period\n         */\n        runPeriodically: period => {\n          republishHandle._timeoutId = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n            republishHandle._timeoutId = null;\n\n            try {\n              // @ts-ignore - _task could be null\n              republishHandle._inflightTask = republishHandle._task();\n              yield republishHandle._inflightTask; // Schedule next\n\n              if (republishHandle._task) {\n                republishHandle.runPeriodically(period);\n              }\n            } catch (err) {\n              log.error(err);\n            }\n          }), period());\n        },\n        cancel: function () {\n          var _ref2 = _asyncToGenerator(function* () {\n            // do not run again\n            if (republishHandle._timeoutId != null) {\n              clearTimeout(republishHandle._timeoutId);\n            }\n\n            republishHandle._task = null; // wait for the currently in flight task to complete\n\n            yield republishHandle._inflightTask;\n          });\n\n          return function cancel() {\n            return _ref2.apply(this, arguments);\n          };\n        }()\n      };\n      const {\n        privKey\n      } = _this._peerId;\n      const {\n        pass\n      } = _this._options;\n      let firstRun = true;\n\n      republishHandle._task = () => _this._republishEntries(privKey, pass);\n\n      republishHandle.runPeriodically(() => {\n        if (firstRun) {\n          firstRun = false;\n          return _this._options.initialBroadcastInterval || minute;\n        }\n\n        return _this._options.broadcastInterval || defaultBroadcastInterval;\n      });\n      _this._republishHandle = republishHandle;\n    })();\n  }\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const republishHandle = _this2._republishHandle;\n\n      if (!republishHandle) {\n        throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n      }\n\n      _this2._republishHandle = null;\n      yield republishHandle.cancel();\n    })();\n  }\n  /**\n   * @param {PrivateKey} privateKey\n   * @param {string} pass\n   */\n\n\n  _republishEntries(privateKey, pass) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO: Should use list of published entries.\n      // We can't currently *do* that because go uses this method for now.\n      try {\n        yield _this3._republishEntry(privateKey);\n      } catch (err) {\n        const errMsg = 'cannot republish entry for the node\\'s private key';\n        log.error(errMsg);\n        return;\n      } // keychain needs pass to get the cryptographic keys\n\n\n      if (pass) {\n        try {\n          const keys = yield _this3._keychain.listKeys();\n\n          for (const key of keys) {\n            if (key.name === 'self') {\n              continue;\n            }\n\n            const pem = yield _this3._keychain.exportKey(key.name, pass);\n            const privKey = yield crypto.keys.import(pem, pass);\n            yield _this3._republishEntry(privKey);\n          }\n        } catch (err) {\n          log.error(err);\n        }\n      }\n    })();\n  }\n  /**\n   * @param {PrivateKey} privateKey\n   */\n\n\n  _republishEntry(privateKey) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!privateKey || !privateKey.bytes) {\n        throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n      }\n\n      try {\n        const peerId = yield PeerId.createFromPrivKey(privateKey.bytes);\n        const value = yield _this4._getPreviousValue(peerId);\n        yield _this4._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);\n      } catch (err) {\n        if (err.code === 'ERR_NO_ENTRY_FOUND') {\n          return;\n        }\n\n        throw err;\n      }\n    })();\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  _getPreviousValue(peerId) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!PeerId.isPeerId(peerId)) {\n        throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n      }\n\n      try {\n        const dsVal = yield _this5._datastore.get(ipns.getLocalKey(peerId.id));\n\n        if (!(dsVal instanceof Uint8Array)) {\n          throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD');\n        } // unmarshal data\n\n\n        try {\n          const record = ipns.unmarshal(dsVal);\n          return record.value;\n        } catch (err) {\n          log.error(err);\n          throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n        }\n      } catch (err) {\n        // error handling\n        // no need to republish\n        if (err && err.notFound) {\n          throw errcode(new Error(`no previous entry for record with id: ${peerId.id}`), 'ERR_NO_ENTRY_FOUND');\n        }\n\n        throw err;\n      }\n    })();\n  }\n\n}\n\nexports = module.exports = IpnsRepublisher;","map":null,"metadata":{},"sourceType":"script"}