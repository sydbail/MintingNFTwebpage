{"ast":null,"code":"var _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst toDuplex = require('./duplex');\n\nmodule.exports = transform => /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (source) {\n    const duplex = toDuplex(transform); // In a transform the sink and source are connected, an error in the sink\n    // will be thrown in the source also. Catch the sink error to avoid unhandled\n    // rejections and yield from the source.\n\n    let sinkError;\n    duplex.sink(source).catch(err => {\n      sinkError = err;\n    });\n    yield* _asyncGeneratorDelegate(_asyncIterator(duplex.source), _awaitAsyncGenerator);\n    if (sinkError) throw sinkError;\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}