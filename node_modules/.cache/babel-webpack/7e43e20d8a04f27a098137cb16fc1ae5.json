{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errCode = require('err-code');\n\nconst {\n  concat: uint8arraysConcat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString: uint8arraysFromString\n} = require('uint8arrays/from-string'); // @ts-ignore libp2p-crypto does not support types\n\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst PeerId = require('peer-id');\n\nconst varint = require('varint');\n\nconst {\n  equals: uint8arraysEquals\n} = require('uint8arrays/equals');\n\nconst {\n  codes\n} = require('../../errors');\n\nconst {\n  Envelope: Protobuf\n} = require('./envelope');\n/**\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\n\nclass Envelope {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   *\n   * @class\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload - marshaled record\n   * @param {Uint8Array} params.signature - signature of the domain string :: type hint :: payload.\n   */\n  constructor({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  }) {\n    this.peerId = peerId;\n    this.payloadType = payloadType;\n    this.payload = payload;\n    this.signature = signature; // Cache\n\n    this._marshal = undefined;\n  }\n  /**\n   * Marshal the envelope content.\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  marshal() {\n    if (this._marshal) {\n      return this._marshal;\n    }\n\n    const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);\n    this._marshal = Protobuf.encode({\n      publicKey: publicKey,\n      payloadType: this.payloadType,\n      payload: this.payload,\n      signature: this.signature\n    }).finish();\n    return this._marshal;\n  }\n  /**\n   * Verifies if the other Envelope is identical to this one.\n   *\n   * @param {Envelope} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);\n  }\n  /**\n   * Validate envelope data signature for the given domain.\n   *\n   * @param {string} domain\n   * @returns {Promise<boolean>}\n   */\n\n\n  validate(domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);\n    return this.peerId.pubKey.verify(signData, this.signature);\n  }\n\n}\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n *\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @returns {Uint8Array}\n */\n\n\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n  const domainUint8Array = uint8arraysFromString(domain);\n  const domainLength = varint.encode(domainUint8Array.byteLength);\n  const payloadTypeLength = varint.encode(payloadType.length);\n  const payloadLength = varint.encode(payload.length);\n  return uint8arraysConcat([new Uint8Array(domainLength), domainUint8Array, new Uint8Array(payloadTypeLength), payloadType, new Uint8Array(payloadLength), payload]);\n};\n/**\n * Unmarshal a serialized Envelope protobuf message.\n *\n * @param {Uint8Array} data\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.createFromProtobuf = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (data) {\n    const envelopeData = Protobuf.decode(data);\n    const peerId = yield PeerId.createFromPubKey(envelopeData.publicKey);\n    return new Envelope({\n      peerId,\n      payloadType: envelopeData.payloadType,\n      payload: envelopeData.payload,\n      signature: envelopeData.signature\n    });\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key.\n *\n * @async\n * @param {Record} record\n * @param {PeerId} peerId\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.seal = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (record, peerId) {\n    const domain = record.domain;\n    const payloadType = record.codec;\n    const payload = record.marshal();\n    const signData = formatSignaturePayload(domain, payloadType, payload);\n    const signature = yield peerId.privKey.sign(signData);\n    return new Envelope({\n      peerId,\n      payloadType,\n      payload,\n      signature\n    });\n  });\n\n  return function (_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n *\n * @param {Uint8Array} data\n * @param {string} domain\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.openAndCertify = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (data, domain) {\n    const envelope = yield Envelope.createFromProtobuf(data);\n    const valid = yield envelope.validate(domain);\n\n    if (!valid) {\n      throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID);\n    }\n\n    return envelope;\n  });\n\n  return function (_x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nmodule.exports = Envelope;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/libp2p/src/record/envelope/index.js"],"names":["errCode","require","concat","uint8arraysConcat","fromString","uint8arraysFromString","cryptoKeys","PeerId","varint","equals","uint8arraysEquals","codes","Envelope","Protobuf","constructor","peerId","payloadType","payload","signature","_marshal","undefined","marshal","publicKey","marshalPublicKey","pubKey","encode","finish","other","bytes","validate","domain","signData","formatSignaturePayload","verify","domainUint8Array","domainLength","byteLength","payloadTypeLength","length","payloadLength","Uint8Array","createFromProtobuf","data","envelopeData","decode","createFromPubKey","seal","record","codec","privKey","sign","openAndCertify","envelope","valid","Error","ERR_SIGNATURE_NOT_VALID","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { concat: uint8arraysConcat } = require('uint8arrays/concat')\nconst { fromString: uint8arraysFromString } = require('uint8arrays/from-string')\n// @ts-ignore libp2p-crypto does not support types\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst PeerId = require('peer-id')\nconst varint = require('varint')\nconst { equals: uint8arraysEquals } = require('uint8arrays/equals')\n\nconst { codes } = require('../../errors')\nconst { Envelope: Protobuf } = require('./envelope')\n\n/**\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\nclass Envelope {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   *\n   * @class\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload - marshaled record\n   * @param {Uint8Array} params.signature - signature of the domain string :: type hint :: payload.\n   */\n  constructor ({ peerId, payloadType, payload, signature }) {\n    this.peerId = peerId\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n\n    // Cache\n    this._marshal = undefined\n  }\n\n  /**\n   * Marshal the envelope content.\n   *\n   * @returns {Uint8Array}\n   */\n  marshal () {\n    if (this._marshal) {\n      return this._marshal\n    }\n\n    const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey)\n\n    this._marshal = Protobuf.encode({\n      publicKey: publicKey,\n      payloadType: this.payloadType,\n      payload: this.payload,\n      signature: this.signature\n    }).finish()\n\n    return this._marshal\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one.\n   *\n   * @param {Envelope} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) &&\n      uint8arraysEquals(this.payloadType, other.payloadType) &&\n      uint8arraysEquals(this.payload, other.payload) &&\n      uint8arraysEquals(this.signature, other.signature)\n  }\n\n  /**\n   * Validate envelope data signature for the given domain.\n   *\n   * @param {string} domain\n   * @returns {Promise<boolean>}\n   */\n  validate (domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    return this.peerId.pubKey.verify(signData, this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n *\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @returns {Uint8Array}\n */\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return uint8arraysConcat([\n    new Uint8Array(domainLength),\n    domainUint8Array,\n    new Uint8Array(payloadTypeLength),\n    payloadType,\n    new Uint8Array(payloadLength),\n    payload\n  ])\n}\n\n/**\n * Unmarshal a serialized Envelope protobuf message.\n *\n * @param {Uint8Array} data\n * @returns {Promise<Envelope>}\n */\nEnvelope.createFromProtobuf = async (data) => {\n  const envelopeData = Protobuf.decode(data)\n  const peerId = await PeerId.createFromPubKey(envelopeData.publicKey)\n\n  return new Envelope({\n    peerId,\n    payloadType: envelopeData.payloadType,\n    payload: envelopeData.payload,\n    signature: envelopeData.signature\n  })\n}\n\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key.\n *\n * @async\n * @param {Record} record\n * @param {PeerId} peerId\n * @returns {Promise<Envelope>}\n */\nEnvelope.seal = async (record, peerId) => {\n  const domain = record.domain\n  const payloadType = record.codec\n  const payload = record.marshal()\n\n  const signData = formatSignaturePayload(domain, payloadType, payload)\n  const signature = await peerId.privKey.sign(signData)\n\n  return new Envelope({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  })\n}\n\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n *\n * @param {Uint8Array} data\n * @param {string} domain\n * @returns {Promise<Envelope>}\n */\nEnvelope.openAndCertify = async (data, domain) => {\n  const envelope = await Envelope.createFromProtobuf(data)\n  const valid = await envelope.validate(domain)\n\n  if (!valid) {\n    throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID)\n  }\n\n  return envelope\n}\n\nmodule.exports = Envelope\n"]},"metadata":{},"sourceType":"script"}