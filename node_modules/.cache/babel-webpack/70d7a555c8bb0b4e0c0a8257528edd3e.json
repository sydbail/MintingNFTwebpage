{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst _get = require('just-safe-get');\n\nconst _set = require('just-safe-set');\n\nconst errCode = require('err-code');\n\nconst errors = require('./errors');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  hasWithFallback,\n  getWithFallback // @ts-ignore\n\n} = require('ipfs-repo-migrations/src/utils');\n\nconst configKey = new Key('config');\n/**\n * @typedef {import('./types').Config} Config\n */\n\n/**\n * @param {import('interface-datastore').Datastore} store\n */\n\nmodule.exports = store => {\n  const setQueue = new Queue({\n    concurrency: 1\n  });\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    getAll(options = {}) {\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n        // using IndexedDB API with string keys - only necessary until we do\n        // the migratiion to v10 or above\n        const encodedValue = yield getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store, {\n          signal: options.signal\n        });\n        return JSON.parse(uint8ArrayToString(encodedValue));\n      })();\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    get(key, options = {}) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        if (key == null) {\n          throw new errors.NotFoundError(`Key ${key} does not exist in config`);\n        }\n\n        const config = yield _this.getAll(options);\n\n        const value = _get(config, key);\n\n        if (value === undefined) {\n          throw new errors.NotFoundError(`Key ${key} does not exist in config`);\n        }\n\n        return value;\n      })();\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set(key, value, options = {}) {\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n      }\n\n      if (value === undefined || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace(value, options = {}) {\n      if (!value || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    exists() {\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n        // using IndexedDB API with string keys - only necessary until we do\n        // the migratiion to v10 or above\n        return hasWithFallback(configKey, store.has.bind(store), store);\n      })();\n    }\n\n  };\n  return configStore;\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n\n  function _maybeDoSet(_x, _x2) {\n    return _maybeDoSet2.apply(this, arguments);\n  }\n  /**\n   * @param {unknown} config\n   */\n\n\n  function _maybeDoSet2() {\n    _maybeDoSet2 = _asyncToGenerator(function* (m, signal) {\n      if (signal && signal.aborted) {\n        return;\n      }\n\n      const key = m.key;\n      const value = m.value;\n\n      if (key) {\n        const config = yield configStore.getAll();\n\n        if (typeof config === 'object' && config !== null) {\n          _set(config, key, value);\n        }\n\n        return _saveAll(config);\n      }\n\n      return _saveAll(value);\n    });\n    return _maybeDoSet2.apply(this, arguments);\n  }\n\n  function _saveAll(config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}