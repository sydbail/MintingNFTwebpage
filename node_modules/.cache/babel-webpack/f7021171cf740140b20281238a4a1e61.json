{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst IPNS = require('../ipns');\n\nconst routingConfig = require('../ipns/routing/config');\n\nconst OfflineDatastore = require('../ipns/routing/offline-datastore');\n\nconst {\n  NotInitializedError,\n  AlreadyInitializedError\n} = require('../errors');\n\nconst log = require('debug')('ipfs:components:ipns');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n *\n * @typedef {Object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {Object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {Object} DHTConfig\n * @property {boolean} [enabled]\n */\n\n\nclass IPNSAPI {\n  /**\n   * @param {Object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor(options = {\n    pass: ''\n  }) {\n    this.options = options;\n    /** @type {IPNS | null} */\n\n    this.offline = null;\n    /** @type {IPNS | null} */\n\n    this.online = null;\n  }\n\n  getIPNS() {\n    const ipns = this.online || this.offline;\n\n    if (ipns) {\n      return ipns;\n    } else {\n      throw new NotInitializedError();\n    }\n  }\n\n  get routing() {\n    return this.getIPNS().routing;\n  }\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {Object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('peer-id')} config.peerId\n   * @param {import('libp2p/src/keychain')} config.keychain\n   */\n\n\n  startOffline({\n    repo,\n    peerId,\n    keychain\n  }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError();\n    }\n\n    log('initializing IPNS keyspace');\n    const routing = new OfflineDatastore(repo);\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n    this.offline = ipns;\n  }\n  /**\n   * @param {Object} config\n   * @param {import('libp2p')} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('peer-id')} config.peerId\n   * @param {import('libp2p/src/keychain')} config.keychain\n   */\n\n\n  startOnline({\n    libp2p,\n    repo,\n    peerId,\n    keychain\n  }) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.online != null) {\n        throw new AlreadyInitializedError();\n      }\n\n      const routing = routingConfig({\n        libp2p,\n        repo,\n        peerId,\n        options: _this.options\n      }); // @ts-ignore routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n\n      const ipns = new IPNS(routing, repo.datastore, peerId, keychain, _this.options);\n      yield ipns.republisher.start();\n      _this.online = ipns;\n    })();\n  }\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const ipns = _this2.online;\n\n      if (ipns) {\n        yield ipns.republisher.stop();\n        _this2.online = null;\n      }\n    })();\n  }\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  publish(privKey, value, lifetime) {\n    return this.getIPNS().publish(privKey, value, lifetime);\n  }\n  /**\n   *\n   * @param {string} name\n   * @param {*} [options]\n   */\n\n\n  resolve(name, options) {\n    return this.getIPNS().resolve(name, options);\n  }\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n\n\n  initializeKeyspace(privKey, value) {\n    return this.getIPNS().initializeKeyspace(privKey, value);\n  }\n\n}\n\nmodule.exports = IPNSAPI;","map":null,"metadata":{},"sourceType":"script"}