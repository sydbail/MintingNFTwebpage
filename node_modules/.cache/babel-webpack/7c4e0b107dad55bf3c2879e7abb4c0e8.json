{"ast":null,"code":"'use strict';\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  exporter\n} = require('ipfs-unixfs-exporter');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst map = require('it-map');\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('ipfs-core-types/src/files').MFSEntry} MFSEntry\n */\n\n/**\n * @param {import('ipfs-unixfs-exporter').UnixFSEntry} fsEntry\n */\n\n\nconst toOutput = fsEntry => {\n  /** @type {MFSEntry} */\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: fsEntry.type === 'directory' ? 'directory' : 'file',\n    size: fsEntry.size\n  };\n\n  if (fsEntry.type === 'file' || fsEntry.type === 'directory') {\n    output.mode = fsEntry.unixfs.mode;\n    output.mtime = fsEntry.unixfs.mtime;\n  }\n\n  return output;\n};\n/**\n * @param {MfsContext} context\n */\n\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"ls\"]}\n   */\n  function mfsLs(_x) {\n    return _mfsLs.apply(this, arguments);\n  }\n\n  function _mfsLs() {\n    _mfsLs = _wrapAsyncGenerator(function* (path, options = {}) {\n      const mfsPath = yield _awaitAsyncGenerator(toMfsPath(context, path, options));\n      const fsEntry = yield _awaitAsyncGenerator(exporter(mfsPath.mfsPath, context.repo.blocks)); // directory, perhaps sharded\n\n      if (fsEntry.type === 'directory') {\n        yield* _asyncGeneratorDelegate(_asyncIterator(map(fsEntry.content(options), toOutput)), _awaitAsyncGenerator);\n        return;\n      } // single file/node\n\n\n      yield toOutput(fsEntry);\n    });\n    return _mfsLs.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsLs);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/components/files/ls.js"],"names":["exporter","require","toMfsPath","withTimeoutOption","map","toOutput","fsEntry","output","cid","name","type","size","mode","unixfs","mtime","module","exports","context","mfsLs","path","options","mfsPath","repo","blocks","content"],"mappings":"AAAA;;;;;;;;;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAeC,OAAO,CAAC,sBAAD,CAA5B;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAME,iBAAiB,GAAGF,OAAO,CAAC,yCAAD,CAAjC;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,QAAD,CAAnB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMI,QAAQ,GAAIC,OAAD,IAAa;AAC5B;AACA,QAAMC,MAAM,GAAG;AACbC,IAAAA,GAAG,EAAEF,OAAO,CAACE,GADA;AAEbC,IAAAA,IAAI,EAAEH,OAAO,CAACG,IAFD;AAGbC,IAAAA,IAAI,EAAEJ,OAAO,CAACI,IAAR,KAAiB,WAAjB,GAA+B,WAA/B,GAA6C,MAHtC;AAIbC,IAAAA,IAAI,EAAEL,OAAO,CAACK;AAJD,GAAf;;AAOA,MAAIL,OAAO,CAACI,IAAR,KAAiB,MAAjB,IAA2BJ,OAAO,CAACI,IAAR,KAAiB,WAAhD,EAA6D;AAC3DH,IAAAA,MAAM,CAACK,IAAP,GAAcN,OAAO,CAACO,MAAR,CAAeD,IAA7B;AACAL,IAAAA,MAAM,CAACO,KAAP,GAAeR,OAAO,CAACO,MAAR,CAAeC,KAA9B;AACD;;AAED,SAAOP,MAAP;AACD,CAfD;AAiBA;AACA;AACA;;;AACAQ,MAAM,CAACC,OAAP,GAAkBC,OAAD,IAAa;AAC5B;AACF;AACA;AAH8B,WAIXC,KAJW;AAAA;AAAA;;AAAA;AAAA,iCAI5B,WAAwBC,IAAxB,EAA8BC,OAAO,GAAG,EAAxC,EAA4C;AAC1C,YAAMC,OAAO,8BAASnB,SAAS,CAACe,OAAD,EAAUE,IAAV,EAAgBC,OAAhB,CAAlB,CAAb;AACA,YAAMd,OAAO,8BAASN,QAAQ,CAACqB,OAAO,CAACA,OAAT,EAAkBJ,OAAO,CAACK,IAAR,CAAaC,MAA/B,CAAjB,CAAb,CAF0C,CAI1C;;AACA,UAAIjB,OAAO,CAACI,IAAR,KAAiB,WAArB,EAAkC;AAChC,sDAAQN,GAAG,CAACE,OAAO,CAACkB,OAAR,CAAgBJ,OAAhB,CAAD,EAA2Bf,QAA3B,CAAX;AAEA;AACD,OATyC,CAW1C;;;AACA,YAAMA,QAAQ,CAACC,OAAD,CAAd;AACD,KAjB2B;AAAA;AAAA;;AAmB5B,SAAOH,iBAAiB,CAACe,KAAD,CAAxB;AACD,CApBD","sourcesContent":["'use strict'\n\nconst { exporter } = require('ipfs-unixfs-exporter')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst map = require('it-map')\n\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('ipfs-core-types/src/files').MFSEntry} MFSEntry\n */\n\n/**\n * @param {import('ipfs-unixfs-exporter').UnixFSEntry} fsEntry\n */\nconst toOutput = (fsEntry) => {\n  /** @type {MFSEntry} */\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: fsEntry.type === 'directory' ? 'directory' : 'file',\n    size: fsEntry.size\n  }\n\n  if (fsEntry.type === 'file' || fsEntry.type === 'directory') {\n    output.mode = fsEntry.unixfs.mode\n    output.mtime = fsEntry.unixfs.mtime\n  }\n\n  return output\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"ls\"]}\n   */\n  async function * mfsLs (path, options = {}) {\n    const mfsPath = await toMfsPath(context, path, options)\n    const fsEntry = await exporter(mfsPath.mfsPath, context.repo.blocks)\n\n    // directory, perhaps sharded\n    if (fsEntry.type === 'directory') {\n      yield * map(fsEntry.content(options), toOutput)\n\n      return\n    }\n\n    // single file/node\n    yield toOutput(fsEntry)\n  }\n\n  return withTimeoutOption(mfsLs)\n}\n"]},"metadata":{},"sourceType":"script"}