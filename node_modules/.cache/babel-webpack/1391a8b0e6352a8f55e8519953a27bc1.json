{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst _get = require('just-safe-get');\n\nconst debug = require('debug');\n\nconst errCode = require('err-code');\n\nconst migrator = require('ipfs-repo-migrations');\n\nconst bytes = require('bytes');\n\nconst merge = require('merge-options');\n\nconst constants = require('./constants');\n\nconst version = require('./version');\n\nconst config = require('./config');\n\nconst spec = require('./spec');\n\nconst apiAddr = require('./api-addr');\n\nconst createIdstore = require('./idstore');\n\nconst defaultOptions = require('./default-options');\n\nconst defaultDatastore = require('./default-datastore');\n\nconst ERRORS = require('./errors');\n\nconst {\n  PinManager,\n  PinTypes\n} = require('./pins');\n\nconst createPinnedBlockstore = require('./pinned-blockstore'); // @ts-ignore - no types\n\n\nconst mortice = require('mortice');\n\nconst gc = require('./gc');\n\nconst MemoryLock = require('./locks/memory');\n\nconst FSLock = require('./locks/fs');\n\nconst log = debug('ipfs:repo');\nconst noLimit = Number.MAX_SAFE_INTEGER;\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\n\nclass Repo {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  constructor(path, loadCodec, backends, options) {\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path');\n    }\n\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader');\n    }\n    /** @type {Options} */\n\n\n    this.options = merge(defaultOptions, options);\n    this.closed = true;\n    this.path = path;\n    this.root = backends.root;\n    this.datastore = backends.datastore;\n    this.keys = backends.keys;\n    const blockstore = backends.blocks;\n    const pinstore = backends.pins;\n    this.pins = new PinManager({\n      pinstore,\n      blockstore,\n      loadCodec\n    }); // this blockstore will not delete blocks that have been pinned\n\n    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore); // this blockstore will extract blocks from multihashes with the identity codec\n\n    this.blocks = createIdstore(pinnedBlockstore);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n    /** @type {GCLock} */\n\n    this.gcLock = mortice(path, {\n      singleProcess: this.options.repoOwner !== false\n    });\n    this.gc = gc({\n      gcLock: this.gcLock,\n      pins: this.pins,\n      blockstore: this.blocks,\n      root: this.root,\n      loadCodec\n    });\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  init(config) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      log('initializing at: %s', _this.path);\n      yield _this._openRoot();\n      yield _this.config.replace(buildConfig(config));\n      yield _this.spec.set(buildDatastoreSpec(config));\n      yield _this.version.set(constants.repoVersion);\n    })();\n  }\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  isInitialized() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.closed) {\n        // repo is open, must be initialized\n        return true;\n      }\n\n      try {\n        // have to open the root datastore in the browser before\n        // we can check whether it's been initialized\n        yield _this2._openRoot();\n        yield _this2._checkInitialized();\n        yield _this2.root.close();\n        return true;\n      } catch (err) {\n        // FIXME: do not use exceptions for flow control\n        return false;\n      }\n    })();\n  }\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  open() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this3.closed) {\n        throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n      }\n\n      log('opening at: %s', _this3.path); // check if the repo is already initialized\n\n      try {\n        yield _this3._openRoot();\n        yield _this3._checkInitialized();\n        _this3._lockfile = yield _this3._openLock();\n        log('acquired repo.lock');\n        const isCompatible = yield _this3.version.check(constants.repoVersion);\n\n        if (!isCompatible) {\n          if (yield _this3._isAutoMigrationEnabled()) {\n            yield _this3._migrate(constants.repoVersion, {\n              root: _this3.root,\n              datastore: _this3.datastore,\n              pins: _this3.pins.pinstore,\n              blocks: _this3.pins.blockstore,\n              keys: _this3.keys\n            });\n          } else {\n            throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n          }\n        }\n\n        log('creating datastore');\n        yield _this3.datastore.open();\n        log('creating blocks');\n\n        _this3.blocks.open();\n\n        log('creating keystore');\n        yield _this3.keys.open();\n        log('creating pins');\n        yield _this3.pins.pinstore.open();\n        _this3.closed = false;\n        log('all opened');\n      } catch (err) {\n        if (_this3._lockfile) {\n          try {\n            yield _this3._closeLock();\n            _this3._lockfile = null;\n          } catch (err2) {\n            log('error removing lock', err2);\n          }\n        }\n\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   *\n   * @private\n   */\n\n\n  _openRoot() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this4.root.open();\n      } catch (err) {\n        if (err.message !== 'Already open') {\n          throw err;\n        }\n      }\n    })();\n  }\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @private\n   * @returns {Promise<LockCloser>}\n   */\n\n\n  _openLock() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const lockfile = yield _this5.options.repoLock.lock(_this5.path);\n\n      if (typeof lockfile.close !== 'function') {\n        throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n      }\n\n      return lockfile;\n    })();\n  }\n  /**\n   * Closes the lock on the repo\n   *\n   * @private\n   */\n\n\n  _closeLock() {\n    return this._lockfile && this._lockfile.close();\n  }\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   */\n\n\n  _checkInitialized() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      log('init check');\n      let config;\n\n      try {\n        [config] = yield Promise.all([_this6.config.exists(), _this6.spec.exists(), _this6.version.exists()]);\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n            path: _this6.path\n          });\n        }\n\n        throw err;\n      }\n\n      if (!config) {\n        throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: _this6.path\n        });\n      }\n    })();\n  }\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  close() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this7.closed) {\n        throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n      }\n\n      log('closing at: %s', _this7.path);\n\n      try {\n        // Delete api, ignoring irrelevant errors\n        yield _this7.apiAddr.delete();\n      } catch (err) {\n        if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n          throw err;\n        }\n      }\n\n      yield Promise.all([_this7.root, _this7.blocks, _this7.keys, _this7.datastore, _this7.pins.pinstore].map(store => store && store.close()));\n      log('unlocking');\n      _this7.closed = true;\n      yield _this7._closeLock();\n    })();\n  }\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  exists() {\n    return this.version.exists();\n  }\n  /**\n   * Get repo status.\n   *\n   * @returns {Promise<Stat>}\n   */\n\n\n  stat() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this8.datastore && _this8.keys) {\n        const [storageMax, blocks, version, datastore, keys] = yield Promise.all([_this8._storageMaxStat(), _this8._blockStat(), _this8.version.get(), getSize(_this8.datastore), getSize(_this8.keys)]);\n        const size = blocks.size + datastore + keys;\n        return {\n          repoPath: _this8.path,\n          storageMax,\n          version: version,\n          numObjects: blocks.count,\n          repoSize: size\n        };\n      }\n\n      throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: _this8.path\n      });\n    })();\n  }\n  /**\n   * @private\n   */\n\n\n  _isAutoMigrationEnabled() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this9.options.autoMigrate !== undefined) {\n        return _this9.options.autoMigrate;\n      } // TODO we need to figure out the priority here, between repo options and config.\n\n\n      let autoMigrateConfig;\n\n      try {\n        autoMigrateConfig = yield _this9.config.get(AUTO_MIGRATE_CONFIG_KEY);\n      } catch (e) {\n        if (e.code === ERRORS.NotFoundError.code) {\n          autoMigrateConfig = true; // Config's default value is True\n        } else {\n          throw e;\n        }\n      }\n\n      return autoMigrateConfig;\n    })();\n  }\n  /**\n   * Internal migration\n   *\n   * @private\n   * @param {number} toVersion\n   * @param {Backends} backends\n   */\n\n\n  _migrate(toVersion, backends) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const currentRepoVersion = yield _this10.version.get();\n\n      if (currentRepoVersion > toVersion) {\n        log(`reverting to version ${toVersion}`);\n        return migrator.revert(_this10.path, backends, _this10.options, toVersion, {\n          ignoreLock: true,\n          onProgress: _this10.options.onMigrationProgress\n        });\n      } else {\n        log(`migrating to version ${toVersion}`);\n        return migrator.migrate(_this10.path, backends, _this10.options, toVersion, {\n          ignoreLock: true,\n          onProgress: _this10.options.onMigrationProgress\n        });\n      }\n    })();\n  }\n  /**\n   * @private\n   */\n\n\n  _storageMaxStat() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const max = yield _this11.config.get('Datastore.StorageMax');\n        return BigInt(bytes(max));\n      } catch (err) {\n        return BigInt(noLimit);\n      }\n    })();\n  }\n  /**\n   * @private\n   */\n\n\n  _blockStat() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      let count = BigInt(0);\n      let size = BigInt(0);\n\n      if (_this12.blocks) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(_this12.blocks.query({})), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const {\n              key,\n              value\n            } = _value;\n            count += BigInt(1);\n            size += BigInt(value.byteLength);\n            size += BigInt(key.bytes.byteLength);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return {\n        count,\n        size\n      };\n    })();\n  }\n\n}\n/**\n * @param {Datastore} datastore\n */\n\n\nfunction getSize(_x) {\n  return _getSize.apply(this, arguments);\n}\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\n\n\nfunction _getSize() {\n  _getSize = _asyncToGenerator(function* (datastore) {\n    let sum = BigInt(0);\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n\n    var _iteratorError2;\n\n    try {\n      for (var _iterator2 = _asyncIterator(datastore.query({})), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n        const block = _value2;\n        sum += BigInt(block.value.byteLength);\n        sum += BigInt(block.key.uint8Array().byteLength);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          yield _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return sum;\n  });\n  return _getSize.apply(this, arguments);\n}\n\nfunction createRepo(path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options);\n}\n\nmodule.exports = {\n  createRepo,\n  repoVersion: constants.repoVersion,\n  errors: ERRORS,\n  utils: {\n    blockstore: require('./utils/blockstore')\n  },\n  locks: {\n    memory: MemoryLock,\n    fs: FSLock\n  },\n  PinTypes\n};\n/**\n * @param {import('./types').Config} _config\n */\n\nfunction buildConfig(_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'));\n  return _config;\n}\n/**\n * @param {import('./types').Config} _config\n */\n\n\nfunction buildDatastoreSpec(_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  const spec = { ...defaultDatastore.Spec,\n    ..._get(_config, 'Datastore.Spec')\n  };\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(mounting => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  };\n}","map":null,"metadata":{},"sourceType":"script"}