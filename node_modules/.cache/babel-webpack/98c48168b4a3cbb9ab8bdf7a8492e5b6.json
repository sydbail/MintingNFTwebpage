{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst {\n  encodeBase32\n} = require('./utils');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:offline-datastore'), {\n  error: debug('ipfs:ipns:offline-datastore:error')\n}); // Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\n\nclass OfflineDatastore {\n  /**\n   * @param {import('ipfs-repo').IPFSRepo} repo\n   */\n  constructor(repo) {\n    this._repo = repo;\n    /** @type {any[]} */\n\n    this.stores = [];\n  }\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n\n\n  put(key, value) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (!(key instanceof Uint8Array)) {\n        throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n      }\n\n      if (!(value instanceof Uint8Array)) {\n        throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE');\n      }\n\n      let routingKey;\n\n      try {\n        routingKey = _this._routingKey(key);\n      } catch (err) {\n        log.error(err);\n        throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n      } // Marshal to libp2p record as the DHT does\n\n\n      const record = new Record(key, value);\n      return _this._repo.datastore.put(routingKey, record.serialize());\n    })();\n  }\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   */\n\n\n  get(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(key instanceof Uint8Array)) {\n        throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n      }\n\n      let routingKey;\n\n      try {\n        routingKey = _this2._routingKey(key);\n      } catch (err) {\n        log.error(err);\n        throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n      }\n\n      const res = yield _this2._repo.datastore.get(routingKey); // Unmarshal libp2p record as the DHT does\n\n      let record;\n\n      try {\n        record = Record.deserialize(res);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n\n      return record.value;\n    })();\n  }\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  _routingKey(key) {\n    return new Key('/' + encodeBase32(key), false);\n  }\n\n}\n\nexports = module.exports = OfflineDatastore;","map":null,"metadata":{},"sourceType":"script"}