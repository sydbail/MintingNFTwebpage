{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.floatNext = exports.indexToFloat = exports.floatToIndex = exports.decomposeFloat = exports.EPSILON_32 = exports.MAX_VALUE_32 = exports.MIN_VALUE_32 = void 0;\n\nconst integer_1 = require(\"../../arbitrary/integer\");\n\nexports.MIN_VALUE_32 = 2 ** -126 * 2 ** -23;\nexports.MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);\nexports.EPSILON_32 = 2 ** -23;\nconst INDEX_POSITIVE_INFINITY = 2139095040;\nconst INDEX_NEGATIVE_INFINITY = -2139095041;\n\nfunction decomposeFloat(f) {\n  const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;\n\n  for (let exponent = -126; exponent !== 128; ++exponent) {\n    const powExponent = 2 ** exponent;\n    const maxForExponent = maxSignificand * powExponent;\n\n    if (Math.abs(f) <= maxForExponent) {\n      return {\n        exponent,\n        significand: f / powExponent\n      };\n    }\n  }\n\n  return {\n    exponent: Number.NaN,\n    significand: Number.NaN\n  };\n}\n\nexports.decomposeFloat = decomposeFloat;\n\nfunction indexInFloatFromDecomp(exponent, significand) {\n  if (exponent === -126) {\n    return significand * 0x800000;\n  }\n\n  return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;\n}\n\nfunction floatToIndex(f) {\n  if (f === Number.POSITIVE_INFINITY) {\n    return INDEX_POSITIVE_INFINITY;\n  }\n\n  if (f === Number.NEGATIVE_INFINITY) {\n    return INDEX_NEGATIVE_INFINITY;\n  }\n\n  const decomp = decomposeFloat(f);\n  const exponent = decomp.exponent;\n  const significand = decomp.significand;\n\n  if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {\n    return Number.NaN;\n  }\n\n  if (f > 0 || f === 0 && 1 / f === Number.POSITIVE_INFINITY) {\n    return indexInFloatFromDecomp(exponent, significand);\n  } else {\n    return -indexInFloatFromDecomp(exponent, -significand) - 1;\n  }\n}\n\nexports.floatToIndex = floatToIndex;\n\nfunction indexToFloat(index) {\n  if (index < 0) {\n    return -indexToFloat(-index - 1);\n  }\n\n  if (index === INDEX_POSITIVE_INFINITY) {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  if (index < 0x1000000) {\n    return index * 2 ** -149;\n  }\n\n  const postIndex = index - 0x1000000;\n  const exponent = -125 + (postIndex >> 23);\n  const significand = 1 + (postIndex & 0x7fffff) / 0x800000;\n  return significand * 2 ** exponent;\n}\n\nexports.indexToFloat = indexToFloat;\n\nfunction safeFloatToIndex(f, constraintsLabel) {\n  const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';\n  const errorMessage = 'fc.floatNext constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;\n\n  if (Number.isNaN(f) || Number.isFinite(f) && (f < -exports.MAX_VALUE_32 || f > exports.MAX_VALUE_32)) {\n    throw new Error(errorMessage);\n  }\n\n  const index = floatToIndex(f);\n\n  if (!Number.isInteger(index)) {\n    throw new Error(errorMessage);\n  }\n\n  return index;\n}\n\nfunction floatNext(constraints = {}) {\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -exports.MAX_VALUE_32 : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? exports.MAX_VALUE_32 : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeFloatToIndex(min, 'min');\n  const maxIndex = safeFloatToIndex(max, 'max');\n\n  if (minIndex > maxIndex) {\n    throw new Error('fc.floatNext constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return integer_1.integer({\n      min: minIndex,\n      max: maxIndex\n    }).map(indexToFloat);\n  }\n\n  const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;\n  const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;\n  return integer_1.integer({\n    min: minIndexWithNaN,\n    max: maxIndexWithNaN\n  }).map(index => {\n    if (index > maxIndex || index < minIndex) return Number.NaN;else return indexToFloat(index);\n  });\n}\n\nexports.floatNext = floatNext;","map":null,"metadata":{},"sourceType":"script"}