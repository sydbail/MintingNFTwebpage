{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXFallbackHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n\n    this.initialMsg = initialMsg;\n  } // stage 0\n  // eslint-disable-next-line require-await\n\n\n  propose() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.isInitiator) {\n        _this.xx.sendMessage(_this.session, buffer_1.Buffer.alloc(0), _this.ephemeralKeys);\n\n        logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n        logger_1.logLocalEphemeralKeys(_this.session.hs.e);\n      } else {\n        logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n        const receivedMessageBuffer = encoder_1.decode0(_this.initialMsg);\n\n        const {\n          valid\n        } = _this.xx.recvMessage(_this.session, {\n          ne: receivedMessageBuffer.ne,\n          ns: buffer_1.Buffer.alloc(0),\n          ciphertext: buffer_1.Buffer.alloc(0)\n        });\n\n        if (!valid) {\n          throw new Error('xx fallback stage 0 decryption validation fail');\n        }\n\n        logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');\n        logger_1.logRemoteEphemeralKey(_this.session.hs.re);\n      }\n    })();\n  } // stage 1\n\n\n  exchange() {\n    var _superprop_getExchange = () => super.exchange,\n        _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isInitiator) {\n        const receivedMessageBuffer = encoder_1.decode1(_this2.initialMsg);\n\n        const {\n          plaintext,\n          valid\n        } = _this2.xx.recvMessage(_this2.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('xx fallback stage 1 decryption validation fail');\n        }\n\n        logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n        logger_1.logRemoteEphemeralKey(_this2.session.hs.re);\n        logger_1.logRemoteStaticKey(_this2.session.hs.rs);\n        logger_1.logger(\"Initiator going to check remote's signature...\");\n\n        try {\n          const decodedPayload = yield utils_1.decodePayload(plaintext);\n          _this2.remotePeer = _this2.remotePeer || (yield utils_1.getPeerIdFromPayload(decodedPayload));\n          yield utils_1.verifySignedPayload(_this2.session.hs.rs, decodedPayload, _this2.remotePeer);\n\n          _this2.setRemoteEarlyData(decodedPayload.data);\n        } catch (e) {\n          const err = e;\n          throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);\n        }\n\n        logger_1.logger('All good with the signature!');\n      } else {\n        logger_1.logger('XX Fallback Stage 1 - Responder start');\n        yield _superprop_getExchange().call(_this2);\n        logger_1.logger('XX Fallback Stage 1 - Responder end');\n      }\n    })();\n  }\n\n}\n\nexports.XXFallbackHandshake = XXFallbackHandshake; //# sourceMappingURL=handshake-xx-fallback.js.map","map":null,"metadata":{},"sourceType":"script"}