{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst keysPBM = require('./keys');\n\nrequire('node-forge/lib/asn1');\n\nrequire('node-forge/lib/pbe');\n\nconst forge = require('node-forge/lib/forge');\n\nconst errcode = require('err-code');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst importer = require('./importer');\n\nconst supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('./secp256k1-class')(keysPBM, require('../random-bytes'))\n};\nconst ErrMissingSecp256K1 = {\n  message: 'secp256k1 support requires libp2p-crypto-secp256k1 package',\n  code: 'ERR_MISSING_PACKAGE'\n};\n\nfunction typeToKey(type) {\n  const key = supportedKeys[type.toLowerCase()];\n\n  if (!key) {\n    const supported = Object.keys(supportedKeys).join(' / ');\n    throw errcode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), 'ERR_UNSUPPORTED_KEY_TYPE');\n  }\n\n  return key;\n} // Generates a keypair of the given type and bitsize\n\n\nconst generateKeyPair = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (type, bits) {\n    // eslint-disable-line require-await\n    return typeToKey(type).generateKeyPair(bits);\n  });\n\n  return function generateKeyPair(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\n\n\nconst generateKeyPairFromSeed = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (type, seed, bits) {\n    // eslint-disable-line require-await\n    const key = typeToKey(type);\n\n    if (type.toLowerCase() !== 'ed25519') {\n      throw errcode(new Error('Seed key derivation is unimplemented for RSA or secp256k1'), 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');\n    }\n\n    return key.generateKeyPairFromSeed(seed, bits);\n  });\n\n  return function generateKeyPairFromSeed(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // Converts a protobuf serialized public key into its\n// representative object\n\n\nconst unmarshalPublicKey = buf => {\n  const decoded = keysPBM.PublicKey.decode(buf);\n  const data = decoded.Data;\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);\n      }\n\n    default:\n      typeToKey(decoded.Type);\n    // throws because type is not supported\n  }\n}; // Converts a public key object into a protobuf serialized public key\n\n\nconst marshalPublicKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n}; // Converts a protobuf serialized private key into its\n// representative object\n\n\nconst unmarshalPrivateKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (buf) {\n    // eslint-disable-line require-await\n    const decoded = keysPBM.PrivateKey.decode(buf);\n    const data = decoded.Data;\n\n    switch (decoded.Type) {\n      case keysPBM.KeyType.RSA:\n        return supportedKeys.rsa.unmarshalRsaPrivateKey(data);\n\n      case keysPBM.KeyType.Ed25519:\n        return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);\n\n      case keysPBM.KeyType.Secp256k1:\n        if (supportedKeys.secp256k1) {\n          return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);\n        } else {\n          throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);\n        }\n\n      default:\n        typeToKey(decoded.Type);\n      // throws because type is not supported\n    }\n  });\n\n  return function unmarshalPrivateKey(_x6) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // Converts a private key object into a protobuf serialized private key\n\n\nconst marshalPrivateKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n};\n/**\n *\n * @param {string} encryptedKey\n * @param {string} password\n */\n\n\nconst importKey = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (encryptedKey, password) {\n    // eslint-disable-line require-await\n    try {\n      const key = yield importer.import(encryptedKey, password);\n      return unmarshalPrivateKey(key);\n    } catch (_) {// Ignore and try the old pem decrypt\n    } // Only rsa supports pem right now\n\n\n    const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);\n\n    if (key === null) {\n      throw errcode(new Error('Cannot read the key, most likely the password is wrong or not a RSA key'), 'ERR_CANNOT_DECRYPT_PEM');\n    }\n\n    let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));\n    der = uint8ArrayFromString(der.getBytes(), 'ascii');\n    return supportedKeys.rsa.unmarshalRsaPrivateKey(der);\n  });\n\n  return function importKey(_x7, _x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nmodule.exports = {\n  supportedKeys,\n  keysPBM,\n  keyStretcher: require('./key-stretcher'),\n  generateEphemeralKeyPair: require('./ephemeral-keys'),\n  generateKeyPair,\n  generateKeyPairFromSeed,\n  unmarshalPublicKey,\n  marshalPublicKey,\n  unmarshalPrivateKey,\n  marshalPrivateKey,\n  import: importKey\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-crypto/src/keys/index.js"],"names":["keysPBM","require","forge","errcode","fromString","uint8ArrayFromString","importer","supportedKeys","rsa","ed25519","secp256k1","ErrMissingSecp256K1","message","code","typeToKey","type","key","toLowerCase","supported","Object","keys","join","Error","generateKeyPair","bits","generateKeyPairFromSeed","seed","unmarshalPublicKey","buf","decoded","PublicKey","decode","data","Data","Type","KeyType","RSA","unmarshalRsaPublicKey","Ed25519","unmarshalEd25519PublicKey","Secp256k1","unmarshalSecp256k1PublicKey","marshalPublicKey","bytes","unmarshalPrivateKey","PrivateKey","unmarshalRsaPrivateKey","unmarshalEd25519PrivateKey","unmarshalSecp256k1PrivateKey","marshalPrivateKey","importKey","encryptedKey","password","import","_","pki","decryptRsaPrivateKey","der","asn1","toDer","privateKeyToAsn1","getBytes","module","exports","keyStretcher","generateEphemeralKeyPair"],"mappings":"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","sourcesContent":["'use strict'\n\nconst keysPBM = require('./keys')\nrequire('node-forge/lib/asn1')\nrequire('node-forge/lib/pbe')\nconst forge = require('node-forge/lib/forge')\nconst errcode = require('err-code')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\nconst importer = require('./importer')\n\nconst supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('./secp256k1-class')(keysPBM, require('../random-bytes'))\n}\n\nconst ErrMissingSecp256K1 = {\n  message: 'secp256k1 support requires libp2p-crypto-secp256k1 package',\n  code: 'ERR_MISSING_PACKAGE'\n}\n\nfunction typeToKey (type) {\n  const key = supportedKeys[type.toLowerCase()]\n  if (!key) {\n    const supported = Object.keys(supportedKeys).join(' / ')\n    throw errcode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), 'ERR_UNSUPPORTED_KEY_TYPE')\n  }\n  return key\n}\n\n// Generates a keypair of the given type and bitsize\nconst generateKeyPair = async (type, bits) => { // eslint-disable-line require-await\n  return typeToKey(type).generateKeyPair(bits)\n}\n\n// Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\nconst generateKeyPairFromSeed = async (type, seed, bits) => { // eslint-disable-line require-await\n  const key = typeToKey(type)\n  if (type.toLowerCase() !== 'ed25519') {\n    throw errcode(new Error('Seed key derivation is unimplemented for RSA or secp256k1'), 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE')\n  }\n  return key.generateKeyPairFromSeed(seed, bits)\n}\n\n// Converts a protobuf serialized public key into its\n// representative object\nconst unmarshalPublicKey = (buf) => {\n  const decoded = keysPBM.PublicKey.decode(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code)\n      }\n    default:\n      typeToKey(decoded.Type) // throws because type is not supported\n  }\n}\n\n// Converts a public key object into a protobuf serialized public key\nconst marshalPublicKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n// Converts a protobuf serialized private key into its\n// representative object\nconst unmarshalPrivateKey = async (buf) => { // eslint-disable-line require-await\n  const decoded = keysPBM.PrivateKey.decode(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data)\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code)\n      }\n    default:\n      typeToKey(decoded.Type) // throws because type is not supported\n  }\n}\n\n// Converts a private key object into a protobuf serialized private key\nconst marshalPrivateKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n/**\n *\n * @param {string} encryptedKey\n * @param {string} password\n */\nconst importKey = async (encryptedKey, password) => { // eslint-disable-line require-await\n  try {\n    const key = await importer.import(encryptedKey, password)\n    return unmarshalPrivateKey(key)\n  } catch (_) {\n    // Ignore and try the old pem decrypt\n  }\n\n  // Only rsa supports pem right now\n  const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password)\n  if (key === null) {\n    throw errcode(new Error('Cannot read the key, most likely the password is wrong or not a RSA key'), 'ERR_CANNOT_DECRYPT_PEM')\n  }\n  let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))\n  der = uint8ArrayFromString(der.getBytes(), 'ascii')\n  return supportedKeys.rsa.unmarshalRsaPrivateKey(der)\n}\n\nmodule.exports = {\n  supportedKeys,\n  keysPBM,\n  keyStretcher: require('./key-stretcher'),\n  generateEphemeralKeyPair: require('./ephemeral-keys'),\n  generateKeyPair,\n  generateKeyPairFromSeed,\n  unmarshalPublicKey,\n  marshalPublicKey,\n  unmarshalPrivateKey,\n  marshalPrivateKey,\n  import: importKey\n}\n"]},"metadata":{},"sourceType":"script"}