{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n});\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst errCode = require('err-code');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerRouting = require('./peer-routing');\n\nconst ContentRouting = require('./content-routing');\n\nconst getPeer = require('./get-peer');\n\nconst {\n  validate: validateConfig\n} = require('./config');\n\nconst {\n  codes,\n  messages\n} = require('./errors');\n\nconst AddressManager = require('./address-manager');\n\nconst ConnectionManager = require('./connection-manager');\n\nconst Circuit = require('./circuit/transport');\n\nconst Relay = require('./circuit');\n\nconst Dialer = require('./dialer');\n\nconst Keychain = require('./keychain');\n\nconst Metrics = require('./metrics');\n\nconst TransportManager = require('./transport-manager');\n\nconst Upgrader = require('./upgrader');\n\nconst PeerStore = require('./peer-store');\n\nconst PubsubAdapter = require('./pubsub-adapter');\n\nconst PersistentPeerStore = require('./peer-store/persistent');\n\nconst Registrar = require('./registrar');\n\nconst ping = require('./ping');\n\nconst IdentifyService = require('./identify');\n\nconst NatManager = require('./nat-manager');\n\nconst {\n  updateSelfPeerRecord\n} = require('./record/utils');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} RandomWalkOptions\n * @property {boolean} [enabled = false]\n * @property {number} [queriesPerPeriod = 1]\n * @property {number} [interval = 300e3]\n * @property {number} [timeout = 10e3]\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {RandomWalkOptions} [randomWalk]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions & import('./peer-store/persistent').PersistentPeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nclass Libp2p extends EventEmitter {\n  /**\n   * Like `new Libp2p(options)` except it will create a `PeerId`\n   * instance if one is not provided in options.\n   *\n   * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n   * @returns {Promise<Libp2p>}\n   */\n  static create(options) {\n    return _asyncToGenerator(function* () {\n      if (options.peerId) {\n        // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n        return new Libp2p(options);\n      }\n\n      const peerId = yield PeerId.create();\n      options.peerId = peerId; // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n\n      return new Libp2p(options);\n    })();\n  }\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n\n\n  constructor(_options) {\n    super(); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    this._options = validateConfig(_options);\n    /** @type {PeerId} */\n\n    this.peerId = this._options.peerId;\n    this.datastore = this._options.datastore;\n    this.peerStore = this.datastore && this._options.peerStore.persistence ? new PersistentPeerStore({\n      peerId: this.peerId,\n      datastore: this.datastore,\n      ...this._options.peerStore\n    }) : new PeerStore({\n      peerId: this.peerId\n    }); // Addresses {listen, announce, noAnnounce}\n\n    this.addresses = this._options.addresses;\n    this.addressManager = new AddressManager(this.peerId, this._options.addresses); // when addresses change, update our peer record\n\n    this.addressManager.on('change:addresses', () => {\n      updateSelfPeerRecord(this).catch(err => {\n        log.error('Error updating self peer record', err);\n      });\n    });\n    this._modules = this._options.modules;\n    this._config = this._options.config;\n    this._transport = []; // Transport instances/references\n\n    this._discovery = new Map(); // Discovery service instances/references\n    // Create the Connection Manager\n\n    this.connectionManager = new ConnectionManager(this, {\n      autoDial: this._config.peerDiscovery.autoDial,\n      ...this._options.connectionManager\n    }); // Create Metrics\n\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({ ...this._options.metrics,\n        connectionManager: this.connectionManager\n      });\n    } // Create keychain\n\n\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain');\n      const keychainOpts = Keychain.generateOptions();\n      this.keychain = new Keychain(this._options.keychain.datastore, { ...keychainOpts,\n        ...this._options.keychain\n      });\n      log('keychain constructed');\n    } // Setup the Upgrader\n\n\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: connection => this.connectionManager.onConnect(connection),\n      onConnectionEnd: connection => this.connectionManager.onDisconnect(connection)\n    }); // Setup the transport manager\n\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    }); // Create the Nat Manager\n\n    this.natManager = new NatManager({\n      peerId: this.peerId,\n      addressManager: this.addressManager,\n      transportManager: this.transportManager,\n      // @ts-ignore Nat typedef is not understood as Object\n      ...this._options.config.nat\n    }); // Create the Registrar\n\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    });\n    this.handle = this.handle.bind(this);\n    this.registrar.handle = this.handle; // Attach crypto channels\n\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);\n    }\n\n    const cryptos = this._modules.connEncryption;\n    cryptos.forEach(crypto => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto);\n    });\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      ...this._options.dialer\n    });\n\n    this._modules.transport.forEach(Transport => {\n      const key = Transport.prototype[Symbol.toStringTag];\n      const transportOptions = this._config.transport[key];\n      this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n      this.relay = new Relay(this);\n    } // Attach stream multiplexers\n\n\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer;\n      muxers.forEach(muxer => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      this.identifyService = new IdentifyService({\n        libp2p: this\n      });\n      this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (this._modules.dht) {\n      const DHT = this._modules.dht; // @ts-ignore Object is not constructable\n\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      });\n    } // Create pubsub if provided\n\n\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub; // using pubsub adapter with *DEPRECATED* handlers functionality\n\n      /** @type {Pubsub} */\n\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    this.peerRouting = new PeerRouting(this);\n    this.contentRouting = new ContentRouting(this); // Mount default protocols\n\n    ping.mount(this);\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n\n\n  emit(eventName, ...args) {\n    // TODO: do we still need this?\n    // @ts-ignore _events does not exist in libp2p\n    if (eventName === 'error' && !this._events.error) {\n      log.error(args);\n      return false;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      log('libp2p is starting');\n\n      try {\n        yield _this._onStarting();\n        yield _this._onDidStart();\n        log('libp2p has started');\n      } catch (err) {\n        _this.emit('error', err);\n\n        log.error('An error occurred starting libp2p', err);\n        yield _this.stop();\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      log('libp2p is stopping');\n\n      try {\n        _this2._isStarted = false;\n        _this2.relay && _this2.relay.stop();\n\n        _this2.peerRouting.stop();\n\n        for (const service of _this2._discovery.values()) {\n          service.removeListener('peer', _this2._onDiscoveryPeer);\n        }\n\n        yield Promise.all(Array.from(_this2._discovery.values(), s => s.stop()));\n        _this2._discovery = new Map();\n        yield _this2.peerStore.stop();\n        yield _this2.connectionManager.stop();\n        yield Promise.all([_this2.pubsub && _this2.pubsub.stop(), _this2._dht && _this2._dht.stop(), _this2.metrics && _this2.metrics.stop()]);\n        yield _this2.natManager.stop();\n        yield _this2.transportManager.close();\n        ping.unmount(_this2);\n\n        _this2.dialer.destroy();\n      } catch (err) {\n        if (err) {\n          log.error(err);\n\n          _this2.emit('error', err);\n        }\n      }\n\n      log('libp2p has stopped');\n    })();\n  }\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  loadKeychain() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this3.keychain) {\n        return;\n      }\n\n      try {\n        yield _this3.keychain.findKeyByName('self');\n      } catch (err) {\n        yield _this3.keychain.importPeer('self', _this3.peerId);\n      }\n    })();\n  }\n\n  isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   *\n   * @returns {Map<string, Connection[]>}\n   */\n\n\n  get connections() {\n    return this.connectionManager.connections;\n  }\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(peer, options) {\n    return this._dial(peer, options);\n  }\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  dialProtocol(peer, protocols, options) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!protocols || !protocols.length) {\n        throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n      }\n\n      const connection = yield _this4._dial(peer, options);\n      return connection.newStream(protocols);\n    })();\n  }\n  /**\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @returns {Promise<Connection>}\n   */\n\n\n  _dial(peer, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        id,\n        multiaddrs\n      } = getPeer(peer);\n\n      if (id.equals(_this5.peerId)) {\n        throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF);\n      }\n\n      let connection = _this5.connectionManager.get(id);\n\n      if (!connection) {\n        connection = yield _this5.dialer.connectToPeer(peer, options);\n      } else if (multiaddrs) {\n        _this5.peerStore.addressBook.add(id, multiaddrs);\n      }\n\n      return connection;\n    })();\n  }\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  get multiaddrs() {\n    let addrs = this.addressManager.getAnnounceAddrs().map(ma => ma.toString());\n\n    if (!addrs.length) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.transportManager.getAddrs().map(ma => ma.toString());\n    }\n\n    addrs = addrs.concat(this.addressManager.getObservedAddrs().map(ma => ma.toString()));\n    const announceFilter = this._options.addresses.announceFilter; // dedupe multiaddrs\n\n    const addrSet = new Set(addrs); // Create advertising list\n\n    return announceFilter(Array.from(addrSet).map(str => new Multiaddr(str)));\n  }\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n   * @returns {Promise<void>}\n   */\n\n\n  hangUp(peer) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        id\n      } = getPeer(peer);\n\n      const connections = _this6.connectionManager.connections.get(id.toB58String());\n\n      if (!connections) {\n        return;\n      }\n\n      yield Promise.all(connections.map(connection => {\n        return connection.close();\n      }));\n    })();\n  }\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to ping\n   * @returns {Promise<number>}\n   */\n\n\n  ping(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer); // If received multiaddr, ping it\n\n    if (multiaddrs) {\n      return ping(this, multiaddrs[0]);\n    }\n\n    return ping(this, id);\n  }\n  /**\n   * Registers the `handler` for each protocol\n   *\n   * @param {string[]|string} protocols\n   * @param {(props: HandlerProps) => void} handler\n   */\n\n\n  handle(protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler);\n    }); // Add new protocols to self protocols in the Protobook\n\n    this.peerStore.protoBook.add(this.peerId, protocols);\n  }\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @param {string[]|string} protocols\n   */\n\n\n  unhandle(protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol);\n    }); // Remove protocols from self protocols in the Protobook\n\n    this.peerStore.protoBook.remove(this.peerId, protocols);\n  }\n\n  _onStarting() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      // Listen on the provided transports for the provided addresses\n      const addrs = _this7.addressManager.getListenAddrs();\n\n      yield _this7.transportManager.listen(addrs); // Manage your NATs\n\n      _this7.natManager.start(); // Start PeerStore\n\n\n      yield _this7.peerStore.start();\n\n      if (_this7._config.pubsub.enabled) {\n        _this7.pubsub && _this7.pubsub.start();\n      } // DHT subsystem\n\n\n      if (_this7._config.dht.enabled) {\n        _this7._dht && _this7._dht.start(); // TODO: this should be modified once random-walk is used as\n        // the other discovery modules\n\n        _this7._dht.on('peer', _this7._onDiscoveryPeer);\n      } // Start metrics if present\n\n\n      _this7.metrics && _this7.metrics.start();\n    })();\n  }\n  /**\n   * Called when libp2p has started and before it returns\n   *\n   * @private\n   */\n\n\n  _onDidStart() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      _this8._isStarted = true;\n\n      _this8.peerStore.on('peer', peerId => {\n        _this8.emit('peer:discovery', peerId);\n\n        _this8._maybeConnect(peerId);\n      }); // Once we start, emit any peers we may have already discovered\n      // TODO: this should be removed, as we already discovered these peers in the past\n\n\n      for (const peer of _this8.peerStore.peers.values()) {\n        _this8.emit('peer:discovery', peer.id);\n      }\n\n      _this8.connectionManager.start(); // Peer discovery\n\n\n      yield _this8._setupPeerDiscovery(); // Relay\n\n      _this8.relay && _this8.relay.start();\n\n      _this8.peerRouting.start();\n    })();\n  }\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   *\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n   */\n\n\n  _onDiscoveryPeer(peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);\n  }\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   *\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _maybeConnect(peerId) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      // If auto dialing is on and we have no connection to the peer, check if we should dial\n      if (_this9._config.peerDiscovery.autoDial === true && !_this9.connectionManager.get(peerId)) {\n        const minConnections = _this9._options.connectionManager.minConnections || 0;\n\n        if (minConnections > _this9.connectionManager.size) {\n          log('connecting to discovered peer %s', peerId.toB58String());\n\n          try {\n            yield _this9.dialer.connectToPeer(peerId);\n          } catch (err) {\n            log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`);\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n\n\n  _setupPeerDiscovery() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      /**\n       * @param {PeerDiscoveryFactory} DiscoveryService\n       */\n      const setupService = DiscoveryService => {\n        let config = {\n          enabled: true // on by default\n\n        };\n\n        if (DiscoveryService.tag && _this10._config.peerDiscovery && _this10._config.peerDiscovery[DiscoveryService.tag]) {\n          // @ts-ignore PeerDiscovery not understood as an Object for spread\n          config = { ...config,\n            ..._this10._config.peerDiscovery[DiscoveryService.tag]\n          };\n        }\n\n        if (config.enabled && !_this10._discovery.has(DiscoveryService.tag)) {\n          // not already added\n          let discoveryService;\n\n          if (typeof DiscoveryService === 'function') {\n            // @ts-ignore DiscoveryService has no constructor type inferred\n            discoveryService = new DiscoveryService(Object.assign({}, config, {\n              peerId: _this10.peerId,\n              libp2p: _this10\n            }));\n          } else {\n            discoveryService = DiscoveryService;\n          }\n\n          discoveryService.on('peer', _this10._onDiscoveryPeer);\n\n          _this10._discovery.set(DiscoveryService.tag, discoveryService);\n        }\n      }; // Discovery modules\n\n\n      for (const DiscoveryService of _this10._modules.peerDiscovery || []) {\n        setupService(DiscoveryService);\n      } // Transport modules with discovery\n\n\n      for (const Transport of _this10.transportManager.getTransports()) {\n        // @ts-ignore Transport interface does not include discovery\n        if (Transport.discovery) {\n          // @ts-ignore Transport interface does not include discovery\n          setupService(Transport.discovery);\n        }\n      }\n\n      yield Promise.all(Array.from(_this10._discovery.values(), d => d.start()));\n    })();\n  }\n\n}\n\nmodule.exports = Libp2p;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p/src/index.js"],"names":["debug","require","log","Object","assign","error","EventEmitter","errCode","PeerId","Multiaddr","PeerRouting","ContentRouting","getPeer","validate","validateConfig","codes","messages","AddressManager","ConnectionManager","Circuit","Relay","Dialer","Keychain","Metrics","TransportManager","Upgrader","PeerStore","PubsubAdapter","PersistentPeerStore","Registrar","ping","IdentifyService","NatManager","updateSelfPeerRecord","Libp2p","create","options","peerId","constructor","_options","datastore","peerStore","persistence","addresses","addressManager","on","catch","err","_modules","modules","_config","config","_transport","_discovery","Map","connectionManager","autoDial","peerDiscovery","metrics","enabled","keychain","keychainOpts","generateOptions","upgrader","localPeer","onConnection","connection","onConnect","onConnectionEnd","onDisconnect","transportManager","libp2p","faultTolerance","natManager","nat","registrar","handle","bind","connEncryption","length","Error","CONN_ENCRYPTION_REQUIRED","cryptos","forEach","crypto","set","protocol","dialer","transport","Transport","key","prototype","Symbol","toStringTag","transportOptions","add","relay","streamMuxer","muxers","muxer","multicodec","identifyService","values","getProtocolStr","handleMessage","connProtector","protector","globalThis","process","undefined","env","LIBP2P_FORCE_PNET","dht","DHT","_dht","pubsub","Pubsub","peerRouting","contentRouting","mount","_onDiscoveryPeer","emit","eventName","args","_events","start","_onStarting","_onDidStart","stop","_isStarted","service","removeListener","Promise","all","Array","from","s","close","unmount","destroy","loadKeychain","findKeyByName","importPeer","isStarted","connections","dial","peer","_dial","dialProtocol","protocols","ERR_INVALID_PROTOCOLS_FOR_STREAM","newStream","id","multiaddrs","equals","ERR_DIALED_SELF","get","connectToPeer","addressBook","addrs","getAnnounceAddrs","map","ma","toString","getAddrs","concat","getObservedAddrs","announceFilter","addrSet","Set","str","hangUp","toB58String","handler","isArray","protoBook","unhandle","delete","remove","getListenAddrs","listen","_maybeConnect","peers","_setupPeerDiscovery","ERR_DISCOVERED_SELF","minConnections","size","setupService","DiscoveryService","tag","has","discoveryService","getTransports","discovery","d","module","exports"],"mappings":"AAAA;;;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,QAAD,CAAnB,EAA+B;AACzCK,EAAAA,KAAK,EAAEL,KAAK,CAAC,YAAD;AAD6B,CAA/B,CAAZ;;AAGA,MAAM;AAAEM,EAAAA;AAAF,IAAmBL,OAAO,CAAC,QAAD,CAAhC;;AAEA,MAAMM,OAAO,GAAGN,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMO,MAAM,GAAGP,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAM;AAAEQ,EAAAA;AAAF,IAAgBR,OAAO,CAAC,WAAD,CAA7B;;AAEA,MAAMS,WAAW,GAAGT,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMU,cAAc,GAAGV,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMW,OAAO,GAAGX,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAM;AAAEY,EAAAA,QAAQ,EAAEC;AAAZ,IAA+Bb,OAAO,CAAC,UAAD,CAA5C;;AACA,MAAM;AAAEc,EAAAA,KAAF;AAASC,EAAAA;AAAT,IAAsBf,OAAO,CAAC,UAAD,CAAnC;;AAEA,MAAMgB,cAAc,GAAGhB,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMiB,iBAAiB,GAAGjB,OAAO,CAAC,sBAAD,CAAjC;;AACA,MAAMkB,OAAO,GAAGlB,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMmB,KAAK,GAAGnB,OAAO,CAAC,WAAD,CAArB;;AACA,MAAMoB,MAAM,GAAGpB,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMqB,QAAQ,GAAGrB,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMsB,OAAO,GAAGtB,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMuB,gBAAgB,GAAGvB,OAAO,CAAC,qBAAD,CAAhC;;AACA,MAAMwB,QAAQ,GAAGxB,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMyB,SAAS,GAAGzB,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAM0B,aAAa,GAAG1B,OAAO,CAAC,kBAAD,CAA7B;;AACA,MAAM2B,mBAAmB,GAAG3B,OAAO,CAAC,yBAAD,CAAnC;;AACA,MAAM4B,SAAS,GAAG5B,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAM6B,IAAI,GAAG7B,OAAO,CAAC,QAAD,CAApB;;AACA,MAAM8B,eAAe,GAAG9B,OAAO,CAAC,YAAD,CAA/B;;AACA,MAAM+B,UAAU,GAAG/B,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAM;AAAEgC,EAAAA;AAAF,IAA2BhC,OAAO,CAAC,gBAAD,CAAxC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMiC,MAAN,SAAqB5B,YAArB,CAAkC;AAChC;AACF;AACA;AACA;AACA;AACA;AACA;AACqB,SAAN6B,MAAM,CAAEC,OAAF,EAAW;AAAA;AAC5B,UAAIA,OAAO,CAACC,MAAZ,EAAoB;AAClB;AACA,eAAO,IAAIH,MAAJ,CAAWE,OAAX,CAAP;AACD;;AAED,YAAMC,MAAM,SAAS7B,MAAM,CAAC2B,MAAP,EAArB;AAEAC,MAAAA,OAAO,CAACC,MAAR,GAAiBA,MAAjB,CAR4B,CAS5B;;AACA,aAAO,IAAIH,MAAJ,CAAWE,OAAX,CAAP;AAV4B;AAW7B;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,WAAW,CAAEC,QAAF,EAAY;AACrB,YADqB,CAErB;AACA;;AACA,SAAKA,QAAL,GAAgBzB,cAAc,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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n})\nconst { EventEmitter } = require('events')\n\nconst errCode = require('err-code')\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\n\nconst PeerRouting = require('./peer-routing')\nconst ContentRouting = require('./content-routing')\nconst getPeer = require('./get-peer')\nconst { validate: validateConfig } = require('./config')\nconst { codes, messages } = require('./errors')\n\nconst AddressManager = require('./address-manager')\nconst ConnectionManager = require('./connection-manager')\nconst Circuit = require('./circuit/transport')\nconst Relay = require('./circuit')\nconst Dialer = require('./dialer')\nconst Keychain = require('./keychain')\nconst Metrics = require('./metrics')\nconst TransportManager = require('./transport-manager')\nconst Upgrader = require('./upgrader')\nconst PeerStore = require('./peer-store')\nconst PubsubAdapter = require('./pubsub-adapter')\nconst PersistentPeerStore = require('./peer-store/persistent')\nconst Registrar = require('./registrar')\nconst ping = require('./ping')\nconst IdentifyService = require('./identify')\nconst NatManager = require('./nat-manager')\nconst { updateSelfPeerRecord } = require('./record/utils')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} RandomWalkOptions\n * @property {boolean} [enabled = false]\n * @property {number} [queriesPerPeriod = 1]\n * @property {number} [interval = 300e3]\n * @property {number} [timeout = 10e3]\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {RandomWalkOptions} [randomWalk]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions & import('./peer-store/persistent').PersistentPeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\nclass Libp2p extends EventEmitter {\n  /**\n   * Like `new Libp2p(options)` except it will create a `PeerId`\n   * instance if one is not provided in options.\n   *\n   * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n   * @returns {Promise<Libp2p>}\n   */\n  static async create (options) {\n    if (options.peerId) {\n      // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n      return new Libp2p(options)\n    }\n\n    const peerId = await PeerId.create()\n\n    options.peerId = peerId\n    // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n    return new Libp2p(options)\n  }\n\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    /** @type {PeerId} */\n    this.peerId = this._options.peerId\n    this.datastore = this._options.datastore\n\n    this.peerStore = (this.datastore && this._options.peerStore.persistence)\n      ? new PersistentPeerStore({\n        peerId: this.peerId,\n        datastore: this.datastore,\n        ...this._options.peerStore\n      })\n      : new PeerStore({ peerId: this.peerId })\n\n    // Addresses {listen, announce, noAnnounce}\n    this.addresses = this._options.addresses\n    this.addressManager = new AddressManager(this.peerId, this._options.addresses)\n\n    // when addresses change, update our peer record\n    this.addressManager.on('change:addresses', () => {\n      updateSelfPeerRecord(this).catch(err => {\n        log.error('Error updating self peer record', err)\n      })\n    })\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = new Map() // Discovery service instances/references\n\n    // Create the Connection Manager\n    this.connectionManager = new ConnectionManager(this, {\n      autoDial: this._config.peerDiscovery.autoDial,\n      ...this._options.connectionManager\n    })\n\n    // Create Metrics\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({\n        ...this._options.metrics,\n        connectionManager: this.connectionManager\n      })\n    }\n\n    // Create keychain\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain')\n\n      const keychainOpts = Keychain.generateOptions()\n\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        ...keychainOpts,\n        ...this._options.keychain\n      })\n\n      log('keychain constructed')\n    }\n\n    // Setup the Upgrader\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: (connection) => this.connectionManager.onConnect(connection),\n      onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)\n    })\n\n    // Setup the transport manager\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    })\n\n    // Create the Nat Manager\n    this.natManager = new NatManager({\n      peerId: this.peerId,\n      addressManager: this.addressManager,\n      transportManager: this.transportManager,\n      // @ts-ignore Nat typedef is not understood as Object\n      ...this._options.config.nat\n    })\n\n    // Create the Registrar\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    })\n\n    this.handle = this.handle.bind(this)\n    this.registrar.handle = this.handle\n\n    // Attach crypto channels\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED)\n    }\n    const cryptos = this._modules.connEncryption\n    cryptos.forEach((crypto) => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto)\n    })\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      ...this._options.dialer\n    })\n\n    this._modules.transport.forEach((Transport) => {\n      const key = Transport.prototype[Symbol.toStringTag]\n      const transportOptions = this._config.transport[key]\n      this.transportManager.add(key, Transport, transportOptions)\n    })\n\n    if (this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit)\n      this.relay = new Relay(this)\n    }\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer)\n      })\n\n      // Add the identify service since we can multiplex\n      this.identifyService = new IdentifyService({ libp2p: this })\n      this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage)\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) { // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._modules.dht) {\n      const DHT = this._modules.dht\n      // @ts-ignore Object is not constructable\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      })\n    }\n\n    // Create pubsub if provided\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub\n      // using pubsub adapter with *DEPRECATED* handlers functionality\n      /** @type {Pubsub} */\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = new PeerRouting(this)\n    this.contentRouting = new ContentRouting(this)\n\n    // Mount default protocols\n    ping.mount(this)\n\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this)\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n  emit (eventName, ...args) {\n    // TODO: do we still need this?\n    // @ts-ignore _events does not exist in libp2p\n    if (eventName === 'error' && !this._events.error) {\n      log.error(args)\n      return false\n    } else {\n      return super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('libp2p is starting')\n\n    try {\n      await this._onStarting()\n      await this._onDidStart()\n      log('libp2p has started')\n    } catch (err) {\n      this.emit('error', err)\n      log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n  async stop () {\n    log('libp2p is stopping')\n\n    try {\n      this._isStarted = false\n\n      this.relay && this.relay.stop()\n      this.peerRouting.stop()\n\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer)\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()))\n\n      this._discovery = new Map()\n\n      await this.peerStore.stop()\n      await this.connectionManager.stop()\n\n      await Promise.all([\n        this.pubsub && this.pubsub.stop(),\n        this._dht && this._dht.stop(),\n        this.metrics && this.metrics.stop()\n      ])\n\n      await this.natManager.stop()\n      await this.transportManager.close()\n\n      ping.unmount(this)\n      this.dialer.destroy()\n    } catch (err) {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n    }\n    log('libp2p has stopped')\n  }\n\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n  async loadKeychain () {\n    if (!this.keychain) {\n      return\n    }\n\n    try {\n      await this.keychain.findKeyByName('self')\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId)\n    }\n  }\n\n  isStarted () {\n    return this._isStarted\n  }\n\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   *\n   * @returns {Map<string, Connection[]>}\n   */\n  get connections () {\n    return this.connectionManager.connections\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  dial (peer, options) {\n    return this._dial(peer, options)\n  }\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async dialProtocol (peer, protocols, options) {\n    if (!protocols || !protocols.length) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    const connection = await this._dial(peer, options)\n    return connection.newStream(protocols)\n  }\n\n  /**\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @returns {Promise<Connection>}\n   */\n  async _dial (peer, options) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (id.equals(this.peerId)) {\n      throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF)\n    }\n\n    let connection = this.connectionManager.get(id)\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options)\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    return connection\n  }\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @returns {Multiaddr[]}\n   */\n  get multiaddrs () {\n    let addrs = this.addressManager.getAnnounceAddrs().map(ma => ma.toString())\n\n    if (!addrs.length) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.transportManager.getAddrs().map(ma => ma.toString())\n    }\n\n    addrs = addrs.concat(this.addressManager.getObservedAddrs().map(ma => ma.toString()))\n\n    const announceFilter = this._options.addresses.announceFilter\n\n    // dedupe multiaddrs\n    const addrSet = new Set(addrs)\n\n    // Create advertising list\n    return announceFilter(Array.from(addrSet).map(str => new Multiaddr(str)))\n  }\n\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n   * @returns {Promise<void>}\n   */\n  async hangUp (peer) {\n    const { id } = getPeer(peer)\n\n    const connections = this.connectionManager.connections.get(id.toB58String())\n\n    if (!connections) {\n      return\n    }\n\n    await Promise.all(\n      connections.map(connection => {\n        return connection.close()\n      })\n    )\n  }\n\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to ping\n   * @returns {Promise<number>}\n   */\n  ping (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    // If received multiaddr, ping it\n    if (multiaddrs) {\n      return ping(this, multiaddrs[0])\n    }\n\n    return ping(this, id)\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   *\n   * @param {string[]|string} protocols\n   * @param {(props: HandlerProps) => void} handler\n   */\n  handle (protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler)\n    })\n\n    // Add new protocols to self protocols in the Protobook\n    this.peerStore.protoBook.add(this.peerId, protocols)\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @param {string[]|string} protocols\n   */\n  unhandle (protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol)\n    })\n\n    // Remove protocols from self protocols in the Protobook\n    this.peerStore.protoBook.remove(this.peerId, protocols)\n  }\n\n  async _onStarting () {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.addressManager.getListenAddrs()\n    await this.transportManager.listen(addrs)\n\n    // Manage your NATs\n    this.natManager.start()\n\n    // Start PeerStore\n    await this.peerStore.start()\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start()\n    }\n\n    // DHT subsystem\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start()\n\n      // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n      this._dht.on('peer', this._onDiscoveryPeer)\n    }\n\n    // Start metrics if present\n    this.metrics && this.metrics.start()\n  }\n\n  /**\n   * Called when libp2p has started and before it returns\n   *\n   * @private\n   */\n  async _onDidStart () {\n    this._isStarted = true\n\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId)\n      this._maybeConnect(peerId)\n    })\n\n    // Once we start, emit any peers we may have already discovered\n    // TODO: this should be removed, as we already discovered these peers in the past\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id)\n    }\n\n    this.connectionManager.start()\n\n    // Peer discovery\n    await this._setupPeerDiscovery()\n\n    // Relay\n    this.relay && this.relay.start()\n\n    this.peerRouting.start()\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   *\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n   */\n  _onDiscoveryPeer (peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs)\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols)\n  }\n\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   *\n   * @private\n   * @param {PeerId} peerId\n   */\n  async _maybeConnect (peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minConnections = this._options.connectionManager.minConnections || 0\n      if (minConnections > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String())\n        try {\n          await this.dialer.connectToPeer(peerId)\n        } catch (err) {\n          log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`)\n        }\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n  async _setupPeerDiscovery () {\n    /**\n     * @param {PeerDiscoveryFactory} DiscoveryService\n     */\n    const setupService = (DiscoveryService) => {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        // @ts-ignore PeerDiscovery not understood as an Object for spread\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled &&\n        !this._discovery.has(DiscoveryService.tag)) { // not already added\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          // @ts-ignore DiscoveryService has no constructor type inferred\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer)\n        this._discovery.set(DiscoveryService.tag, discoveryService)\n      }\n    }\n\n    // Discovery modules\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService)\n    }\n\n    // Transport modules with discovery\n    for (const Transport of this.transportManager.getTransports()) {\n      // @ts-ignore Transport interface does not include discovery\n      if (Transport.discovery) {\n        // @ts-ignore Transport interface does not include discovery\n        setupService(Transport.discovery)\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()))\n  }\n}\n\nmodule.exports = Libp2p\n"]},"metadata":{},"sourceType":"script"}