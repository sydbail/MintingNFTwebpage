{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} = require('./content-routing/utils');\n\nconst merge = require('it-merge');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst first = require('it-first');\n\nconst drain = require('it-drain');\n\nconst filter = require('it-filter');\n\nconst {\n  setDelayedInterval,\n  clearDelayedInterval // @ts-ignore module with no types\n\n} = require('set-delayed-interval');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor(libp2p) {\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    /** @type {PeerRoutingModule[]} */\n\n    this._routers = libp2p._modules.peerRouting || []; // If we have the dht, add it to the available peer routers\n\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(libp2p._dht);\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);\n  }\n  /**\n   * Start peer routing service.\n   */\n\n\n  start() {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return;\n    }\n\n    this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);\n  }\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n\n\n  _findClosestPeersTask() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // nb getClosestPeers adds the addresses to the address book\n        yield drain(_this2.getClosestPeers(_this2._peerId.id));\n      } catch (err) {\n        log.error(err);\n      }\n    })();\n  }\n  /**\n   * Stop peer routing service.\n   */\n\n\n  stop() {\n    clearDelayedInterval(this._timeoutId);\n  }\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  findPeer(id, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (!_this3._routers.length) {\n        throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      if (id.toB58String() === _this3._peerId.toB58String()) {\n        throw errCode(new Error('Should not try to find self'), 'ERR_FIND_SELF');\n      }\n\n      const output = yield pipe(merge(..._this3._routers.map(router => [router.findPeer(id, options)])), source => filter(source, Boolean), // @ts-ignore findPeer resolves a Promise\n      source => storeAddresses(source, _this3._peerStore), source => first(source));\n\n      if (output) {\n        return output;\n      }\n\n      throw errCode(new Error('not found'), 'NOT_FOUND');\n    })();\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  getClosestPeers(key, options = {\n    timeout: 30e3\n  }) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      if (!_this._routers.length) {\n        throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      yield* _asyncGeneratorDelegate(_asyncIterator(pipe(merge(..._this._routers.map(router => router.getClosestPeers(key, options))), source => storeAddresses(source, _this._peerStore), source => uniquePeers(source), source => requirePeers(source))), _awaitAsyncGenerator);\n    })();\n  }\n\n}\n\nmodule.exports = PeerRouting;","map":null,"metadata":{},"sourceType":"script"}