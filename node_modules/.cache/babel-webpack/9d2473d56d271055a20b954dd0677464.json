{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst log = require('debug')('ipfs:repo:gc');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst parallelBatch = require('it-parallel-batch');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst merge = require('it-merge');\n\nconst map = require('it-map');\n\nconst filter = require('it-filter');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst walkDag = require('./utils/walk-dag'); // Limit on the number of parallel block remove operations\n\n\nconst BLOCK_RM_CONCURRENCY = 256;\nconst MFS_ROOT_KEY = new Key('/local/filesroot');\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\nmodule.exports = ({\n  gcLock,\n  pins,\n  blockstore,\n  root,\n  loadCodec\n}) => {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  function gc() {\n    return _gc.apply(this, arguments);\n  }\n\n  function _gc() {\n    _gc = _wrapAsyncGenerator(function* () {\n      const start = Date.now();\n      log('Creating set of marked blocks');\n      const release = yield _awaitAsyncGenerator(gcLock.writeLock());\n\n      try {\n        // Mark all blocks that are being used\n        const markedSet = yield _awaitAsyncGenerator(createMarkedSet({\n          pins,\n          blockstore,\n          root,\n          loadCodec\n        })); // Get all blocks keys from the blockstore\n\n        const blockKeys = blockstore.queryKeys({}); // Delete blocks that are not being used\n        // @ts-ignore ts cannot tell that we filter out null results\n\n        yield* _asyncGeneratorDelegate(_asyncIterator(deleteUnmarkedBlocks({\n          blockstore\n        }, markedSet, blockKeys)), _awaitAsyncGenerator);\n        log(`Complete (${Date.now() - start}ms)`);\n      } finally {\n        release();\n      }\n    });\n    return _gc.apply(this, arguments);\n  }\n\n  return gc;\n};\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\n\nfunction createMarkedSet(_x4) {\n  return _createMarkedSet.apply(this, arguments);\n}\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\n\n\nfunction _createMarkedSet() {\n  _createMarkedSet = _asyncToGenerator(function* ({\n    pins,\n    blockstore,\n    loadCodec,\n    root\n  }) {\n    const mfsSource = _wrapAsyncGenerator(function* () {\n      let mh;\n\n      try {\n        mh = yield _awaitAsyncGenerator(root.get(MFS_ROOT_KEY));\n      } catch (err) {\n        if (err.code === ERR_NOT_FOUND) {\n          log('No blocks in MFS');\n          return;\n        }\n\n        throw err;\n      }\n\n      const rootCid = CID.decode(mh);\n      yield rootCid;\n      yield* _asyncGeneratorDelegate(_asyncIterator(walkDag(rootCid, blockstore, loadCodec)), _awaitAsyncGenerator);\n    })();\n\n    const pinsSource = merge(map(pins.recursiveKeys(), ({\n      cid\n    }) => cid), pins.indirectKeys(), map(pins.directKeys(), ({\n      cid\n    }) => cid), mfsSource);\n    const output = new Set();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(merge(pinsSource, mfsSource)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const cid = _value;\n        output.add(base32.encode(cid.multihash.bytes));\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return output;\n  });\n  return _createMarkedSet.apply(this, arguments);\n}\n\nfunction deleteUnmarkedBlocks(_x, _x2, _x3) {\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}\n\nfunction _deleteUnmarkedBlocks() {\n  _deleteUnmarkedBlocks = _wrapAsyncGenerator(function* ({\n    blockstore\n  }, markedSet, blockKeys) {\n    // Iterate through all blocks and find those that are not in the marked set\n    // blockKeys yields { key: Key() }\n    let blocksCount = 0;\n    let removedBlocksCount = 0;\n    /**\n     * @param {CID} cid\n     */\n\n    const removeBlock = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (cid) {\n        return /*#__PURE__*/function () {\n          var _remove = _asyncToGenerator(function* () {\n            blocksCount++;\n\n            try {\n              const b32 = base32.encode(cid.multihash.bytes);\n\n              if (markedSet.has(b32)) {\n                return null;\n              }\n\n              try {\n                yield blockstore.delete(cid);\n                removedBlocksCount++;\n              } catch (err) {\n                return {\n                  err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n                };\n              }\n\n              return {\n                cid\n              };\n            } catch (err) {\n              const msg = `Could delete block with CID ${cid}`;\n              log(msg, err);\n              return {\n                err: new Error(msg + `: ${err.message}`)\n              };\n            }\n          });\n\n          function remove() {\n            return _remove.apply(this, arguments);\n          }\n\n          return remove;\n        }();\n      });\n\n      return function removeBlock(_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    yield* _asyncGeneratorDelegate(_asyncIterator(pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), // filter nulls (blocks that were retained)\n    source => filter(source, Boolean))), _awaitAsyncGenerator);\n    log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n  });\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-repo/src/gc.js"],"names":["CID","require","log","Errors","ERR_NOT_FOUND","notFoundError","code","parallelBatch","pipe","merge","map","filter","Key","base32","walkDag","BLOCK_RM_CONCURRENCY","MFS_ROOT_KEY","module","exports","gcLock","pins","blockstore","root","loadCodec","gc","start","Date","now","release","writeLock","markedSet","createMarkedSet","blockKeys","queryKeys","deleteUnmarkedBlocks","mfsSource","mh","get","err","rootCid","decode","pinsSource","recursiveKeys","cid","indirectKeys","directKeys","output","Set","add","encode","multihash","bytes","blocksCount","removedBlocksCount","removeBlock","b32","has","delete","Error","message","msg","remove","source","Boolean","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst log = require('debug')('ipfs:repo:gc')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst parallelBatch = require('it-parallel-batch')\nconst { pipe } = require('it-pipe')\nconst merge = require('it-merge')\nconst map = require('it-map')\nconst filter = require('it-filter')\nconst { Key } = require('interface-datastore')\nconst { base32 } = require('multiformats/bases/base32')\nconst walkDag = require('./utils/walk-dag')\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\nconst MFS_ROOT_KEY = new Key('/local/filesroot')\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nmodule.exports = ({ gcLock, pins, blockstore, root, loadCodec }) => {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function * gc () {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec })\n      // Get all blocks keys from the blockstore\n      const blockKeys = blockstore.queryKeys({})\n\n      // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n      yield * deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  }\n\n  return gc\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nasync function createMarkedSet ({ pins, blockstore, loadCodec, root }) {\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await root.get(MFS_ROOT_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n\n      throw err\n    }\n\n    const rootCid = CID.decode(mh)\n    yield rootCid\n    yield * walkDag(rootCid, blockstore, loadCodec)\n  })()\n\n  const pinsSource = merge(\n    map(pins.recursiveKeys(), ({ cid }) => cid),\n    pins.indirectKeys(),\n    map(pins.directKeys(), ({ cid }) => cid),\n    mfsSource\n  )\n\n  const output = new Set()\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes))\n  }\n\n  return output\n}\n\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nasync function * deleteUnmarkedBlocks ({ blockstore }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  /**\n   * @param {CID} cid\n   */\n  const removeBlock = async (cid) => {\n    return async function remove () {\n      blocksCount++\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes)\n\n        if (markedSet.has(b32)) {\n          return null\n        }\n\n        try {\n          await blockstore.delete(cid)\n          removedBlocksCount++\n        } catch (err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          }\n        }\n\n        return { cid }\n      } catch (err) {\n        const msg = `Could delete block with CID ${cid}`\n        log(msg, err)\n        return { err: new Error(msg + `: ${err.message}`) }\n      }\n    }\n  }\n\n  yield * pipe(\n    parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n    // filter nulls (blocks that were retained)\n    source => filter(source, Boolean)\n  )\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"]},"metadata":{},"sourceType":"script"}