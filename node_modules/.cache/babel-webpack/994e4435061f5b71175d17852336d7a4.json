{"ast":null,"code":"'use strict';\n\nconst get = require('dlv');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst errCode = require('err-code');\n\nconst PubsubRouters = require('../runtime/libp2p-pubsub-routers-nodejs'); // @ts-ignore - no types\n\n\nconst DelegatedPeerRouter = require('libp2p-delegated-peer-routing'); // @ts-ignore - no types\n\n\nconst DelegatedContentRouter = require('libp2p-delegated-content-routing');\n\nconst {\n  create: ipfsHttpClient\n} = require('ipfs-http-client');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst pkgversion = require('../../package.json').version;\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p')} LibP2P\n * @typedef {import('libp2p').Libp2pOptions & import('libp2p').CreateOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n */\n\n/**\n * @param {Object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\n\n\nmodule.exports = ({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) => {\n  const {\n    datastore,\n    keys\n  } = repo;\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keys,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  });\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({\n      libp2pOptions,\n      options,\n      config,\n      datastore,\n      peerId\n    });\n  } // Required inline to reduce startup time\n\n\n  const Libp2p = require('libp2p');\n\n  return Libp2p.create(libp2pOptions);\n};\n/**\n * @param {Object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {Repo['keys']} input.keys\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\n\n\nfunction getLibp2pOptions({\n  options,\n  config,\n  datastore,\n  keys,\n  keychainConfig,\n  peerId,\n  multiaddrs\n}) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub'; // @ts-ignore - `router` value is not constrained\n\n    if (!PubsubRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED');\n    } // @ts-ignore - `router` value is not constrained\n\n\n    return PubsubRouters[router];\n  };\n\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId,\n    modules: {}\n  };\n  const libp2pOptions = {\n    /**\n     * @type {Partial<Libp2pOptions[\"modules\"]>}\n     */\n    modules: {\n      pubsub: getPubsubRouter(),\n      contentRouting: [],\n      peerRouting: []\n    },\n    config: {\n      peerDiscovery: {\n        mdns: {\n          enabled: get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))\n        },\n        webRTCStar: {\n          enabled: get(options, 'config.Discovery.webRTCStar.Enabled', get(config, 'Discovery.webRTCStar.Enabled', true))\n        },\n        bootstrap: {\n          list: get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n        }\n      },\n      relay: {\n        enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n        hop: {\n          enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n          active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n        }\n      },\n      dht: {\n        enabled: get(config, 'Routing.Type', 'none') !== 'none',\n        clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n        kBucketSize: get(options, 'dht.kBucketSize', 20)\n      },\n      pubsub: {\n        enabled: get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))\n      },\n      nat: {\n        enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n      }\n    },\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: {\n      datastore: keys,\n      ...keychainConfig\n    },\n    host: {\n      agentVersion: `js-ipfs/${pkgversion}`\n    }\n  }; // Required inline to reduce startup time\n  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified\n\n  const getEnvLibp2pOptions = require('../runtime/libp2p-nodejs');\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n\n\n  let constructorOptions = get(options, 'libp2p', undefined);\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined;\n  } // Merge defaults with Node.js/browser/other environments options and configuration\n\n\n  const libp2pConfig = mergeOptions(libp2pDefaults, getEnvLibp2pOptions(), libp2pOptions, constructorOptions);\n  const bootstrapList = get(libp2pConfig, 'config.peerDiscovery.bootstrap.list', []);\n\n  if (bootstrapList.length > 0) {\n    libp2pConfig.modules.peerDiscovery.push(require('libp2p-bootstrap'));\n  } // Set up Delegate Routing based on the presence of Delegates in the config\n\n\n  const delegateHosts = get(options, 'config.Addresses.Delegates', get(config, 'Addresses.Delegates', []));\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];\n    const delegateAddr = new Multiaddr(delegateString).toOptions();\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-ignore - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    };\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions);\n    libp2pOptions.modules.contentRouting = libp2pOptions.modules.contentRouting || [];\n    libp2pOptions.modules.contentRouting.push(new DelegatedContentRouter(peerId, delegateHttpClient));\n    libp2pOptions.modules.peerRouting = libp2pOptions.modules.peerRouting || [];\n    libp2pOptions.modules.peerRouting.push(new DelegatedPeerRouter(delegateHttpClient));\n  }\n\n  return libp2pConfig;\n}","map":null,"metadata":{},"sourceType":"script"}