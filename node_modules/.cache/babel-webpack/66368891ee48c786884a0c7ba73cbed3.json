{"ast":null,"code":"/* eslint-disable no-unreachable */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst isIpfs = require('is-ipfs');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Key = require('interface-datastore').Key;\n\nconst errCode = require('err-code');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst dagPb = require('@ipld/dag-pb');\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\n\nconst normalizePath = pathStr => {\n  if (pathStr instanceof CID) {\n    return `/ipfs/${pathStr}`;\n  }\n\n  try {\n    CID.parse(pathStr);\n    pathStr = `/ipfs/${pathStr}`;\n  } catch {}\n\n  if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n\n/**\n * @param {Uint8Array|CID|string} path\n * @returns {string}\n */\n\n\nconst normalizeCidPath = path => {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString();\n  }\n\n  if (path instanceof CID) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\n\n\nconst resolvePath = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (repo, codecs, ipfsPath, options = {}) {\n    const {\n      cid,\n      path\n    } = toCidAndPath(ipfsPath);\n\n    if (path) {\n      options.path = path;\n    }\n\n    let lastCid = cid;\n    let lastRemainderPath = options.path || '';\n\n    if (lastRemainderPath.startsWith('/')) {\n      lastRemainderPath = lastRemainderPath.substring(1);\n    }\n\n    if (options.path) {\n      try {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(resolve(cid, options.path, codecs, repo, {\n            signal: options.signal\n          })), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const {\n              value,\n              remainderPath\n            } = _value;\n\n            if (!(value instanceof CID)) {\n              break;\n            }\n\n            lastRemainderPath = remainderPath;\n            lastCid = value;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } catch (err) {\n        // TODO: add error codes to IPLD\n        if (err.message.startsWith('Object has no property')) {\n          err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`;\n          err.code = 'ERR_NO_LINK';\n        }\n\n        throw err;\n      }\n    }\n\n    return {\n      cid: lastCid,\n      remainderPath: lastRemainderPath || ''\n    };\n  });\n\n  return function resolvePath(_x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\n\n\nconst mapFile = file => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(`Unknown node type '${file.type}'`);\n  }\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n\n\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  };\n\n  if (file.type === 'directory') {\n    // @ts-ignore - TS type can't be changed from File to Directory\n    output.type = 'dir';\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize();\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode;\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime;\n    }\n  }\n\n  return output;\n};\n\nconst withTimeout = withTimeoutOption(\n/*#__PURE__*/\n\n/**\n * @template T\n * @param {Promise<T>|T} promise\n * @param {AbortOptions} [_options]\n * @returns {Promise<T>}\n */\nfunction () {\n  var _ref3 = _asyncToGenerator(function* (promise, _options) {\n    return yield promise;\n  });\n\n  return function (_x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}());\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\n\nconst resolve = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (cid, path, codecs, repo, options) {\n    /**\n     * @param {CID} cid\n     */\n    const load = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (cid) {\n        const codec = yield codecs.getCodec(cid.code);\n        const block = yield repo.blocks.get(cid, options);\n        return codec.decode(block);\n      });\n\n      return function load(_x11) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n\n    const parts = path.split('/').filter(Boolean);\n    let value = yield _awaitAsyncGenerator(load(cid));\n    let lastCid = cid;\n\n    if (!parts.length) {\n      yield {\n        value,\n        remainderPath: ''\n      };\n    } // End iteration if there isn't a CID to follow any more\n\n\n    while (parts.length) {\n      const key = parts.shift();\n\n      if (!key) {\n        throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH');\n      } // special case for dag-pb, use the link name as the path segment\n\n\n      if (cid.code === dagPb.code && Array.isArray(value.Links)) {\n        const link = value.Links.find((\n        /** @type {PBLink} */\n        l) => l.Name === key);\n\n        if (link) {\n          yield {\n            value: link.Hash,\n            remainderPath: parts.join('/')\n          };\n          value = yield _awaitAsyncGenerator(load(link.Hash));\n          lastCid = link.Hash;\n          continue;\n        }\n      }\n\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        value = value[key];\n        yield {\n          value,\n          remainderPath: parts.join('/')\n        };\n      } else {\n        throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK');\n      }\n\n      if (value instanceof CID) {\n        lastCid = value;\n        value = yield _awaitAsyncGenerator(load(value));\n      }\n    }\n  });\n\n  return function resolve(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = {\n  normalizePath,\n  normalizeCidPath,\n  resolvePath,\n  mapFile,\n  withTimeout,\n  resolve,\n  OFFLINE_ERROR: 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.',\n  MFS_ROOT_KEY: new Key('/local/filesroot'),\n  MFS_MAX_CHUNK_SIZE: 262144,\n  MFS_MAX_LINKS: 174\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/utils.js"],"names":["isIpfs","require","CID","Key","errCode","withTimeoutOption","toCidAndPath","dagPb","ERR_BAD_PATH","normalizePath","pathStr","parse","path","Error","normalizeCidPath","Uint8Array","decode","toString","indexOf","substring","length","charAt","resolvePath","repo","codecs","ipfsPath","options","cid","lastCid","lastRemainderPath","startsWith","resolve","signal","value","remainderPath","err","message","split","code","mapFile","file","type","output","name","size","unixfs","fileSize","mode","mtime","undefined","withTimeout","promise","_options","load","codec","getCodec","block","blocks","get","parts","filter","Boolean","key","shift","Array","isArray","Links","link","find","l","Name","Hash","join","Object","prototype","hasOwnProperty","call","module","exports","OFFLINE_ERROR","MFS_ROOT_KEY","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS"],"mappings":"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","sourcesContent":["/* eslint-disable no-unreachable */\n'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst { CID } = require('multiformats/cid')\nconst Key = require('interface-datastore').Key\nconst errCode = require('err-code')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path')\nconst dagPb = require('@ipld/dag-pb')\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\nconst normalizePath = (pathStr) => {\n  if (pathStr instanceof CID) {\n    return `/ipfs/${pathStr}`\n  }\n\n  try {\n    CID.parse(pathStr)\n    pathStr = `/ipfs/${pathStr}`\n  } catch {}\n\n  if (isIpfs.path(pathStr)) {\n    return pathStr\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH)\n  }\n}\n\n// TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n/**\n * @param {Uint8Array|CID|string} path\n * @returns {string}\n */\nconst normalizeCidPath = (path) => {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString()\n  }\n  if (path instanceof CID) {\n    return path.toString()\n  }\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\nconst resolvePath = async function (repo, codecs, ipfsPath, options = {}) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (path) {\n    options.path = path\n  }\n\n  let lastCid = cid\n  let lastRemainderPath = options.path || ''\n\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1)\n  }\n\n  if (options.path) {\n    try {\n      for await (const { value, remainderPath } of resolve(cid, options.path, codecs, repo, {\n        signal: options.signal\n      })) {\n        if (!(value instanceof CID)) {\n          break\n        }\n\n        lastRemainderPath = remainderPath\n        lastCid = value\n      }\n    } catch (err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`\n        err.code = 'ERR_NO_LINK'\n      }\n      throw err\n    }\n  }\n\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  }\n}\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\nconst mapFile = (file) => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(`Unknown node type '${file.type}'`)\n  }\n\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  }\n\n  if (file.type === 'directory') {\n    // @ts-ignore - TS type can't be changed from File to Directory\n    output.type = 'dir'\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize()\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime\n    }\n  }\n\n  return output\n}\n\nconst withTimeout = withTimeoutOption(\n  /**\n   * @template T\n   * @param {Promise<T>|T} promise\n   * @param {AbortOptions} [_options]\n   * @returns {Promise<T>}\n   */\n  async (promise, _options) => await promise\n)\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\nconst resolve = async function * (cid, path, codecs, repo, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await repo.blocks.get(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  if (!parts.length) {\n    yield {\n      value,\n      remainderPath: ''\n    }\n  }\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    // special case for dag-pb, use the link name as the path segment\n    if (cid.code === dagPb.code && Array.isArray(value.Links)) {\n      const link = value.Links.find((/** @type {PBLink} */ l) => l.Name === key)\n\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        }\n\n        value = await load(link.Hash)\n        lastCid = link.Hash\n\n        continue\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    if (value instanceof CID) {\n      lastCid = value\n      value = await load(value)\n    }\n  }\n}\n\nmodule.exports = {\n  normalizePath,\n  normalizeCidPath,\n  resolvePath,\n  mapFile,\n  withTimeout,\n  resolve,\n\n  OFFLINE_ERROR: 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.',\n  MFS_ROOT_KEY: new Key('/local/filesroot'),\n  MFS_MAX_CHUNK_SIZE: 262144,\n  MFS_MAX_LINKS: 174\n}\n"]},"metadata":{},"sourceType":"script"}