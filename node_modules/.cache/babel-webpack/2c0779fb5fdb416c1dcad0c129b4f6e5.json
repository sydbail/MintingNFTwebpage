{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = debug('dns-over-http-resolver');\nlog.error = debug('dns-over-http-resolver:error');\n\nconst Receptacle = require('receptacle');\n\nconst utils = require('./utils');\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\n\n\nlet Resolver = /*#__PURE__*/(() => {\n  class Resolver {\n    /**\n     * @class\n     * @param {object} [properties]\n     * @param {number} [properties.maxCache = 100] - maximum number of cached dns records.\n     */\n    constructor({\n      maxCache = 100\n    } = {}) {\n      this._cache = new Receptacle({\n        max: maxCache\n      });\n      this._servers = ['https://cloudflare-dns.com/dns-query', 'https://dns.google/resolve'];\n    }\n    /**\n     * Get an array of the IP addresses currently configured for DNS resolution.\n     * These addresses are formatted according to RFC 5952. It can include a custom port.\n     *\n     * @returns {Array<string>}\n     */\n\n\n    getServers() {\n      return this._servers;\n    }\n    /**\n     * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n     * These addresses are formatted according to RFC 5952. It can include a custom port.\n     *\n     * @returns {Array<string>}\n     */\n\n\n    _getShuffledServers() {\n      const newServers = [].concat(this._servers);\n\n      for (let i = newServers.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * i);\n        const temp = newServers[i];\n        newServers[i] = newServers[j];\n        newServers[j] = temp;\n      }\n\n      return newServers;\n    }\n    /**\n     * Sets the IP address and port of servers to be used when performing DNS resolution.\n     *\n     * @param {Array<string>} servers - array of RFC 5952 formatted addresses.\n     */\n\n\n    setServers(servers) {\n      this._servers = servers;\n    }\n    /**\n     * Uses the DNS protocol to resolve the given host name into the appropriate DNS record.\n     *\n     * @param {string} hostname - host name to resolve.\n     * @param {string} [rrType = 'A'] - resource record type.\n     * @returns {Promise<*>}\n     */\n\n\n    resolve(hostname, rrType = 'A') {\n      switch (rrType) {\n        case 'A':\n          return this.resolve4(hostname);\n\n        case 'AAAA':\n          return this.resolve6(hostname);\n\n        case 'TXT':\n          return this.resolveTxt(hostname);\n\n        default:\n          throw new Error(`${rrType} is not supported`);\n      }\n    }\n    /**\n     * Uses the DNS protocol to resolve the given host name into IPv4 addresses.\n     *\n     * @param {string} hostname - host name to resolve.\n     * @returns {Promise<Array<string>>}\n     */\n\n\n    resolve4(hostname) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const recordType = 'A';\n\n        const cached = _this._cache.get(utils.getCacheKey(hostname, recordType));\n\n        if (cached) {\n          return cached;\n        }\n\n        for (const server of _this._getShuffledServers()) {\n          try {\n            const response = yield utils.fetch(utils.buildResource({\n              serverResolver: server,\n              hostname,\n              recordType\n            }));\n            const d = yield response.json();\n            const data = d.Answer.map(a => a.data);\n            const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n            _this._cache.set(utils.getCacheKey(hostname, recordType), data, {\n              ttl\n            });\n\n            return data;\n          } catch (err) {\n            log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n          }\n        }\n\n        throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n      })();\n    }\n    /**\n     * Uses the DNS protocol to resolve the given host name into IPv6 addresses.\n     *\n     * @param {string} hostname - host name to resolve.\n     * @returns {Promise<Array<string>>}\n     */\n\n\n    resolve6(hostname) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        const recordType = 'AAAA';\n\n        const cached = _this2._cache.get(utils.getCacheKey(hostname, recordType));\n\n        if (cached) {\n          return cached;\n        }\n\n        for (const server of _this2._getShuffledServers()) {\n          try {\n            const response = yield utils.fetch(utils.buildResource({\n              serverResolver: server,\n              hostname,\n              recordType\n            }));\n            const d = yield response.json();\n            const data = d.Answer.map(a => a.data);\n            const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n            _this2._cache.set(utils.getCacheKey(hostname, recordType), data, {\n              ttl\n            });\n\n            return data;\n          } catch (err) {\n            log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n          }\n        }\n\n        throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n      })();\n    }\n    /**\n     * Uses the DNS protocol to resolve the given host name into a Text record.\n     *\n     * @param {string} hostname - host name to resolve.\n     * @returns {Promise<Array<Array<string>>>}\n     */\n\n\n    resolveTxt(hostname) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        const recordType = 'TXT';\n\n        const cached = _this3._cache.get(utils.getCacheKey(hostname, recordType));\n\n        if (cached) {\n          return cached;\n        }\n\n        for (const server of _this3._getShuffledServers()) {\n          try {\n            const response = yield utils.fetch(utils.buildResource({\n              serverResolver: server,\n              hostname,\n              recordType\n            }));\n            const d = yield response.json();\n            const data = d.Answer.map(a => [a.data.replace(/['\"]+/g, '')]);\n            const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n            _this3._cache.set(utils.getCacheKey(hostname, recordType), data, {\n              ttl\n            });\n\n            return data;\n          } catch (err) {\n            log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n          }\n        }\n\n        throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n      })();\n    }\n\n  }\n\n  Resolver.Resolver = Resolver;\n  return Resolver;\n})();\nmodule.exports = Resolver;","map":null,"metadata":{},"sourceType":"script"}