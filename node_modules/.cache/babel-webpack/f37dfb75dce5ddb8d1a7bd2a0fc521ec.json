{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst BufferList = require('bl/BufferList');\n\nconst ZERO_OFFSET = '0'.charCodeAt(0);\nconst USTAR_MAGIC = Buffer.from('ustar\\x00', 'binary');\nconst GNU_MAGIC = Buffer.from('ustar\\x20', 'binary');\nconst GNU_VER = Buffer.from('\\x20\\x00', 'binary');\nconst MAGIC_OFFSET = 257;\nconst VERSION_OFFSET = 263;\n\nconst clamp = function (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue;\n  index = ~~index; // Coerce to integer.\n\n  if (index >= len) return len;\n  if (index >= 0) return index;\n  index += len;\n  if (index >= 0) return index;\n  return 0;\n};\n\nconst toType = function (flag) {\n  switch (flag) {\n    case 0:\n      return 'file';\n\n    case 1:\n      return 'link';\n\n    case 2:\n      return 'symlink';\n\n    case 3:\n      return 'character-device';\n\n    case 4:\n      return 'block-device';\n\n    case 5:\n      return 'directory';\n\n    case 6:\n      return 'fifo';\n\n    case 7:\n      return 'contiguous-file';\n\n    case 72:\n      return 'pax-header';\n\n    case 55:\n      return 'pax-global-header';\n\n    case 27:\n      return 'gnu-long-link-path';\n\n    case 28:\n    case 30:\n      return 'gnu-long-path';\n  }\n\n  return null;\n};\n\nconst indexOf = function (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block.get(offset) === num) return offset;\n  }\n\n  return end;\n};\n\nconst cksum = function (block) {\n  let sum = 8 * 32;\n\n  for (let i = 0; i < 148; i++) sum += block.get(i);\n\n  for (let j = 156; j < 512; j++) sum += block.get(j);\n\n  return sum;\n};\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\n\n\nfunction parse256(buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive;\n  if (buf.get(0) === 0x80) positive = true;else if (buf.get(0) === 0xFF) positive = false;else return null; // build up a base-256 tuple from the least sig to the highest\n\n  let zero = false;\n  const tuple = [];\n\n  for (let i = buf.length - 1; i > 0; i--) {\n    const byte = buf.get(i);\n    if (positive) tuple.push(byte);else if (zero && byte === 0) tuple.push(0);else if (zero) {\n      zero = false;\n      tuple.push(0x100 - byte);\n    } else tuple.push(0xFF - byte);\n  }\n\n  let sum = 0;\n  const l = tuple.length;\n\n  for (let i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i);\n  }\n\n  return positive ? sum : -1 * sum;\n}\n\nconst decodeOct = function (val, offset, length) {\n  val = val.shallowSlice(offset, offset + length);\n  offset = 0; // If prefixed with 0x80 then parse as a base-256 integer\n\n  if (val.get(offset) & 0x80) {\n    return parse256(val);\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val.get(offset) === 32) offset++;\n\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);\n\n    while (offset < end && val.get(offset) === 0) offset++;\n\n    if (end === offset) return 0;\n    return parseInt(val.shallowSlice(offset, end).toString(), 8);\n  }\n};\n\nconst decodeStr = function (val, offset, length, encoding) {\n  return val.shallowSlice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);\n};\n\nexports.decodeLongPath = function (buf, encoding) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  return decodeStr(buf, 0, buf.length, encoding);\n};\n\nexports.decodePax = function (buf) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  const result = {};\n\n  while (buf.length) {\n    let i = 0;\n\n    while (i < buf.length && buf.get(i) !== 32) i++;\n\n    const len = parseInt(buf.shallowSlice(0, i).toString(), 10);\n    if (!len) return result;\n    const b = buf.shallowSlice(i + 1, len - 1).toString();\n    const keyIndex = b.indexOf('=');\n    if (keyIndex === -1) return result;\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);\n    buf = buf.shallowSlice(len);\n  }\n\n  return result;\n};\n\nexports.decode = function (buf, filenameEncoding) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  let typeflag = buf.get(156) === 0 ? 0 : buf.get(156) - ZERO_OFFSET;\n  let name = decodeStr(buf, 0, 100, filenameEncoding);\n  const mode = decodeOct(buf, 100, 8);\n  const uid = decodeOct(buf, 108, 8);\n  const gid = decodeOct(buf, 116, 8);\n  const size = decodeOct(buf, 124, 12);\n  const mtime = decodeOct(buf, 136, 12);\n  const type = toType(typeflag);\n  const linkname = buf.get(157) === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);\n  const uname = decodeStr(buf, 265, 32);\n  const gname = decodeStr(buf, 297, 32);\n  const devmajor = decodeOct(buf, 329, 8);\n  const devminor = decodeOct(buf, 337, 8);\n  const c = cksum(buf); // checksum is still initial value if header was null.\n\n  if (c === 8 * 32) return null; // valid checksum\n\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?');\n\n  if (USTAR_MAGIC.compare(buf.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf.get(345)) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name;\n  } else if (GNU_MAGIC.compare(buf.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0 && GNU_VER.compare(buf.slice(VERSION_OFFSET, VERSION_OFFSET + 2)) === 0) {// 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    throw new Error('Invalid tar header: unknown format.');\n  } // to support old tar versions that use trailing / to indicate dirs\n\n\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5;\n  return {\n    name: name,\n    mode: mode,\n    uid: uid,\n    gid: gid,\n    size: size,\n    mtime: new Date(1000 * mtime),\n    type: type,\n    linkname: linkname,\n    uname: uname,\n    gname: gname,\n    devmajor: devmajor,\n    devminor: devminor\n  };\n};","map":null,"metadata":{},"sourceType":"script"}