{"ast":null,"code":"'use strict'; // @ts-ignore\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst distance = require('xor-distance');\n\nconst utils = require('../utils');\n\nconst pMap = require('p-map');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../').PeerData} PeerData\n */\n\n/**\n * Maintains a list of peerIds sorted by distance from a DHT key.\n */\n\n\nclass PeerDistanceList {\n  /**\n   * Creates a new PeerDistanceList.\n   *\n   * @param {Uint8Array} originDhtKey - the DHT key from which distance is calculated\n   * @param {number} capacity - the maximum size of the list\n   */\n  constructor(originDhtKey, capacity) {\n    this.originDhtKey = originDhtKey;\n    this.capacity = capacity;\n    /** @type {{ peerId: PeerId, distance: Uint8Array }[]} */\n\n    this.peerDistances = [];\n  }\n  /**\n   * The length of the list\n   */\n\n\n  get length() {\n    return this.peerDistances.length;\n  }\n  /**\n   * The peerIds in the list, in order of distance from the origin key\n   */\n\n\n  get peers() {\n    return this.peerDistances.map(pd => pd.peerId);\n  }\n  /**\n   * Add a peerId to the list.\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  add(peerId) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.peerDistances.find(pd => uint8ArrayEquals(pd.peerId.id, peerId.id))) {\n        return;\n      }\n\n      const dhtKey = yield utils.convertPeerId(peerId);\n      const el = {\n        peerId,\n        distance: distance(_this.originDhtKey, dhtKey)\n      };\n\n      _this.peerDistances.push(el);\n\n      _this.peerDistances.sort((a, b) => distance.compare(a.distance, b.distance));\n\n      _this.peerDistances = _this.peerDistances.slice(0, _this.capacity);\n    })();\n  }\n  /**\n   * Indicates whether any of the peerIds passed as a parameter are closer\n   * to the origin key than the furthest peerId in the PeerDistanceList.\n   *\n   * @param {PeerId[]} peerIds\n   */\n\n\n  anyCloser(peerIds) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!peerIds.length) {\n        return false;\n      }\n\n      if (!_this2.length) {\n        return true;\n      }\n\n      const dhtKeys = yield pMap(peerIds, peerId => utils.convertPeerId(peerId));\n      const furthestDistance = _this2.peerDistances[_this2.peerDistances.length - 1].distance;\n\n      for (const dhtKey of dhtKeys) {\n        const keyDistance = distance(_this2.originDhtKey, dhtKey);\n\n        if (distance.compare(keyDistance, furthestDistance) < 0) {\n          return true;\n        }\n      }\n\n      return false;\n    })();\n  }\n\n}\n\nmodule.exports = PeerDistanceList;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-kad-dht/src/peer-list/peer-distance-list.js"],"names":["distance","require","utils","pMap","equals","uint8ArrayEquals","PeerDistanceList","constructor","originDhtKey","capacity","peerDistances","length","peers","map","pd","peerId","add","find","id","dhtKey","convertPeerId","el","push","sort","a","b","compare","slice","anyCloser","peerIds","dhtKeys","furthestDistance","keyDistance","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// @ts-ignore\nconst distance = require('xor-distance')\nconst utils = require('../utils')\nconst pMap = require('p-map')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../').PeerData} PeerData\n */\n\n/**\n * Maintains a list of peerIds sorted by distance from a DHT key.\n */\nclass PeerDistanceList {\n  /**\n   * Creates a new PeerDistanceList.\n   *\n   * @param {Uint8Array} originDhtKey - the DHT key from which distance is calculated\n   * @param {number} capacity - the maximum size of the list\n   */\n  constructor (originDhtKey, capacity) {\n    this.originDhtKey = originDhtKey\n    this.capacity = capacity\n\n    /** @type {{ peerId: PeerId, distance: Uint8Array }[]} */\n    this.peerDistances = []\n  }\n\n  /**\n   * The length of the list\n   */\n  get length () {\n    return this.peerDistances.length\n  }\n\n  /**\n   * The peerIds in the list, in order of distance from the origin key\n   */\n  get peers () {\n    return this.peerDistances.map(pd => pd.peerId)\n  }\n\n  /**\n   * Add a peerId to the list.\n   *\n   * @param {PeerId} peerId\n   */\n  async add (peerId) {\n    if (this.peerDistances.find(pd => uint8ArrayEquals(pd.peerId.id, peerId.id))) {\n      return\n    }\n\n    const dhtKey = await utils.convertPeerId(peerId)\n    const el = {\n      peerId,\n      distance: distance(this.originDhtKey, dhtKey)\n    }\n\n    this.peerDistances.push(el)\n    this.peerDistances.sort((a, b) => distance.compare(a.distance, b.distance))\n    this.peerDistances = this.peerDistances.slice(0, this.capacity)\n  }\n\n  /**\n   * Indicates whether any of the peerIds passed as a parameter are closer\n   * to the origin key than the furthest peerId in the PeerDistanceList.\n   *\n   * @param {PeerId[]} peerIds\n   */\n  async anyCloser (peerIds) {\n    if (!peerIds.length) {\n      return false\n    }\n\n    if (!this.length) {\n      return true\n    }\n\n    const dhtKeys = await pMap(peerIds, (peerId) => utils.convertPeerId(peerId))\n    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance\n\n    for (const dhtKey of dhtKeys) {\n      const keyDistance = distance(this.originDhtKey, dhtKey)\n\n      if (distance.compare(keyDistance, furthestDistance) < 0) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = PeerDistanceList\n"]},"metadata":{},"sourceType":"script"}