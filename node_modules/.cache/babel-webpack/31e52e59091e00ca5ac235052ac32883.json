{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  createBitswap\n} = require('ipfs-bitswap');\n\nconst createLibP2P = require('./libp2p');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst errCode = require('err-code');\n\nconst BlockStorage = require('../block-storage');\n/**\n * @typedef {Object} Online\n * @property {libp2p} libp2p\n * @property {Bitswap} bitswap\n *\n * @typedef {Object} Options\n * @property {PeerId} options.peerId\n * @property {Repo} options.repo\n * @property {Print} options.print\n * @property {IPFSOptions} options.options\n *\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('../types').Print} Print\n * @typedef {import('libp2p')} libp2p\n * @typedef {import('ipfs-bitswap').IPFSBitswap} Bitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n\nclass Network {\n  /**\n   * @param {PeerId} peerId\n   * @param {libp2p} libp2p\n   * @param {Bitswap} bitswap\n   * @param {Repo} repo\n   * @param {BlockStorage} blockstore\n   */\n  constructor(peerId, libp2p, bitswap, repo, blockstore) {\n    this.peerId = peerId;\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.repo = repo;\n    this.blockstore = blockstore;\n  }\n  /**\n   * @param {Options} options\n   */\n\n\n  static start({\n    peerId,\n    repo,\n    print,\n    options\n  }) {\n    return _asyncToGenerator(function* () {\n      // Need to ensure that repo is open as it could have been closed between\n      // `init` and `start`.\n      if (repo.closed) {\n        yield repo.open();\n      }\n      /** @type {IPFSConfig} */\n\n\n      const config = yield repo.config.getAll();\n      const libp2p = yield createLibP2P({\n        options,\n        repo,\n        peerId,\n        multiaddrs: readAddrs(peerId, config),\n        config,\n        keychainConfig: undefined\n      });\n\n      if (libp2p.keychain) {\n        yield libp2p.loadKeychain();\n      }\n\n      yield libp2p.start();\n\n      for (const ma of libp2p.multiaddrs) {\n        print(`Swarm listening on ${ma}/p2p/${peerId.toB58String()}`);\n      }\n\n      const bitswap = createBitswap(libp2p, repo.blocks, {\n        statsEnabled: true\n      });\n      yield bitswap.start();\n      const blockstore = new BlockStorage(repo.blocks, bitswap);\n      repo.blocks = blockstore; // @ts-ignore private field\n\n      repo.pins.blockstore = blockstore;\n      return new Network(peerId, libp2p, bitswap, repo, blockstore);\n    })();\n  }\n  /**\n   * @param {Network} network\n   */\n\n\n  static stop(network) {\n    return _asyncToGenerator(function* () {\n      network.repo.blocks = network.blockstore.unwrap(); // @ts-ignore private field\n\n      network.repo.pins.blockstore = network.blockstore.unwrap();\n      yield Promise.all([network.bitswap.stop(), network.libp2p.stop()]);\n    })();\n  }\n\n}\n\nmodule.exports = Network;\n/**\n * @param {PeerId} peerId\n * @param {IPFSConfig} config\n */\n\nconst readAddrs = (peerId, config) => {\n  const peerIdStr = peerId.toB58String();\n  /** @type {Multiaddr[]} */\n\n  const addrs = [];\n  const swarm = config.Addresses && config.Addresses.Swarm || [];\n\n  for (const addr of swarm) {\n    let ma = new Multiaddr(addr); // Temporary error for users migrating using websocket-star multiaddrs for listenning on libp2p\n    // websocket-star support was removed from ipfs and libp2p\n\n    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {\n      throw errCode(new Error('websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779'), 'ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED');\n    } // multiaddrs that go via a signalling server or other intermediary (e.g. stardust,\n    // webrtc-star) can have the intermediary's peer ID in the address, so append our\n    // peer ID to the end of it\n\n\n    const maId = ma.getPeerId();\n\n    if (maId && maId !== peerIdStr) {\n      ma = ma.encapsulate(`/p2p/${peerIdStr}`);\n    }\n\n    addrs.push(ma);\n  }\n\n  return addrs;\n};\n\nconst WEBSOCKET_STAR_PROTO_CODE = 479;","map":null,"metadata":{},"sourceType":"script"}