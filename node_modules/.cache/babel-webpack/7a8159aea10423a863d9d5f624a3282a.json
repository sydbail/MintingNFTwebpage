{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst ready = require('./ready');\n\nmodule.exports = (socket, options) => {\n  options = options || {};\n  options.closeOnEnd = options.closeOnEnd !== false;\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (source) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const data = _value;\n\n          try {\n            yield ready(socket);\n          } catch (err) {\n            if (err.message === 'socket closed') break;\n            throw err;\n          }\n\n          socket.send(data);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (options.closeOnEnd && socket.readyState <= 1) {\n        return new Promise((resolve, reject) => {\n          socket.addEventListener('close', event => {\n            if (event.wasClean || event.code === 1006) {\n              resolve();\n            } else {\n              const err = Object.assign(new Error('ws error'), {\n                event\n              });\n              reject(err);\n            }\n          });\n          setTimeout(() => socket.close());\n        });\n      }\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/it-ws/sink.js"],"names":["ready","require","module","exports","socket","options","closeOnEnd","source","data","err","message","send","readyState","Promise","resolve","reject","addEventListener","event","wasClean","code","Object","assign","Error","setTimeout","close"],"mappings":";;;;AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,CAACC,MAAD,EAASC,OAAT,KAAqB;AACpCA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,EAAAA,OAAO,CAACC,UAAR,GAAqBD,OAAO,CAACC,UAAR,KAAuB,KAA5C;AAEA;AAAA,iCAAO,WAAMC,MAAN,EAAgB;AAAA;AAAA;;AAAA;;AAAA;AACrB,4CAAyBA,MAAzB,oLAAiC;AAAA,gBAAhBC,IAAgB;;AAC/B,cAAI;AACF,kBAAMR,KAAK,CAACI,MAAD,CAAX;AACD,WAFD,CAEE,OAAOK,GAAP,EAAY;AACZ,gBAAIA,GAAG,CAACC,OAAJ,KAAgB,eAApB,EAAqC;AACrC,kBAAMD,GAAN;AACD;;AAEDL,UAAAA,MAAM,CAACO,IAAP,CAAYH,IAAZ;AACD;AAVoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYrB,UAAIH,OAAO,CAACC,UAAR,IAAsBF,MAAM,CAACQ,UAAP,IAAqB,CAA/C,EAAkD;AAChD,eAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCX,UAAAA,MAAM,CAACY,gBAAP,CAAwB,OAAxB,EAAiCC,KAAK,IAAI;AACxC,gBAAIA,KAAK,CAACC,QAAN,IAAkBD,KAAK,CAACE,IAAN,KAAe,IAArC,EAA2C;AACzCL,cAAAA,OAAO;AACR,aAFD,MAEO;AACL,oBAAML,GAAG,GAAGW,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,UAAV,CAAd,EAAqC;AAAEL,gBAAAA;AAAF,eAArC,CAAZ;AACAF,cAAAA,MAAM,CAACN,GAAD,CAAN;AACD;AACF,WAPD;AASAc,UAAAA,UAAU,CAAC,MAAMnB,MAAM,CAACoB,KAAP,EAAP,CAAV;AACD,SAXM,CAAP;AAYD;AACF,KA1BD;;AAAA;AAAA;AAAA;AAAA;AA2BD,CA/BD","sourcesContent":["const ready = require('./ready')\n\nmodule.exports = (socket, options) => {\n  options = options || {}\n  options.closeOnEnd = options.closeOnEnd !== false\n\n  return async source => {\n    for await (const data of source) {\n      try {\n        await ready(socket)\n      } catch (err) {\n        if (err.message === 'socket closed') break\n        throw err\n      }\n\n      socket.send(data)\n    }\n\n    if (options.closeOnEnd && socket.readyState <= 1) {\n      return new Promise((resolve, reject) => {\n        socket.addEventListener('close', event => {\n          if (event.wasClean || event.code === 1006) {\n            resolve()\n          } else {\n            const err = Object.assign(new Error('ws error'), { event })\n            reject(err)\n          }\n        })\n\n        setTimeout(() => socket.close())\n      })\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}