{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errCode = require('err-code');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst removeLink = require('./utils/remove-link');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst toTrail = require('./utils/to-trail');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"rm\"]}\n   */\n  function mfsRm(_x) {\n    return _mfsRm.apply(this, arguments);\n  }\n\n  function _mfsRm() {\n    _mfsRm = _asyncToGenerator(function* (paths, opts = {}) {\n      /** @type {DefaultOptions} */\n      const options = mergeOptions(defaultOptions, opts);\n\n      if (!Array.isArray(paths)) {\n        paths = [paths];\n      }\n\n      const sources = yield Promise.all(paths.map(path => toMfsPath(context, path, options)));\n\n      if (!sources.length) {\n        throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n      }\n\n      sources.forEach(source => {\n        if (source.path === '/') {\n          throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n        }\n      });\n\n      for (const source of sources) {\n        yield removePath(context, source.path, options);\n      }\n    });\n    return _mfsRm.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsRm);\n};\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\n\n\nconst removePath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (context, path, options) {\n    const mfsPath = yield toMfsPath(context, path, options);\n    const trail = yield toTrail(context, mfsPath.mfsPath);\n    const child = trail[trail.length - 1];\n    trail.pop();\n    const parent = trail[trail.length - 1];\n\n    if (!parent) {\n      throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n    }\n\n    if (child.type === 'directory' && !options.recursive) {\n      throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR');\n    }\n\n    const {\n      cid\n    } = yield removeLink(context, {\n      parentCid: parent.cid,\n      name: child.name,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold\n    });\n    parent.cid = cid; // update the tree with the new child\n\n    const newRootCid = yield updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n    yield updateMfsRoot(context, newRootCid, options);\n  });\n\n  return function removePath(_x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-core/src/components/files/rm.js"],"names":["errCode","require","updateTree","updateMfsRoot","removeLink","toMfsPath","toTrail","withTimeoutOption","mergeOptions","bind","ignoreUndefined","defaultOptions","recursive","cidVersion","hashAlg","flush","shardSplitThreshold","module","exports","context","mfsRm","paths","opts","options","Array","isArray","sources","Promise","all","map","path","length","Error","forEach","source","removePath","mfsPath","trail","child","pop","parent","type","cid","parentCid","name","newRootCid"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst removeLink = require('./utils/remove-link')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toTrail = require('./utils/to-trail')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"rm\"]}\n   */\n  async function mfsRm (paths, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    if (!Array.isArray(paths)) {\n      paths = [paths]\n    }\n\n    const sources = await Promise.all(\n      paths.map(path => toMfsPath(context, path, options))\n    )\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS')\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS')\n      }\n    })\n\n    for (const source of sources) {\n      await removePath(context, source.path, options)\n    }\n  }\n\n  return withTimeoutOption(mfsRm)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options)\n  const trail = await toTrail(context, mfsPath.mfsPath)\n  const child = trail[trail.length - 1]\n  trail.pop()\n  const parent = trail[trail.length - 1]\n\n  if (!parent) {\n    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR')\n  }\n\n  const {\n    cid\n  } = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  parent.cid = cid\n\n  // update the tree with the new child\n  const newRootCid = await updateTree(context, trail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n"]},"metadata":{},"sourceType":"script"}