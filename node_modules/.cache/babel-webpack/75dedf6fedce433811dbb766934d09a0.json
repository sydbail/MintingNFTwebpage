{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-proto-book\"] || ($protobuf.roots[\"libp2p-proto-book\"] = {});\n\n$root.Protocols = function () {\n  /**\n   * Properties of a Protocols.\n   * @exports IProtocols\n   * @interface IProtocols\n   * @property {Array.<string>|null} [protocols] Protocols protocols\n   */\n\n  /**\n   * Constructs a new Protocols.\n   * @exports Protocols\n   * @classdesc Represents a Protocols.\n   * @implements IProtocols\n   * @constructor\n   * @param {IProtocols=} [p] Properties to set\n   */\n  function Protocols(p) {\n    this.protocols = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Protocols protocols.\n   * @member {Array.<string>} protocols\n   * @memberof Protocols\n   * @instance\n   */\n\n\n  Protocols.prototype.protocols = $util.emptyArray;\n  /**\n   * Encodes the specified Protocols message. Does not implicitly {@link Protocols.verify|verify} messages.\n   * @function encode\n   * @memberof Protocols\n   * @static\n   * @param {IProtocols} m Protocols message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Protocols.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n\n    if (m.protocols != null && m.protocols.length) {\n      for (var i = 0; i < m.protocols.length; ++i) w.uint32(10).string(m.protocols[i]);\n    }\n\n    return w;\n  };\n  /**\n   * Decodes a Protocols message from the specified reader or buffer.\n   * @function decode\n   * @memberof Protocols\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Protocols} Protocols\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Protocols.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Protocols();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          if (!(m.protocols && m.protocols.length)) m.protocols = [];\n          m.protocols.push(r.string());\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a Protocols message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Protocols\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Protocols} Protocols\n   */\n\n\n  Protocols.fromObject = function fromObject(d) {\n    if (d instanceof $root.Protocols) return d;\n    var m = new $root.Protocols();\n\n    if (d.protocols) {\n      if (!Array.isArray(d.protocols)) throw TypeError(\".Protocols.protocols: array expected\");\n      m.protocols = [];\n\n      for (var i = 0; i < d.protocols.length; ++i) {\n        m.protocols[i] = String(d.protocols[i]);\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a Protocols message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Protocols\n   * @static\n   * @param {Protocols} m Protocols\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Protocols.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.arrays || o.defaults) {\n      d.protocols = [];\n    }\n\n    if (m.protocols && m.protocols.length) {\n      d.protocols = [];\n\n      for (var j = 0; j < m.protocols.length; ++j) {\n        d.protocols[j] = m.protocols[j];\n      }\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Protocols to JSON.\n   * @function toJSON\n   * @memberof Protocols\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Protocols.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Protocols;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}