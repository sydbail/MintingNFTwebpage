{"ast":null,"code":"'use strict';\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\n\nmodule.exports = function ({\n  repo,\n  codecs,\n  resolve,\n  preload\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  function refs(_x) {\n    return _refs.apply(this, arguments);\n  }\n\n  function _refs() {\n    _refs = _wrapAsyncGenerator(function* (ipfsPath, options = {}) {\n      if (options.maxDepth === 0) {\n        return;\n      }\n\n      if (options.edges && options.format && options.format !== Format.default) {\n        throw new Error('Cannot set edges to true and also specify format');\n      }\n\n      options.format = options.edges ? Format.edges : options.format;\n\n      if (typeof options.maxDepth !== 'number') {\n        options.maxDepth = options.recursive ? Infinity : 1;\n      }\n      /** @type {(string|CID)[]} */\n\n\n      const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n      const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n      for (const path of paths) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(refsStream(resolve, repo, codecs, path, options)), _awaitAsyncGenerator);\n      }\n    });\n    return _refs.apply(this, arguments);\n  }\n\n  return withTimeoutOption(refs);\n};\n\nmodule.exports.Format = Format;\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\nfunction getFullPath(preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath);\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return `/ipfs/${cid}${path || ''}`;\n}\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\n\nfunction refsStream(_x2, _x3, _x4, _x5, _x6) {\n  return _refsStream.apply(this, arguments);\n}\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\n\n\nfunction _refsStream() {\n  _refsStream = _wrapAsyncGenerator(function* (resolve, repo, codecs, path, options) {\n    // Resolve to the target CID of the path\n    const resPath = yield _awaitAsyncGenerator(resolve(path));\n    const {\n      cid\n    } = toCIDAndPath(resPath);\n    const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n    const unique = options.unique || false; // Traverse the DAG, converting it into a stream\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(objectStream(repo, codecs, cid, maxDepth, unique)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const obj = _value;\n\n        // Root object will not have a parent\n        if (!obj.parent) {\n          continue;\n        } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n        if (obj.isDuplicate) {\n          continue;\n        } // Format the links\n        // Clients expect refs to be in the format { ref: <ref> }\n\n\n        yield {\n          ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n        };\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return _refsStream.apply(this, arguments);\n}\n\nfunction formatLink(srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n */\n\n\nfunction objectStream(_x7, _x8, _x9, _x10, _x11) {\n  return _objectStream.apply(this, arguments);\n}\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {Array<string|number>} base\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\n\n\nfunction _objectStream() {\n  _objectStream = _wrapAsyncGenerator(function* (repo, codecs, rootCid, maxDepth, uniqueOnly) {\n    // eslint-disable-line require-await\n    const seen = new Set();\n    /**\n     * @param {Node} parent\n     * @param {number} depth\n     * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n     */\n\n    function traverseLevel(_x15, _x16) {\n      return _traverseLevel.apply(this, arguments);\n    }\n\n    function _traverseLevel() {\n      _traverseLevel = _wrapAsyncGenerator(function* (parent, depth) {\n        const nextLevelDepth = depth + 1; // Check the depth\n\n        if (nextLevelDepth > maxDepth) {\n          return;\n        } // Get this object's links\n\n\n        try {\n          // Look at each link, parent and the new depth\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n\n          var _iteratorError2;\n\n          try {\n            for (var _iterator2 = _asyncIterator(getLinks(repo, codecs, parent.cid)), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n              const link = _value2;\n              yield {\n                parent: parent,\n                node: link,\n                isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n              };\n\n              if (uniqueOnly) {\n                seen.add(link.cid.toString());\n              }\n\n              yield* _asyncGeneratorDelegate(_asyncIterator(traverseLevel(link, nextLevelDepth)), _awaitAsyncGenerator);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                yield _awaitAsyncGenerator(_iterator2.return());\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        } catch (err) {\n          if (err.code === ERR_NOT_FOUND) {\n            err.message = `Could not find object with CID: ${parent.cid}`;\n          }\n\n          throw err;\n        }\n      });\n      return _traverseLevel.apply(this, arguments);\n    }\n\n    yield* _asyncGeneratorDelegate(_asyncIterator(traverseLevel({\n      cid: rootCid\n    }, 0)), _awaitAsyncGenerator);\n  });\n  return _objectStream.apply(this, arguments);\n}\n\nfunction getLinks(_x12, _x13, _x14) {\n  return _getLinks.apply(this, arguments);\n}\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\n\n\nfunction _getLinks() {\n  _getLinks = _wrapAsyncGenerator(function* (repo, codecs, cid, base = []) {\n    const block = yield _awaitAsyncGenerator(repo.blocks.get(cid));\n    const codec = yield _awaitAsyncGenerator(codecs.getCodec(cid.code));\n    const value = codec.decode(block);\n    const isDagPb = cid.code === dagPb.code;\n\n    for (const [name, cid] of links(value, base)) {\n      // special case for dag-pb - use the name of the link\n      // instead of the path within the object\n      if (isDagPb) {\n        const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n\n        if (match) {\n          const index = Number(match[1]);\n\n          if (index < value.Links.length) {\n            yield {\n              name: value.Links[index].Name,\n              cid\n            };\n            continue;\n          }\n        }\n      }\n\n      yield {\n        name,\n        cid\n      };\n    }\n  });\n  return _getLinks.apply(this, arguments);\n}\n\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n\n  if (source instanceof Uint8Array) {\n    return;\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element); // eslint-disable-next-line max-depth\n\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  } // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n\n\n  return [];\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/components/refs/index.js"],"names":["dagPb","require","Errors","ERR_NOT_FOUND","notFoundError","code","withTimeoutOption","toCIDAndPath","CID","Format","default","edges","module","exports","repo","codecs","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","cid","resPath","unique","objectStream","obj","parent","isDuplicate","ref","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","getLinks","link","has","add","err","message","base","block","blocks","get","codec","getCodec","value","decode","isDagPb","links","match","index","Number","Links","length","Name","source","Uint8Array","key","Object","entries","element","elementPath","asCID","join"],"mappings":"AAAA;;;;;;;;;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,cAAD,CAArB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAaD,OAAO,CAAC,qBAAD,CAA1B;;AACA,MAAME,aAAa,GAAGD,MAAM,CAACE,aAAP,GAAuBC,IAA7C;;AACA,MAAMC,iBAAiB,GAAGL,OAAO,CAAC,yCAAD,CAAjC;;AACA,MAAMM,YAAY,GAAGN,OAAO,CAAC,qCAAD,CAA5B;;AACA,MAAM;AAAEO,EAAAA;AAAF,IAAUP,OAAO,CAAC,kBAAD,CAAvB;;AAEA,MAAMQ,MAAM,GAAG;AACbC,EAAAA,OAAO,EAAE,OADI;AAEbC,EAAAA,KAAK,EAAE;AAFM,CAAf;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAAU;AAAEC,EAAAA,IAAF;AAAQC,EAAAA,MAAR;AAAgBC,EAAAA,OAAhB;AAAyBC,EAAAA;AAAzB,CAAV,EAA8C;AAC7D;AACF;AACA;AAH+D,WAI5CC,IAJ4C;AAAA;AAAA;;AAAA;AAAA,gCAI7D,WAAuBC,QAAvB,EAAiCC,OAAO,GAAG,EAA3C,EAA+C;AAC7C,UAAIA,OAAO,CAACC,QAAR,KAAqB,CAAzB,EAA4B;AAC1B;AACD;;AAED,UAAID,OAAO,CAACT,KAAR,IAAiBS,OAAO,CAACE,MAAzB,IAAmCF,OAAO,CAACE,MAAR,KAAmBb,MAAM,CAACC,OAAjE,EAA0E;AACxE,cAAM,IAAIa,KAAJ,CAAU,kDAAV,CAAN;AACD;;AAEDH,MAAAA,OAAO,CAACE,MAAR,GAAiBF,OAAO,CAACT,KAAR,GAAgBF,MAAM,CAACE,KAAvB,GAA+BS,OAAO,CAACE,MAAxD;;AAEA,UAAI,OAAOF,OAAO,CAACC,QAAf,KAA4B,QAAhC,EAA0C;AACxCD,QAAAA,OAAO,CAACC,QAAR,GAAmBD,OAAO,CAACI,SAAR,GAAoBC,QAApB,GAA+B,CAAlD;AACD;AAED;;;AACA,YAAMC,QAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcT,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAAtD;AAEA,YAAMU,KAAK,GAAGH,QAAQ,CAACI,GAAT,CAAaC,CAAC,IAAIC,WAAW,CAACf,OAAD,EAAUc,CAAV,EAAaX,OAAb,CAA7B,CAAd;;AAEA,WAAK,MAAMa,IAAX,IAAmBJ,KAAnB,EAA0B;AACxB,sDAAQK,UAAU,CAAClB,OAAD,EAAUF,IAAV,EAAgBC,MAAhB,EAAwBkB,IAAxB,EAA8Bb,OAA9B,CAAlB;AACD;AACF,KA3B4D;AAAA;AAAA;;AA6B7D,SAAOd,iBAAiB,CAACY,IAAD,CAAxB;AACD,CA9BD;;AAgCAN,MAAM,CAACC,OAAP,CAAeJ,MAAf,GAAwBA,MAAxB;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASuB,WAAT,CAAsBf,OAAtB,EAA+BE,QAA/B,EAAyCC,OAAzC,EAAkD;AAChD,QAAM;AACJe,IAAAA,GADI;AAEJF,IAAAA;AAFI,MAGF1B,YAAY,CAACY,QAAD,CAHhB;;AAKA,MAAIC,OAAO,CAACH,OAAR,KAAoB,KAAxB,EAA+B;AAC7BA,IAAAA,OAAO,CAACkB,GAAD,CAAP;AACD;;AAED,SAAQ,SAAQA,GAAI,GAAEF,IAAI,IAAI,EAAG,EAAjC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACiBC,U;;;AA8BjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;oCArCA,WAA6BlB,OAA7B,EAAsCF,IAAtC,EAA4CC,MAA5C,EAAoDkB,IAApD,EAA0Db,OAA1D,EAAmE;AACjE;AACA,UAAMgB,OAAO,8BAASpB,OAAO,CAACiB,IAAD,CAAhB,CAAb;AACA,UAAM;AACJE,MAAAA;AADI,QAEF5B,YAAY,CAAC6B,OAAD,CAFhB;AAIA,UAAMf,QAAQ,GAAGD,OAAO,CAACC,QAAR,IAAoB,IAApB,GAA2BD,OAAO,CAACC,QAAnC,GAA8CI,QAA/D;AACA,UAAMY,MAAM,GAAGjB,OAAO,CAACiB,MAAR,IAAkB,KAAjC,CARiE,CAUjE;;AAViE;AAAA;;AAAA;;AAAA;AAWjE,0CAAwBC,YAAY,CAACxB,IAAD,EAAOC,MAAP,EAAeoB,GAAf,EAAoBd,QAApB,EAA8BgB,MAA9B,CAApC,gOAA2E;AAAA,cAA1DE,GAA0D;;AACzE;AACA,YAAI,CAACA,GAAG,CAACC,MAAT,EAAiB;AACf;AACD,SAJwE,CAMzE;;;AACA,YAAID,GAAG,CAACE,WAAR,EAAqB;AACnB;AACD,SATwE,CAWzE;AACA;;;AACA,cAAM;AACJC,UAAAA,GAAG,EAAEC,UAAU,CAACJ,GAAG,CAACC,MAAJ,CAAWL,GAAZ,EAAiBI,GAAG,CAACK,IAAJ,CAAST,GAA1B,EAA+BI,GAAG,CAACK,IAAJ,CAASC,IAAxC,EAA8CzB,OAAO,CAACE,MAAtD;AADX,SAAN;AAGD;AA3BgE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BlE,G;;;;AAUD,SAASqB,UAAT,CAAqBG,MAArB,EAA6BC,MAA7B,EAAqCC,QAAQ,GAAG,EAAhD,EAAoD1B,MAAM,GAAGb,MAAM,CAACC,OAApE,EAA6E;AAC3E,MAAIuC,GAAG,GAAG3B,MAAM,CAAC4B,OAAP,CAAe,QAAf,EAAyBJ,MAAM,CAACK,QAAP,EAAzB,CAAV;AACAF,EAAAA,GAAG,GAAGA,GAAG,CAACC,OAAJ,CAAY,QAAZ,EAAsBH,MAAM,CAACI,QAAP,EAAtB,CAAN;AACAF,EAAAA,GAAG,GAAGA,GAAG,CAACC,OAAJ,CAAY,aAAZ,EAA2BF,QAA3B,CAAN;AACA,SAAOC,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACiBX,Y;;;AA4CjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;sCApDA,WAA+BxB,IAA/B,EAAqCC,MAArC,EAA6CqC,OAA7C,EAAsD/B,QAAtD,EAAgEgC,UAAhE,EAA4E;AAAE;AAC5E,UAAMC,IAAI,GAAG,IAAIC,GAAJ,EAAb;AAEA;AACF;AACA;AACA;AACA;;AAP4E,aAQzDC,aARyD;AAAA;AAAA;;AAAA;AAAA,2CAQ1E,WAAgChB,MAAhC,EAAwCiB,KAAxC,EAA+C;AAC7C,cAAMC,cAAc,GAAGD,KAAK,GAAG,CAA/B,CAD6C,CAG7C;;AACA,YAAIC,cAAc,GAAGrC,QAArB,EAA+B;AAC7B;AACD,SAN4C,CAQ7C;;;AACA,YAAI;AACF;AADE;AAAA;;AAAA;;AAAA;AAEF,iDAAyBsC,QAAQ,CAAC7C,IAAD,EAAOC,MAAP,EAAeyB,MAAM,CAACL,GAAtB,CAAjC,0OAA6D;AAAA,oBAA5CyB,IAA4C;AAC3D,oBAAM;AACJpB,gBAAAA,MAAM,EAAEA,MADJ;AAEJI,gBAAAA,IAAI,EAAEgB,IAFF;AAGJnB,gBAAAA,WAAW,EAAEY,UAAU,IAAIC,IAAI,CAACO,GAAL,CAASD,IAAI,CAACzB,GAAL,CAASgB,QAAT,EAAT;AAHvB,eAAN;;AAMA,kBAAIE,UAAJ,EAAgB;AACdC,gBAAAA,IAAI,CAACQ,GAAL,CAASF,IAAI,CAACzB,GAAL,CAASgB,QAAT,EAAT;AACD;;AAED,4DAAQK,aAAa,CAACI,IAAD,EAAOF,cAAP,CAArB;AACD;AAdC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeH,SAfD,CAeE,OAAOK,GAAP,EAAY;AACZ,cAAIA,GAAG,CAAC1D,IAAJ,KAAaF,aAAjB,EAAgC;AAC9B4D,YAAAA,GAAG,CAACC,OAAJ,GAAe,mCAAkCxB,MAAM,CAACL,GAAI,EAA5D;AACD;;AAED,gBAAM4B,GAAN;AACD;AACF,OAvCyE;AAAA;AAAA;;AAyC1E,kDAAQP,aAAa,CAAC;AAAErB,MAAAA,GAAG,EAAEiB;AAAP,KAAD,EAAmB,CAAnB,CAArB;AACD,G;;;;SAWgBO,Q;;;AAiCjB;AACA;AACA;AACA;AACA;;;;kCArCA,WAA2B7C,IAA3B,EAAiCC,MAAjC,EAAyCoB,GAAzC,EAA8C8B,IAAI,GAAG,EAArD,EAAyD;AACvD,UAAMC,KAAK,8BAASpD,IAAI,CAACqD,MAAL,CAAYC,GAAZ,CAAgBjC,GAAhB,CAAT,CAAX;AACA,UAAMkC,KAAK,8BAAStD,MAAM,CAACuD,QAAP,CAAgBnC,GAAG,CAAC9B,IAApB,CAAT,CAAX;AACA,UAAMkE,KAAK,GAAGF,KAAK,CAACG,MAAN,CAAaN,KAAb,CAAd;AACA,UAAMO,OAAO,GAAGtC,GAAG,CAAC9B,IAAJ,KAAaL,KAAK,CAACK,IAAnC;;AAEA,SAAK,MAAM,CAACwC,IAAD,EAAOV,GAAP,CAAX,IAA0BuC,KAAK,CAACH,KAAD,EAAQN,IAAR,CAA/B,EAA8C;AAC5C;AACA;AACA,UAAIQ,OAAJ,EAAa;AACX,cAAME,KAAK,GAAG9B,IAAI,CAAC8B,KAAL,CAAW,sBAAX,CAAd;;AAEA,YAAIA,KAAJ,EAAW;AACT,gBAAMC,KAAK,GAAGC,MAAM,CAACF,KAAK,CAAC,CAAD,CAAN,CAApB;;AAEA,cAAIC,KAAK,GAAGL,KAAK,CAACO,KAAN,CAAYC,MAAxB,EAAgC;AAC9B,kBAAM;AACJlC,cAAAA,IAAI,EAAE0B,KAAK,CAACO,KAAN,CAAYF,KAAZ,EAAmBI,IADrB;AAEJ7C,cAAAA;AAFI,aAAN;AAKA;AACD;AACF;AACF;;AAED,YAAM;AACJU,QAAAA,IADI;AAEJV,QAAAA;AAFI,OAAN;AAID;AACF,G;;;;AAOD,MAAMuC,KAAK,GAAG,WAAYO,MAAZ,EAAoBhB,IAApB,EAA0B;AACtC,MAAIgB,MAAM,IAAI,IAAd,EAAoB;AAClB;AACD;;AAED,MAAIA,MAAM,YAAYC,UAAtB,EAAkC;AAChC;AACD;;AAED,OAAK,MAAM,CAACC,GAAD,EAAMZ,KAAN,CAAX,IAA2Ba,MAAM,CAACC,OAAP,CAAeJ,MAAf,CAA3B,EAAmD;AACjD,UAAMhD,IAAI,GAAG,CAAC,GAAGgC,IAAJ,EAAUkB,GAAV,CAAb;;AAEA,QAAIZ,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAP,KAAiB,QAAtC,EAAgD;AAC9C,UAAI5C,KAAK,CAACC,OAAN,CAAc2C,KAAd,CAAJ,EAA0B;AACxB,aAAK,MAAM,CAACK,KAAD,EAAQU,OAAR,CAAX,IAA+Bf,KAAK,CAACc,OAAN,EAA/B,EAAgD;AAC9C,gBAAME,WAAW,GAAG,CAAC,GAAGtD,IAAJ,EAAU2C,KAAV,CAApB;AACA,gBAAMzC,GAAG,GAAG3B,GAAG,CAACgF,KAAJ,CAAUF,OAAV,CAAZ,CAF8C,CAI9C;;AACA,cAAInD,GAAJ,EAAS;AACP,kBAAM,CAACoD,WAAW,CAACE,IAAZ,CAAiB,GAAjB,CAAD,EAAwBtD,GAAxB,CAAN;AACD,WAFD,MAEO,IAAI,OAAOmD,OAAP,KAAmB,QAAvB,EAAiC;AACtC,mBAAQZ,KAAK,CAACY,OAAD,EAAUC,WAAV,CAAb;AACD;AACF;AACF,OAZD,MAYO;AACL,cAAMpD,GAAG,GAAG3B,GAAG,CAACgF,KAAJ,CAAUjB,KAAV,CAAZ;;AAEA,YAAIpC,GAAJ,EAAS;AACP,gBAAM,CAACF,IAAI,CAACwD,IAAL,CAAU,GAAV,CAAD,EAAiBtD,GAAjB,CAAN;AACD,SAFD,MAEO;AACL,iBAAQuC,KAAK,CAACH,KAAD,EAAQtC,IAAR,CAAb;AACD;AACF;AACF;AACF,GAnCqC,CAqCtC;AACA;;;AACA,SAAO,EAAP;AACD,CAxCD","sourcesContent":["'use strict'\n\nconst dagPb = require('@ipld/dag-pb')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path')\nconst { CID } = require('multiformats/cid')\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nmodule.exports = function ({ repo, codecs, resolve, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  async function * refs (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      yield * refsStream(resolve, repo, codecs, path, options)\n    }\n  }\n\n  return withTimeoutOption(refs)\n}\n\nmodule.exports.Format = Format\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath (preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath)\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return `/ipfs/${cid}${path || ''}`\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function * refsStream (resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path)\n  const {\n    cid\n  } = toCIDAndPath(resPath)\n\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity\n  const unique = options.unique || false\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink (srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n */\nasync function * objectStream (repo, codecs, rootCid, maxDepth, uniqueOnly) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {Array<string|number>} base\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function * getLinks (repo, codecs, cid, base = []) {\n  const block = await repo.blocks.get(cid)\n  const codec = await codecs.getCodec(cid.code)\n  const value = codec.decode(block)\n  const isDagPb = cid.code === dagPb.code\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/)\n\n      if (match) {\n        const index = Number(match[1])\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          }\n\n          continue\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    }\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function * (source, base) {\n  if (source == null) {\n    return\n  }\n\n  if (source instanceof Uint8Array) {\n    return\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key]\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index]\n          const cid = CID.asCID(element)\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid]\n          } else if (typeof element === 'object') {\n            yield * links(element, elementPath)\n          }\n        }\n      } else {\n        const cid = CID.asCID(value)\n\n        if (cid) {\n          yield [path.join('/'), cid]\n        } else {\n          yield * links(value, path)\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return []\n}\n"]},"metadata":{},"sourceType":"script"}