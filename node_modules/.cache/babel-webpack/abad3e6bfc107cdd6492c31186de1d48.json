{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SchedulerImplem = void 0;\n\nconst TextEscaper_1 = require(\"../../../check/arbitrary/helpers/TextEscaper\");\n\nconst symbols_1 = require(\"../../../check/symbols\");\n\nconst stringify_1 = require(\"../../../utils/stringify\");\n\nclass SchedulerImplem {\n  constructor(act, taskSelector) {\n    this.act = act;\n    this.taskSelector = taskSelector;\n    this.lastTaskId = 0;\n    this.sourceTaskSelector = taskSelector.clone();\n    this.scheduledTasks = [];\n    this.triggeredTasks = [];\n  }\n\n  static buildLog(reportItem) {\n    return `[task\\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${TextEscaper_1.escapeForTemplateString(reportItem.outputValue)}` : ''}`;\n  }\n\n  log(schedulingType, taskId, label, metadata, status, data) {\n    this.triggeredTasks.push({\n      status,\n      schedulingType,\n      taskId,\n      label,\n      metadata,\n      outputValue: data !== undefined ? stringify_1.stringify(data) : undefined\n    });\n  }\n\n  scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {\n    let trigger = null;\n    const taskId = ++this.lastTaskId;\n    const scheduledPromise = new Promise((resolve, reject) => {\n      trigger = () => {\n        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then(data => {\n          this.log(schedulingType, taskId, label, metadata, 'resolved', data);\n          return resolve(data);\n        }, err => {\n          this.log(schedulingType, taskId, label, metadata, 'rejected', err);\n          return reject(err);\n        });\n      };\n    });\n    this.scheduledTasks.push({\n      original: task,\n      scheduled: scheduledPromise,\n      trigger: trigger,\n      schedulingType,\n      taskId,\n      label,\n      metadata\n    });\n    return scheduledPromise;\n  }\n\n  schedule(task, label, metadata) {\n    return this.scheduleInternal('promise', label || '', task, metadata);\n  }\n\n  scheduleFunction(asyncFunction) {\n    return (...args) => this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify_1.stringify).join(',')})`, asyncFunction(...args), undefined);\n  }\n\n  scheduleSequence(sequenceBuilders) {\n    const status = {\n      done: false,\n      faulty: false\n    };\n    const dummyResolvedPromise = {\n      then: f => f()\n    };\n\n    let resolveSequenceTask = () => {};\n\n    const sequenceTask = new Promise(resolve => resolveSequenceTask = resolve);\n    sequenceBuilders.reduce((previouslyScheduled, item) => {\n      const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];\n      return previouslyScheduled.then(() => {\n        const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());\n        scheduled.catch(() => {\n          status.faulty = true;\n          resolveSequenceTask();\n        });\n        return scheduled;\n      });\n    }, dummyResolvedPromise).then(() => {\n      status.done = true;\n      resolveSequenceTask();\n    }, () => {});\n    return Object.assign(status, {\n      task: Promise.resolve(sequenceTask).then(() => {\n        return {\n          done: status.done,\n          faulty: status.faulty\n        };\n      })\n    });\n  }\n\n  count() {\n    return this.scheduledTasks.length;\n  }\n\n  internalWaitOne() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.scheduledTasks.length === 0) {\n        throw new Error('No task scheduled');\n      }\n\n      const taskIndex = _this.taskSelector.nextTaskIndex(_this.scheduledTasks);\n\n      const [scheduledTask] = _this.scheduledTasks.splice(taskIndex, 1);\n\n      scheduledTask.trigger();\n\n      try {\n        yield scheduledTask.scheduled;\n      } catch (_err) {}\n    })();\n  }\n\n  waitOne() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.act( /*#__PURE__*/_asyncToGenerator(function* () {\n        return yield _this2.internalWaitOne();\n      }));\n    })();\n  }\n\n  waitAll() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      while (_this3.scheduledTasks.length > 0) {\n        yield _this3.waitOne();\n      }\n    })();\n  }\n\n  report() {\n    return [...this.triggeredTasks, ...this.scheduledTasks.map(t => ({\n      status: 'pending',\n      schedulingType: t.schedulingType,\n      taskId: t.taskId,\n      label: t.label,\n      metadata: t.metadata\n    }))];\n  }\n\n  toString() {\n    return 'schedulerFor()`\\n' + this.report().map(SchedulerImplem.buildLog).map(log => `-> ${log}`).join('\\n') + '`';\n  }\n\n  [symbols_1.cloneMethod]() {\n    return new SchedulerImplem(this.act, this.sourceTaskSelector);\n  }\n\n}\n\nexports.SchedulerImplem = SchedulerImplem;","map":null,"metadata":{},"sourceType":"script"}