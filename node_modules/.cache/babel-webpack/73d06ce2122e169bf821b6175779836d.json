{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst b32 = require('multiformats/bases/base32');\n\nconst b36 = require('multiformats/bases/base36');\n\nconst b58 = require('multiformats/bases/base58');\n\nconst b64 = require('multiformats/bases/base64');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst {\n  base16\n} = require('multiformats/bases/base16');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst withIs = require('class-is');\n\nconst {\n  PeerIdProto\n} = require('./proto');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n\nconst bases = { ...b32,\n  ...b36,\n  ...b58,\n  ...b64\n};\nconst baseDecoder = Object.keys(bases).reduce((acc, curr) => acc.or(bases[curr]), base32.decoder); // these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\n\nconst DAG_PB_CODE = 0x70;\nconst LIBP2P_KEY_CODE = 0x72;\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided');\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = base58btc.encode(this.id).substring(1);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n\n    try {\n      const decoded = Digest.decode(this.id);\n\n      if (decoded.code === identity.code) {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return this._pubKey;\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  } // Return the protobuf version of the peer-id\n\n\n  marshal(excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    }).finish();\n  }\n\n  toPrint() {\n    let pid = this.toB58String(); // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n\n    let maxRunes = 6;\n\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return base16.encode(this.id).substring(1);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  } // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n\n  toString() {\n    if (!this._idCIDString) {\n      const cid = CID.createV1(LIBP2P_KEY_CODE, Digest.decode(this.id));\n      Object.defineProperty(this, '_idCIDString', {\n        value: cid.toString(),\n        enumerable: false\n      });\n    }\n\n    return this._idCIDString;\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  equals(id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.id, id);\n    } else if (id.id) {\n      return uint8ArrayEquals(this.id, id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @deprecated Use `.equals`\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  isEqual(id) {\n    return this.equals(id);\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid() {\n    // TODO: needs better checking\n    return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));\n  }\n  /**\n   * Check if the PeerId has an inline public key.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasInlinePublicKey() {\n    try {\n      const decoded = Digest.decode(this.id);\n\n      if (decoded.code === identity.code) {\n        return true;\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return false;\n  }\n\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nconst computeDigest = pubKey => {\n  if (pubKey.bytes.length <= 42) {\n    return Digest.create(identity.code, pubKey.bytes).bytes;\n  } else {\n    return pubKey.hash();\n  }\n};\n\nconst computePeerId = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (privKey, pubKey) {\n    const digest = yield computeDigest(pubKey);\n    return new PeerIdWithIs(digest, privKey, pubKey);\n  });\n\n  return function computePeerId(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // generation\n\n\nexports.create = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (opts) {\n    opts = opts || {};\n    opts.bits = opts.bits || 2048;\n    opts.keyType = opts.keyType || 'RSA';\n    const key = yield cryptoKeys.generateKeyPair(opts.keyType, opts.bits);\n    return computePeerId(key, key.public);\n  });\n\n  return function (_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.createFromHexString = str => {\n  return new PeerIdWithIs(base16.decode('f' + str));\n};\n\nexports.createFromBytes = buf => {\n  try {\n    const cid = CID.decode(buf);\n\n    if (!validMulticodec(cid)) {\n      throw new Error('Supplied PeerID CID is invalid');\n    }\n\n    return exports.createFromCID(cid);\n  } catch {\n    const digest = Digest.decode(buf);\n\n    if (digest.code !== identity.code) {\n      throw new Error('Supplied PeerID CID is invalid');\n    }\n\n    return new PeerIdWithIs(buf);\n  }\n};\n\nexports.createFromB58String = str => {\n  return exports.createFromBytes(base58btc.decode('z' + str));\n};\n\nconst validMulticodec = cid => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE;\n};\n\nexports.createFromCID = cid => {\n  cid = CID.asCID(cid);\n\n  if (!cid || !validMulticodec(cid)) {\n    throw new Error('Supplied PeerID CID is invalid');\n  }\n\n  return new PeerIdWithIs(cid.multihash.bytes);\n}; // Public Key input will be a Uint8Array\n\n\nexports.createFromPubKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (key) {\n    let buf = key;\n\n    if (typeof buf === 'string') {\n      buf = uint8ArrayFromString(key, 'base64pad');\n    }\n\n    if (!(buf instanceof Uint8Array)) {\n      throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n    }\n\n    const pubKey = yield cryptoKeys.unmarshalPublicKey(buf);\n    return computePeerId(undefined, pubKey);\n  });\n\n  return function (_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // Private key input will be a string\n\n\nexports.createFromPrivKey = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (key) {\n    if (typeof key === 'string') {\n      key = uint8ArrayFromString(key, 'base64pad');\n    }\n\n    if (!(key instanceof Uint8Array)) {\n      throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n    }\n\n    const privKey = yield cryptoKeys.unmarshalPrivateKey(key);\n    return computePeerId(privKey, privKey.public);\n  });\n\n  return function (_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.createFromJSON = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (obj) {\n    const id = base58btc.decode('z' + obj.id);\n    const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad');\n    const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad');\n    const pub = rawPubKey && (yield cryptoKeys.unmarshalPublicKey(rawPubKey));\n\n    if (!rawPrivKey) {\n      return new PeerIdWithIs(id, undefined, pub);\n    }\n\n    const privKey = yield cryptoKeys.unmarshalPrivateKey(rawPrivKey);\n    const privDigest = yield computeDigest(privKey.public);\n    let pubDigest;\n\n    if (pub) {\n      pubDigest = yield computeDigest(pub);\n    }\n\n    if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {\n      throw new Error('Public and private key do not match');\n    }\n\n    if (id && !uint8ArrayEquals(privDigest, id)) {\n      throw new Error('Id and private key do not match');\n    }\n\n    return new PeerIdWithIs(id, privKey, pub);\n  });\n\n  return function (_x6) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.createFromProtobuf = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator(function* (buf) {\n    if (typeof buf === 'string') {\n      buf = uint8ArrayFromString(buf, 'base16');\n    }\n\n    let {\n      id,\n      privKey,\n      pubKey\n    } = PeerIdProto.decode(buf);\n    privKey = privKey ? yield cryptoKeys.unmarshalPrivateKey(privKey) : false;\n    pubKey = pubKey ? yield cryptoKeys.unmarshalPublicKey(pubKey) : false;\n    let pubDigest;\n    let privDigest;\n\n    if (privKey) {\n      privDigest = yield computeDigest(privKey.public);\n    }\n\n    if (pubKey) {\n      pubDigest = yield computeDigest(pubKey);\n    }\n\n    if (privKey) {\n      if (pubKey) {\n        if (!uint8ArrayEquals(privDigest, pubDigest)) {\n          throw new Error('Public and private key do not match');\n        }\n      }\n\n      return new PeerIdWithIs(privDigest, privKey, privKey.public);\n    } // TODO: val id and pubDigest\n\n\n    if (pubKey) {\n      return new PeerIdWithIs(pubDigest, undefined, pubKey);\n    }\n\n    if (id) {\n      return new PeerIdWithIs(id);\n    }\n\n    throw new Error('Protobuf did not contain any usable key material');\n  });\n\n  return function (_x7) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nexports.parse = str => {\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519 key or sha2-256 hash of rsa public key\n    // base58btc encoded either way\n    str = `z${str}`;\n  }\n\n  return exports.createFromBytes(baseDecoder.decode(str));\n};\n\nexports.isPeerId = peerId => {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad');\n  }\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/peer-id/src/index.js"],"names":["CID","require","b32","b36","b58","b64","base58btc","base32","base16","Digest","cryptoKeys","withIs","PeerIdProto","equals","uint8ArrayEquals","fromString","uint8ArrayFromString","toString","uint8ArrayToString","identity","bases","baseDecoder","Object","keys","reduce","acc","curr","or","decoder","DAG_PB_CODE","LIBP2P_KEY_CODE","PeerId","constructor","id","privKey","pubKey","Uint8Array","Error","public","bytes","_id","_idB58String","encode","substring","_privKey","_pubKey","val","decoded","decode","code","unmarshalPublicKey","digest","_","marshalPubKey","marshalPublicKey","marshalPrivKey","marshalPrivateKey","marshal","excludePriv","toBytes","finish","toPrint","pid","toB58String","startsWith","slice","maxRunes","length","substr","toJSON","toB64Opt","toHexString","_idCIDString","cid","createV1","defineProperty","value","enumerable","isEqual","isValid","Boolean","hasInlinePublicKey","PeerIdWithIs","className","symbolName","exports","module","computeDigest","create","hash","computePeerId","opts","bits","keyType","key","generateKeyPair","createFromHexString","str","createFromBytes","buf","validMulticodec","createFromCID","createFromB58String","asCID","multihash","createFromPubKey","undefined","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","privDigest","pubDigest","createFromProtobuf","parse","charAt","isPeerId","peerId"],"mappings":"AAAA;AACA;AACA;AAEA;;;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAUC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,2BAAD,CAAnB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,2BAAD,CAAnB;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,2BAAD,CAAnB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,2BAAD,CAAnB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAgBL,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAAaN,OAAO,CAAC,2BAAD,CAA1B;;AACA,MAAM;AAAEO,EAAAA;AAAF,IAAaP,OAAO,CAAC,2BAAD,CAA1B;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,4BAAD,CAAtB;;AACA,MAAMS,UAAU,GAAGT,OAAO,CAAC,wBAAD,CAA1B;;AACA,MAAMU,MAAM,GAAGV,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAM;AAAEW,EAAAA;AAAF,IAAkBX,OAAO,CAAC,SAAD,CAA/B;;AACA,MAAM;AAAEY,EAAAA,MAAM,EAAEC;AAAV,IAA+Bb,OAAO,CAAC,oBAAD,CAA5C;;AACA,MAAM;AAAEc,EAAAA,UAAU,EAAEC;AAAd,IAAuCf,OAAO,CAAC,yBAAD,CAApD;;AACA,MAAM;AAAEgB,EAAAA,QAAQ,EAAEC;AAAZ,IAAmCjB,OAAO,CAAC,uBAAD,CAAhD;;AACA,MAAM;AAAEkB,EAAAA;AAAF,IAAelB,OAAO,CAAC,8BAAD,CAA5B;;AAEA,MAAMmB,KAAK,GAAG,EACZ,GAAGlB,GADS;AAEZ,KAAGC,GAFS;AAGZ,KAAGC,GAHS;AAIZ,KAAGC;AAJS,CAAd;AAMA,MAAMgB,WAAW,GAAGC,MAAM,CAACC,IAAP,CAAYH,KAAZ,EAAmBI,MAAnB,CAClB,CAACC,GAAD,EAAMC,IAAN,KAAeD,GAAG,CAACE,EAAJ,CAAOP,KAAK,CAACM,IAAD,CAAZ,CADG,EAElBnB,MAAM,CAACqB,OAFW,CAApB,C,CAKA;;AACA,MAAMC,WAAW,GAAG,IAApB;AACA,MAAMC,eAAe,GAAG,IAAxB;;AAEA,MAAMC,MAAN,CAAa;AACXC,EAAAA,WAAW,CAAEC,EAAF,EAAMC,OAAN,EAAeC,MAAf,EAAuB;AAChC,QAAI,EAAEF,EAAE,YAAYG,UAAhB,CAAJ,EAAiC;AAC/B,YAAM,IAAIC,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,QAAIH,OAAO,IAAIC,MAAX,IAAqB,CAACrB,gBAAgB,CAACoB,OAAO,CAACI,MAAR,CAAeC,KAAhB,EAAuBJ,MAAM,CAACI,KAA9B,CAA1C,EAAgF;AAC9E,YAAM,IAAIF,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,SAAKG,GAAL,GAAWP,EAAX;AACA,SAAKQ,YAAL,GAAoBnC,SAAS,CAACoC,MAAV,CAAiB,KAAKT,EAAtB,EAA0BU,SAA1B,CAAoC,CAApC,CAApB;AACA,SAAKC,QAAL,GAAgBV,OAAhB;AACA,SAAKW,OAAL,GAAeV,MAAf;AACD;;AAEK,MAAFF,EAAE,GAAI;AACR,WAAO,KAAKO,GAAZ;AACD;;AAEK,MAAFP,EAAE,CAAEa,GAAF,EAAO;AACX,UAAM,IAAIT,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAEU,MAAPH,OAAO,GAAI;AACb,WAAO,KAAKU,QAAZ;AACD;;AAEU,MAAPV,OAAO,CAAEA,OAAF,EAAW;AACpB,SAAKU,QAAL,GAAgBV,OAAhB;AACD;;AAES,MAANC,MAAM,GAAI;AACZ,QAAI,KAAKU,OAAT,EAAkB;AAChB,aAAO,KAAKA,OAAZ;AACD;;AAED,QAAI,KAAKD,QAAT,EAAmB;AACjB,aAAO,KAAKA,QAAL,CAAcN,MAArB;AACD;;AAED,QAAI;AACF,YAAMS,OAAO,GAAGtC,MAAM,CAACuC,MAAP,CAAc,KAAKf,EAAnB,CAAhB;;AAEA,UAAIc,OAAO,CAACE,IAAR,KAAiB9B,QAAQ,CAAC8B,IAA9B,EAAoC;AAClC,aAAKJ,OAAL,GAAenC,UAAU,CAACwC,kBAAX,CAA8BH,OAAO,CAACI,MAAtC,CAAf;AACD;AACF,KAND,CAME,OAAOC,CAAP,EAAU,CACV;AACD;;AAED,WAAO,KAAKP,OAAZ;AACD;;AAES,MAANV,MAAM,CAAEA,MAAF,EAAU;AAClB,SAAKU,OAAL,GAAeV,MAAf;AACD,GAxDU,CA0DX;;;AACAkB,EAAAA,aAAa,GAAI;AACf,QAAI,KAAKlB,MAAT,EAAiB;AACf,aAAOzB,UAAU,CAAC4C,gBAAX,CAA4B,KAAKnB,MAAjC,CAAP;AACD;AACF,GA/DU,CAiEX;;;AACAoB,EAAAA,cAAc,GAAI;AAChB,QAAI,KAAKrB,OAAT,EAAkB;AAChB,aAAOxB,UAAU,CAAC8C,iBAAX,CAA6B,KAAKtB,OAAlC,CAAP;AACD;AACF,GAtEU,CAwEX;;;AACAuB,EAAAA,OAAO,CAAEC,WAAF,EAAe;AACpB,WAAO9C,WAAW,CAAC8B,MAAZ,CAAmB;AACxBT,MAAAA,EAAE,EAAE,KAAK0B,OAAL,EADoB;AAExBxB,MAAAA,MAAM,EAAE,KAAKkB,aAAL,EAFgB;AAGxBnB,MAAAA,OAAO,EAAEwB,WAAW,GAAG,IAAH,GAAU,KAAKH,cAAL;AAHN,KAAnB,EAIJK,MAJI,EAAP;AAKD;;AAEDC,EAAAA,OAAO,GAAI;AACT,QAAIC,GAAG,GAAG,KAAKC,WAAL,EAAV,CADS,CAET;AACA;;AACA,QAAID,GAAG,CAACE,UAAJ,CAAe,IAAf,CAAJ,EAA0B;AACxBF,MAAAA,GAAG,GAAGA,GAAG,CAACG,KAAJ,CAAU,CAAV,CAAN;AACD;;AACD,QAAIC,QAAQ,GAAG,CAAf;;AACA,QAAIJ,GAAG,CAACK,MAAJ,GAAaD,QAAjB,EAA2B;AACzBA,MAAAA,QAAQ,GAAGJ,GAAG,CAACK,MAAf;AACD;;AAED,WAAO,cAAcL,GAAG,CAACM,MAAJ,CAAW,CAAX,EAAcF,QAAd,CAAd,GAAwC,GAA/C;AACD,GA9FU,CAgGX;AACA;;;AACAG,EAAAA,MAAM,GAAI;AACR,WAAO;AACLpC,MAAAA,EAAE,EAAE,KAAK8B,WAAL,EADC;AAEL7B,MAAAA,OAAO,EAAEoC,QAAQ,CAAC,KAAKf,cAAL,EAAD,CAFZ;AAGLpB,MAAAA,MAAM,EAAEmC,QAAQ,CAAC,KAAKjB,aAAL,EAAD;AAHX,KAAP;AAKD,GAxGU,CA0GX;;;AACAkB,EAAAA,WAAW,GAAI;AACb,WAAO/D,MAAM,CAACkC,MAAP,CAAc,KAAKT,EAAnB,EAAuBU,SAAvB,CAAiC,CAAjC,CAAP;AACD;;AAEDgB,EAAAA,OAAO,GAAI;AACT,WAAO,KAAK1B,EAAZ;AACD;;AAED8B,EAAAA,WAAW,GAAI;AACb,WAAO,KAAKtB,YAAZ;AACD,GArHU,CAuHX;AACA;;;AACAxB,EAAAA,QAAQ,GAAI;AACV,QAAI,CAAC,KAAKuD,YAAV,EAAwB;AACtB,YAAMC,GAAG,GAAGzE,GAAG,CAAC0E,QAAJ,CAAa5C,eAAb,EAA8BrB,MAAM,CAACuC,MAAP,CAAc,KAAKf,EAAnB,CAA9B,CAAZ;AAEAX,MAAAA,MAAM,CAACqD,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;AAC1CC,QAAAA,KAAK,EAAEH,GAAG,CAACxD,QAAJ,EADmC;AAE1C4D,QAAAA,UAAU,EAAE;AAF8B,OAA5C;AAID;;AACD,WAAO,KAAKL,YAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE3D,EAAAA,MAAM,CAAEoB,EAAF,EAAM;AACV,QAAIA,EAAE,YAAYG,UAAlB,EAA8B;AAC5B,aAAOtB,gBAAgB,CAAC,KAAKmB,EAAN,EAAUA,EAAV,CAAvB;AACD,KAFD,MAEO,IAAIA,EAAE,CAACA,EAAP,EAAW;AAChB,aAAOnB,gBAAgB,CAAC,KAAKmB,EAAN,EAAUA,EAAE,CAACA,EAAb,CAAvB;AACD,KAFM,MAEA;AACL,YAAM,IAAII,KAAJ,CAAU,cAAV,CAAN;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEyC,EAAAA,OAAO,CAAE7C,EAAF,EAAM;AACX,WAAO,KAAKpB,MAAL,CAAYoB,EAAZ,CAAP;AACD;AAED;AACF;AACA;;;AACE8C,EAAAA,OAAO,GAAI;AACT;AACA,WAAOC,OAAO,CAAC,KAAK9C,OAAL,IACb,KAAKA,OAAL,CAAaI,MADA,IAEb,KAAKJ,OAAL,CAAaI,MAAb,CAAoBC,KAFP,IAGb,KAAKJ,MAAL,CAAYI,KAAZ,YAA6BH,UAHhB,IAIXtB,gBAAgB,CAAC,KAAKoB,OAAL,CAAaI,MAAb,CAAoBC,KAArB,EAA4B,KAAKJ,MAAL,CAAYI,KAAxC,CAJN,CAAd;AAKD;AAED;AACF;AACA;AACA;AACA;;;AACE0C,EAAAA,kBAAkB,GAAI;AACpB,QAAI;AACF,YAAMlC,OAAO,GAAGtC,MAAM,CAACuC,MAAP,CAAc,KAAKf,EAAnB,CAAhB;;AAEA,UAAIc,OAAO,CAACE,IAAR,KAAiB9B,QAAQ,CAAC8B,IAA9B,EAAoC;AAClC,eAAO,IAAP;AACD;AACF,KAND,CAME,OAAOG,CAAP,EAAU,CACV;AACD;;AAED,WAAO,KAAP;AACD;;AA7LU;;AAgMb,MAAM8B,YAAY,GAAGvE,MAAM,CAACoB,MAAD,EAAS;AAClCoD,EAAAA,SAAS,EAAE,QADuB;AAElCC,EAAAA,UAAU,EAAE;AAFsB,CAAT,CAA3B;AAKAC,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBH,YAA3B;;AAEA,MAAMK,aAAa,GAAIpD,MAAD,IAAY;AAChC,MAAIA,MAAM,CAACI,KAAP,CAAa4B,MAAb,IAAuB,EAA3B,EAA+B;AAC7B,WAAO1D,MAAM,CAAC+E,MAAP,CAAcrE,QAAQ,CAAC8B,IAAvB,EAA6Bd,MAAM,CAACI,KAApC,EAA2CA,KAAlD;AACD,GAFD,MAEO;AACL,WAAOJ,MAAM,CAACsD,IAAP,EAAP;AACD;AACF,CAND;;AAQA,MAAMC,aAAa;AAAA,+BAAG,WAAOxD,OAAP,EAAgBC,MAAhB,EAA2B;AAC/C,UAAMgB,MAAM,SAASoC,aAAa,CAACpD,MAAD,CAAlC;AACA,WAAO,IAAI+C,YAAJ,CAAiB/B,MAAjB,EAAyBjB,OAAzB,EAAkCC,MAAlC,CAAP;AACD,GAHkB;;AAAA,kBAAbuD,aAAa;AAAA;AAAA;AAAA,GAAnB,C,CAKA;;;AACAL,OAAO,CAACG,MAAR;AAAA,gCAAiB,WAAOG,IAAP,EAAgB;AAC/BA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,IAAAA,IAAI,CAACC,IAAL,GAAYD,IAAI,CAACC,IAAL,IAAa,IAAzB;AACAD,IAAAA,IAAI,CAACE,OAAL,GAAeF,IAAI,CAACE,OAAL,IAAgB,KAA/B;AAEA,UAAMC,GAAG,SAASpF,UAAU,CAACqF,eAAX,CAA2BJ,IAAI,CAACE,OAAhC,EAAyCF,IAAI,CAACC,IAA9C,CAAlB;AACA,WAAOF,aAAa,CAACI,GAAD,EAAMA,GAAG,CAACxD,MAAV,CAApB;AACD,GAPD;;AAAA;AAAA;AAAA;AAAA;;AASA+C,OAAO,CAACW,mBAAR,GAA+BC,GAAD,IAAS;AACrC,SAAO,IAAIf,YAAJ,CAAiB1E,MAAM,CAACwC,MAAP,CAAc,MAAMiD,GAApB,CAAjB,CAAP;AACD,CAFD;;AAIAZ,OAAO,CAACa,eAAR,GAA2BC,GAAD,IAAS;AACjC,MAAI;AACF,UAAM1B,GAAG,GAAGzE,GAAG,CAACgD,MAAJ,CAAWmD,GAAX,CAAZ;;AAEA,QAAI,CAACC,eAAe,CAAC3B,GAAD,CAApB,EAA2B;AACzB,YAAM,IAAIpC,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,WAAOgD,OAAO,CAACgB,aAAR,CAAsB5B,GAAtB,CAAP;AACD,GARD,CAQE,MAAM;AACN,UAAMtB,MAAM,GAAG1C,MAAM,CAACuC,MAAP,CAAcmD,GAAd,CAAf;;AAEA,QAAIhD,MAAM,CAACF,IAAP,KAAgB9B,QAAQ,CAAC8B,IAA7B,EAAmC;AACjC,YAAM,IAAIZ,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,WAAO,IAAI6C,YAAJ,CAAiBiB,GAAjB,CAAP;AACD;AACF,CAlBD;;AAoBAd,OAAO,CAACiB,mBAAR,GAA+BL,GAAD,IAAS;AACrC,SAAOZ,OAAO,CAACa,eAAR,CAAwB5F,SAAS,CAAC0C,MAAV,CAAiB,MAAMiD,GAAvB,CAAxB,CAAP;AACD,CAFD;;AAIA,MAAMG,eAAe,GAAI3B,GAAD,IAAS;AAC/B;AACA,SAAOA,GAAG,CAACxB,IAAJ,KAAanB,eAAb,IAAgC2C,GAAG,CAACxB,IAAJ,KAAapB,WAApD;AACD,CAHD;;AAKAwD,OAAO,CAACgB,aAAR,GAAyB5B,GAAD,IAAS;AAC/BA,EAAAA,GAAG,GAAGzE,GAAG,CAACuG,KAAJ,CAAU9B,GAAV,CAAN;;AAEA,MAAI,CAACA,GAAD,IAAQ,CAAC2B,eAAe,CAAC3B,GAAD,CAA5B,EAAmC;AACjC,UAAM,IAAIpC,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,SAAO,IAAI6C,YAAJ,CAAiBT,GAAG,CAAC+B,SAAJ,CAAcjE,KAA/B,CAAP;AACD,CARD,C,CAUA;;;AACA8C,OAAO,CAACoB,gBAAR;AAAA,gCAA2B,WAAOX,GAAP,EAAe;AACxC,QAAIK,GAAG,GAAGL,GAAV;;AAEA,QAAI,OAAOK,GAAP,KAAe,QAAnB,EAA6B;AAC3BA,MAAAA,GAAG,GAAGnF,oBAAoB,CAAC8E,GAAD,EAAM,WAAN,CAA1B;AACD;;AAED,QAAI,EAAEK,GAAG,YAAY/D,UAAjB,CAAJ,EAAkC;AAChC,YAAM,IAAIC,KAAJ,CAAU,0DAAV,CAAN;AACD;;AAED,UAAMF,MAAM,SAASzB,UAAU,CAACwC,kBAAX,CAA8BiD,GAA9B,CAArB;AACA,WAAOT,aAAa,CAACgB,SAAD,EAAYvE,MAAZ,CAApB;AACD,GAbD;;AAAA;AAAA;AAAA;AAAA,I,CAeA;;;AACAkD,OAAO,CAACsB,iBAAR;AAAA,gCAA4B,WAAOb,GAAP,EAAe;AACzC,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3BA,MAAAA,GAAG,GAAG9E,oBAAoB,CAAC8E,GAAD,EAAM,WAAN,CAA1B;AACD;;AAED,QAAI,EAAEA,GAAG,YAAY1D,UAAjB,CAAJ,EAAkC;AAChC,YAAM,IAAIC,KAAJ,CAAU,0DAAV,CAAN;AACD;;AAED,UAAMH,OAAO,SAASxB,UAAU,CAACkG,mBAAX,CAA+Bd,GAA/B,CAAtB;AACA,WAAOJ,aAAa,CAACxD,OAAD,EAAUA,OAAO,CAACI,MAAlB,CAApB;AACD,GAXD;;AAAA;AAAA;AAAA;AAAA;;AAaA+C,OAAO,CAACwB,cAAR;AAAA,gCAAyB,WAAOC,GAAP,EAAe;AACtC,UAAM7E,EAAE,GAAG3B,SAAS,CAAC0C,MAAV,CAAiB,MAAM8D,GAAG,CAAC7E,EAA3B,CAAX;AACA,UAAM8E,UAAU,GAAGD,GAAG,CAAC5E,OAAJ,IAAelB,oBAAoB,CAAC8F,GAAG,CAAC5E,OAAL,EAAc,WAAd,CAAtD;AACA,UAAM8E,SAAS,GAAGF,GAAG,CAAC3E,MAAJ,IAAcnB,oBAAoB,CAAC8F,GAAG,CAAC3E,MAAL,EAAa,WAAb,CAApD;AACA,UAAM8E,GAAG,GAAGD,SAAS,WAAUtG,UAAU,CAACwC,kBAAX,CAA8B8D,SAA9B,CAAV,CAArB;;AAEA,QAAI,CAACD,UAAL,EAAiB;AACf,aAAO,IAAI7B,YAAJ,CAAiBjD,EAAjB,EAAqByE,SAArB,EAAgCO,GAAhC,CAAP;AACD;;AAED,UAAM/E,OAAO,SAASxB,UAAU,CAACkG,mBAAX,CAA+BG,UAA/B,CAAtB;AACA,UAAMG,UAAU,SAAS3B,aAAa,CAACrD,OAAO,CAACI,MAAT,CAAtC;AAEA,QAAI6E,SAAJ;;AAEA,QAAIF,GAAJ,EAAS;AACPE,MAAAA,SAAS,SAAS5B,aAAa,CAAC0B,GAAD,CAA/B;AACD;;AAED,QAAIA,GAAG,IAAI,CAACnG,gBAAgB,CAACoG,UAAD,EAAaC,SAAb,CAA5B,EAAqD;AACnD,YAAM,IAAI9E,KAAJ,CAAU,qCAAV,CAAN;AACD;;AAED,QAAIJ,EAAE,IAAI,CAACnB,gBAAgB,CAACoG,UAAD,EAAajF,EAAb,CAA3B,EAA6C;AAC3C,YAAM,IAAII,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAED,WAAO,IAAI6C,YAAJ,CAAiBjD,EAAjB,EAAqBC,OAArB,EAA8B+E,GAA9B,CAAP;AACD,GA5BD;;AAAA;AAAA;AAAA;AAAA;;AA8BA5B,OAAO,CAAC+B,kBAAR;AAAA,gCAA6B,WAAOjB,GAAP,EAAe;AAC1C,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3BA,MAAAA,GAAG,GAAGnF,oBAAoB,CAACmF,GAAD,EAAM,QAAN,CAA1B;AACD;;AAED,QAAI;AAAElE,MAAAA,EAAF;AAAMC,MAAAA,OAAN;AAAeC,MAAAA;AAAf,QAA0BvB,WAAW,CAACoC,MAAZ,CAAmBmD,GAAnB,CAA9B;AAEAjE,IAAAA,OAAO,GAAGA,OAAO,SAASxB,UAAU,CAACkG,mBAAX,CAA+B1E,OAA/B,CAAT,GAAmD,KAApE;AACAC,IAAAA,MAAM,GAAGA,MAAM,SAASzB,UAAU,CAACwC,kBAAX,CAA8Bf,MAA9B,CAAT,GAAiD,KAAhE;AAEA,QAAIgF,SAAJ;AACA,QAAID,UAAJ;;AAEA,QAAIhF,OAAJ,EAAa;AACXgF,MAAAA,UAAU,SAAS3B,aAAa,CAACrD,OAAO,CAACI,MAAT,CAAhC;AACD;;AAED,QAAIH,MAAJ,EAAY;AACVgF,MAAAA,SAAS,SAAS5B,aAAa,CAACpD,MAAD,CAA/B;AACD;;AAED,QAAID,OAAJ,EAAa;AACX,UAAIC,MAAJ,EAAY;AACV,YAAI,CAACrB,gBAAgB,CAACoG,UAAD,EAAaC,SAAb,CAArB,EAA8C;AAC5C,gBAAM,IAAI9E,KAAJ,CAAU,qCAAV,CAAN;AACD;AACF;;AACD,aAAO,IAAI6C,YAAJ,CAAiBgC,UAAjB,EAA6BhF,OAA7B,EAAsCA,OAAO,CAACI,MAA9C,CAAP;AACD,KA5ByC,CA8B1C;;;AAEA,QAAIH,MAAJ,EAAY;AACV,aAAO,IAAI+C,YAAJ,CAAiBiC,SAAjB,EAA4BT,SAA5B,EAAuCvE,MAAvC,CAAP;AACD;;AAED,QAAIF,EAAJ,EAAQ;AACN,aAAO,IAAIiD,YAAJ,CAAiBjD,EAAjB,CAAP;AACD;;AAED,UAAM,IAAII,KAAJ,CAAU,kDAAV,CAAN;AACD,GAzCD;;AAAA;AAAA;AAAA;AAAA;;AA2CAgD,OAAO,CAACgC,KAAR,GAAiBpB,GAAD,IAAS;AACvB,MAAIA,GAAG,CAACqB,MAAJ,CAAW,CAAX,MAAkB,GAAlB,IAAyBrB,GAAG,CAACqB,MAAJ,CAAW,CAAX,MAAkB,GAA/C,EAAoD;AAClD;AACA;AACArB,IAAAA,GAAG,GAAI,IAAGA,GAAI,EAAd;AACD;;AAED,SAAOZ,OAAO,CAACa,eAAR,CAAwB7E,WAAW,CAAC2B,MAAZ,CAAmBiD,GAAnB,CAAxB,CAAP;AACD,CARD;;AAUAZ,OAAO,CAACkC,QAAR,GAAoBC,MAAD,IAAY;AAC7B,SAAOxC,OAAO,CAAC,OAAOwC,MAAP,KAAkB,QAAlB,IACbA,MAAM,CAAChF,GADM,IAEbgF,MAAM,CAAC/E,YAFK,CAAd;AAGD,CAJD;;AAMA,SAAS6B,QAAT,CAAmBxB,GAAnB,EAAwB;AACtB,MAAIA,GAAJ,EAAS;AACP,WAAO5B,kBAAkB,CAAC4B,GAAD,EAAM,WAAN,CAAzB;AACD;AACF","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst b32 = require('multiformats/bases/base32')\nconst b36 = require('multiformats/bases/base36')\nconst b58 = require('multiformats/bases/base58')\nconst b64 = require('multiformats/bases/base64')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { base32 } = require('multiformats/bases/base32')\nconst { base16 } = require('multiformats/bases/base16')\nconst Digest = require('multiformats/hashes/digest')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst withIs = require('class-is')\nconst { PeerIdProto } = require('./proto')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { identity } = require('multiformats/hashes/identity')\n\nconst bases = {\n  ...b32,\n  ...b36,\n  ...b58,\n  ...b64\n}\nconst baseDecoder = Object.keys(bases).reduce(\n  (acc, curr) => acc.or(bases[curr]),\n  base32.decoder\n)\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst DAG_PB_CODE = 0x70\nconst LIBP2P_KEY_CODE = 0x72\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided')\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = base58btc.encode(this.id).substring(1)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    try {\n      const decoded = Digest.decode(this.id)\n\n      if (decoded.code === identity.code) {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return this._pubKey\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // Return the protobuf version of the peer-id\n  marshal (excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    }).finish()\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return base16.encode(this.id).substring(1)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toString () {\n    if (!this._idCIDString) {\n      const cid = CID.createV1(LIBP2P_KEY_CODE, Digest.decode(this.id))\n\n      Object.defineProperty(this, '_idCIDString', {\n        value: cid.toString(),\n        enumerable: false\n      })\n    }\n    return this._idCIDString\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n  equals (id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.id, id)\n    } else if (id.id) {\n      return uint8ArrayEquals(this.id, id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @deprecated Use `.equals`\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n  isEqual (id) {\n    return this.equals(id)\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid () {\n    // TODO: needs better checking\n    return Boolean(this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      this.pubKey.bytes instanceof Uint8Array &&\n        uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes))\n  }\n\n  /**\n   * Check if the PeerId has an inline public key.\n   *\n   * @returns {boolean}\n   */\n  hasInlinePublicKey () {\n    try {\n      const decoded = Digest.decode(this.id)\n\n      if (decoded.code === identity.code) {\n        return true\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return false\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n})\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey) => {\n  if (pubKey.bytes.length <= 42) {\n    return Digest.create(identity.code, pubKey.bytes).bytes\n  } else {\n    return pubKey.hash()\n  }\n}\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey)\n  return new PeerIdWithIs(digest, privKey, pubKey)\n}\n\n// generation\nexports.create = async (opts) => {\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits)\n  return computePeerId(key, key.public)\n}\n\nexports.createFromHexString = (str) => {\n  return new PeerIdWithIs(base16.decode('f' + str))\n}\n\nexports.createFromBytes = (buf) => {\n  try {\n    const cid = CID.decode(buf)\n\n    if (!validMulticodec(cid)) {\n      throw new Error('Supplied PeerID CID is invalid')\n    }\n\n    return exports.createFromCID(cid)\n  } catch {\n    const digest = Digest.decode(buf)\n\n    if (digest.code !== identity.code) {\n      throw new Error('Supplied PeerID CID is invalid')\n    }\n\n    return new PeerIdWithIs(buf)\n  }\n}\n\nexports.createFromB58String = (str) => {\n  return exports.createFromBytes(base58btc.decode('z' + str))\n}\n\nconst validMulticodec = (cid) => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE\n}\n\nexports.createFromCID = (cid) => {\n  cid = CID.asCID(cid)\n\n  if (!cid || !validMulticodec(cid)) {\n    throw new Error('Supplied PeerID CID is invalid')\n  }\n\n  return new PeerIdWithIs(cid.multihash.bytes)\n}\n\n// Public Key input will be a Uint8Array\nexports.createFromPubKey = async (key) => {\n  let buf = key\n\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(key, 'base64pad')\n  }\n\n  if (!(buf instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array')\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf)\n  return computePeerId(undefined, pubKey)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = async (key) => {\n  if (typeof key === 'string') {\n    key = uint8ArrayFromString(key, 'base64pad')\n  }\n\n  if (!(key instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array')\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(key)\n  return computePeerId(privKey, privKey.public)\n}\n\nexports.createFromJSON = async (obj) => {\n  const id = base58btc.decode('z' + obj.id)\n  const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad')\n  const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad')\n  const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey)\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, undefined, pub)\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey)\n  const privDigest = await computeDigest(privKey.public)\n\n  let pubDigest\n\n  if (pub) {\n    pubDigest = await computeDigest(pub)\n  }\n\n  if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {\n    throw new Error('Public and private key do not match')\n  }\n\n  if (id && !uint8ArrayEquals(privDigest, id)) {\n    throw new Error('Id and private key do not match')\n  }\n\n  return new PeerIdWithIs(id, privKey, pub)\n}\n\nexports.createFromProtobuf = async (buf) => {\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(buf, 'base16')\n  }\n\n  let { id, privKey, pubKey } = PeerIdProto.decode(buf)\n\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false\n\n  let pubDigest\n  let privDigest\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public)\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey)\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!uint8ArrayEquals(privDigest, pubDigest)) {\n        throw new Error('Public and private key do not match')\n      }\n    }\n    return new PeerIdWithIs(privDigest, privKey, privKey.public)\n  }\n\n  // TODO: val id and pubDigest\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, undefined, pubKey)\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id)\n  }\n\n  throw new Error('Protobuf did not contain any usable key material')\n}\n\nexports.parse = (str) => {\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519 key or sha2-256 hash of rsa public key\n    // base58btc encoded either way\n    str = `z${str}`\n  }\n\n  return exports.createFromBytes(baseDecoder.decode(str))\n}\n\nexports.isPeerId = (peerId) => {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}