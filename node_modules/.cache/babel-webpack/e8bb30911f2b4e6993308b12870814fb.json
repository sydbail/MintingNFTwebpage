{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst IPNS = require('../ipns');\n\nconst routingConfig = require('../ipns/routing/config');\n\nconst OfflineDatastore = require('../ipns/routing/offline-datastore');\n\nconst {\n  NotInitializedError,\n  AlreadyInitializedError\n} = require('../errors');\n\nconst log = require('debug')('ipfs:components:ipns');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n *\n * @typedef {Object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {Object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {Object} DHTConfig\n * @property {boolean} [enabled]\n */\n\n\nclass IPNSAPI {\n  /**\n   * @param {Object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor(options = {\n    pass: ''\n  }) {\n    this.options = options;\n    /** @type {IPNS | null} */\n\n    this.offline = null;\n    /** @type {IPNS | null} */\n\n    this.online = null;\n  }\n\n  getIPNS() {\n    const ipns = this.online || this.offline;\n\n    if (ipns) {\n      return ipns;\n    } else {\n      throw new NotInitializedError();\n    }\n  }\n\n  get routing() {\n    return this.getIPNS().routing;\n  }\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {Object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('peer-id')} config.peerId\n   * @param {import('libp2p/src/keychain')} config.keychain\n   */\n\n\n  startOffline({\n    repo,\n    peerId,\n    keychain\n  }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError();\n    }\n\n    log('initializing IPNS keyspace');\n    const routing = new OfflineDatastore(repo);\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n    this.offline = ipns;\n  }\n  /**\n   * @param {Object} config\n   * @param {import('libp2p')} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('peer-id')} config.peerId\n   * @param {import('libp2p/src/keychain')} config.keychain\n   */\n\n\n  startOnline({\n    libp2p,\n    repo,\n    peerId,\n    keychain\n  }) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.online != null) {\n        throw new AlreadyInitializedError();\n      }\n\n      const routing = routingConfig({\n        libp2p,\n        repo,\n        peerId,\n        options: _this.options\n      }); // @ts-ignore routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n\n      const ipns = new IPNS(routing, repo.datastore, peerId, keychain, _this.options);\n      yield ipns.republisher.start();\n      _this.online = ipns;\n    })();\n  }\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const ipns = _this2.online;\n\n      if (ipns) {\n        yield ipns.republisher.stop();\n        _this2.online = null;\n      }\n    })();\n  }\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  publish(privKey, value, lifetime) {\n    return this.getIPNS().publish(privKey, value, lifetime);\n  }\n  /**\n   *\n   * @param {string} name\n   * @param {*} [options]\n   */\n\n\n  resolve(name, options) {\n    return this.getIPNS().resolve(name, options);\n  }\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n\n\n  initializeKeyspace(privKey, value) {\n    return this.getIPNS().initializeKeyspace(privKey, value);\n  }\n\n}\n\nmodule.exports = IPNSAPI;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/components/ipns.js"],"names":["IPNS","require","routingConfig","OfflineDatastore","NotInitializedError","AlreadyInitializedError","log","IPNSAPI","constructor","options","pass","offline","online","getIPNS","ipns","routing","startOffline","repo","peerId","keychain","datastore","startOnline","libp2p","republisher","start","stop","publish","privKey","value","lifetime","resolve","name","initializeKeyspace","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst IPNS = require('../ipns')\nconst routingConfig = require('../ipns/routing/config')\nconst OfflineDatastore = require('../ipns/routing/offline-datastore')\nconst { NotInitializedError, AlreadyInitializedError } = require('../errors')\nconst log = require('debug')('ipfs:components:ipns')\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n *\n * @typedef {Object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {Object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {Object} DHTConfig\n * @property {boolean} [enabled]\n */\n\nclass IPNSAPI {\n  /**\n   * @param {Object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor (options = { pass: '' }) {\n    this.options = options\n\n    /** @type {IPNS | null} */\n    this.offline = null\n\n    /** @type {IPNS | null} */\n    this.online = null\n  }\n\n  getIPNS () {\n    const ipns = this.online || this.offline\n    if (ipns) {\n      return ipns\n    } else {\n      throw new NotInitializedError()\n    }\n  }\n\n  get routing () {\n    return this.getIPNS().routing\n  }\n\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {Object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('peer-id')} config.peerId\n   * @param {import('libp2p/src/keychain')} config.keychain\n   */\n  startOffline ({ repo, peerId, keychain }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError()\n    }\n\n    log('initializing IPNS keyspace')\n\n    const routing = new OfflineDatastore(repo)\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n\n    this.offline = ipns\n  }\n\n  /**\n   * @param {Object} config\n   * @param {import('libp2p')} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('peer-id')} config.peerId\n   * @param {import('libp2p/src/keychain')} config.keychain\n   */\n  async startOnline ({ libp2p, repo, peerId, keychain }) {\n    if (this.online != null) {\n      throw new AlreadyInitializedError()\n    }\n    const routing = routingConfig({ libp2p, repo, peerId, options: this.options })\n\n    // @ts-ignore routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n    await ipns.republisher.start()\n    this.online = ipns\n  }\n\n  async stop () {\n    const ipns = this.online\n    if (ipns) {\n      await ipns.republisher.stop()\n      this.online = null\n    }\n  }\n\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n  publish (privKey, value, lifetime) {\n    return this.getIPNS().publish(privKey, value, lifetime)\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @param {*} [options]\n   */\n  resolve (name, options) {\n    return this.getIPNS().resolve(name, options)\n  }\n\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n  initializeKeyspace (privKey, value) {\n    return this.getIPNS().initializeKeyspace(privKey, value)\n  }\n}\nmodule.exports = IPNSAPI\n"]},"metadata":{},"sourceType":"script"}