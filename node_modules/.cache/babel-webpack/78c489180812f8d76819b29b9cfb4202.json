{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst readme = require('./shard-readme');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./types').Shard} Shard\n */\n\n\nconst PREFIX = '/repo/flatfs/shard/';\nconst SHARDING_FN = 'SHARDING';\nconst README_FN = '_README';\n/**\n * @implements {Shard}\n */\n\nclass ShardBase {\n  /**\n   * @param {any} param\n   */\n  constructor(param) {\n    this.param = param;\n    this.name = 'base';\n    this._padding = '';\n  }\n  /**\n   * @param {string} s\n   */\n\n\n  fun(s) {\n    return 'implement me';\n  }\n\n  toString() {\n    return `${PREFIX}v1/${this.name}/${this.param}`;\n  }\n\n}\n/**\n * @implements {Shard}\n */\n\n\nclass Prefix extends ShardBase {\n  /**\n   * @param {number} prefixLen\n   */\n  constructor(prefixLen) {\n    super(prefixLen);\n    this._padding = ''.padStart(prefixLen, '_');\n    this.name = 'prefix';\n  }\n  /**\n   * @param {string} noslash\n   */\n\n\n  fun(noslash) {\n    return (noslash + this._padding).slice(0, this.param);\n  }\n\n}\n\nclass Suffix extends ShardBase {\n  /**\n   * @param {number} suffixLen\n   */\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen, '_');\n    this.name = 'suffix';\n  }\n  /**\n   * @param {string} noslash\n   */\n\n\n  fun(noslash) {\n    const s = this._padding + noslash;\n    return s.slice(s.length - this.param);\n  }\n\n}\n\nclass NextToLast extends ShardBase {\n  /**\n   * @param {number} suffixLen\n   */\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen + 1, '_');\n    this.name = 'next-to-last';\n  }\n  /**\n   * @param {string} noslash\n   */\n\n\n  fun(noslash) {\n    const s = this._padding + noslash;\n    const offset = s.length - this.param - 1;\n    return s.slice(offset, offset + this.param);\n  }\n\n}\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {Shard}\n */\n\n\nfunction parseShardFun(str) {\n  str = str.trim();\n\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`);\n  }\n\n  const parts = str.slice(PREFIX.length).split('/');\n  const version = parts[0];\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`);\n  }\n\n  const name = parts[1];\n\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n\n  const param = parseInt(parts[2], 10);\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param);\n\n    case 'suffix':\n      return new Suffix(param);\n\n    case 'next-to-last':\n      return new NextToLast(param);\n\n    default:\n      throw new Error(`unkown sharding function: ${name}`);\n  }\n}\n/**\n * @param {string | Uint8Array} path\n * @param {Datastore} store\n */\n\n\nconst readShardFun = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path, store) {\n    const key = new Key(path).child(new Key(SHARDING_FN)); // @ts-ignore\n\n    const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n    const res = yield get(key);\n    return parseShardFun(new TextDecoder().decode(res || '').trim());\n  });\n\n  return function readShardFun(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = {\n  readme,\n  parseShardFun,\n  readShardFun,\n  Prefix,\n  Suffix,\n  NextToLast,\n  README_FN,\n  SHARDING_FN,\n  PREFIX\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/datastore-core/src/shard.js"],"names":["Key","require","readme","PREFIX","SHARDING_FN","README_FN","ShardBase","constructor","param","name","_padding","fun","s","toString","Prefix","prefixLen","padStart","noslash","slice","Suffix","suffixLen","length","NextToLast","offset","parseShardFun","str","trim","Error","startsWith","parts","split","version","parseInt","readShardFun","path","store","key","child","get","getRaw","bind","res","TextDecoder","decode","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst readme = require('./shard-readme')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./types').Shard} Shard\n */\n\nconst PREFIX = '/repo/flatfs/shard/'\nconst SHARDING_FN = 'SHARDING'\nconst README_FN = '_README'\n\n/**\n * @implements {Shard}\n */\nclass ShardBase {\n  /**\n   * @param {any} param\n   */\n  constructor (param) {\n    this.param = param\n    this.name = 'base'\n    this._padding = ''\n  }\n\n  /**\n   * @param {string} s\n   */\n  fun (s) {\n    return 'implement me'\n  }\n\n  toString () {\n    return `${PREFIX}v1/${this.name}/${this.param}`\n  }\n}\n/**\n * @implements {Shard}\n */\nclass Prefix extends ShardBase {\n  /**\n   * @param {number} prefixLen\n   */\n  constructor (prefixLen) {\n    super(prefixLen)\n    this._padding = ''.padStart(prefixLen, '_')\n    this.name = 'prefix'\n  }\n\n  /**\n   * @param {string} noslash\n   */\n  fun (noslash) {\n    return (noslash + this._padding).slice(0, this.param)\n  }\n}\n\nclass Suffix extends ShardBase {\n  /**\n   * @param {number} suffixLen\n   */\n  constructor (suffixLen) {\n    super(suffixLen)\n    this._padding = ''.padStart(suffixLen, '_')\n    this.name = 'suffix'\n  }\n\n  /**\n   * @param {string} noslash\n   */\n  fun (noslash) {\n    const s = this._padding + noslash\n    return s.slice(s.length - this.param)\n  }\n}\n\nclass NextToLast extends ShardBase {\n  /**\n   * @param {number} suffixLen\n   */\n  constructor (suffixLen) {\n    super(suffixLen)\n    this._padding = ''.padStart(suffixLen + 1, '_')\n    this.name = 'next-to-last'\n  }\n\n  /**\n   * @param {string} noslash\n   */\n  fun (noslash) {\n    const s = this._padding + noslash\n    const offset = s.length - this.param - 1\n    return s.slice(offset, offset + this.param)\n  }\n}\n\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {Shard}\n */\nfunction parseShardFun (str) {\n  str = str.trim()\n\n  if (str.length === 0) {\n    throw new Error('empty shard string')\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`)\n  }\n\n  const parts = str.slice(PREFIX.length).split('/')\n  const version = parts[0]\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`)\n  }\n\n  const name = parts[1]\n\n  if (!parts[2]) {\n    throw new Error('missing param')\n  }\n\n  const param = parseInt(parts[2], 10)\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param)\n    case 'suffix':\n      return new Suffix(param)\n    case 'next-to-last':\n      return new NextToLast(param)\n    default:\n      throw new Error(`unkown sharding function: ${name}`)\n  }\n}\n\n/**\n * @param {string | Uint8Array} path\n * @param {Datastore} store\n */\nconst readShardFun = async (path, store) => {\n  const key = new Key(path).child(new Key(SHARDING_FN))\n  // @ts-ignore\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store)\n  const res = await get(key)\n  return parseShardFun(new TextDecoder().decode(res || '').trim())\n}\n\nmodule.exports = {\n  readme,\n  parseShardFun,\n  readShardFun,\n  Prefix,\n  Suffix,\n  NextToLast,\n  README_FN,\n  SHARDING_FN,\n  PREFIX\n}\n"]},"metadata":{},"sourceType":"script"}