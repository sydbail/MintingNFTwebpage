{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst drain = require('it-drain');\n\nconst pushable = require('it-pushable');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst raw = require('multiformats/codecs/raw');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst {\n  base32,\n  base32pad\n} = require('multiformats/bases/base32');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst errcode = require('err-code');\n\nconst {\n  BlockstoreAdapter\n} = require('interface-blockstore');\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\n\n\nfunction cidToKey(cid) {\n  if (!(cid instanceof CID)) {\n    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  return new Key('/' + base32.encode(cid.multihash.bytes).slice(1).toUpperCase(), false);\n}\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n * @returns {CID}\n */\n\n\nfunction keyToCid(key) {\n  // Block key is of the form <base32 encoded string>\n  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())));\n}\n/**\n * Tries to decode a prefix as the first part of a CID and then\n * strip off the version and codec bytes to just leave part of\n * the multihash.\n *\n * Only really works if the prefix length aligns with the byte\n * boundaries of the encoding.\n *\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction convertPrefix(prefix) {\n  let bytes;\n  const firstChar = prefix.substring(0, 1);\n\n  if (firstChar === '/') {\n    return convertPrefix(prefix.substring(1));\n  }\n\n  if (firstChar.toLowerCase() === 'b') {\n    // v1 cid prefix, remove version and codec bytes\n    bytes = base32.decode(prefix.toLowerCase()).subarray(2);\n  } else if (firstChar.toLowerCase() === 'c') {\n    // v1 cid prefix, remove version and codec bytes\n    bytes = base32pad.decode(prefix.toLowerCase()).subarray(2);\n  } else if (firstChar === 'z') {\n    // v1 cid\n    bytes = base58btc.decode(prefix).subarray(2);\n  } else if (firstChar === 'Q') {\n    // v0 cid prefix\n    bytes = base58btc.decode('z' + prefix);\n  } else {\n    bytes = base32.decode('b' + prefix.toLowerCase()).subarray(2);\n  }\n\n  const str = base32.encode(bytes).substring(1).toUpperCase();\n  return str || 'C';\n}\n/**\n * @param {import('interface-blockstore').Query} query\n * @returns {import('interface-datastore').Query}\n */\n\n\nfunction convertQuery(query) {\n  return { ...query,\n    prefix: query.prefix ? `/${convertPrefix(query.prefix)}` : undefined,\n    filters: query.filters ? query.filters.map(filter => pair => {\n      return filter({\n        key: keyToCid(pair.key),\n        value: pair.value\n      });\n    }) : undefined,\n    orders: query.orders ? query.orders.map(order => (a, b) => {\n      return order({\n        key: keyToCid(a.key),\n        value: a.value\n      }, {\n        key: keyToCid(b.key),\n        value: b.value\n      });\n    }) : undefined\n  };\n}\n/**\n * @param {import('interface-blockstore').KeyQuery} query\n * @returns {import('interface-datastore').KeyQuery}\n */\n\n\nfunction convertKeyQuery(query) {\n  return { ...query,\n    prefix: query.prefix ? `/${convertPrefix(query.prefix)}` : undefined,\n    filters: query.filters ? query.filters.map(filter => key => {\n      return filter(keyToCid(key));\n    }) : undefined,\n    orders: query.orders ? query.orders.map(order => (a, b) => {\n      return order(keyToCid(a), keyToCid(b));\n    }) : undefined\n  };\n}\n/**\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @implements {Blockstore}\n */\n\n\nclass BlockstoreDatastoreAdapter extends BlockstoreAdapter {\n  /**\n   * @param {Datastore} datastore\n   */\n  constructor(datastore) {\n    super();\n    this.child = datastore;\n  }\n\n  open() {\n    return this.child.open();\n  }\n\n  close() {\n    return this.child.close();\n  }\n  /**\n   * @param {Query} query\n   * @param {Options} [options]\n   */\n\n\n  query(query, options) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(_this.child.query(convertQuery(query), options)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const {\n            key,\n            value\n          } = _value;\n          yield {\n            key: keyToCid(key),\n            value\n          };\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {KeyQuery} query\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(query, options) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this2.child.queryKeys(convertKeyQuery(query), options)), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const key = _value2;\n          yield keyToCid(key);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   * @returns\n   */\n\n\n  get(cid, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this5.child.get(cidToKey(cid), options);\n    })();\n  }\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n\n\n  getMany(cids, options) {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(cids), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const cid = _value3;\n          yield _this3.get(cid, options);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            yield _awaitAsyncGenerator(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n\n\n  put(cid, value, options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6.child.put(cidToKey(cid), value, options);\n    })();\n  }\n  /**\n   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks\n   * @param {Options} [options]\n   */\n\n\n  putMany(blocks, options) {\n    var _this4 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      // eslint-disable-line require-await\n      // we cannot simply chain to `store.putMany` because we convert a CID into\n      // a key based on the multihash only, so we lose the version & codec and\n      // cannot give the user back the CID they used to create the block, so yield\n      // to `store.putMany` but return the actual block the user passed in.\n      //\n      // nb. we want to use `store.putMany` here so bitswap can control batching\n      // up block HAVEs to send to the network - if we use multiple `store.put`s\n      // it will not be able to guess we are about to `store.put` more blocks\n      const output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n\n      const runner = process && process.nextTick ? process.nextTick : setImmediate;\n      runner( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          const store = _this4.child;\n          yield drain(_this4.child.putMany(_wrapAsyncGenerator(function* () {\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n\n            var _iteratorError4;\n\n            try {\n              for (var _iterator4 = _asyncIterator(blocks), _step4, _value4; _step4 = yield _awaitAsyncGenerator(_iterator4.next()), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _awaitAsyncGenerator(_step4.value), !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {\n                const block = _value4;\n                const key = cidToKey(block.key);\n                const exists = yield _awaitAsyncGenerator(store.has(key, options));\n\n                if (!exists) {\n                  yield {\n                    key,\n                    value: block.value\n                  };\n                } // there is an assumption here that after the yield has completed\n                // the underlying datastore has finished writing the block\n\n\n                output.push(block);\n              }\n            } catch (err) {\n              _didIteratorError4 = true;\n              _iteratorError4 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                  yield _awaitAsyncGenerator(_iterator4.return());\n                }\n              } finally {\n                if (_didIteratorError4) {\n                  throw _iteratorError4;\n                }\n              }\n            }\n          })()));\n          output.end();\n        } catch (err) {\n          output.end(err);\n        }\n      }));\n      yield* _asyncGeneratorDelegate(_asyncIterator(output), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n\n\n  has(cid, options) {\n    return this.child.has(cidToKey(cid), options);\n  }\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n\n\n  delete(cid, options) {\n    return this.child.delete(cidToKey(cid), options);\n  }\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n\n\n  deleteMany(cids, options) {\n    const out = pushable();\n    drain(this.child.deleteMany(_wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n\n      var _iteratorError5;\n\n      try {\n        for (var _iterator5 = _asyncIterator(cids), _step5, _value5; _step5 = yield _awaitAsyncGenerator(_iterator5.next()), _iteratorNormalCompletion5 = _step5.done, _value5 = yield _awaitAsyncGenerator(_step5.value), !_iteratorNormalCompletion5; _iteratorNormalCompletion5 = true) {\n          const cid = _value5;\n          yield cidToKey(cid);\n          out.push(cid);\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            yield _awaitAsyncGenerator(_iterator5.return());\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      out.end();\n    })(), options)).catch(err => {\n      out.end(err);\n    });\n    return out;\n  }\n\n}\n\nmodule.exports = BlockstoreDatastoreAdapter;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/blockstore-datastore-adapter/src/index.js"],"names":["drain","require","pushable","Key","CID","raw","Digest","base32","base32pad","base58btc","errcode","BlockstoreAdapter","cidToKey","cid","Error","encode","multihash","bytes","slice","toUpperCase","keyToCid","key","createV1","code","decode","toString","toLowerCase","convertPrefix","prefix","firstChar","substring","subarray","str","convertQuery","query","undefined","filters","map","filter","pair","value","orders","order","a","b","convertKeyQuery","BlockstoreDatastoreAdapter","constructor","datastore","child","open","close","options","queryKeys","get","getMany","cids","put","putMany","blocks","output","runner","process","nextTick","setImmediate","store","block","exists","has","push","end","err","delete","deleteMany","out","catch","module","exports"],"mappings":"AAAA;;;;;;;;;;;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAArB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAUF,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAUH,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,yBAAD,CAAnB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,4BAAD,CAAtB;;AACA,MAAM;AAAEM,EAAAA,MAAF;AAAUC,EAAAA;AAAV,IAAwBP,OAAO,CAAC,2BAAD,CAArC;;AACA,MAAM;AAAEQ,EAAAA;AAAF,IAAgBR,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAMS,OAAO,GAAGT,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEU,EAAAA;AAAF,IAAwBV,OAAO,CAAC,sBAAD,CAArC;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,QAAT,CAAmBC,GAAnB,EAAwB;AACtB,MAAI,EAAEA,GAAG,YAAYT,GAAjB,CAAJ,EAA2B;AACzB,UAAMM,OAAO,CAAC,IAAII,KAAJ,CAAU,iBAAV,CAAD,EAA+B,iBAA/B,CAAb;AACD;;AAED,SAAO,IAAIX,GAAJ,CAAQ,MAAMI,MAAM,CAACQ,MAAP,CAAcF,GAAG,CAACG,SAAJ,CAAcC,KAA5B,EAAmCC,KAAnC,CAAyC,CAAzC,EAA4CC,WAA5C,EAAd,EAAyE,KAAzE,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,QAAT,CAAmBC,GAAnB,EAAwB;AACtB;AACA,SAAOjB,GAAG,CAACkB,QAAJ,CAAajB,GAAG,CAACkB,IAAjB,EAAuBjB,MAAM,CAACkB,MAAP,CAAcjB,MAAM,CAACiB,MAAP,CAAc,MAAMH,GAAG,CAACI,QAAJ,GAAeP,KAAf,CAAqB,CAArB,EAAwBQ,WAAxB,EAApB,CAAd,CAAvB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,aAAT,CAAwBC,MAAxB,EAAgC;AAC9B,MAAIX,KAAJ;AACA,QAAMY,SAAS,GAAGD,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoB,CAApB,CAAlB;;AAEA,MAAID,SAAS,KAAK,GAAlB,EAAuB;AACrB,WAAOF,aAAa,CAACC,MAAM,CAACE,SAAP,CAAiB,CAAjB,CAAD,CAApB;AACD;;AAED,MAAID,SAAS,CAACH,WAAV,OAA4B,GAAhC,EAAqC;AACnC;AACAT,IAAAA,KAAK,GAAGV,MAAM,CAACiB,MAAP,CAAcI,MAAM,CAACF,WAAP,EAAd,EAAoCK,QAApC,CAA6C,CAA7C,CAAR;AACD,GAHD,MAGO,IAAIF,SAAS,CAACH,WAAV,OAA4B,GAAhC,EAAqC;AAC1C;AACAT,IAAAA,KAAK,GAAGT,SAAS,CAACgB,MAAV,CAAiBI,MAAM,CAACF,WAAP,EAAjB,EAAuCK,QAAvC,CAAgD,CAAhD,CAAR;AACD,GAHM,MAGA,IAAIF,SAAS,KAAK,GAAlB,EAAuB;AAC5B;AACAZ,IAAAA,KAAK,GAAGR,SAAS,CAACe,MAAV,CAAiBI,MAAjB,EAAyBG,QAAzB,CAAkC,CAAlC,CAAR;AACD,GAHM,MAGA,IAAIF,SAAS,KAAK,GAAlB,EAAuB;AAC5B;AACAZ,IAAAA,KAAK,GAAGR,SAAS,CAACe,MAAV,CAAiB,MAAMI,MAAvB,CAAR;AACD,GAHM,MAGA;AACLX,IAAAA,KAAK,GAAGV,MAAM,CAACiB,MAAP,CAAc,MAAMI,MAAM,CAACF,WAAP,EAApB,EAA0CK,QAA1C,CAAmD,CAAnD,CAAR;AACD;;AAED,QAAMC,GAAG,GAAGzB,MAAM,CAACQ,MAAP,CAAcE,KAAd,EAAqBa,SAArB,CAA+B,CAA/B,EAAkCX,WAAlC,EAAZ;AAEA,SAAOa,GAAG,IAAI,GAAd;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASC,YAAT,CAAuBC,KAAvB,EAA8B;AAC5B,SAAO,EACL,GAAGA,KADE;AAELN,IAAAA,MAAM,EAAEM,KAAK,CAACN,MAAN,GAAgB,IAAGD,aAAa,CAACO,KAAK,CAACN,MAAP,CAAe,EAA/C,GAAmDO,SAFtD;AAGLC,IAAAA,OAAO,EAAEF,KAAK,CAACE,OAAN,GACLF,KAAK,CAACE,OAAN,CAAcC,GAAd,CACAC,MAAM,IAAKC,IAAD,IAAU;AAClB,aAAOD,MAAM,CAAC;AAAEjB,QAAAA,GAAG,EAAED,QAAQ,CAACmB,IAAI,CAAClB,GAAN,CAAf;AAA2BmB,QAAAA,KAAK,EAAED,IAAI,CAACC;AAAvC,OAAD,CAAb;AACD,KAHD,CADK,GAMLL,SATC;AAULM,IAAAA,MAAM,EAAEP,KAAK,CAACO,MAAN,GACJP,KAAK,CAACO,MAAN,CAAaJ,GAAb,CACAK,KAAK,IAAI,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACjB,aAAOF,KAAK,CAAC;AAAErB,QAAAA,GAAG,EAAED,QAAQ,CAACuB,CAAC,CAACtB,GAAH,CAAf;AAAwBmB,QAAAA,KAAK,EAAEG,CAAC,CAACH;AAAjC,OAAD,EAA2C;AAAEnB,QAAAA,GAAG,EAAED,QAAQ,CAACwB,CAAC,CAACvB,GAAH,CAAf;AAAwBmB,QAAAA,KAAK,EAAEI,CAAC,CAACJ;AAAjC,OAA3C,CAAZ;AACD,KAHD,CADI,GAMJL;AAhBC,GAAP;AAkBD;AAED;AACA;AACA;AACA;;;AACA,SAASU,eAAT,CAA0BX,KAA1B,EAAiC;AAC/B,SAAO,EACL,GAAGA,KADE;AAELN,IAAAA,MAAM,EAAEM,KAAK,CAACN,MAAN,GAAgB,IAAGD,aAAa,CAACO,KAAK,CAACN,MAAP,CAAe,EAA/C,GAAmDO,SAFtD;AAGLC,IAAAA,OAAO,EAAEF,KAAK,CAACE,OAAN,GACLF,KAAK,CAACE,OAAN,CAAcC,GAAd,CACAC,MAAM,IAAKjB,GAAD,IAAS;AACjB,aAAOiB,MAAM,CAAClB,QAAQ,CAACC,GAAD,CAAT,CAAb;AACD,KAHD,CADK,GAMLc,SATC;AAULM,IAAAA,MAAM,EAAEP,KAAK,CAACO,MAAN,GACJP,KAAK,CAACO,MAAN,CAAaJ,GAAb,CACAK,KAAK,IAAI,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACjB,aAAOF,KAAK,CAACtB,QAAQ,CAACuB,CAAD,CAAT,EAAcvB,QAAQ,CAACwB,CAAD,CAAtB,CAAZ;AACD,KAHD,CADI,GAMJT;AAhBC,GAAP;AAkBD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMW,0BAAN,SAAyCnC,iBAAzC,CAA2D;AACzD;AACF;AACA;AACEoC,EAAAA,WAAW,CAAEC,SAAF,EAAa;AACtB;AAEA,SAAKC,KAAL,GAAaD,SAAb;AACD;;AAEDE,EAAAA,IAAI,GAAI;AACN,WAAO,KAAKD,KAAL,CAAWC,IAAX,EAAP;AACD;;AAEDC,EAAAA,KAAK,GAAI;AACP,WAAO,KAAKF,KAAL,CAAWE,KAAX,EAAP;AACD;AAED;AACF;AACA;AACA;;;AACUjB,EAAAA,KAAK,CAAEA,KAAF,EAASkB,OAAT,EAAkB;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAC7B,4CAAmC,KAAI,CAACH,KAAL,CAAWf,KAAX,CAAiBD,YAAY,CAACC,KAAD,CAA7B,EAAsCkB,OAAtC,CAAnC,gOAAmF;AAAA,gBAAlE;AAAE/B,YAAAA,GAAF;AAAOmB,YAAAA;AAAP,WAAkE;AACjF,gBAAM;AAAEnB,YAAAA,GAAG,EAAED,QAAQ,CAACC,GAAD,CAAf;AAAsBmB,YAAAA;AAAtB,WAAN;AACD;AAH4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAI9B;AAED;AACF;AACA;AACA;;;AACUa,EAAAA,SAAS,CAAEnB,KAAF,EAASkB,OAAT,EAAkB;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AACjC,6CAAwB,MAAI,CAACH,KAAL,CAAWI,SAAX,CAAqBR,eAAe,CAACX,KAAD,CAApC,EAA6CkB,OAA7C,CAAxB,0OAA+E;AAAA,gBAA9D/B,GAA8D;AAC7E,gBAAMD,QAAQ,CAACC,GAAD,CAAd;AACD;AAHgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIlC;AAED;AACF;AACA;AACA;AACA;;;AACQiC,EAAAA,GAAG,CAAEzC,GAAF,EAAOuC,OAAP,EAAgB;AAAA;;AAAA;AACvB,aAAO,MAAI,CAACH,KAAL,CAAWK,GAAX,CAAe1C,QAAQ,CAACC,GAAD,CAAvB,EAA8BuC,OAA9B,CAAP;AADuB;AAExB;AAED;AACF;AACA;AACA;;;AACUG,EAAAA,OAAO,CAAEC,IAAF,EAAQJ,OAAR,EAAiB;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAC9B,6CAAwBI,IAAxB,0OAA8B;AAAA,gBAAb3C,GAAa;AAC5B,gBAAM,MAAI,CAACyC,GAAL,CAASzC,GAAT,EAAcuC,OAAd,CAAN;AACD;AAH6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAI/B;AAED;AACF;AACA;AACA;AACA;;;AACQK,EAAAA,GAAG,CAAE5C,GAAF,EAAO2B,KAAP,EAAcY,OAAd,EAAuB;AAAA;;AAAA;AAC9B,YAAM,MAAI,CAACH,KAAL,CAAWQ,GAAX,CAAe7C,QAAQ,CAACC,GAAD,CAAvB,EAA8B2B,KAA9B,EAAqCY,OAArC,CAAN;AAD8B;AAE/B;AAED;AACF;AACA;AACA;;;AACUM,EAAAA,OAAO,CAAEC,MAAF,EAAUP,OAAV,EAAmB;AAAA;;AAAA;AAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAMQ,MAAM,GAAG1D,QAAQ,EAAvB,CATgC,CAWhC;AACA;;AACA,YAAM2D,MAAM,GAAGC,OAAO,IAAIA,OAAO,CAACC,QAAnB,GAA8BD,OAAO,CAACC,QAAtC,GAAiDC,YAAhE;AAEAH,MAAAA,MAAM,iCAAC,aAAY;AACjB,YAAI;AACF,gBAAMI,KAAK,GAAG,MAAI,CAAChB,KAAnB;AAEA,gBAAMjD,KAAK,CAAC,MAAI,CAACiD,KAAL,CAAWS,OAAX,CAAmB,iCAAoB;AAAA;AAAA;;AAAA;;AAAA;AACjD,mDAA0BC,MAA1B,0OAAkC;AAAA,sBAAjBO,KAAiB;AAChC,sBAAM7C,GAAG,GAAGT,QAAQ,CAACsD,KAAK,CAAC7C,GAAP,CAApB;AACA,sBAAM8C,MAAM,8BAASF,KAAK,CAACG,GAAN,CAAU/C,GAAV,EAAe+B,OAAf,CAAT,CAAZ;;AAEA,oBAAI,CAACe,MAAL,EAAa;AACX,wBAAM;AAAE9C,oBAAAA,GAAF;AAAOmB,oBAAAA,KAAK,EAAE0B,KAAK,CAAC1B;AAApB,mBAAN;AACD,iBAN+B,CAQhC;AACA;;;AACAoB,gBAAAA,MAAM,CAACS,IAAP,CAAYH,KAAZ;AACD;AAZgD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAalD,WAb8B,GAAnB,CAAD,CAAX;AAeAN,UAAAA,MAAM,CAACU,GAAP;AACD,SAnBD,CAmBE,OAAOC,GAAP,EAAY;AACZX,UAAAA,MAAM,CAACU,GAAP,CAAWC,GAAX;AACD;AACF,OAvBK,EAAN;AAyBA,oDAAQX,MAAR;AAxCgC;AAyCjC;AAED;AACF;AACA;AACA;;;AACEQ,EAAAA,GAAG,CAAEvD,GAAF,EAAOuC,OAAP,EAAgB;AACjB,WAAO,KAAKH,KAAL,CAAWmB,GAAX,CAAexD,QAAQ,CAACC,GAAD,CAAvB,EAA8BuC,OAA9B,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEoB,EAAAA,MAAM,CAAE3D,GAAF,EAAOuC,OAAP,EAAgB;AACpB,WAAO,KAAKH,KAAL,CAAWuB,MAAX,CAAkB5D,QAAQ,CAACC,GAAD,CAA1B,EAAiCuC,OAAjC,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEqB,EAAAA,UAAU,CAAEjB,IAAF,EAAQJ,OAAR,EAAiB;AACzB,UAAMsB,GAAG,GAAGxE,QAAQ,EAApB;AAEAF,IAAAA,KAAK,CAAC,KAAKiD,KAAL,CAAWwB,UAAX,CAAuB,iCAAoB;AAAA;AAAA;;AAAA;;AAAA;AAC/C,6CAAwBjB,IAAxB,0OAA8B;AAAA,gBAAb3C,GAAa;AAC5B,gBAAMD,QAAQ,CAACC,GAAD,CAAd;AAEA6D,UAAAA,GAAG,CAACL,IAAJ,CAASxD,GAAT;AACD;AAL8C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAO/C6D,MAAAA,GAAG,CAACJ,GAAJ;AACD,KAR4B,GAAvB,EAQAlB,OARA,CAAD,CAAL,CAQgBuB,KARhB,CAQsBJ,GAAG,IAAI;AAC3BG,MAAAA,GAAG,CAACJ,GAAJ,CAAQC,GAAR;AACD,KAVD;AAYA,WAAOG,GAAP;AACD;;AArJwD;;AAwJ3DE,MAAM,CAACC,OAAP,GAAiB/B,0BAAjB","sourcesContent":["'use strict'\n\nconst drain = require('it-drain')\nconst pushable = require('it-pushable')\nconst { Key } = require('interface-datastore')\nconst { CID } = require('multiformats/cid')\nconst raw = require('multiformats/codecs/raw')\nconst Digest = require('multiformats/hashes/digest')\nconst { base32, base32pad } = require('multiformats/bases/base32')\nconst { base58btc } = require('multiformats/bases/base58')\nconst errcode = require('err-code')\nconst { BlockstoreAdapter } = require('interface-blockstore')\n\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\nfunction cidToKey (cid) {\n  if (!(cid instanceof CID)) {\n    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  return new Key('/' + base32.encode(cid.multihash.bytes).slice(1).toUpperCase(), false)\n}\n\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n * @returns {CID}\n */\nfunction keyToCid (key) {\n  // Block key is of the form <base32 encoded string>\n  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())))\n}\n\n/**\n * Tries to decode a prefix as the first part of a CID and then\n * strip off the version and codec bytes to just leave part of\n * the multihash.\n *\n * Only really works if the prefix length aligns with the byte\n * boundaries of the encoding.\n *\n * @param {string} prefix\n * @returns {string}\n */\nfunction convertPrefix (prefix) {\n  let bytes\n  const firstChar = prefix.substring(0, 1)\n\n  if (firstChar === '/') {\n    return convertPrefix(prefix.substring(1))\n  }\n\n  if (firstChar.toLowerCase() === 'b') {\n    // v1 cid prefix, remove version and codec bytes\n    bytes = base32.decode(prefix.toLowerCase()).subarray(2)\n  } else if (firstChar.toLowerCase() === 'c') {\n    // v1 cid prefix, remove version and codec bytes\n    bytes = base32pad.decode(prefix.toLowerCase()).subarray(2)\n  } else if (firstChar === 'z') {\n    // v1 cid\n    bytes = base58btc.decode(prefix).subarray(2)\n  } else if (firstChar === 'Q') {\n    // v0 cid prefix\n    bytes = base58btc.decode('z' + prefix)\n  } else {\n    bytes = base32.decode('b' + prefix.toLowerCase()).subarray(2)\n  }\n\n  const str = base32.encode(bytes).substring(1).toUpperCase()\n\n  return str || 'C'\n}\n\n/**\n * @param {import('interface-blockstore').Query} query\n * @returns {import('interface-datastore').Query}\n */\nfunction convertQuery (query) {\n  return {\n    ...query,\n    prefix: query.prefix ? `/${convertPrefix(query.prefix)}` : undefined,\n    filters: query.filters\n      ? query.filters.map(\n        filter => (pair) => {\n          return filter({ key: keyToCid(pair.key), value: pair.value })\n        }\n      )\n      : undefined,\n    orders: query.orders\n      ? query.orders.map(\n        order => (a, b) => {\n          return order({ key: keyToCid(a.key), value: a.value }, { key: keyToCid(b.key), value: b.value })\n        }\n      )\n      : undefined\n  }\n}\n\n/**\n * @param {import('interface-blockstore').KeyQuery} query\n * @returns {import('interface-datastore').KeyQuery}\n */\nfunction convertKeyQuery (query) {\n  return {\n    ...query,\n    prefix: query.prefix ? `/${convertPrefix(query.prefix)}` : undefined,\n    filters: query.filters\n      ? query.filters.map(\n        filter => (key) => {\n          return filter(keyToCid(key))\n        }\n      )\n      : undefined,\n    orders: query.orders\n      ? query.orders.map(\n        order => (a, b) => {\n          return order(keyToCid(a), keyToCid(b))\n        }\n      )\n      : undefined\n  }\n}\n\n/**\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @implements {Blockstore}\n */\nclass BlockstoreDatastoreAdapter extends BlockstoreAdapter {\n  /**\n   * @param {Datastore} datastore\n   */\n  constructor (datastore) {\n    super()\n\n    this.child = datastore\n  }\n\n  open () {\n    return this.child.open()\n  }\n\n  close () {\n    return this.child.close()\n  }\n\n  /**\n   * @param {Query} query\n   * @param {Options} [options]\n   */\n  async * query (query, options) {\n    for await (const { key, value } of this.child.query(convertQuery(query), options)) {\n      yield { key: keyToCid(key), value }\n    }\n  }\n\n  /**\n   * @param {KeyQuery} query\n   * @param {Options} [options]\n   */\n  async * queryKeys (query, options) {\n    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {\n      yield keyToCid(key)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   * @returns\n   */\n  async get (cid, options) {\n    return this.child.get(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  async * getMany (cids, options) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  async put (cid, value, options) {\n    await this.child.put(cidToKey(cid), value, options)\n  }\n\n  /**\n   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks\n   * @param {Options} [options]\n   */\n  async * putMany (blocks, options) { // eslint-disable-line require-await\n    // we cannot simply chain to `store.putMany` because we convert a CID into\n    // a key based on the multihash only, so we lose the version & codec and\n    // cannot give the user back the CID they used to create the block, so yield\n    // to `store.putMany` but return the actual block the user passed in.\n    //\n    // nb. we want to use `store.putMany` here so bitswap can control batching\n    // up block HAVEs to send to the network - if we use multiple `store.put`s\n    // it will not be able to guess we are about to `store.put` more blocks\n    const output = pushable()\n\n    // process.nextTick runs on the microtask queue, setImmediate runs on the next\n    // event loop iteration so is slower. Use process.nextTick if it is available.\n    const runner = process && process.nextTick ? process.nextTick : setImmediate\n\n    runner(async () => {\n      try {\n        const store = this.child\n\n        await drain(this.child.putMany(async function * () {\n          for await (const block of blocks) {\n            const key = cidToKey(block.key)\n            const exists = await store.has(key, options)\n\n            if (!exists) {\n              yield { key, value: block.value }\n            }\n\n            // there is an assumption here that after the yield has completed\n            // the underlying datastore has finished writing the block\n            output.push(block)\n          }\n        }()))\n\n        output.end()\n      } catch (err) {\n        output.end(err)\n      }\n    })\n\n    yield * output\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  has (cid, options) {\n    return this.child.has(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  delete (cid, options) {\n    return this.child.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  deleteMany (cids, options) {\n    const out = pushable()\n\n    drain(this.child.deleteMany((async function * () {\n      for await (const cid of cids) {\n        yield cidToKey(cid)\n\n        out.push(cid)\n      }\n\n      out.end()\n    }()), options)).catch(err => {\n      out.end(err)\n    })\n\n    return out\n  }\n}\n\nmodule.exports = BlockstoreDatastoreAdapter\n"]},"metadata":{},"sourceType":"script"}