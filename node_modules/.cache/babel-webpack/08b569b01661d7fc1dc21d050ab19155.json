{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst errcode = require('err-code');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst exporter = require('./exporter');\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')(randomBytes);\n\n  class Secp256k1PublicKey {\n    constructor(key) {\n      crypto.validatePublicKey(key);\n      this._key = key;\n    }\n\n    verify(data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data);\n    }\n\n    marshal() {\n      return crypto.compressPublicKey(this._key);\n    }\n\n    get bytes() {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      }).finish();\n    }\n\n    equals(key) {\n      return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n\n    hash() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          bytes\n        } = yield sha256.digest(_this.bytes);\n        return bytes;\n      })();\n    }\n\n  }\n\n  class Secp256k1PrivateKey {\n    constructor(key, publicKey) {\n      this._key = key;\n      this._publicKey = publicKey || crypto.computePublicKey(key);\n      crypto.validatePrivateKey(this._key);\n      crypto.validatePublicKey(this._publicKey);\n    }\n\n    sign(message) {\n      return crypto.hashAndSign(this._key, message);\n    }\n\n    get public() {\n      return new Secp256k1PublicKey(this._publicKey);\n    }\n\n    marshal() {\n      return this._key;\n    }\n\n    get bytes() {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      }).finish();\n    }\n\n    equals(key) {\n      return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n\n    hash() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          bytes\n        } = yield sha256.digest(_this2.bytes);\n        return bytes;\n      })();\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n\n\n    id() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        const hash = yield _this3.public.hash();\n        return uint8ArrayToString(hash, 'base58btc');\n      })();\n    }\n    /**\n     * Exports the key into a password protected `format`\n     *\n     * @param {string} password - The password to encrypt the key\n     * @param {string} [format=libp2p-key] - The format in which to export as\n     * @returns {Promise<string>} The encrypted private key\n     */\n\n\n    export(password, format = 'libp2p-key') {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        if (format === 'libp2p-key') {\n          return exporter.export(_this4.bytes, password);\n        } else {\n          throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n        }\n      })();\n    }\n\n  }\n\n  function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n  }\n\n  function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  function generateKeyPair() {\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  function _generateKeyPair() {\n    _generateKeyPair = _asyncToGenerator(function* () {\n      const privateKeyBytes = yield crypto.generateKey();\n      return new Secp256k1PrivateKey(privateKeyBytes);\n    });\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  };\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-crypto/src/keys/secp256k1-class.js"],"names":["sha256","require","errcode","equals","uint8ArrayEquals","toString","uint8ArrayToString","exporter","module","exports","keysProtobuf","randomBytes","crypto","Secp256k1PublicKey","constructor","key","validatePublicKey","_key","verify","data","sig","hashAndVerify","marshal","compressPublicKey","bytes","PublicKey","encode","Type","KeyType","Secp256k1","Data","finish","hash","digest","Secp256k1PrivateKey","publicKey","_publicKey","computePublicKey","validatePrivateKey","sign","message","hashAndSign","public","PrivateKey","id","export","password","format","Error","unmarshalSecp256k1PrivateKey","unmarshalSecp256k1PublicKey","generateKeyPair","privateKeyBytes","generateKey"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst exporter = require('./exporter')\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')(randomBytes)\n\n  class Secp256k1PublicKey {\n    constructor (key) {\n      crypto.validatePublicKey(key)\n      this._key = key\n    }\n\n    verify (data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data)\n    }\n\n    marshal () {\n      return crypto.compressPublicKey(this._key)\n    }\n\n    get bytes () {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      }).finish()\n    }\n\n    equals (key) {\n      return uint8ArrayEquals(this.bytes, key.bytes)\n    }\n\n    async hash () {\n      const { bytes } = await sha256.digest(this.bytes)\n\n      return bytes\n    }\n  }\n\n  class Secp256k1PrivateKey {\n    constructor (key, publicKey) {\n      this._key = key\n      this._publicKey = publicKey || crypto.computePublicKey(key)\n      crypto.validatePrivateKey(this._key)\n      crypto.validatePublicKey(this._publicKey)\n    }\n\n    sign (message) {\n      return crypto.hashAndSign(this._key, message)\n    }\n\n    get public () {\n      return new Secp256k1PublicKey(this._publicKey)\n    }\n\n    marshal () {\n      return this._key\n    }\n\n    get bytes () {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      }).finish()\n    }\n\n    equals (key) {\n      return uint8ArrayEquals(this.bytes, key.bytes)\n    }\n\n    async hash () {\n      const { bytes } = await sha256.digest(this.bytes)\n\n      return bytes\n    }\n\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n    async id () {\n      const hash = await this.public.hash()\n      return uint8ArrayToString(hash, 'base58btc')\n    }\n\n    /**\n     * Exports the key into a password protected `format`\n     *\n     * @param {string} password - The password to encrypt the key\n     * @param {string} [format=libp2p-key] - The format in which to export as\n     * @returns {Promise<string>} The encrypted private key\n     */\n    async export (password, format = 'libp2p-key') { // eslint-disable-line require-await\n      if (format === 'libp2p-key') {\n        return exporter.export(this.bytes, password)\n      } else {\n        throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n      }\n    }\n  }\n\n  function unmarshalSecp256k1PrivateKey (bytes) {\n    return new Secp256k1PrivateKey(bytes)\n  }\n\n  function unmarshalSecp256k1PublicKey (bytes) {\n    return new Secp256k1PublicKey(bytes)\n  }\n\n  async function generateKeyPair () {\n    const privateKeyBytes = await crypto.generateKey()\n    return new Secp256k1PrivateKey(privateKeyBytes)\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  }\n}\n"]},"metadata":{},"sourceType":"script"}