{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errcode = require('err-code');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst hmac = require('../hmac');\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}; // Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (cipherType, hash, secret) {\n    const cipher = cipherMap[cipherType];\n\n    if (!cipher) {\n      const allowed = Object.keys(cipherMap).join(' / ');\n      throw errcode(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), 'ERR_INVALID_CIPHER_TYPE');\n    }\n\n    if (!hash) {\n      throw errcode(new Error('missing hash type'), 'ERR_MISSING_HASH_TYPE');\n    }\n\n    const cipherKeySize = cipher.keySize;\n    const ivSize = cipher.ivSize;\n    const hmacKeySize = 20;\n    const seed = uint8ArrayFromString('key expansion');\n    const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n    const m = yield hmac.create(hash, secret);\n    let a = yield m.digest(seed);\n    const result = [];\n    let j = 0;\n\n    while (j < resultLength) {\n      const b = yield m.digest(uint8ArrayConcat([a, seed]));\n      let todo = b.length;\n\n      if (j + todo > resultLength) {\n        todo = resultLength - j;\n      }\n\n      result.push(b);\n      j += todo;\n      a = yield m.digest(a);\n    }\n\n    const half = resultLength / 2;\n    const resultBuffer = uint8ArrayConcat(result);\n    const r1 = resultBuffer.slice(0, half);\n    const r2 = resultBuffer.slice(half, resultLength);\n\n    const createKey = res => ({\n      iv: res.slice(0, ivSize),\n      cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n      macKey: res.slice(ivSize + cipherKeySize)\n    });\n\n    return {\n      k1: createKey(r1),\n      k2: createKey(r2)\n    };\n  });\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/libp2p-crypto/src/keys/key-stretcher.js"],"names":["errcode","require","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","hmac","cipherMap","ivSize","keySize","Blowfish","cipherKeySize","module","exports","cipherType","hash","secret","cipher","allowed","Object","keys","join","Error","hmacKeySize","seed","resultLength","m","create","a","digest","result","j","b","todo","length","push","half","resultBuffer","r1","slice","r2","createKey","res","iv","cipherKey","macKey","k1","k2"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst hmac = require('../hmac')\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}\n\n// Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\nmodule.exports = async (cipherType, hash, secret) => {\n  const cipher = cipherMap[cipherType]\n\n  if (!cipher) {\n    const allowed = Object.keys(cipherMap).join(' / ')\n    throw errcode(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), 'ERR_INVALID_CIPHER_TYPE')\n  }\n\n  if (!hash) {\n    throw errcode(new Error('missing hash type'), 'ERR_MISSING_HASH_TYPE')\n  }\n\n  const cipherKeySize = cipher.keySize\n  const ivSize = cipher.ivSize\n  const hmacKeySize = 20\n  const seed = uint8ArrayFromString('key expansion')\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)\n\n  const m = await hmac.create(hash, secret)\n  let a = await m.digest(seed)\n\n  const result = []\n  let j = 0\n\n  while (j < resultLength) {\n    const b = await m.digest(uint8ArrayConcat([a, seed]))\n    let todo = b.length\n\n    if (j + todo > resultLength) {\n      todo = resultLength - j\n    }\n\n    result.push(b)\n    j += todo\n    a = await m.digest(a)\n  }\n\n  const half = resultLength / 2\n  const resultBuffer = uint8ArrayConcat(result)\n  const r1 = resultBuffer.slice(0, half)\n  const r2 = resultBuffer.slice(half, resultLength)\n\n  const createKey = (res) => ({\n    iv: res.slice(0, ivSize),\n    cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n    macKey: res.slice(ivSize + cipherKeySize)\n  })\n\n  return {\n    k1: createKey(r1),\n    k2: createKey(r2)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}