{"ast":null,"code":"import _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport extractDataFromBlock from '../../../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js';\nimport { UnixFS } from 'ipfs-unixfs';\nimport errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\n\nfunction emitBytes(_x, _x2, _x3, _x4) {\n  return _emitBytes.apply(this, arguments);\n}\n\nfunction _emitBytes() {\n  _emitBytes = _wrapAsyncGenerator(function* (blockstore, node, start, end, streamPosition = 0, options) {\n    if (node instanceof Uint8Array) {\n      const buf = extractDataFromBlock(node, streamPosition, start, end);\n\n      if (buf.length) {\n        yield buf;\n      }\n\n      streamPosition += buf.length;\n      return streamPosition;\n    }\n\n    if (node.Data == null) {\n      throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n    }\n\n    let file;\n\n    try {\n      file = UnixFS.unmarshal(node.Data);\n    } catch (err) {\n      throw errCode(err, 'ERR_NOT_UNIXFS');\n    }\n\n    if (file.data && file.data.length) {\n      const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n\n      if (buf.length) {\n        yield buf;\n      }\n\n      streamPosition += file.data.length;\n    }\n\n    let childStart = streamPosition;\n\n    for (let i = 0; i < node.Links.length; i++) {\n      const childLink = node.Links[i];\n      const childEnd = streamPosition + file.blockSizes[i];\n\n      if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n        const block = yield _awaitAsyncGenerator(blockstore.get(childLink.Hash, {\n          signal: options.signal\n        }));\n        let child;\n\n        switch (childLink.Hash.code) {\n          case dagPb.code:\n            child = yield _awaitAsyncGenerator(dagPb.decode(block));\n            break;\n\n          case raw.code:\n            child = block;\n            break;\n\n          case dagCbor.code:\n            child = yield _awaitAsyncGenerator(dagCbor.decode(block));\n            break;\n\n          default:\n            throw Error(`Unsupported codec: ${childLink.Hash.code}`);\n        }\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(emitBytes(blockstore, child, start, end, streamPosition, options)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const buf = _value;\n            streamPosition += buf.length;\n            yield buf;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      streamPosition = childEnd;\n      childStart = childEnd + 1;\n    }\n  });\n  return _emitBytes.apply(this, arguments);\n}\n\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent(options = {}) {\n    const fileSize = unixfs.fileSize();\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n\n  return yieldFileContent;\n};\n\nexport default fileContent;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js"],"names":["extractDataFromBlock","validateOffsetAndLength","UnixFS","errCode","dagPb","dagCbor","raw","emitBytes","blockstore","node","start","end","streamPosition","options","Uint8Array","buf","length","Data","Error","file","unmarshal","err","data","childStart","i","Links","childLink","childEnd","blockSizes","block","get","Hash","signal","child","code","decode","fileContent","cid","unixfs","path","resolve","depth","yieldFileContent","fileSize","undefined","offset"],"mappings":"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","sourcesContent":["import extractDataFromBlock from '../../../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js';\nimport { UnixFS } from 'ipfs-unixfs';\nimport errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\nasync function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += buf.length;\n    return streamPosition;\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  let file;\n  try {\n    file = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (file.data && file.data.length) {\n    const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += file.data.length;\n  }\n  let childStart = streamPosition;\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i];\n    const childEnd = streamPosition + file.blockSizes[i];\n    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n      const block = await blockstore.get(childLink.Hash, { signal: options.signal });\n      let child;\n      switch (childLink.Hash.code) {\n      case dagPb.code:\n        child = await dagPb.decode(block);\n        break;\n      case raw.code:\n        child = block;\n        break;\n      case dagCbor.code:\n        child = await dagCbor.decode(block);\n        break;\n      default:\n        throw Error(`Unsupported codec: ${ childLink.Hash.code }`);\n      }\n      for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n        streamPosition += buf.length;\n        yield buf;\n      }\n    }\n    streamPosition = childEnd;\n    childStart = childEnd + 1;\n  }\n}\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent(options = {}) {\n    const fileSize = unixfs.fileSize();\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n    const {offset, length} = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n  return yieldFileContent;\n};\nexport default fileContent;"]},"metadata":{},"sourceType":"module"}