{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Bucket, createHAMT } from 'hamt-sharding';\nimport { decode } from '@ipld/dag-pb';\nimport { murmur3128 } from '@multiformats/murmur3';\n\nconst hashFn = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (buf) {\n    return (yield murmur3128.encode(buf)).slice(0, 8).reverse();\n  });\n\n  return function hashFn(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      throw new Error('Unexpected Link without a Name');\n    }\n\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nconst findShardCid = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (node, name, blockstore, context, options) {\n    if (!context) {\n      const rootBucket = createHAMT({\n        hashFn\n      });\n      context = {\n        rootBucket,\n        hamtDepth: 1,\n        lastBucket: rootBucket\n      };\n    }\n\n    yield addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n    const position = yield context.rootBucket._findNewBucketAndPos(name);\n    let prefix = toPrefix(position.pos);\n    const bucketPath = toBucketPath(position);\n\n    if (bucketPath.length > context.hamtDepth) {\n      context.lastBucket = bucketPath[context.hamtDepth];\n      prefix = toPrefix(context.lastBucket._posAtParent);\n    }\n\n    const link = node.Links.find(link => {\n      if (link.Name == null) {\n        return false;\n      }\n\n      const entryPrefix = link.Name.substring(0, 2);\n      const entryName = link.Name.substring(2);\n\n      if (entryPrefix !== prefix) {\n        return false;\n      }\n\n      if (entryName && entryName !== name) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!link) {\n      return null;\n    }\n\n    if (link.Name != null && link.Name.substring(2) === name) {\n      return link.Hash;\n    }\n\n    context.hamtDepth++;\n    const block = yield blockstore.get(link.Hash, options);\n    node = decode(block);\n    return findShardCid(node, name, blockstore, context, options);\n  });\n\n  return function findShardCid(_x2, _x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexport default findShardCid;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js"],"names":["Bucket","createHAMT","decode","murmur3128","hashFn","buf","encode","slice","reverse","addLinksToHamtBucket","links","bucket","rootBucket","Promise","all","map","link","Name","Error","length","pos","parseInt","_putObjectAt","hash","_options","bits","put","substring","toPrefix","position","toString","toUpperCase","padStart","toBucketPath","path","_parent","push","findShardCid","node","name","blockstore","context","options","hamtDepth","lastBucket","Links","_findNewBucketAndPos","prefix","bucketPath","_posAtParent","find","entryPrefix","entryName","Hash","block","get"],"mappings":"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","sourcesContent":["import {\n  Bucket,\n  createHAMT\n} from 'hamt-sharding';\nimport { decode } from '@ipld/dag-pb';\nimport { murmur3128 } from '@multiformats/murmur3';\nconst hashFn = async function (buf) {\n  return (await murmur3128.encode(buf)).slice(0, 8).reverse();\n};\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      throw new Error('Unexpected Link without a Name');\n    }\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n  path.push(bucket);\n  return path.reverse();\n};\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = createHAMT({ hashFn });\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    };\n  }\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false;\n    }\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n    if (entryPrefix !== prefix) {\n      return false;\n    }\n    if (entryName && entryName !== name) {\n      return false;\n    }\n    return true;\n  });\n  if (!link) {\n    return null;\n  }\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n  context.hamtDepth++;\n  const block = await blockstore.get(link.Hash, options);\n  node = decode(block);\n  return findShardCid(node, name, blockstore, context, options);\n};\nexport default findShardCid;"]},"metadata":{},"sourceType":"module"}