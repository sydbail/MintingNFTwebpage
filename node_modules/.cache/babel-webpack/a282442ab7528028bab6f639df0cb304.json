{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key,\n  Errors,\n  Adapter,\n  utils: {\n    sortAll\n  }\n} = require('interface-datastore');\n\nconst filter = require('it-filter');\n\nconst map = require('it-map');\n\nconst take = require('it-take');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} QueryOptions\n */\n\n/**\n * A datastore backed by leveldb.\n *\n * @implements {Datastore}\n */\n\n\nclass LevelDatastore extends Adapter {\n  /**\n   * @param {any} path\n   * @param {Object} [opts]\n   * @param {any} [opts.db] - level db reference\n   * @param {boolean} [opts.createIfMissing]\n   * @param {boolean} [opts.errorIfExists]\n   * @param {string} [opts.prefix] - level-js option\n   * @param {number} [opts.version] - level-js option\n   * @param {number} [opts.cacheSize] - leveldown option\n   * @param {number} [opts.writeBufferSize] - leveldown option\n   * @param {number} [opts.blockSize] - leveldown option\n   * @param {number} [opts.maxOpenFiles] - leveldown option\n   * @param {number} [opts.blockRestartInterval] - leveldown option\n   * @param {number} [opts.maxFileSize] - leveldown option\n   */\n  constructor(path, opts) {\n    super();\n    this.path = path;\n    this.opts = opts;\n\n    if (opts && opts.db) {\n      this.database = opts.db;\n      delete opts.db;\n    } else {\n      // @ts-ignore\n      this.database = require('level');\n    }\n  }\n\n  _initDb() {\n    return new Promise((resolve, reject) => {\n      this.db = this.database(this.path, { ...this.opts,\n        valueEncoding: 'binary',\n        compression: false // same default as go\n\n      },\n      /** @param {Error}  [err] */\n      err => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(this.db);\n      });\n    });\n  }\n\n  open() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        if (_this.db) {\n          yield _this.db.open();\n        } else {\n          _this.db = yield _this._initDb();\n        }\n      } catch (err) {\n        throw Errors.dbOpenFailedError(err);\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n\n\n  put(key, value) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this2.db.put(key.toString(), value);\n      } catch (err) {\n        throw Errors.dbWriteFailedError(err);\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  get(key) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let data;\n\n      try {\n        data = yield _this3.db.get(key.toString());\n      } catch (err) {\n        if (err.notFound) throw Errors.notFoundError(err);\n        throw Errors.dbWriteFailedError(err);\n      }\n\n      return data;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<boolean>}\n   */\n\n\n  has(key) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this4.db.get(key.toString());\n      } catch (err) {\n        if (err.notFound) return false;\n        throw err;\n      }\n\n      return true;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<void>}\n   */\n\n\n  delete(key) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this5.db.del(key.toString());\n      } catch (err) {\n        throw Errors.dbDeleteFailedError(err);\n      }\n    })();\n  }\n\n  close() {\n    return this.db && this.db.close();\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    /** @type {{ type: string; key: string; value?: Uint8Array; }[]} */\n    const ops = [];\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        });\n      },\n      delete: key => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        });\n      },\n      commit: () => {\n        return this.db.batch(ops);\n      }\n    };\n  }\n  /**\n   * @param {Query} q\n   */\n\n\n  query(q) {\n    let it = this._query({\n      values: true,\n      prefix: q.prefix\n    });\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    const {\n      offset,\n      limit\n    } = q;\n\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n\n    if (limit) {\n      it = take(it, limit);\n    }\n\n    return it;\n  }\n  /**\n   * @param {KeyQuery} q\n   */\n\n\n  queryKeys(q) {\n    let it = map(this._query({\n      values: false,\n      prefix: q.prefix\n    }), ({\n      key\n    }) => key);\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    const {\n      offset,\n      limit\n    } = q;\n\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n\n    if (limit) {\n      it = take(it, limit);\n    }\n\n    return it;\n  }\n  /**\n   * @param {object} opts\n   * @param {boolean} opts.values\n   * @param {string} [opts.prefix]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  _query(opts) {\n    const iteratorOpts = {\n      keys: true,\n      keyAsBuffer: true,\n      values: opts.values\n    }; // Let the db do the prefix matching\n\n    if (opts.prefix != null) {\n      const prefix = opts.prefix.toString(); // Match keys greater than or equal to `prefix` and\n      // @ts-ignore\n\n      iteratorOpts.gte = prefix; // less than `prefix` + \\xFF (hex escape sequence)\n      // @ts-ignore\n\n      iteratorOpts.lt = prefix + '\\xFF';\n    }\n\n    return levelIteratorToIterator(this.db.iterator(iteratorOpts));\n  }\n\n}\n/**\n * @typedef {Object} LevelIterator\n * @property {(cb: (err: Error, key: string | Uint8Array | null, value: any)=> void)=>void} next\n * @property {(cb: (err: Error) => void) => void } end\n */\n\n/**\n * @param {LevelIterator} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\n\n\nfunction levelIteratorToIterator(li) {\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next: () => new Promise((resolve, reject) => {\n          li.next((err, key, value) => {\n            if (err) return reject(err);\n\n            if (key == null) {\n              return li.end(err => {\n                if (err) return reject(err);\n                resolve({\n                  done: true,\n                  value: undefined\n                });\n              });\n            }\n\n            resolve({\n              done: false,\n              value: {\n                key: new Key(key, false),\n                value\n              }\n            });\n          });\n        }),\n        return: () => new Promise((resolve, reject) => {\n          li.end(err => {\n            if (err) return reject(err);\n            resolve({\n              done: true,\n              value: undefined\n            });\n          });\n        })\n      };\n    }\n\n  };\n}\n\nmodule.exports = LevelDatastore;","map":null,"metadata":{},"sourceType":"script"}