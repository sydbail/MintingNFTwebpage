{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nconst Message = require('./types/message');\n\nconst CONSTANTS = require('./constants');\n\nconst logger = require('./utils').logger;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {Object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {Object} Stream\n * @property {AsyncIterable<Uint8Array>} source\n * @property {(output:AsyncIterable<Uint8Array>) => Promise<void>} sink\n */\n\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nclass Network {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {import('./bitswap')} bitswap\n   * @param {import('./stats')} stats\n   * @param {Object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor(libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110);\n\n      this._protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashers = options.hashers || {};\n  }\n\n  start() {\n    this._running = true;\n\n    this._libp2p.handle(this._protocols, this._onConnection); // register protocol with topology\n\n\n    const topology = new MulticodecTopology({\n      multicodecs: this._protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    });\n    this._registrarId = this._libp2p.registrar.register(topology); // All existing connections are like new ones for us\n\n    for (const peer of this._libp2p.peerStore.peers.values()) {\n      const conn = this._libp2p.connectionManager.get(peer.id);\n\n      conn && this._onPeerConnect(conn.remotePeer);\n    }\n  }\n\n  stop() {\n    this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n    this._libp2p.unhandle(this._protocols); // unregister protocol and handlers\n\n\n    if (this._registrarId != null) {\n      this._libp2p.registrar.unregister(this._registrarId);\n    }\n  }\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {string} connection.protocol - The protocol the stream is running\n   * @param {MuxedStream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n\n\n  _onConnection({\n    protocol,\n    stream,\n    connection\n  }) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this._running) {\n        return;\n      }\n\n      _this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n      try {\n        yield pipe(stream, lp.decode(),\n        /*#__PURE__*/\n\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        function () {\n          var _ref = _asyncToGenerator(function* (source) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n\n            var _iteratorError;\n\n            try {\n              for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n                const data = _value;\n\n                try {\n                  const message = yield Message.deserialize(data.slice(), _this._hashers);\n                  yield _this._bitswap._receiveMessage(connection.remotePeer, message);\n                } catch (err) {\n                  _this._bitswap._receiveError(err);\n\n                  break;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      } catch (err) {\n        _this._log(err);\n      }\n    })();\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerConnect(peerId) {\n    this._bitswap._onPeerConnected(peerId);\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerDisconnect(peerId) {\n    this._bitswap._onPeerDisconnected(peerId);\n  }\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n\n\n  findProviders(cid, maxProviders, options = {}) {\n    return this._libp2p.contentRouting.findProviders(cid, {\n      timeout: CONSTANTS.providerRequestTimeout,\n      maxNumProviders: maxProviders\n    });\n  }\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  findAndConnect(cid, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const connectAttempts = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this2.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const provider = _value2;\n\n          _this2._log(`connecting to provider ${provider.id}`);\n\n          connectAttempts.push(_this2.connectTo(provider.id, options).catch(err => {\n            // Prevent unhandled promise rejection\n            _this2._log.error(err);\n          }));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      yield Promise.all(connectAttempts);\n    })();\n  }\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  provide(cid, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // @ts-expect-error - contentRouting takes no options\n      yield _this3._libp2p.contentRouting.provide(cid, options);\n    })();\n  }\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n\n\n  sendMessage(peer, msg) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this4._running) throw new Error('network isn\\'t running');\n      const stringId = peer.toB58String();\n\n      _this4._log('sendMessage to %s', stringId, msg);\n\n      const connection = yield _this4._libp2p.dial(peer);\n      const {\n        stream,\n        protocol\n      } = yield connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);\n      /** @type {Uint8Array} */\n\n      let serialized;\n\n      switch (protocol) {\n        case BITSWAP100:\n          serialized = msg.serializeToBitswap100();\n          break;\n\n        case BITSWAP110:\n        case BITSWAP120:\n          serialized = msg.serializeToBitswap110();\n          break;\n\n        default:\n          throw new Error('Unknown protocol: ' + protocol);\n      } // Note: Don't wait for writeMessage() to complete\n\n\n      writeMessage(stream, serialized, _this4._log);\n\n      _this4._updateSentStats(peer, msg.blocks);\n    })();\n  }\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  connectTo(peer, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (!_this5._running) {\n        throw new Error('network isn\\'t running');\n      }\n\n      return _this5._libp2p.dial(peer, options);\n    })();\n  }\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n\n\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toB58String();\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length);\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n\n}\n/**\n *\n * @param {MuxedStream} stream\n * @param {Uint8Array} msg\n * @param {*} log\n */\n\n\nfunction writeMessage(_x2, _x3, _x4) {\n  return _writeMessage.apply(this, arguments);\n}\n\nfunction _writeMessage() {\n  _writeMessage = _asyncToGenerator(function* (stream, msg, log) {\n    try {\n      yield pipe([msg], lp.encode(), stream);\n    } catch (err) {\n      log(err);\n    }\n  });\n  return _writeMessage.apply(this, arguments);\n}\n\nmodule.exports = Network;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-bitswap/src/network.js"],"names":["lp","require","pipe","MulticodecTopology","Message","CONSTANTS","logger","BITSWAP100","BITSWAP110","BITSWAP120","Network","constructor","libp2p","bitswap","stats","options","_log","peerId","_libp2p","_bitswap","_protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","_hashers","hashers","start","handle","topology","multicodecs","handlers","onConnect","onDisconnect","_registrarId","registrar","register","peer","peerStore","peers","values","conn","connectionManager","get","id","remotePeer","stop","unhandle","unregister","protocol","stream","connection","toB58String","decode","source","data","message","deserialize","slice","_receiveMessage","err","_receiveError","_onPeerConnected","_onPeerDisconnected","findProviders","cid","maxProviders","contentRouting","timeout","providerRequestTimeout","maxNumProviders","findAndConnect","connectAttempts","maxProvidersPerRequest","provider","push","connectTo","catch","error","Promise","all","provide","sendMessage","msg","Error","stringId","dial","newStream","serialized","serializeToBitswap100","serializeToBitswap110","writeMessage","_updateSentStats","blocks","block","length","size","log","encode","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst lp = require('it-length-prefixed')\nconst { pipe } = require('it-pipe')\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology')\n\nconst Message = require('./types/message')\nconst CONSTANTS = require('./constants')\nconst logger = require('./utils').logger\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {Object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {Object} Stream\n * @property {AsyncIterable<Uint8Array>} source\n * @property {(output:AsyncIterable<Uint8Array>) => Promise<void>} sink\n */\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0'\n\nclass Network {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {import('./bitswap')} bitswap\n   * @param {import('./stats')} stats\n   * @param {Object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor (libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network')\n    this._libp2p = libp2p\n    this._bitswap = bitswap\n    this._protocols = [BITSWAP100]\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110)\n      this._protocols.unshift(BITSWAP120)\n    }\n\n    this._stats = stats\n    this._running = false\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n    this._onConnection = this._onConnection.bind(this)\n    this._hashers = options.hashers || {}\n  }\n\n  start () {\n    this._running = true\n    this._libp2p.handle(this._protocols, this._onConnection)\n\n    // register protocol with topology\n    const topology = new MulticodecTopology({\n      multicodecs: this._protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    })\n    this._registrarId = this._libp2p.registrar.register(topology)\n\n    // All existing connections are like new ones for us\n    for (const peer of this._libp2p.peerStore.peers.values()) {\n      const conn = this._libp2p.connectionManager.get(peer.id)\n\n      conn && this._onPeerConnect(conn.remotePeer)\n    }\n  }\n\n  stop () {\n    this._running = false\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    this._libp2p.unhandle(this._protocols)\n\n    // unregister protocol and handlers\n    if (this._registrarId != null) {\n      this._libp2p.registrar.unregister(this._registrarId)\n    }\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {string} connection.protocol - The protocol the stream is running\n   * @param {MuxedStream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n  async _onConnection ({ protocol, stream, connection }) {\n    if (!this._running) { return }\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String())\n\n    try {\n      await pipe(\n        stream,\n        lp.decode(),\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        async (source) => {\n          for await (const data of source) {\n            try {\n              const message = await Message.deserialize(data.slice(), this._hashers)\n              await this._bitswap._receiveMessage(connection.remotePeer, message)\n            } catch (err) {\n              this._bitswap._receiveError(err)\n              break\n            }\n          }\n        }\n      )\n    } catch (err) {\n      this._log(err)\n    }\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerConnect (peerId) {\n    this._bitswap._onPeerConnected(peerId)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnect (peerId) {\n    this._bitswap._onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n  findProviders (cid, maxProviders, options = {}) {\n    return this._libp2p.contentRouting.findProviders(\n      cid,\n      {\n        timeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders\n      }\n    )\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async findAndConnect (cid, options) {\n    const connectAttempts = []\n    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {\n      this._log(`connecting to provider ${provider.id}`)\n      connectAttempts.push(\n        this.connectTo(provider.id, options)\n          .catch(err => {\n            // Prevent unhandled promise rejection\n            this._log.error(err)\n          })\n      )\n    }\n    await Promise.all(connectAttempts)\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async provide (cid, options) {\n    // @ts-expect-error - contentRouting takes no options\n    await this._libp2p.contentRouting.provide(cid, options)\n  }\n\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toB58String()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const connection = await this._libp2p.dial(peer)\n    const { stream, protocol } = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100])\n\n    /** @type {Uint8Array} */\n    let serialized\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + protocol)\n    }\n\n    // Note: Don't wait for writeMessage() to complete\n    writeMessage(stream, serialized, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  async connectTo (peer, options) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this._libp2p.dial(peer, options)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toB58String()\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length)\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\n/**\n *\n * @param {MuxedStream} stream\n * @param {Uint8Array} msg\n * @param {*} log\n */\nasync function writeMessage (stream, msg, log) {\n  try {\n    await pipe(\n      [msg],\n      lp.encode(),\n      stream\n    )\n  } catch (err) {\n    log(err)\n  }\n}\n\nmodule.exports = Network\n"]},"metadata":{},"sourceType":"script"}