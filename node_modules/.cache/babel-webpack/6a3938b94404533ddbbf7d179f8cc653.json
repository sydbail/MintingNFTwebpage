{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n\nconst debug = require('debug');\n\nconst first = require('it-first');\n\nconst Block = require('multiformats/block');\n\nconst cborg = require('cborg');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  cidToKey,\n  keyToMultihash\n} = require('./utils/blockstore');\n\nconst walkDag = require('./utils/walk-dag');\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').CIDVersion} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @param {string} type\n */\n\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nconst PinTypes = {\n  /** @type {'direct'} */\n  direct: 'direct',\n\n  /** @type {'recursive'} */\n  recursive: 'recursive',\n\n  /** @type {'indirect'} */\n  indirect: 'indirect',\n\n  /** @type {'all'} */\n  all: 'all'\n};\n/**\n * @implements {Pins}\n */\n\nclass PinManager {\n  /**\n   * @param {Object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor({\n    pinstore,\n    blockstore,\n    loadCodec\n  }) {\n    this.pinstore = pinstore;\n    this.blockstore = blockstore;\n    this.loadCodec = loadCodec;\n    this.log = debug('ipfs:repo:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  pinDirectly(cid, options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.blockstore.get(cid, options);\n      /** @type {PinInternal} */\n\n      const pin = {\n        depth: 0\n      };\n\n      if (cid.version !== 0) {\n        pin.version = cid.version;\n      }\n\n      if (cid.code !== dagPb.code) {\n        pin.codec = cid.code;\n      }\n\n      if (options.metadata) {\n        pin.metadata = options.metadata;\n      }\n\n      return _this4.pinstore.put(cidToKey(cid), cborg.encode(pin));\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n\n\n  unpin(cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options);\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  pinRecursively(cid, options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.fetchCompleteDag(cid, options);\n      /** @type {PinInternal} */\n\n      const pin = {\n        depth: Infinity\n      };\n\n      if (cid.version !== 0) {\n        pin.version = cid.version;\n      }\n\n      if (cid.code !== dagPb.code) {\n        pin.codec = cid.code;\n      }\n\n      if (options.metadata) {\n        pin.metadata = options.metadata;\n      }\n\n      yield _this5.pinstore.put(cidToKey(cid), cborg.encode(pin));\n    })();\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  directKeys(options) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(_this.pinstore.query({\n          filters: [entry => {\n            const pin = cborg.decode(entry.value);\n            return pin.depth === 0;\n          }]\n        })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const entry = _value;\n          const pin = cborg.decode(entry.value);\n          const version = pin.version || 0;\n          const codec = pin.codec != null ? pin.codec : dagPb.code;\n          const multihash = keyToMultihash(entry.key);\n          yield {\n            cid: CID.create(version, codec, multihash),\n            metadata: pin.metadata\n          };\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  recursiveKeys(options) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this2.pinstore.query({\n          filters: [entry => {\n            const pin = cborg.decode(entry.value);\n            return pin.depth === Infinity;\n          }]\n        })), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const entry = _value2;\n          const pin = cborg.decode(entry.value);\n          const version = pin.version || 0;\n          const codec = pin.codec != null ? pin.codec : dagPb.code;\n          const multihash = keyToMultihash(entry.key);\n          yield {\n            cid: CID.create(version, codec, multihash),\n            metadata: pin.metadata\n          };\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  indirectKeys(options) {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(_this3.recursiveKeys()), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const {\n            cid\n          } = _value3;\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n\n          var _iteratorError4;\n\n          try {\n            for (var _iterator4 = _asyncIterator(walkDag(cid, _this3.blockstore, _this3.loadCodec, options)), _step4, _value4; _step4 = yield _awaitAsyncGenerator(_iterator4.next()), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _awaitAsyncGenerator(_step4.value), !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {\n              const childCid = _value4;\n              // recursive pins override indirect pins\n              const types = [PinTypes.recursive];\n              const result = yield _awaitAsyncGenerator(_this3.isPinnedWithType(childCid, types));\n\n              if (result.pinned) {\n                continue;\n              }\n\n              yield childCid;\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                yield _awaitAsyncGenerator(_iterator4.return());\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            yield _awaitAsyncGenerator(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n\n\n  isPinnedWithType(cid, types, options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!Array.isArray(types)) {\n        types = [types];\n      }\n\n      const all = types.includes(PinTypes.all);\n      const direct = types.includes(PinTypes.direct);\n      const recursive = types.includes(PinTypes.recursive);\n      const indirect = types.includes(PinTypes.indirect);\n\n      if (recursive || direct || all) {\n        const result = yield first(_this6.pinstore.query({\n          prefix: cidToKey(cid).toString(),\n          filters: [entry => {\n            if (all) {\n              return true;\n            }\n\n            const pin = cborg.decode(entry.value);\n            return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);\n          }],\n          limit: 1\n        }));\n\n        if (result) {\n          const pin = cborg.decode(result.value);\n          return {\n            cid,\n            pinned: true,\n            reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n            metadata: pin.metadata\n          };\n        }\n      }\n\n      const self = _this6;\n      /**\n       * @param {CID} key\n       * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n       */\n\n      function findChild(_x, _x2) {\n        return _findChild.apply(this, arguments);\n      }\n\n      function _findChild() {\n        _findChild = _wrapAsyncGenerator(function* (key, source) {\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n\n          var _iteratorError5;\n\n          try {\n            for (var _iterator5 = _asyncIterator(source), _step5, _value5; _step5 = yield _awaitAsyncGenerator(_iterator5.next()), _iteratorNormalCompletion5 = _step5.done, _value5 = yield _awaitAsyncGenerator(_step5.value), !_iteratorNormalCompletion5; _iteratorNormalCompletion5 = true) {\n              const {\n                cid: parentCid\n              } = _value5;\n              var _iteratorNormalCompletion6 = true;\n              var _didIteratorError6 = false;\n\n              var _iteratorError6;\n\n              try {\n                for (var _iterator6 = _asyncIterator(walkDag(parentCid, self.blockstore, self.loadCodec)), _step6, _value6; _step6 = yield _awaitAsyncGenerator(_iterator6.next()), _iteratorNormalCompletion6 = _step6.done, _value6 = yield _awaitAsyncGenerator(_step6.value), !_iteratorNormalCompletion6; _iteratorNormalCompletion6 = true) {\n                  const childCid = _value6;\n\n                  if (childCid.equals(key)) {\n                    yield parentCid;\n                    return;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                    yield _awaitAsyncGenerator(_iterator6.return());\n                  }\n                } finally {\n                  if (_didIteratorError6) {\n                    throw _iteratorError6;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                yield _awaitAsyncGenerator(_iterator5.return());\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        });\n        return _findChild.apply(this, arguments);\n      }\n\n      if (all || indirect) {\n        // indirect (default)\n        // check each recursive key to see if multihash is under it\n        const parentCid = yield first(findChild(cid, _this6.recursiveKeys()));\n\n        if (parentCid) {\n          return {\n            cid,\n            pinned: true,\n            reason: PinTypes.indirect,\n            parent: parentCid\n          };\n        }\n      }\n\n      return {\n        cid,\n        pinned: false\n      };\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n\n\n  fetchCompleteDag(cid, options) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const seen = new Set();\n      /**\n       * @param {CID} cid\n       * @param {AbortOptions} options\n       */\n\n      const walkDag = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (cid, options) {\n          if (seen.has(cid.toString())) {\n            return;\n          }\n\n          seen.add(cid.toString());\n          const bytes = yield _this7.blockstore.get(cid, options);\n          const codec = yield _this7.loadCodec(cid.code);\n          const block = Block.createUnsafe({\n            bytes,\n            cid,\n            codec\n          });\n          yield Promise.all([...block.links()].map(([, childCid]) => walkDag(childCid, options)));\n        });\n\n        return function walkDag(_x3, _x4) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      yield walkDag(cid, options);\n    })();\n  }\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = {\n  PinManager,\n  PinTypes\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-repo/src/pins.js"],"names":["CID","require","errCode","debug","first","Block","cborg","dagPb","cidToKey","keyToMultihash","walkDag","invalidPinTypeErr","type","errMsg","Error","PinTypes","direct","recursive","indirect","all","PinManager","constructor","pinstore","blockstore","loadCodec","log","directPins","Set","recursivePins","pinDirectly","cid","options","get","pin","depth","version","code","codec","metadata","put","encode","unpin","delete","pinRecursively","fetchCompleteDag","Infinity","directKeys","query","filters","entry","decode","value","multihash","key","create","recursiveKeys","indirectKeys","childCid","types","result","isPinnedWithType","pinned","Array","isArray","includes","prefix","toString","limit","reason","self","findChild","source","parentCid","equals","parent","seen","has","add","bytes","block","createUnsafe","Promise","links","map","checkPinType","Object","keys","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\nconst debug = require('debug')\nconst first = require('it-first')\nconst Block = require('multiformats/block')\nconst cborg = require('cborg')\nconst dagPb = require('@ipld/dag-pb')\nconst {\n  cidToKey,\n  keyToMultihash\n} = require('./utils/blockstore')\nconst walkDag = require('./utils/walk-dag')\n\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').CIDVersion} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @param {string} type\n */\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\nconst PinTypes = {\n  /** @type {'direct'} */\n  direct: ('direct'),\n  /** @type {'recursive'} */\n  recursive: ('recursive'),\n  /** @type {'indirect'} */\n  indirect: ('indirect'),\n  /** @type {'all'} */\n  all: ('all')\n}\n\n/**\n * @implements {Pins}\n */\nclass PinManager {\n  /**\n   * @param {Object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor ({ pinstore, blockstore, loadCodec }) {\n    this.pinstore = pinstore\n    this.blockstore = blockstore\n    this.loadCodec = loadCodec\n    this.log = debug('ipfs:repo:pin')\n    this.directPins = new Set()\n    this.recursivePins = new Set()\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinDirectly (cid, options = {}) {\n    await this.blockstore.get(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n  unpin (cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinRecursively (cid, options = {}) {\n    await this.fetchCompleteDag(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * directKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === 0\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * recursiveKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === Infinity\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * indirectKeys (options) {\n    for await (const { cid } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [\n          PinTypes.recursive\n        ]\n\n        const result = await this.isPinnedWithType(childCid, types)\n\n        if (result.pinned) {\n          continue\n        }\n\n        yield childCid\n      }\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n  async isPinnedWithType (cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types]\n    }\n\n    const all = types.includes(PinTypes.all)\n    const direct = types.includes(PinTypes.direct)\n    const recursive = types.includes(PinTypes.recursive)\n    const indirect = types.includes(PinTypes.indirect)\n\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true\n          }\n\n          const pin = cborg.decode(entry.value)\n\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive)\n        }],\n        limit: 1\n      }))\n\n      if (result) {\n        const pin = cborg.decode(result.value)\n\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        }\n      }\n    }\n\n    const self = this\n\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n    async function * findChild (key, source) {\n      for await (const { cid: parentCid } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid\n            return\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n\n      const parentCid = await first(findChild(cid, this.recursiveKeys()))\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        }\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n  async fetchCompleteDag (cid, options) {\n    const seen = new Set()\n\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return\n      }\n\n      seen.add(cid.toString())\n\n      const bytes = await this.blockstore.get(cid, options)\n      const codec = await this.loadCodec(cid.code)\n      const block = Block.createUnsafe({ bytes, cid, codec })\n\n      await Promise.all(\n        [...block.links()].map(([, childCid]) => walkDag(childCid, options))\n      )\n    }\n\n    await walkDag(cid, options)\n  }\n\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n  static checkPinType (type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type)\n    }\n    return true\n  }\n}\n\nmodule.exports = {\n  PinManager,\n  PinTypes\n}\n"]},"metadata":{},"sourceType":"script"}