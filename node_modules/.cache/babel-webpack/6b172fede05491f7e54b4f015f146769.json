{"ast":null,"code":"/*eslint-disable*/\n(function (global, factory) {\n  /* global define, require, module */\n\n  /* AMD */\n  if (typeof define === 'function' && define.amd) define([\"protobufjs/minimal\"], factory);\n  /* CommonJS */\n  else if (typeof require === 'function' && typeof module === 'object' && module && module.exports) module.exports = factory(require(\"protobufjs/minimal\"));\n})(this, function ($protobuf) {\n  \"use strict\"; // Common aliases\n\n  var $Reader = $protobuf.Reader,\n      $Writer = $protobuf.Writer,\n      $util = $protobuf.util; // Exported root namespace\n\n  var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n  $root.RPC = function () {\n    /**\n     * Properties of a RPC.\n     * @exports IRPC\n     * @interface IRPC\n     * @property {Array.<RPC.ISubOpts>|null} [subscriptions] RPC subscriptions\n     * @property {Array.<RPC.IMessage>|null} [msgs] RPC msgs\n     * @property {RPC.IControlMessage|null} [control] RPC control\n     */\n\n    /**\n     * Constructs a new RPC.\n     * @exports RPC\n     * @classdesc Represents a RPC.\n     * @implements IRPC\n     * @constructor\n     * @param {IRPC=} [p] Properties to set\n     */\n    function RPC(p) {\n      this.subscriptions = [];\n      this.msgs = [];\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * RPC subscriptions.\n     * @member {Array.<RPC.ISubOpts>} subscriptions\n     * @memberof RPC\n     * @instance\n     */\n\n\n    RPC.prototype.subscriptions = $util.emptyArray;\n    /**\n     * RPC msgs.\n     * @member {Array.<RPC.IMessage>} msgs\n     * @memberof RPC\n     * @instance\n     */\n\n    RPC.prototype.msgs = $util.emptyArray;\n    /**\n     * RPC control.\n     * @member {RPC.IControlMessage|null|undefined} control\n     * @memberof RPC\n     * @instance\n     */\n\n    RPC.prototype.control = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * RPC _control.\n     * @member {\"control\"|undefined} _control\n     * @memberof RPC\n     * @instance\n     */\n\n    Object.defineProperty(RPC.prototype, \"_control\", {\n      get: $util.oneOfGetter($oneOfFields = [\"control\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Encodes the specified RPC message. Does not implicitly {@link RPC.verify|verify} messages.\n     * @function encode\n     * @memberof RPC\n     * @static\n     * @param {IRPC} m RPC message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    RPC.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n\n      if (m.subscriptions != null && m.subscriptions.length) {\n        for (var i = 0; i < m.subscriptions.length; ++i) $root.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();\n      }\n\n      if (m.msgs != null && m.msgs.length) {\n        for (var i = 0; i < m.msgs.length; ++i) $root.RPC.Message.encode(m.msgs[i], w.uint32(18).fork()).ldelim();\n      }\n\n      if (m.control != null && Object.hasOwnProperty.call(m, \"control\")) $root.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();\n      return w;\n    };\n    /**\n     * Decodes a RPC message from the specified reader or buffer.\n     * @function decode\n     * @memberof RPC\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {RPC} RPC\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    RPC.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.RPC();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            if (!(m.subscriptions && m.subscriptions.length)) m.subscriptions = [];\n            m.subscriptions.push($root.RPC.SubOpts.decode(r, r.uint32()));\n            break;\n\n          case 2:\n            if (!(m.msgs && m.msgs.length)) m.msgs = [];\n            m.msgs.push($root.RPC.Message.decode(r, r.uint32()));\n            break;\n\n          case 3:\n            m.control = $root.RPC.ControlMessage.decode(r, r.uint32());\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a RPC message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof RPC\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {RPC} RPC\n     */\n\n\n    RPC.fromObject = function fromObject(d) {\n      if (d instanceof $root.RPC) return d;\n      var m = new $root.RPC();\n\n      if (d.subscriptions) {\n        if (!Array.isArray(d.subscriptions)) throw TypeError(\".RPC.subscriptions: array expected\");\n        m.subscriptions = [];\n\n        for (var i = 0; i < d.subscriptions.length; ++i) {\n          if (typeof d.subscriptions[i] !== \"object\") throw TypeError(\".RPC.subscriptions: object expected\");\n          m.subscriptions[i] = $root.RPC.SubOpts.fromObject(d.subscriptions[i]);\n        }\n      }\n\n      if (d.msgs) {\n        if (!Array.isArray(d.msgs)) throw TypeError(\".RPC.msgs: array expected\");\n        m.msgs = [];\n\n        for (var i = 0; i < d.msgs.length; ++i) {\n          if (typeof d.msgs[i] !== \"object\") throw TypeError(\".RPC.msgs: object expected\");\n          m.msgs[i] = $root.RPC.Message.fromObject(d.msgs[i]);\n        }\n      }\n\n      if (d.control != null) {\n        if (typeof d.control !== \"object\") throw TypeError(\".RPC.control: object expected\");\n        m.control = $root.RPC.ControlMessage.fromObject(d.control);\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a RPC message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof RPC\n     * @static\n     * @param {RPC} m RPC\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    RPC.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.arrays || o.defaults) {\n        d.subscriptions = [];\n        d.msgs = [];\n      }\n\n      if (m.subscriptions && m.subscriptions.length) {\n        d.subscriptions = [];\n\n        for (var j = 0; j < m.subscriptions.length; ++j) {\n          d.subscriptions[j] = $root.RPC.SubOpts.toObject(m.subscriptions[j], o);\n        }\n      }\n\n      if (m.msgs && m.msgs.length) {\n        d.msgs = [];\n\n        for (var j = 0; j < m.msgs.length; ++j) {\n          d.msgs[j] = $root.RPC.Message.toObject(m.msgs[j], o);\n        }\n      }\n\n      if (m.control != null && m.hasOwnProperty(\"control\")) {\n        d.control = $root.RPC.ControlMessage.toObject(m.control, o);\n        if (o.oneofs) d._control = \"control\";\n      }\n\n      return d;\n    };\n    /**\n     * Converts this RPC to JSON.\n     * @function toJSON\n     * @memberof RPC\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    RPC.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    RPC.SubOpts = function () {\n      /**\n       * Properties of a SubOpts.\n       * @memberof RPC\n       * @interface ISubOpts\n       * @property {boolean|null} [subscribe] SubOpts subscribe\n       * @property {string|null} [topicID] SubOpts topicID\n       */\n\n      /**\n       * Constructs a new SubOpts.\n       * @memberof RPC\n       * @classdesc Represents a SubOpts.\n       * @implements ISubOpts\n       * @constructor\n       * @param {RPC.ISubOpts=} [p] Properties to set\n       */\n      function SubOpts(p) {\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * SubOpts subscribe.\n       * @member {boolean|null|undefined} subscribe\n       * @memberof RPC.SubOpts\n       * @instance\n       */\n\n\n      SubOpts.prototype.subscribe = null;\n      /**\n       * SubOpts topicID.\n       * @member {string|null|undefined} topicID\n       * @memberof RPC.SubOpts\n       * @instance\n       */\n\n      SubOpts.prototype.topicID = null; // OneOf field names bound to virtual getters and setters\n\n      var $oneOfFields;\n      /**\n       * SubOpts _subscribe.\n       * @member {\"subscribe\"|undefined} _subscribe\n       * @memberof RPC.SubOpts\n       * @instance\n       */\n\n      Object.defineProperty(SubOpts.prototype, \"_subscribe\", {\n        get: $util.oneOfGetter($oneOfFields = [\"subscribe\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * SubOpts _topicID.\n       * @member {\"topicID\"|undefined} _topicID\n       * @memberof RPC.SubOpts\n       * @instance\n       */\n\n      Object.defineProperty(SubOpts.prototype, \"_topicID\", {\n        get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Encodes the specified SubOpts message. Does not implicitly {@link RPC.SubOpts.verify|verify} messages.\n       * @function encode\n       * @memberof RPC.SubOpts\n       * @static\n       * @param {RPC.ISubOpts} m SubOpts message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      SubOpts.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n        if (m.subscribe != null && Object.hasOwnProperty.call(m, \"subscribe\")) w.uint32(8).bool(m.subscribe);\n        if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\")) w.uint32(18).string(m.topicID);\n        return w;\n      };\n      /**\n       * Decodes a SubOpts message from the specified reader or buffer.\n       * @function decode\n       * @memberof RPC.SubOpts\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {RPC.SubOpts} SubOpts\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      SubOpts.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.RPC.SubOpts();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              m.subscribe = r.bool();\n              break;\n\n            case 2:\n              m.topicID = r.string();\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a SubOpts message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof RPC.SubOpts\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {RPC.SubOpts} SubOpts\n       */\n\n\n      SubOpts.fromObject = function fromObject(d) {\n        if (d instanceof $root.RPC.SubOpts) return d;\n        var m = new $root.RPC.SubOpts();\n\n        if (d.subscribe != null) {\n          m.subscribe = Boolean(d.subscribe);\n        }\n\n        if (d.topicID != null) {\n          m.topicID = String(d.topicID);\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from a SubOpts message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof RPC.SubOpts\n       * @static\n       * @param {RPC.SubOpts} m SubOpts\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      SubOpts.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (m.subscribe != null && m.hasOwnProperty(\"subscribe\")) {\n          d.subscribe = m.subscribe;\n          if (o.oneofs) d._subscribe = \"subscribe\";\n        }\n\n        if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n          d.topicID = m.topicID;\n          if (o.oneofs) d._topicID = \"topicID\";\n        }\n\n        return d;\n      };\n      /**\n       * Converts this SubOpts to JSON.\n       * @function toJSON\n       * @memberof RPC.SubOpts\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      SubOpts.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return SubOpts;\n    }();\n\n    RPC.Message = function () {\n      /**\n       * Properties of a Message.\n       * @memberof RPC\n       * @interface IMessage\n       * @property {Uint8Array|null} [from] Message from\n       * @property {Uint8Array|null} [data] Message data\n       * @property {Uint8Array|null} [seqno] Message seqno\n       * @property {Array.<string>|null} [topicIDs] Message topicIDs\n       * @property {Uint8Array|null} [signature] Message signature\n       * @property {Uint8Array|null} [key] Message key\n       */\n\n      /**\n       * Constructs a new Message.\n       * @memberof RPC\n       * @classdesc Represents a Message.\n       * @implements IMessage\n       * @constructor\n       * @param {RPC.IMessage=} [p] Properties to set\n       */\n      function Message(p) {\n        this.topicIDs = [];\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * Message from.\n       * @member {Uint8Array|null|undefined} from\n       * @memberof RPC.Message\n       * @instance\n       */\n\n\n      Message.prototype.from = null;\n      /**\n       * Message data.\n       * @member {Uint8Array|null|undefined} data\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Message.prototype.data = null;\n      /**\n       * Message seqno.\n       * @member {Uint8Array|null|undefined} seqno\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Message.prototype.seqno = null;\n      /**\n       * Message topicIDs.\n       * @member {Array.<string>} topicIDs\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Message.prototype.topicIDs = $util.emptyArray;\n      /**\n       * Message signature.\n       * @member {Uint8Array|null|undefined} signature\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Message.prototype.signature = null;\n      /**\n       * Message key.\n       * @member {Uint8Array|null|undefined} key\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Message.prototype.key = null; // OneOf field names bound to virtual getters and setters\n\n      var $oneOfFields;\n      /**\n       * Message _from.\n       * @member {\"from\"|undefined} _from\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Object.defineProperty(Message.prototype, \"_from\", {\n        get: $util.oneOfGetter($oneOfFields = [\"from\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Message _data.\n       * @member {\"data\"|undefined} _data\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Object.defineProperty(Message.prototype, \"_data\", {\n        get: $util.oneOfGetter($oneOfFields = [\"data\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Message _seqno.\n       * @member {\"seqno\"|undefined} _seqno\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Object.defineProperty(Message.prototype, \"_seqno\", {\n        get: $util.oneOfGetter($oneOfFields = [\"seqno\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Message _signature.\n       * @member {\"signature\"|undefined} _signature\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Object.defineProperty(Message.prototype, \"_signature\", {\n        get: $util.oneOfGetter($oneOfFields = [\"signature\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Message _key.\n       * @member {\"key\"|undefined} _key\n       * @memberof RPC.Message\n       * @instance\n       */\n\n      Object.defineProperty(Message.prototype, \"_key\", {\n        get: $util.oneOfGetter($oneOfFields = [\"key\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Encodes the specified Message message. Does not implicitly {@link RPC.Message.verify|verify} messages.\n       * @function encode\n       * @memberof RPC.Message\n       * @static\n       * @param {RPC.IMessage} m Message message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      Message.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n        if (m.from != null && Object.hasOwnProperty.call(m, \"from\")) w.uint32(10).bytes(m.from);\n        if (m.data != null && Object.hasOwnProperty.call(m, \"data\")) w.uint32(18).bytes(m.data);\n        if (m.seqno != null && Object.hasOwnProperty.call(m, \"seqno\")) w.uint32(26).bytes(m.seqno);\n\n        if (m.topicIDs != null && m.topicIDs.length) {\n          for (var i = 0; i < m.topicIDs.length; ++i) w.uint32(34).string(m.topicIDs[i]);\n        }\n\n        if (m.signature != null && Object.hasOwnProperty.call(m, \"signature\")) w.uint32(42).bytes(m.signature);\n        if (m.key != null && Object.hasOwnProperty.call(m, \"key\")) w.uint32(50).bytes(m.key);\n        return w;\n      };\n      /**\n       * Decodes a Message message from the specified reader or buffer.\n       * @function decode\n       * @memberof RPC.Message\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {RPC.Message} Message\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      Message.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.RPC.Message();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              m.from = r.bytes();\n              break;\n\n            case 2:\n              m.data = r.bytes();\n              break;\n\n            case 3:\n              m.seqno = r.bytes();\n              break;\n\n            case 4:\n              if (!(m.topicIDs && m.topicIDs.length)) m.topicIDs = [];\n              m.topicIDs.push(r.string());\n              break;\n\n            case 5:\n              m.signature = r.bytes();\n              break;\n\n            case 6:\n              m.key = r.bytes();\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a Message message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof RPC.Message\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {RPC.Message} Message\n       */\n\n\n      Message.fromObject = function fromObject(d) {\n        if (d instanceof $root.RPC.Message) return d;\n        var m = new $root.RPC.Message();\n\n        if (d.from != null) {\n          if (typeof d.from === \"string\") $util.base64.decode(d.from, m.from = $util.newBuffer($util.base64.length(d.from)), 0);else if (d.from.length) m.from = d.from;\n        }\n\n        if (d.data != null) {\n          if (typeof d.data === \"string\") $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);else if (d.data.length) m.data = d.data;\n        }\n\n        if (d.seqno != null) {\n          if (typeof d.seqno === \"string\") $util.base64.decode(d.seqno, m.seqno = $util.newBuffer($util.base64.length(d.seqno)), 0);else if (d.seqno.length) m.seqno = d.seqno;\n        }\n\n        if (d.topicIDs) {\n          if (!Array.isArray(d.topicIDs)) throw TypeError(\".RPC.Message.topicIDs: array expected\");\n          m.topicIDs = [];\n\n          for (var i = 0; i < d.topicIDs.length; ++i) {\n            m.topicIDs[i] = String(d.topicIDs[i]);\n          }\n        }\n\n        if (d.signature != null) {\n          if (typeof d.signature === \"string\") $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);else if (d.signature.length) m.signature = d.signature;\n        }\n\n        if (d.key != null) {\n          if (typeof d.key === \"string\") $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);else if (d.key.length) m.key = d.key;\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from a Message message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof RPC.Message\n       * @static\n       * @param {RPC.Message} m Message\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      Message.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (o.arrays || o.defaults) {\n          d.topicIDs = [];\n        }\n\n        if (m.from != null && m.hasOwnProperty(\"from\")) {\n          d.from = o.bytes === String ? $util.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;\n          if (o.oneofs) d._from = \"from\";\n        }\n\n        if (m.data != null && m.hasOwnProperty(\"data\")) {\n          d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;\n          if (o.oneofs) d._data = \"data\";\n        }\n\n        if (m.seqno != null && m.hasOwnProperty(\"seqno\")) {\n          d.seqno = o.bytes === String ? $util.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;\n          if (o.oneofs) d._seqno = \"seqno\";\n        }\n\n        if (m.topicIDs && m.topicIDs.length) {\n          d.topicIDs = [];\n\n          for (var j = 0; j < m.topicIDs.length; ++j) {\n            d.topicIDs[j] = m.topicIDs[j];\n          }\n        }\n\n        if (m.signature != null && m.hasOwnProperty(\"signature\")) {\n          d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;\n          if (o.oneofs) d._signature = \"signature\";\n        }\n\n        if (m.key != null && m.hasOwnProperty(\"key\")) {\n          d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;\n          if (o.oneofs) d._key = \"key\";\n        }\n\n        return d;\n      };\n      /**\n       * Converts this Message to JSON.\n       * @function toJSON\n       * @memberof RPC.Message\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      Message.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return Message;\n    }();\n\n    RPC.ControlMessage = function () {\n      /**\n       * Properties of a ControlMessage.\n       * @memberof RPC\n       * @interface IControlMessage\n       * @property {Array.<RPC.IControlIHave>|null} [ihave] ControlMessage ihave\n       * @property {Array.<RPC.IControlIWant>|null} [iwant] ControlMessage iwant\n       * @property {Array.<RPC.IControlGraft>|null} [graft] ControlMessage graft\n       * @property {Array.<RPC.IControlPrune>|null} [prune] ControlMessage prune\n       */\n\n      /**\n       * Constructs a new ControlMessage.\n       * @memberof RPC\n       * @classdesc Represents a ControlMessage.\n       * @implements IControlMessage\n       * @constructor\n       * @param {RPC.IControlMessage=} [p] Properties to set\n       */\n      function ControlMessage(p) {\n        this.ihave = [];\n        this.iwant = [];\n        this.graft = [];\n        this.prune = [];\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * ControlMessage ihave.\n       * @member {Array.<RPC.IControlIHave>} ihave\n       * @memberof RPC.ControlMessage\n       * @instance\n       */\n\n\n      ControlMessage.prototype.ihave = $util.emptyArray;\n      /**\n       * ControlMessage iwant.\n       * @member {Array.<RPC.IControlIWant>} iwant\n       * @memberof RPC.ControlMessage\n       * @instance\n       */\n\n      ControlMessage.prototype.iwant = $util.emptyArray;\n      /**\n       * ControlMessage graft.\n       * @member {Array.<RPC.IControlGraft>} graft\n       * @memberof RPC.ControlMessage\n       * @instance\n       */\n\n      ControlMessage.prototype.graft = $util.emptyArray;\n      /**\n       * ControlMessage prune.\n       * @member {Array.<RPC.IControlPrune>} prune\n       * @memberof RPC.ControlMessage\n       * @instance\n       */\n\n      ControlMessage.prototype.prune = $util.emptyArray;\n      /**\n       * Encodes the specified ControlMessage message. Does not implicitly {@link RPC.ControlMessage.verify|verify} messages.\n       * @function encode\n       * @memberof RPC.ControlMessage\n       * @static\n       * @param {RPC.IControlMessage} m ControlMessage message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      ControlMessage.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n\n        if (m.ihave != null && m.ihave.length) {\n          for (var i = 0; i < m.ihave.length; ++i) $root.RPC.ControlIHave.encode(m.ihave[i], w.uint32(10).fork()).ldelim();\n        }\n\n        if (m.iwant != null && m.iwant.length) {\n          for (var i = 0; i < m.iwant.length; ++i) $root.RPC.ControlIWant.encode(m.iwant[i], w.uint32(18).fork()).ldelim();\n        }\n\n        if (m.graft != null && m.graft.length) {\n          for (var i = 0; i < m.graft.length; ++i) $root.RPC.ControlGraft.encode(m.graft[i], w.uint32(26).fork()).ldelim();\n        }\n\n        if (m.prune != null && m.prune.length) {\n          for (var i = 0; i < m.prune.length; ++i) $root.RPC.ControlPrune.encode(m.prune[i], w.uint32(34).fork()).ldelim();\n        }\n\n        return w;\n      };\n      /**\n       * Decodes a ControlMessage message from the specified reader or buffer.\n       * @function decode\n       * @memberof RPC.ControlMessage\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {RPC.ControlMessage} ControlMessage\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ControlMessage.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.RPC.ControlMessage();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              if (!(m.ihave && m.ihave.length)) m.ihave = [];\n              m.ihave.push($root.RPC.ControlIHave.decode(r, r.uint32()));\n              break;\n\n            case 2:\n              if (!(m.iwant && m.iwant.length)) m.iwant = [];\n              m.iwant.push($root.RPC.ControlIWant.decode(r, r.uint32()));\n              break;\n\n            case 3:\n              if (!(m.graft && m.graft.length)) m.graft = [];\n              m.graft.push($root.RPC.ControlGraft.decode(r, r.uint32()));\n              break;\n\n            case 4:\n              if (!(m.prune && m.prune.length)) m.prune = [];\n              m.prune.push($root.RPC.ControlPrune.decode(r, r.uint32()));\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a ControlMessage message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof RPC.ControlMessage\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {RPC.ControlMessage} ControlMessage\n       */\n\n\n      ControlMessage.fromObject = function fromObject(d) {\n        if (d instanceof $root.RPC.ControlMessage) return d;\n        var m = new $root.RPC.ControlMessage();\n\n        if (d.ihave) {\n          if (!Array.isArray(d.ihave)) throw TypeError(\".RPC.ControlMessage.ihave: array expected\");\n          m.ihave = [];\n\n          for (var i = 0; i < d.ihave.length; ++i) {\n            if (typeof d.ihave[i] !== \"object\") throw TypeError(\".RPC.ControlMessage.ihave: object expected\");\n            m.ihave[i] = $root.RPC.ControlIHave.fromObject(d.ihave[i]);\n          }\n        }\n\n        if (d.iwant) {\n          if (!Array.isArray(d.iwant)) throw TypeError(\".RPC.ControlMessage.iwant: array expected\");\n          m.iwant = [];\n\n          for (var i = 0; i < d.iwant.length; ++i) {\n            if (typeof d.iwant[i] !== \"object\") throw TypeError(\".RPC.ControlMessage.iwant: object expected\");\n            m.iwant[i] = $root.RPC.ControlIWant.fromObject(d.iwant[i]);\n          }\n        }\n\n        if (d.graft) {\n          if (!Array.isArray(d.graft)) throw TypeError(\".RPC.ControlMessage.graft: array expected\");\n          m.graft = [];\n\n          for (var i = 0; i < d.graft.length; ++i) {\n            if (typeof d.graft[i] !== \"object\") throw TypeError(\".RPC.ControlMessage.graft: object expected\");\n            m.graft[i] = $root.RPC.ControlGraft.fromObject(d.graft[i]);\n          }\n        }\n\n        if (d.prune) {\n          if (!Array.isArray(d.prune)) throw TypeError(\".RPC.ControlMessage.prune: array expected\");\n          m.prune = [];\n\n          for (var i = 0; i < d.prune.length; ++i) {\n            if (typeof d.prune[i] !== \"object\") throw TypeError(\".RPC.ControlMessage.prune: object expected\");\n            m.prune[i] = $root.RPC.ControlPrune.fromObject(d.prune[i]);\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from a ControlMessage message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof RPC.ControlMessage\n       * @static\n       * @param {RPC.ControlMessage} m ControlMessage\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ControlMessage.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (o.arrays || o.defaults) {\n          d.ihave = [];\n          d.iwant = [];\n          d.graft = [];\n          d.prune = [];\n        }\n\n        if (m.ihave && m.ihave.length) {\n          d.ihave = [];\n\n          for (var j = 0; j < m.ihave.length; ++j) {\n            d.ihave[j] = $root.RPC.ControlIHave.toObject(m.ihave[j], o);\n          }\n        }\n\n        if (m.iwant && m.iwant.length) {\n          d.iwant = [];\n\n          for (var j = 0; j < m.iwant.length; ++j) {\n            d.iwant[j] = $root.RPC.ControlIWant.toObject(m.iwant[j], o);\n          }\n        }\n\n        if (m.graft && m.graft.length) {\n          d.graft = [];\n\n          for (var j = 0; j < m.graft.length; ++j) {\n            d.graft[j] = $root.RPC.ControlGraft.toObject(m.graft[j], o);\n          }\n        }\n\n        if (m.prune && m.prune.length) {\n          d.prune = [];\n\n          for (var j = 0; j < m.prune.length; ++j) {\n            d.prune[j] = $root.RPC.ControlPrune.toObject(m.prune[j], o);\n          }\n        }\n\n        return d;\n      };\n      /**\n       * Converts this ControlMessage to JSON.\n       * @function toJSON\n       * @memberof RPC.ControlMessage\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ControlMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ControlMessage;\n    }();\n\n    RPC.ControlIHave = function () {\n      /**\n       * Properties of a ControlIHave.\n       * @memberof RPC\n       * @interface IControlIHave\n       * @property {string|null} [topicID] ControlIHave topicID\n       * @property {Array.<Uint8Array>|null} [messageIDs] ControlIHave messageIDs\n       */\n\n      /**\n       * Constructs a new ControlIHave.\n       * @memberof RPC\n       * @classdesc Represents a ControlIHave.\n       * @implements IControlIHave\n       * @constructor\n       * @param {RPC.IControlIHave=} [p] Properties to set\n       */\n      function ControlIHave(p) {\n        this.messageIDs = [];\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * ControlIHave topicID.\n       * @member {string|null|undefined} topicID\n       * @memberof RPC.ControlIHave\n       * @instance\n       */\n\n\n      ControlIHave.prototype.topicID = null;\n      /**\n       * ControlIHave messageIDs.\n       * @member {Array.<Uint8Array>} messageIDs\n       * @memberof RPC.ControlIHave\n       * @instance\n       */\n\n      ControlIHave.prototype.messageIDs = $util.emptyArray; // OneOf field names bound to virtual getters and setters\n\n      var $oneOfFields;\n      /**\n       * ControlIHave _topicID.\n       * @member {\"topicID\"|undefined} _topicID\n       * @memberof RPC.ControlIHave\n       * @instance\n       */\n\n      Object.defineProperty(ControlIHave.prototype, \"_topicID\", {\n        get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Encodes the specified ControlIHave message. Does not implicitly {@link RPC.ControlIHave.verify|verify} messages.\n       * @function encode\n       * @memberof RPC.ControlIHave\n       * @static\n       * @param {RPC.IControlIHave} m ControlIHave message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      ControlIHave.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n        if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\")) w.uint32(10).string(m.topicID);\n\n        if (m.messageIDs != null && m.messageIDs.length) {\n          for (var i = 0; i < m.messageIDs.length; ++i) w.uint32(18).bytes(m.messageIDs[i]);\n        }\n\n        return w;\n      };\n      /**\n       * Decodes a ControlIHave message from the specified reader or buffer.\n       * @function decode\n       * @memberof RPC.ControlIHave\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {RPC.ControlIHave} ControlIHave\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ControlIHave.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.RPC.ControlIHave();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              m.topicID = r.string();\n              break;\n\n            case 2:\n              if (!(m.messageIDs && m.messageIDs.length)) m.messageIDs = [];\n              m.messageIDs.push(r.bytes());\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a ControlIHave message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof RPC.ControlIHave\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {RPC.ControlIHave} ControlIHave\n       */\n\n\n      ControlIHave.fromObject = function fromObject(d) {\n        if (d instanceof $root.RPC.ControlIHave) return d;\n        var m = new $root.RPC.ControlIHave();\n\n        if (d.topicID != null) {\n          m.topicID = String(d.topicID);\n        }\n\n        if (d.messageIDs) {\n          if (!Array.isArray(d.messageIDs)) throw TypeError(\".RPC.ControlIHave.messageIDs: array expected\");\n          m.messageIDs = [];\n\n          for (var i = 0; i < d.messageIDs.length; ++i) {\n            if (typeof d.messageIDs[i] === \"string\") $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);else if (d.messageIDs[i].length) m.messageIDs[i] = d.messageIDs[i];\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from a ControlIHave message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof RPC.ControlIHave\n       * @static\n       * @param {RPC.ControlIHave} m ControlIHave\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ControlIHave.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (o.arrays || o.defaults) {\n          d.messageIDs = [];\n        }\n\n        if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n          d.topicID = m.topicID;\n          if (o.oneofs) d._topicID = \"topicID\";\n        }\n\n        if (m.messageIDs && m.messageIDs.length) {\n          d.messageIDs = [];\n\n          for (var j = 0; j < m.messageIDs.length; ++j) {\n            d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];\n          }\n        }\n\n        return d;\n      };\n      /**\n       * Converts this ControlIHave to JSON.\n       * @function toJSON\n       * @memberof RPC.ControlIHave\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ControlIHave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ControlIHave;\n    }();\n\n    RPC.ControlIWant = function () {\n      /**\n       * Properties of a ControlIWant.\n       * @memberof RPC\n       * @interface IControlIWant\n       * @property {Array.<Uint8Array>|null} [messageIDs] ControlIWant messageIDs\n       */\n\n      /**\n       * Constructs a new ControlIWant.\n       * @memberof RPC\n       * @classdesc Represents a ControlIWant.\n       * @implements IControlIWant\n       * @constructor\n       * @param {RPC.IControlIWant=} [p] Properties to set\n       */\n      function ControlIWant(p) {\n        this.messageIDs = [];\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * ControlIWant messageIDs.\n       * @member {Array.<Uint8Array>} messageIDs\n       * @memberof RPC.ControlIWant\n       * @instance\n       */\n\n\n      ControlIWant.prototype.messageIDs = $util.emptyArray;\n      /**\n       * Encodes the specified ControlIWant message. Does not implicitly {@link RPC.ControlIWant.verify|verify} messages.\n       * @function encode\n       * @memberof RPC.ControlIWant\n       * @static\n       * @param {RPC.IControlIWant} m ControlIWant message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      ControlIWant.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n\n        if (m.messageIDs != null && m.messageIDs.length) {\n          for (var i = 0; i < m.messageIDs.length; ++i) w.uint32(10).bytes(m.messageIDs[i]);\n        }\n\n        return w;\n      };\n      /**\n       * Decodes a ControlIWant message from the specified reader or buffer.\n       * @function decode\n       * @memberof RPC.ControlIWant\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {RPC.ControlIWant} ControlIWant\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ControlIWant.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.RPC.ControlIWant();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              if (!(m.messageIDs && m.messageIDs.length)) m.messageIDs = [];\n              m.messageIDs.push(r.bytes());\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a ControlIWant message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof RPC.ControlIWant\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {RPC.ControlIWant} ControlIWant\n       */\n\n\n      ControlIWant.fromObject = function fromObject(d) {\n        if (d instanceof $root.RPC.ControlIWant) return d;\n        var m = new $root.RPC.ControlIWant();\n\n        if (d.messageIDs) {\n          if (!Array.isArray(d.messageIDs)) throw TypeError(\".RPC.ControlIWant.messageIDs: array expected\");\n          m.messageIDs = [];\n\n          for (var i = 0; i < d.messageIDs.length; ++i) {\n            if (typeof d.messageIDs[i] === \"string\") $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);else if (d.messageIDs[i].length) m.messageIDs[i] = d.messageIDs[i];\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from a ControlIWant message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof RPC.ControlIWant\n       * @static\n       * @param {RPC.ControlIWant} m ControlIWant\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ControlIWant.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (o.arrays || o.defaults) {\n          d.messageIDs = [];\n        }\n\n        if (m.messageIDs && m.messageIDs.length) {\n          d.messageIDs = [];\n\n          for (var j = 0; j < m.messageIDs.length; ++j) {\n            d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];\n          }\n        }\n\n        return d;\n      };\n      /**\n       * Converts this ControlIWant to JSON.\n       * @function toJSON\n       * @memberof RPC.ControlIWant\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ControlIWant.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ControlIWant;\n    }();\n\n    RPC.ControlGraft = function () {\n      /**\n       * Properties of a ControlGraft.\n       * @memberof RPC\n       * @interface IControlGraft\n       * @property {string|null} [topicID] ControlGraft topicID\n       */\n\n      /**\n       * Constructs a new ControlGraft.\n       * @memberof RPC\n       * @classdesc Represents a ControlGraft.\n       * @implements IControlGraft\n       * @constructor\n       * @param {RPC.IControlGraft=} [p] Properties to set\n       */\n      function ControlGraft(p) {\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * ControlGraft topicID.\n       * @member {string|null|undefined} topicID\n       * @memberof RPC.ControlGraft\n       * @instance\n       */\n\n\n      ControlGraft.prototype.topicID = null; // OneOf field names bound to virtual getters and setters\n\n      var $oneOfFields;\n      /**\n       * ControlGraft _topicID.\n       * @member {\"topicID\"|undefined} _topicID\n       * @memberof RPC.ControlGraft\n       * @instance\n       */\n\n      Object.defineProperty(ControlGraft.prototype, \"_topicID\", {\n        get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Encodes the specified ControlGraft message. Does not implicitly {@link RPC.ControlGraft.verify|verify} messages.\n       * @function encode\n       * @memberof RPC.ControlGraft\n       * @static\n       * @param {RPC.IControlGraft} m ControlGraft message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      ControlGraft.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n        if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\")) w.uint32(10).string(m.topicID);\n        return w;\n      };\n      /**\n       * Decodes a ControlGraft message from the specified reader or buffer.\n       * @function decode\n       * @memberof RPC.ControlGraft\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {RPC.ControlGraft} ControlGraft\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ControlGraft.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.RPC.ControlGraft();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              m.topicID = r.string();\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a ControlGraft message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof RPC.ControlGraft\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {RPC.ControlGraft} ControlGraft\n       */\n\n\n      ControlGraft.fromObject = function fromObject(d) {\n        if (d instanceof $root.RPC.ControlGraft) return d;\n        var m = new $root.RPC.ControlGraft();\n\n        if (d.topicID != null) {\n          m.topicID = String(d.topicID);\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from a ControlGraft message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof RPC.ControlGraft\n       * @static\n       * @param {RPC.ControlGraft} m ControlGraft\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ControlGraft.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n          d.topicID = m.topicID;\n          if (o.oneofs) d._topicID = \"topicID\";\n        }\n\n        return d;\n      };\n      /**\n       * Converts this ControlGraft to JSON.\n       * @function toJSON\n       * @memberof RPC.ControlGraft\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ControlGraft.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ControlGraft;\n    }();\n\n    RPC.ControlPrune = function () {\n      /**\n       * Properties of a ControlPrune.\n       * @memberof RPC\n       * @interface IControlPrune\n       * @property {string|null} [topicID] ControlPrune topicID\n       * @property {Array.<RPC.IPeerInfo>|null} [peers] ControlPrune peers\n       * @property {number|null} [backoff] ControlPrune backoff\n       */\n\n      /**\n       * Constructs a new ControlPrune.\n       * @memberof RPC\n       * @classdesc Represents a ControlPrune.\n       * @implements IControlPrune\n       * @constructor\n       * @param {RPC.IControlPrune=} [p] Properties to set\n       */\n      function ControlPrune(p) {\n        this.peers = [];\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * ControlPrune topicID.\n       * @member {string|null|undefined} topicID\n       * @memberof RPC.ControlPrune\n       * @instance\n       */\n\n\n      ControlPrune.prototype.topicID = null;\n      /**\n       * ControlPrune peers.\n       * @member {Array.<RPC.IPeerInfo>} peers\n       * @memberof RPC.ControlPrune\n       * @instance\n       */\n\n      ControlPrune.prototype.peers = $util.emptyArray;\n      /**\n       * ControlPrune backoff.\n       * @member {number|null|undefined} backoff\n       * @memberof RPC.ControlPrune\n       * @instance\n       */\n\n      ControlPrune.prototype.backoff = null; // OneOf field names bound to virtual getters and setters\n\n      var $oneOfFields;\n      /**\n       * ControlPrune _topicID.\n       * @member {\"topicID\"|undefined} _topicID\n       * @memberof RPC.ControlPrune\n       * @instance\n       */\n\n      Object.defineProperty(ControlPrune.prototype, \"_topicID\", {\n        get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * ControlPrune _backoff.\n       * @member {\"backoff\"|undefined} _backoff\n       * @memberof RPC.ControlPrune\n       * @instance\n       */\n\n      Object.defineProperty(ControlPrune.prototype, \"_backoff\", {\n        get: $util.oneOfGetter($oneOfFields = [\"backoff\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Encodes the specified ControlPrune message. Does not implicitly {@link RPC.ControlPrune.verify|verify} messages.\n       * @function encode\n       * @memberof RPC.ControlPrune\n       * @static\n       * @param {RPC.IControlPrune} m ControlPrune message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      ControlPrune.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n        if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\")) w.uint32(10).string(m.topicID);\n\n        if (m.peers != null && m.peers.length) {\n          for (var i = 0; i < m.peers.length; ++i) $root.RPC.PeerInfo.encode(m.peers[i], w.uint32(18).fork()).ldelim();\n        }\n\n        if (m.backoff != null && Object.hasOwnProperty.call(m, \"backoff\")) w.uint32(24).uint64(m.backoff);\n        return w;\n      };\n      /**\n       * Decodes a ControlPrune message from the specified reader or buffer.\n       * @function decode\n       * @memberof RPC.ControlPrune\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {RPC.ControlPrune} ControlPrune\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ControlPrune.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.RPC.ControlPrune();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              m.topicID = r.string();\n              break;\n\n            case 2:\n              if (!(m.peers && m.peers.length)) m.peers = [];\n              m.peers.push($root.RPC.PeerInfo.decode(r, r.uint32()));\n              break;\n\n            case 3:\n              m.backoff = r.uint64();\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a ControlPrune message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof RPC.ControlPrune\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {RPC.ControlPrune} ControlPrune\n       */\n\n\n      ControlPrune.fromObject = function fromObject(d) {\n        if (d instanceof $root.RPC.ControlPrune) return d;\n        var m = new $root.RPC.ControlPrune();\n\n        if (d.topicID != null) {\n          m.topicID = String(d.topicID);\n        }\n\n        if (d.peers) {\n          if (!Array.isArray(d.peers)) throw TypeError(\".RPC.ControlPrune.peers: array expected\");\n          m.peers = [];\n\n          for (var i = 0; i < d.peers.length; ++i) {\n            if (typeof d.peers[i] !== \"object\") throw TypeError(\".RPC.ControlPrune.peers: object expected\");\n            m.peers[i] = $root.RPC.PeerInfo.fromObject(d.peers[i]);\n          }\n        }\n\n        if (d.backoff != null) {\n          if ($util.Long) (m.backoff = $util.Long.fromValue(d.backoff)).unsigned = true;else if (typeof d.backoff === \"string\") m.backoff = parseInt(d.backoff, 10);else if (typeof d.backoff === \"number\") m.backoff = d.backoff;else if (typeof d.backoff === \"object\") m.backoff = new $util.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from a ControlPrune message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof RPC.ControlPrune\n       * @static\n       * @param {RPC.ControlPrune} m ControlPrune\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ControlPrune.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (o.arrays || o.defaults) {\n          d.peers = [];\n        }\n\n        if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n          d.topicID = m.topicID;\n          if (o.oneofs) d._topicID = \"topicID\";\n        }\n\n        if (m.peers && m.peers.length) {\n          d.peers = [];\n\n          for (var j = 0; j < m.peers.length; ++j) {\n            d.peers[j] = $root.RPC.PeerInfo.toObject(m.peers[j], o);\n          }\n        }\n\n        if (m.backoff != null && m.hasOwnProperty(\"backoff\")) {\n          if (typeof m.backoff === \"number\") d.backoff = o.longs === String ? String(m.backoff) : m.backoff;else d.backoff = o.longs === String ? $util.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;\n          if (o.oneofs) d._backoff = \"backoff\";\n        }\n\n        return d;\n      };\n      /**\n       * Converts this ControlPrune to JSON.\n       * @function toJSON\n       * @memberof RPC.ControlPrune\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ControlPrune.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ControlPrune;\n    }();\n\n    RPC.PeerInfo = function () {\n      /**\n       * Properties of a PeerInfo.\n       * @memberof RPC\n       * @interface IPeerInfo\n       * @property {Uint8Array|null} [peerID] PeerInfo peerID\n       * @property {Uint8Array|null} [signedPeerRecord] PeerInfo signedPeerRecord\n       */\n\n      /**\n       * Constructs a new PeerInfo.\n       * @memberof RPC\n       * @classdesc Represents a PeerInfo.\n       * @implements IPeerInfo\n       * @constructor\n       * @param {RPC.IPeerInfo=} [p] Properties to set\n       */\n      function PeerInfo(p) {\n        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n      }\n      /**\n       * PeerInfo peerID.\n       * @member {Uint8Array|null|undefined} peerID\n       * @memberof RPC.PeerInfo\n       * @instance\n       */\n\n\n      PeerInfo.prototype.peerID = null;\n      /**\n       * PeerInfo signedPeerRecord.\n       * @member {Uint8Array|null|undefined} signedPeerRecord\n       * @memberof RPC.PeerInfo\n       * @instance\n       */\n\n      PeerInfo.prototype.signedPeerRecord = null; // OneOf field names bound to virtual getters and setters\n\n      var $oneOfFields;\n      /**\n       * PeerInfo _peerID.\n       * @member {\"peerID\"|undefined} _peerID\n       * @memberof RPC.PeerInfo\n       * @instance\n       */\n\n      Object.defineProperty(PeerInfo.prototype, \"_peerID\", {\n        get: $util.oneOfGetter($oneOfFields = [\"peerID\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * PeerInfo _signedPeerRecord.\n       * @member {\"signedPeerRecord\"|undefined} _signedPeerRecord\n       * @memberof RPC.PeerInfo\n       * @instance\n       */\n\n      Object.defineProperty(PeerInfo.prototype, \"_signedPeerRecord\", {\n        get: $util.oneOfGetter($oneOfFields = [\"signedPeerRecord\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Encodes the specified PeerInfo message. Does not implicitly {@link RPC.PeerInfo.verify|verify} messages.\n       * @function encode\n       * @memberof RPC.PeerInfo\n       * @static\n       * @param {RPC.IPeerInfo} m PeerInfo message or plain object to encode\n       * @param {$protobuf.Writer} [w] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n      PeerInfo.encode = function encode(m, w) {\n        if (!w) w = $Writer.create();\n        if (m.peerID != null && Object.hasOwnProperty.call(m, \"peerID\")) w.uint32(10).bytes(m.peerID);\n        if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, \"signedPeerRecord\")) w.uint32(18).bytes(m.signedPeerRecord);\n        return w;\n      };\n      /**\n       * Decodes a PeerInfo message from the specified reader or buffer.\n       * @function decode\n       * @memberof RPC.PeerInfo\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n       * @param {number} [l] Message length if known beforehand\n       * @returns {RPC.PeerInfo} PeerInfo\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      PeerInfo.decode = function decode(r, l) {\n        if (!(r instanceof $Reader)) r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l,\n            m = new $root.RPC.PeerInfo();\n\n        while (r.pos < c) {\n          var t = r.uint32();\n\n          switch (t >>> 3) {\n            case 1:\n              m.peerID = r.bytes();\n              break;\n\n            case 2:\n              m.signedPeerRecord = r.bytes();\n              break;\n\n            default:\n              r.skipType(t & 7);\n              break;\n          }\n        }\n\n        return m;\n      };\n      /**\n       * Creates a PeerInfo message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof RPC.PeerInfo\n       * @static\n       * @param {Object.<string,*>} d Plain object\n       * @returns {RPC.PeerInfo} PeerInfo\n       */\n\n\n      PeerInfo.fromObject = function fromObject(d) {\n        if (d instanceof $root.RPC.PeerInfo) return d;\n        var m = new $root.RPC.PeerInfo();\n\n        if (d.peerID != null) {\n          if (typeof d.peerID === \"string\") $util.base64.decode(d.peerID, m.peerID = $util.newBuffer($util.base64.length(d.peerID)), 0);else if (d.peerID.length) m.peerID = d.peerID;\n        }\n\n        if (d.signedPeerRecord != null) {\n          if (typeof d.signedPeerRecord === \"string\") $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);else if (d.signedPeerRecord.length) m.signedPeerRecord = d.signedPeerRecord;\n        }\n\n        return m;\n      };\n      /**\n       * Creates a plain object from a PeerInfo message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof RPC.PeerInfo\n       * @static\n       * @param {RPC.PeerInfo} m PeerInfo\n       * @param {$protobuf.IConversionOptions} [o] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      PeerInfo.toObject = function toObject(m, o) {\n        if (!o) o = {};\n        var d = {};\n\n        if (m.peerID != null && m.hasOwnProperty(\"peerID\")) {\n          d.peerID = o.bytes === String ? $util.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;\n          if (o.oneofs) d._peerID = \"peerID\";\n        }\n\n        if (m.signedPeerRecord != null && m.hasOwnProperty(\"signedPeerRecord\")) {\n          d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;\n          if (o.oneofs) d._signedPeerRecord = \"signedPeerRecord\";\n        }\n\n        return d;\n      };\n      /**\n       * Converts this PeerInfo to JSON.\n       * @function toJSON\n       * @memberof RPC.PeerInfo\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      PeerInfo.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return PeerInfo;\n    }();\n\n    return RPC;\n  }();\n\n  return $root;\n});","map":null,"metadata":{},"sourceType":"script"}