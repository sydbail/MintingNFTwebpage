{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst dagCbor = require('@ipld/dag-cbor');\n\nconst raw = require('multiformats/codecs/raw');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('@ipld/dag-pb').PBLink} DAGLink\n */\n\n/**\n * @param {any} node\n * @param {DAGLink[]} [links]\n * @returns {DAGLink[]}\n */\n\n\nfunction findLinks(node, links = []) {\n  for (const key in node) {\n    const val = node[key];\n\n    if (key === '/' && Object.keys(node).length === 1) {\n      try {\n        links.push({\n          Name: '',\n          Tsize: 0,\n          Hash: CID.parse(val)\n        });\n        continue;\n      } catch (_) {// not a CID\n      }\n    }\n\n    if (val instanceof CID) {\n      links.push({\n        Name: '',\n        Tsize: 0,\n        Hash: val\n      });\n      continue;\n    }\n\n    if (Array.isArray(val)) {\n      findLinks(val, links);\n    }\n\n    if (val && typeof val === 'object') {\n      findLinks(val, links);\n    }\n  }\n\n  return links;\n}\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\n\n\nmodule.exports = ({\n  repo,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/object').API[\"links\"]}\n   */\n  function links(_x) {\n    return _links.apply(this, arguments);\n  }\n\n  function _links() {\n    _links = _asyncToGenerator(function* (cid, options = {}) {\n      const codec = yield codecs.getCodec(cid.code);\n      const block = yield repo.blocks.get(cid, options);\n      const node = codec.decode(block);\n\n      if (cid.code === raw.code) {\n        return [];\n      }\n\n      if (cid.code === dagPb.code) {\n        return node.Links;\n      }\n\n      if (cid.code === dagCbor.code) {\n        return findLinks(node);\n      }\n\n      throw new Error(`Cannot resolve links from codec ${cid.code}`);\n    });\n    return _links.apply(this, arguments);\n  }\n\n  return withTimeoutOption(links);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-core/src/components/object/links.js"],"names":["dagPb","require","dagCbor","raw","CID","withTimeoutOption","findLinks","node","links","key","val","Object","keys","length","push","Name","Tsize","Hash","parse","_","Array","isArray","module","exports","repo","codecs","cid","options","codec","getCodec","code","block","blocks","get","decode","Links","Error"],"mappings":"AAAA;;;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,cAAD,CAArB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,yBAAD,CAAnB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAUH,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,yCAAD,CAAjC;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASK,SAAT,CAAoBC,IAApB,EAA0BC,KAAK,GAAG,EAAlC,EAAsC;AACpC,OAAK,MAAMC,GAAX,IAAkBF,IAAlB,EAAwB;AACtB,UAAMG,GAAG,GAAGH,IAAI,CAACE,GAAD,CAAhB;;AAEA,QAAIA,GAAG,KAAK,GAAR,IAAeE,MAAM,CAACC,IAAP,CAAYL,IAAZ,EAAkBM,MAAlB,KAA6B,CAAhD,EAAmD;AACjD,UAAI;AACFL,QAAAA,KAAK,CAACM,IAAN,CAAW;AACTC,UAAAA,IAAI,EAAE,EADG;AAETC,UAAAA,KAAK,EAAE,CAFE;AAGTC,UAAAA,IAAI,EAAEb,GAAG,CAACc,KAAJ,CAAUR,GAAV;AAHG,SAAX;AAKA;AACD,OAPD,CAOE,OAAOS,CAAP,EAAU,CACV;AACD;AACF;;AAED,QAAIT,GAAG,YAAYN,GAAnB,EAAwB;AACtBI,MAAAA,KAAK,CAACM,IAAN,CAAW;AACTC,QAAAA,IAAI,EAAE,EADG;AAETC,QAAAA,KAAK,EAAE,CAFE;AAGTC,QAAAA,IAAI,EAAEP;AAHG,OAAX;AAKA;AACD;;AAED,QAAIU,KAAK,CAACC,OAAN,CAAcX,GAAd,CAAJ,EAAwB;AACtBJ,MAAAA,SAAS,CAACI,GAAD,EAAMF,KAAN,CAAT;AACD;;AAED,QAAIE,GAAG,IAAI,OAAOA,GAAP,KAAe,QAA1B,EAAoC;AAClCJ,MAAAA,SAAS,CAACI,GAAD,EAAMF,KAAN,CAAT;AACD;AACF;;AAED,SAAOA,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACAc,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAAsB;AACrC;AACF;AACA;AAHuC,WAItBjB,KAJsB;AAAA;AAAA;;AAAA;AAAA,+BAIrC,WAAsBkB,GAAtB,EAA2BC,OAAO,GAAG,EAArC,EAAyC;AACvC,YAAMC,KAAK,SAASH,MAAM,CAACI,QAAP,CAAgBH,GAAG,CAACI,IAApB,CAApB;AACA,YAAMC,KAAK,SAASP,IAAI,CAACQ,MAAL,CAAYC,GAAZ,CAAgBP,GAAhB,EAAqBC,OAArB,CAApB;AACA,YAAMpB,IAAI,GAAGqB,KAAK,CAACM,MAAN,CAAaH,KAAb,CAAb;;AAEA,UAAIL,GAAG,CAACI,IAAJ,KAAa3B,GAAG,CAAC2B,IAArB,EAA2B;AACzB,eAAO,EAAP;AACD;;AAED,UAAIJ,GAAG,CAACI,IAAJ,KAAa9B,KAAK,CAAC8B,IAAvB,EAA6B;AAC3B,eAAOvB,IAAI,CAAC4B,KAAZ;AACD;;AAED,UAAIT,GAAG,CAACI,IAAJ,KAAa5B,OAAO,CAAC4B,IAAzB,EAA+B;AAC7B,eAAOxB,SAAS,CAACC,IAAD,CAAhB;AACD;;AAED,YAAM,IAAI6B,KAAJ,CAAW,mCAAkCV,GAAG,CAACI,IAAK,EAAtD,CAAN;AACD,KAtBoC;AAAA;AAAA;;AAwBrC,SAAOzB,iBAAiB,CAACG,KAAD,CAAxB;AACD,CAzBD","sourcesContent":["'use strict'\n\nconst dagPb = require('@ipld/dag-pb')\nconst dagCbor = require('@ipld/dag-cbor')\nconst raw = require('multiformats/codecs/raw')\nconst { CID } = require('multiformats/cid')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('@ipld/dag-pb').PBLink} DAGLink\n */\n\n/**\n * @param {any} node\n * @param {DAGLink[]} [links]\n * @returns {DAGLink[]}\n */\nfunction findLinks (node, links = []) {\n  for (const key in node) {\n    const val = node[key]\n\n    if (key === '/' && Object.keys(node).length === 1) {\n      try {\n        links.push({\n          Name: '',\n          Tsize: 0,\n          Hash: CID.parse(val)\n        })\n        continue\n      } catch (_) {\n        // not a CID\n      }\n    }\n\n    if (val instanceof CID) {\n      links.push({\n        Name: '',\n        Tsize: 0,\n        Hash: val\n      })\n      continue\n    }\n\n    if (Array.isArray(val)) {\n      findLinks(val, links)\n    }\n\n    if (val && typeof val === 'object') {\n      findLinks(val, links)\n    }\n  }\n\n  return links\n}\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\nmodule.exports = ({ repo, codecs }) => {\n  /**\n   * @type {import('ipfs-core-types/src/object').API[\"links\"]}\n   */\n  async function links (cid, options = {}) {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await repo.blocks.get(cid, options)\n    const node = codec.decode(block)\n\n    if (cid.code === raw.code) {\n      return []\n    }\n\n    if (cid.code === dagPb.code) {\n      return node.Links\n    }\n\n    if (cid.code === dagCbor.code) {\n      return findLinks(node)\n    }\n\n    throw new Error(`Cannot resolve links from codec ${cid.code}`)\n  }\n\n  return withTimeoutOption(links)\n}\n"]},"metadata":{},"sourceType":"script"}