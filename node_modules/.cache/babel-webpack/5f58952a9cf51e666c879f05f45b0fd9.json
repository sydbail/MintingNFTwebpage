{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock\n * @param {AbortOptions} [options]\n */\n\n\nconst resolve = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (cid, path, codecs, getBlock, options) {\n    /**\n     * @param {CID} cid\n     */\n    const load = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (cid) {\n        const codec = yield codecs.getCodec(cid.code);\n        const block = yield getBlock(cid, options);\n        return codec.decode(block);\n      });\n\n      return function load(_x6) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    const parts = path.split('/').filter(Boolean);\n    let value = yield _awaitAsyncGenerator(load(cid));\n    let lastCid = cid;\n\n    if (!parts.length) {\n      yield {\n        value,\n        remainderPath: ''\n      };\n    } // End iteration if there isn't a CID to follow any more\n\n\n    while (parts.length) {\n      const key = parts.shift();\n\n      if (!key) {\n        throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH');\n      }\n\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        value = value[key];\n        yield {\n          value,\n          remainderPath: parts.join('/')\n        };\n      } else {\n        throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK');\n      }\n\n      if (value instanceof CID) {\n        lastCid = value;\n        value = yield _awaitAsyncGenerator(load(value));\n      }\n    }\n  });\n\n  return function resolve(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = resolve;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-http-client/src/lib/resolve.js"],"names":["CID","require","errCode","resolve","cid","path","codecs","getBlock","options","load","codec","getCodec","code","block","decode","parts","split","filter","Boolean","value","lastCid","length","remainderPath","key","shift","Error","Object","prototype","hasOwnProperty","call","join","module","exports"],"mappings":"AAAA;;;;;;;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAUC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,OAAO;AAAA,iCAAG,WAAkBC,GAAlB,EAAuBC,IAAvB,EAA6BC,MAA7B,EAAqCC,QAArC,EAA+CC,OAA/C,EAAwD;AACtE;AACF;AACA;AACE,UAAMC,IAAI;AAAA,oCAAG,WAAOL,GAAP,EAAe;AAC1B,cAAMM,KAAK,SAASJ,MAAM,CAACK,QAAP,CAAgBP,GAAG,CAACQ,IAApB,CAApB;AACA,cAAMC,KAAK,SAASN,QAAQ,CAACH,GAAD,EAAMI,OAAN,CAA5B;AAEA,eAAOE,KAAK,CAACI,MAAN,CAAaD,KAAb,CAAP;AACD,OALS;;AAAA,sBAAJJ,IAAI;AAAA;AAAA;AAAA,OAAV;;AAOA,UAAMM,KAAK,GAAGV,IAAI,CAACW,KAAL,CAAW,GAAX,EAAgBC,MAAhB,CAAuBC,OAAvB,CAAd;AACA,QAAIC,KAAK,8BAASV,IAAI,CAACL,GAAD,CAAb,CAAT;AACA,QAAIgB,OAAO,GAAGhB,GAAd;;AAEA,QAAI,CAACW,KAAK,CAACM,MAAX,EAAmB;AACjB,YAAM;AACJF,QAAAA,KADI;AAEJG,QAAAA,aAAa,EAAE;AAFX,OAAN;AAID,KApBqE,CAsBtE;;;AACA,WAAOP,KAAK,CAACM,MAAb,EAAqB;AACnB,YAAME,GAAG,GAAGR,KAAK,CAACS,KAAN,EAAZ;;AAEA,UAAI,CAACD,GAAL,EAAU;AACR,cAAMrB,OAAO,CAAC,IAAIuB,KAAJ,CAAW,2BAA0BpB,IAAK,GAA1C,CAAD,EAAgD,kBAAhD,CAAb;AACD;;AAED,UAAIqB,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCV,KAArC,EAA4CI,GAA5C,CAAJ,EAAsD;AACpDJ,QAAAA,KAAK,GAAGA,KAAK,CAACI,GAAD,CAAb;AAEA,cAAM;AACJJ,UAAAA,KADI;AAEJG,UAAAA,aAAa,EAAEP,KAAK,CAACe,IAAN,CAAW,GAAX;AAFX,SAAN;AAID,OAPD,MAOO;AACL,cAAM5B,OAAO,CAAC,IAAIuB,KAAJ,CAAW,kBAAiBF,GAAI,WAAUH,OAAQ,EAAlD,CAAD,EAAuD,aAAvD,CAAb;AACD;;AAED,UAAID,KAAK,YAAYnB,GAArB,EAA0B;AACxBoB,QAAAA,OAAO,GAAGD,KAAV;AACAA,QAAAA,KAAK,8BAASV,IAAI,CAACU,KAAD,CAAb,CAAL;AACD;AACF;AACF,GA9CY;;AAAA,kBAAPhB,OAAO;AAAA;AAAA;AAAA,GAAb;;AAgDA4B,MAAM,CAACC,OAAP,GAAiB7B,OAAjB","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock\n * @param {AbortOptions} [options]\n */\nconst resolve = async function * (cid, path, codecs, getBlock, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await getBlock(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  if (!parts.length) {\n    yield {\n      value,\n      remainderPath: ''\n    }\n  }\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    if (value instanceof CID) {\n      lastCid = value\n      value = await load(value)\n    }\n  }\n}\n\nmodule.exports = resolve\n"]},"metadata":{},"sourceType":"script"}