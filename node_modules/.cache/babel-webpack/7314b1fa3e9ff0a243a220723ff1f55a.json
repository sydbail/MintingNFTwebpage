{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst ConsumableBuffer = require('./consumable-buffer');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\n\n\nfunction wrapHash(hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing(value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value;\n    } else {\n      return new InfiniteHash(value, hashFn);\n    }\n  }\n\n  return hashing;\n}\n\nclass InfiniteHash {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  constructor(value, hashFn) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays');\n    }\n\n    this._value = value;\n    this._hashFn = hashFn;\n    this._depth = -1;\n    this._availableBits = 0;\n    this._currentBufferIndex = 0;\n    /** @type {ConsumableBuffer[]} */\n\n    this._buffers = [];\n  }\n  /**\n   * @param {number} bits\n   */\n\n\n  take(bits) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let pendingBits = bits;\n\n      while (_this._availableBits < pendingBits) {\n        yield _this._produceMoreBits();\n      }\n\n      let result = 0;\n\n      while (pendingBits > 0) {\n        const hash = _this._buffers[_this._currentBufferIndex];\n        const available = Math.min(hash.availableBits(), pendingBits);\n        const took = hash.take(available);\n        result = (result << available) + took;\n        pendingBits -= available;\n        _this._availableBits -= available;\n\n        if (hash.availableBits() === 0) {\n          _this._currentBufferIndex++;\n        }\n      }\n\n      return result;\n    })();\n  }\n  /**\n   * @param {number} bits\n   */\n\n\n  untake(bits) {\n    let pendingBits = bits;\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex];\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n      hash.untake(availableForUntake);\n      pendingBits -= availableForUntake;\n      this._availableBits += availableForUntake;\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--;\n        this._currentBufferIndex--;\n      }\n    }\n  }\n\n  _produceMoreBits() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2._depth++;\n      const value = _this2._depth ? uint8ArrayConcat([_this2._value, Uint8Array.from([_this2._depth])]) : _this2._value;\n      const hashValue = yield _this2._hashFn(value);\n      const buffer = new ConsumableBuffer(hashValue);\n\n      _this2._buffers.push(buffer);\n\n      _this2._availableBits += buffer.availableBits();\n    })();\n  }\n\n}\n\nmodule.exports = wrapHash;\nmodule.exports.InfiniteHash = InfiniteHash;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/hamt-sharding/src/consumable-hash.js"],"names":["ConsumableBuffer","require","concat","uint8ArrayConcat","wrapHash","hashFn","hashing","value","InfiniteHash","constructor","Uint8Array","Error","_value","_hashFn","_depth","_availableBits","_currentBufferIndex","_buffers","take","bits","pendingBits","_produceMoreBits","result","hash","available","Math","min","availableBits","took","untake","availableForUntake","totalBits","from","hashValue","buffer","push","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ConsumableBuffer = require('./consumable-buffer')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\n\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\nfunction wrapHash (hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing (value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nclass InfiniteHash {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  constructor (value, hashFn) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n\n    /** @type {ConsumableBuffer[]} */\n    this._buffers = []\n  }\n\n  /**\n   * @param {number} bits\n   */\n  async take (bits) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nmodule.exports = wrapHash\nmodule.exports.InfiniteHash = InfiniteHash\n"]},"metadata":{},"sourceType":"script"}