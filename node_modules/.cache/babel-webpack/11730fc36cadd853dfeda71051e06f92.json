{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst Proto = require('./dht');\n\nconst MESSAGE_TYPE = Proto.Message.MessageType;\nconst CONNECTION_TYPE = Proto.Message.ConnectionType;\n/**\n * @typedef {0|1|2|3|4} ConnectionType\n *\n * @typedef {object} PBPeer\n * @property {Uint8Array} id\n * @property {Uint8Array[]} addrs\n * @property {ConnectionType} connection\n *\n * @typedef {import('../index').PeerData} PeerData\n */\n\n/**\n * Represents a single DHT control message.\n */\n\nlet Message = /*#__PURE__*/(() => {\n  class Message {\n    /**\n     * @param {import('./dht').Message.MessageType} type\n     * @param {Uint8Array} key\n     * @param {number} level\n     */\n    constructor(type, key, level) {\n      if (key && !(key instanceof Uint8Array)) {\n        throw new Error('Key must be a Uint8Array');\n      }\n\n      this.type = type;\n      this.key = key;\n      this._clusterLevelRaw = level;\n      /** @type {PeerData[]} */\n\n      this.closerPeers = [];\n      /** @type {PeerData[]} */\n\n      this.providerPeers = [];\n      /** @type {import('libp2p-record').Record | undefined} */\n\n      this.record = undefined;\n    }\n    /**\n     * @type {number}\n     */\n\n\n    get clusterLevel() {\n      const level = this._clusterLevelRaw - 1;\n\n      if (level < 0) {\n        return 0;\n      }\n\n      return level;\n    }\n\n    set clusterLevel(level) {\n      this._clusterLevelRaw = level;\n    }\n    /**\n     * Encode into protobuf\n     */\n\n\n    serialize() {\n      const obj = {\n        key: this.key,\n        type: this.type,\n        clusterLevelRaw: this._clusterLevelRaw,\n        closerPeers: this.closerPeers.map(toPbPeer),\n        providerPeers: this.providerPeers.map(toPbPeer),\n\n        /** @type {Uint8Array | undefined} */\n        record: undefined\n      };\n\n      if (this.record) {\n        if (this.record instanceof Uint8Array) {\n          obj.record = this.record;\n        } else {\n          obj.record = this.record.serialize();\n        }\n      }\n\n      return Proto.Message.encode(obj).finish();\n    }\n    /**\n     * Decode from protobuf\n     *\n     * @param {Uint8Array} raw\n     */\n\n\n    static deserialize(raw) {\n      const dec = Proto.Message.decode(raw);\n      const msg = new Message(dec.type || 0, dec.key || Uint8Array.from([]), dec.clusterLevelRaw || 0);\n      msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n      msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n\n      if (dec.record && dec.record.length) {\n        msg.record = Record.deserialize(dec.record);\n      }\n\n      return msg;\n    }\n\n  }\n\n  Message.TYPES = MESSAGE_TYPE;\n  Message.CONNECTION_TYPES = CONNECTION_TYPE;\n  /**\n   * @param {PeerData} peer\n   */\n\n  return Message;\n})();\n\nfunction toPbPeer(peer) {\n  /** @type {PBPeer} */\n  const output = {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map(m => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  };\n  return output;\n}\n/**\n * @param {import('./dht').Message.IPeer} peer\n */\n\n\nfunction fromPbPeer(peer) {\n  return {\n    // @ts-ignore id is optional on protobuf, but it will exist?\n    id: new PeerId(peer.id),\n    multiaddrs: (peer.addrs || []).map(a => new Multiaddr(a))\n  };\n}\n\nmodule.exports = Message;","map":null,"metadata":{},"sourceType":"script"}