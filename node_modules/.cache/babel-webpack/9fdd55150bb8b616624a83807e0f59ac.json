{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\n\nconst hkdf_1 = require(\"@stablelib/hkdf\");\n\nconst sha256_1 = require(\"@stablelib/sha256\");\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\n\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\n\nconst payload_1 = require(\"./proto/payload\");\n\nconst equals_1 = require(\"uint8arrays/equals\");\n\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\n\nfunction generateKeypair() {\n  const keypair = x25519.generateKeyPair();\n  return {\n    publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n    privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n  };\n}\n\nexports.generateKeypair = generateKeypair;\n\nfunction getPayload(_x, _x2, _x3) {\n  return _getPayload.apply(this, arguments);\n}\n\nfunction _getPayload() {\n  _getPayload = _asyncToGenerator(function* (localPeer, staticPublicKey, earlyData) {\n    const signedPayload = yield signPayload(localPeer, getHandshakePayload(staticPublicKey));\n    const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n    return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n  });\n  return _getPayload.apply(this, arguments);\n}\n\nexports.getPayload = getPayload;\n\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n    identitySig: signedPayload,\n    data: earlyData !== null && earlyData !== void 0 ? earlyData : null\n  });\n  return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\n\nexports.createHandshakePayload = createHandshakePayload;\n\nfunction signPayload(_x4, _x5) {\n  return _signPayload.apply(this, arguments);\n}\n\nfunction _signPayload() {\n  _signPayload = _asyncToGenerator(function* (peerId, payload) {\n    return buffer_1.Buffer.from(yield peerId.privKey.sign(payload));\n  });\n  return _signPayload.apply(this, arguments);\n}\n\nexports.signPayload = signPayload;\n\nfunction getPeerIdFromPayload(_x6) {\n  return _getPeerIdFromPayload.apply(this, arguments);\n}\n\nfunction _getPeerIdFromPayload() {\n  _getPeerIdFromPayload = _asyncToGenerator(function* (payload) {\n    return yield peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n  });\n  return _getPeerIdFromPayload.apply(this, arguments);\n}\n\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\n\nfunction decodePayload(payload) {\n  return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\n\nexports.decodePayload = decodePayload;\n\nfunction getHandshakePayload(publicKey) {\n  return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\n\nexports.getHandshakePayload = getHandshakePayload;\n\nfunction isValidPeerId(_x7, _x8) {\n  return _isValidPeerId.apply(this, arguments);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\n\n\nfunction _isValidPeerId() {\n  _isValidPeerId = _asyncToGenerator(function* (peerId, publicKeyProtobuf) {\n    const generatedPeerId = yield peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n    return equals_1.equals(generatedPeerId.id, peerId);\n  });\n  return _isValidPeerId.apply(this, arguments);\n}\n\nfunction verifySignedPayload(_x9, _x10, _x11) {\n  return _verifySignedPayload.apply(this, arguments);\n}\n\nfunction _verifySignedPayload() {\n  _verifySignedPayload = _asyncToGenerator(function* (noiseStaticKey, payload, remotePeer) {\n    const identityKey = buffer_1.Buffer.from(payload.identityKey);\n\n    if (!(yield isValidPeerId(remotePeer.id, identityKey))) {\n      throw new Error(\"Peer ID doesn't match libp2p public key.\");\n    }\n\n    const generatedPayload = getHandshakePayload(noiseStaticKey); // Unmarshaling from PublicKey protobuf\n\n    const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey); // TODO remove this after libp2p-crypto ships proper types\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n    if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {\n      throw new Error(\"Static key doesn't match to peer that signed payload!\");\n    }\n\n    return yield peer_id_1.default.createFromPubKey(identityKey);\n  });\n  return _verifySignedPayload.apply(this, arguments);\n}\n\nexports.verifySignedPayload = verifySignedPayload;\n\nfunction getHkdf(ck, ikm) {\n  const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);\n  const okmU8Array = hkdf.expand(96);\n  const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);\n  const k1 = okm.slice(0, 32);\n  const k2 = okm.slice(32, 64);\n  const k3 = okm.slice(64, 96);\n  return [k1, k2, k3];\n}\n\nexports.getHkdf = getHkdf;\n\nfunction isValidPublicKey(pk) {\n  if (!buffer_1.Buffer.isBuffer(pk)) {\n    return false;\n  }\n\n  if (pk.length !== 32) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isValidPublicKey = isValidPublicKey;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@chainsafe/libp2p-noise/dist/src/utils.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__importDefault","exports","isValidPublicKey","getHkdf","verifySignedPayload","getHandshakePayload","decodePayload","getPeerIdFromPayload","signPayload","createHandshakePayload","getPayload","generateKeypair","hkdf_1","require","sha256_1","x25519","buffer_1","peer_id_1","libp2p_crypto_1","payload_1","equals_1","NoiseHandshakePayloadProto","pb","NoiseHandshakePayload","keypair","generateKeyPair","publicKey","Buffer","from","buffer","byteOffset","length","privateKey","secretKey","localPeer","staticPublicKey","earlyData","signedPayload","earlyDataPayload","alloc","marshalPubKey","libp2pPublicKey","payloadInit","identityKey","identitySig","data","encode","finish","peerId","payload","privKey","sign","default","createFromPubKey","toObject","decode","concat","isValidPeerId","publicKeyProtobuf","generatedPeerId","equals","id","noiseStaticKey","remotePeer","Error","generatedPayload","keys","unmarshalPublicKey","verify","ck","ikm","hkdf","HKDF","SHA256","okmU8Array","expand","okm","k1","slice","k3","pk","isBuffer"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\nconst hkdf_1 = require(\"@stablelib/hkdf\");\nconst sha256_1 = require(\"@stablelib/sha256\");\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\nconst buffer_1 = require(\"buffer\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\nconst payload_1 = require(\"./proto/payload\");\nconst equals_1 = require(\"uint8arrays/equals\");\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\nfunction generateKeypair() {\n    const keypair = x25519.generateKeyPair();\n    return {\n        publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n        privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n    };\n}\nexports.generateKeypair = generateKeypair;\nasync function getPayload(localPeer, staticPublicKey, earlyData) {\n    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n    const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n    return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n}\nexports.getPayload = getPayload;\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n    const payloadInit = NoiseHandshakePayloadProto.create({\n        identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n        identitySig: signedPayload,\n        data: earlyData !== null && earlyData !== void 0 ? earlyData : null\n    });\n    return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\nexports.createHandshakePayload = createHandshakePayload;\nasync function signPayload(peerId, payload) {\n    return buffer_1.Buffer.from(await peerId.privKey.sign(payload));\n}\nexports.signPayload = signPayload;\nasync function getPeerIdFromPayload(payload) {\n    return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n}\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\nfunction decodePayload(payload) {\n    return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\nexports.decodePayload = decodePayload;\nfunction getHandshakePayload(publicKey) {\n    return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\nexports.getHandshakePayload = getHandshakePayload;\nasync function isValidPeerId(peerId, publicKeyProtobuf) {\n    const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n    return equals_1.equals(generatedPeerId.id, peerId);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nasync function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n    const identityKey = buffer_1.Buffer.from(payload.identityKey);\n    if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n        throw new Error(\"Peer ID doesn't match libp2p public key.\");\n    }\n    const generatedPayload = getHandshakePayload(noiseStaticKey);\n    // Unmarshaling from PublicKey protobuf\n    const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);\n    // TODO remove this after libp2p-crypto ships proper types\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {\n        throw new Error(\"Static key doesn't match to peer that signed payload!\");\n    }\n    return await peer_id_1.default.createFromPubKey(identityKey);\n}\nexports.verifySignedPayload = verifySignedPayload;\nfunction getHkdf(ck, ikm) {\n    const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);\n    const okmU8Array = hkdf.expand(96);\n    const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);\n    const k1 = okm.slice(0, 32);\n    const k2 = okm.slice(32, 64);\n    const k3 = okm.slice(64, 96);\n    return [k1, k2, k3];\n}\nexports.getHkdf = getHkdf;\nfunction isValidPublicKey(pk) {\n    if (!buffer_1.Buffer.isBuffer(pk)) {\n        return false;\n    }\n    if (pk.length !== 32) {\n        return false;\n    }\n    return true;\n}\nexports.isValidPublicKey = isValidPublicKey;\n"]},"metadata":{},"sourceType":"script"}