{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  Key,\n  Errors\n} = require('interface-datastore');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n\nconst CONFIG_KEY = new Key('/config');\nconst VERSION_KEY = new Key('/version');\n/**\n * Level dbs wrap level dbs that wrap level dbs. Find a level-js\n * instance in the chain if one exists.\n *\n * @param {Datastore} store\n * @returns {Datastore | undefined}\n */\n\nfunction findLevelJs(store) {\n  let db = store; // @ts-ignore\n\n  while (db.db || db.child) {\n    // @ts-ignore\n    db = db.db || db.child; // `Level` is only present in the browser, in node it is LevelDOWN\n    // @ts-ignore\n\n    if (db.type === 'level-js' || db.constructor.name === 'Level') {\n      return db;\n    }\n  }\n}\n/**\n * @param {Key} key\n * @param {function (Key): Promise<boolean>} has\n * @param {Datastore} store\n * @returns {Promise<boolean>}\n */\n\n\nfunction hasWithFallback(_x, _x2, _x3) {\n  return _hasWithFallback.apply(this, arguments);\n}\n/**\n * @param {import('interface-datastore').Key} key\n * @param {function (Key): Promise<Uint8Array>} get\n * @param {function (Key): Promise<boolean>} has\n * @param {import('interface-datastore').Datastore} store\n * @returns {Promise<Uint8Array>}\n */\n\n\nfunction _hasWithFallback() {\n  _hasWithFallback = _asyncToGenerator(function* (key, has, store) {\n    const result = yield has(key);\n\n    if (result) {\n      return result;\n    } // Newer versions of level.js changed the key type from Uint8Array|string\n    // to Uint8Array  so fall back to trying Uint8Arrays if we are using level.js\n    // and the string version of the key did not work\n\n\n    const levelJs = findLevelJs(store);\n\n    if (!levelJs) {\n      return false;\n    }\n\n    return new Promise((resolve, reject) => {\n      // drop down to IndexDB API, otherwise level-js will monkey around with the keys/values\n      // @ts-ignore\n      const req = levelJs.store('readonly').get(key.toString());\n\n      req.transaction.onabort = () => {\n        reject(req.transaction.error);\n      };\n\n      req.transaction.oncomplete = () => {\n        resolve(Boolean(req.result));\n      };\n    });\n  });\n  return _hasWithFallback.apply(this, arguments);\n}\n\nfunction getWithFallback(_x4, _x5, _x6, _x7) {\n  return _getWithFallback.apply(this, arguments);\n}\n/**\n * @param {Datastore} store\n */\n\n\nfunction _getWithFallback() {\n  _getWithFallback = _asyncToGenerator(function* (key, get, has, store) {\n    if (yield has(key)) {\n      return get(key);\n    } // Newer versions of level.js changed the key type from Uint8Array|string\n    // to Uint8Array so fall back to trying Uint8Arrays if we are using level.js\n    // and the string version of the key did not work\n\n\n    const levelJs = findLevelJs(store);\n\n    if (!levelJs) {\n      throw Errors.notFoundError();\n    }\n\n    return new Promise((resolve, reject) => {\n      // drop down to IndexDB API, otherwise level-js will monkey around with the keys/values\n      // @ts-ignore\n      const req = levelJs.store('readonly').get(key.toString());\n\n      req.transaction.onabort = () => {\n        reject(req.transaction.error);\n      };\n\n      req.transaction.oncomplete = () => {\n        if (req.result) {\n          return resolve(req.result);\n        }\n\n        reject(Errors.notFoundError());\n      };\n    });\n  });\n  return _getWithFallback.apply(this, arguments);\n}\n\nfunction wrapStore(store) {\n  // necessary since level-js@5 cannot read keys from level-js@4 and earlier\n  const originalGet = store.get.bind(store);\n  const originalHas = store.has.bind(store);\n  /**\n   * @param {Key} key\n   */\n\n  store.get = key => getWithFallback(key, originalGet, originalHas, store);\n  /**\n   * @param {Key} key\n   */\n\n\n  store.has = key => hasWithFallback(key, originalHas, store);\n\n  return store;\n}\n/**\n * @param {import('./types').Backends} backends\n */\n\n\nfunction wrapBackends(backends) {\n  return { ...backends,\n    root: wrapStore(backends.root),\n    datastore: wrapStore(backends.datastore),\n    pins: wrapStore(backends.pins),\n    keys: wrapStore(backends.keys)\n  };\n}\n\nmodule.exports = {\n  wrapBackends,\n  hasWithFallback,\n  getWithFallback,\n  findLevelJs,\n  CONFIG_KEY,\n  VERSION_KEY\n};","map":null,"metadata":{},"sourceType":"script"}