{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst EventEmitter = require('events');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:webrtc-star:listener');\nlog.error = debug('libp2p:webrtc-star:listener:error');\n\nconst errCode = require('err-code');\n\nconst io = require('socket.io-client');\n\nconst SimplePeer = require('libp2p-webrtc-peer');\n\nconst pDefer = require('p-defer');\n\nconst toConnection = require('./socket-to-conn');\n\nconst {\n  cleanUrlSIO\n} = require('./utils');\n\nconst {\n  CODE_P2P\n} = require('./constants');\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true,\n  path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n\n};\n\nmodule.exports = ({\n  handler,\n  upgrader\n}, WebRTCStar, options = {}) => {\n  const listener = new EventEmitter();\n  let listeningAddr;\n  let signallingUrl;\n  listener.__connections = [];\n  listener.__spChannels = new Map();\n  listener.__pendingIntents = new Map();\n\n  listener.listen = ma => {\n    // Should only be used if not already listening\n    if (listeningAddr) {\n      throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING');\n    }\n\n    const defer = pDefer(); // Should be kept unmodified\n\n    listeningAddr = ma;\n    let signallingAddr;\n\n    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {\n      signallingAddr = ma.encapsulate(`/p2p/${upgrader.localPeer.toB58String()}`);\n    } else {\n      signallingAddr = ma;\n    }\n\n    listener.on('error', () => defer.reject());\n    signallingUrl = cleanUrlSIO(ma);\n    log('Dialing to Signalling Server on: ' + signallingUrl);\n    listener.io = io.connect(signallingUrl, sioOptions);\n\n    const incomingDial = offer => {\n      if (offer.answer || offer.err || !offer.intentId) {\n        return;\n      }\n\n      const intentId = offer.intentId;\n\n      let pendings = listener.__pendingIntents.get(intentId);\n\n      if (!pendings) {\n        pendings = [];\n\n        listener.__pendingIntents.set(intentId, pendings);\n      }\n\n      let channel = listener.__spChannels.get(intentId);\n\n      if (channel) {\n        channel.signal(offer.signal);\n        return;\n      } else if (offer.signal.type !== 'offer') {\n        pendings.push(offer);\n        return;\n      }\n\n      const spOptions = {\n        trickle: false,\n        ...options\n      }; // Use custom WebRTC implementation\n\n      if (WebRTCStar.wrtc) {\n        spOptions.wrtc = WebRTCStar.wrtc;\n      }\n\n      channel = new SimplePeer(spOptions);\n\n      const onError = err => {\n        log.error('incoming connection errored', err);\n      };\n\n      channel.on('error', onError);\n      channel.once('close', (...args) => {\n        channel.removeListener('error', onError);\n      });\n      channel.on('signal', signal => {\n        offer.signal = signal;\n        offer.answer = true;\n        listener.io.emit('ss-handshake', offer);\n      });\n      channel.signal(offer.signal);\n\n      for (const pendingOffer of pendings) {\n        channel.signal(pendingOffer.signal);\n      }\n\n      listener.__pendingIntents.set(intentId, []);\n\n      channel.once('connect', /*#__PURE__*/_asyncToGenerator(function* () {\n        const maConn = toConnection(channel);\n        log('new inbound connection %s', maConn.remoteAddr);\n        let conn;\n\n        try {\n          conn = yield upgrader.upgradeInbound(maConn);\n        } catch (err) {\n          log.error('inbound connection failed to upgrade', err);\n          return maConn.close();\n        }\n\n        if (!conn.remoteAddr) {\n          try {\n            conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toB58String()}`);\n          } catch (err) {\n            log.error('could not determine remote address', err);\n          }\n        }\n\n        log('inbound connection %s upgraded', maConn.remoteAddr);\n        trackConn(listener, maConn, intentId);\n        listener.emit('connection', conn);\n        handler(conn);\n      }));\n\n      listener.__spChannels.set(intentId, channel);\n    };\n\n    listener.io.once('connect_error', err => defer.reject(err));\n    listener.io.once('error', err => {\n      listener.emit('error', err);\n      listener.emit('close');\n    });\n    listener.io.on('ws-handshake', incomingDial);\n    listener.io.on('ws-peer', WebRTCStar._peerDiscovered);\n    listener.io.on('connect', () => {\n      listener.io.emit('ss-join', signallingAddr.toString());\n    });\n    listener.io.once('connect', () => {\n      listener.emit('listening');\n      defer.resolve();\n    }); // Store listen and signal reference addresses\n\n    WebRTCStar.sigReferences.set(signallingUrl, {\n      listener,\n      signallingAddr\n    });\n    return defer.promise;\n  };\n\n  listener.close = /*#__PURE__*/_asyncToGenerator(function* () {\n    // Close listener\n    const ref = WebRTCStar.sigReferences.get(signallingUrl);\n\n    if (ref && ref.listener.io) {\n      ref.listener.io.emit('ss-leave');\n      ref.listener.io.close();\n    }\n\n    yield Promise.all(listener.__connections.map(maConn => maConn.close()));\n    listener.emit('close');\n    listener.removeAllListeners(); // Reset state\n\n    listeningAddr = undefined;\n    WebRTCStar.sigReferences.delete(signallingUrl);\n  });\n\n  listener.getAddrs = () => {\n    return [listeningAddr];\n  };\n\n  return listener;\n};\n\nfunction trackConn(listener, maConn, intentId) {\n  listener.__connections.push(maConn);\n\n  const untrackConn = () => {\n    listener.__connections = listener.__connections.filter(c => c !== maConn);\n\n    listener.__spChannels.delete(intentId);\n\n    listener.__pendingIntents.delete(intentId);\n  };\n\n  maConn.conn.once('close', untrackConn);\n}","map":null,"metadata":{},"sourceType":"script"}