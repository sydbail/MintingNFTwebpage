{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst ipns = require('ipns');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:republisher'), {\n  error: debug('ipfs:ipns:republisher:error')\n});\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n */\n\nconst minute = 60 * 1000;\nconst hour = 60 * minute;\nconst defaultBroadcastInterval = 4 * hour;\nconst defaultRecordLifetime = 24 * hour;\n\nclass IpnsRepublisher {\n  /**\n   * @param {import('./publisher')} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('libp2p/src/keychain')} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor(publisher, datastore, peerId, keychain, options = {\n    pass: ''\n  }) {\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (_this._republishHandle) {\n        throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n      } // TODO: this handler should be isolated in another module\n\n\n      const republishHandle = {\n        /** @type {null|(() => Promise<void>)} */\n        _task: null,\n\n        /** @type {null|Promise<void>} */\n        _inflightTask: null,\n\n        /** @type {null|NodeJS.Timeout} */\n        _timeoutId: null,\n\n        /**\n         * @param {function(): number} period\n         */\n        runPeriodically: period => {\n          republishHandle._timeoutId = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n            republishHandle._timeoutId = null;\n\n            try {\n              // @ts-ignore - _task could be null\n              republishHandle._inflightTask = republishHandle._task();\n              yield republishHandle._inflightTask; // Schedule next\n\n              if (republishHandle._task) {\n                republishHandle.runPeriodically(period);\n              }\n            } catch (err) {\n              log.error(err);\n            }\n          }), period());\n        },\n        cancel: function () {\n          var _ref2 = _asyncToGenerator(function* () {\n            // do not run again\n            if (republishHandle._timeoutId != null) {\n              clearTimeout(republishHandle._timeoutId);\n            }\n\n            republishHandle._task = null; // wait for the currently in flight task to complete\n\n            yield republishHandle._inflightTask;\n          });\n\n          return function cancel() {\n            return _ref2.apply(this, arguments);\n          };\n        }()\n      };\n      const {\n        privKey\n      } = _this._peerId;\n      const {\n        pass\n      } = _this._options;\n      let firstRun = true;\n\n      republishHandle._task = () => _this._republishEntries(privKey, pass);\n\n      republishHandle.runPeriodically(() => {\n        if (firstRun) {\n          firstRun = false;\n          return _this._options.initialBroadcastInterval || minute;\n        }\n\n        return _this._options.broadcastInterval || defaultBroadcastInterval;\n      });\n      _this._republishHandle = republishHandle;\n    })();\n  }\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const republishHandle = _this2._republishHandle;\n\n      if (!republishHandle) {\n        throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n      }\n\n      _this2._republishHandle = null;\n      yield republishHandle.cancel();\n    })();\n  }\n  /**\n   * @param {PrivateKey} privateKey\n   * @param {string} pass\n   */\n\n\n  _republishEntries(privateKey, pass) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO: Should use list of published entries.\n      // We can't currently *do* that because go uses this method for now.\n      try {\n        yield _this3._republishEntry(privateKey);\n      } catch (err) {\n        const errMsg = 'cannot republish entry for the node\\'s private key';\n        log.error(errMsg);\n        return;\n      } // keychain needs pass to get the cryptographic keys\n\n\n      if (pass) {\n        try {\n          const keys = yield _this3._keychain.listKeys();\n\n          for (const key of keys) {\n            if (key.name === 'self') {\n              continue;\n            }\n\n            const pem = yield _this3._keychain.exportKey(key.name, pass);\n            const privKey = yield crypto.keys.import(pem, pass);\n            yield _this3._republishEntry(privKey);\n          }\n        } catch (err) {\n          log.error(err);\n        }\n      }\n    })();\n  }\n  /**\n   * @param {PrivateKey} privateKey\n   */\n\n\n  _republishEntry(privateKey) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!privateKey || !privateKey.bytes) {\n        throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n      }\n\n      try {\n        const peerId = yield PeerId.createFromPrivKey(privateKey.bytes);\n        const value = yield _this4._getPreviousValue(peerId);\n        yield _this4._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);\n      } catch (err) {\n        if (err.code === 'ERR_NO_ENTRY_FOUND') {\n          return;\n        }\n\n        throw err;\n      }\n    })();\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  _getPreviousValue(peerId) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!PeerId.isPeerId(peerId)) {\n        throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n      }\n\n      try {\n        const dsVal = yield _this5._datastore.get(ipns.getLocalKey(peerId.id));\n\n        if (!(dsVal instanceof Uint8Array)) {\n          throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD');\n        } // unmarshal data\n\n\n        try {\n          const record = ipns.unmarshal(dsVal);\n          return record.value;\n        } catch (err) {\n          log.error(err);\n          throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n        }\n      } catch (err) {\n        // error handling\n        // no need to republish\n        if (err && err.notFound) {\n          throw errcode(new Error(`no previous entry for record with id: ${peerId.id}`), 'ERR_NO_ENTRY_FOUND');\n        }\n\n        throw err;\n      }\n    })();\n  }\n\n}\n\nexports = module.exports = IpnsRepublisher;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/ipfs-core/src/ipns/republisher.js"],"names":["ipns","require","crypto","PeerId","errcode","debug","log","Object","assign","error","minute","hour","defaultBroadcastInterval","defaultRecordLifetime","IpnsRepublisher","constructor","publisher","datastore","peerId","keychain","options","pass","_publisher","_datastore","_peerId","_keychain","_options","_republishHandle","start","Error","republishHandle","_task","_inflightTask","_timeoutId","runPeriodically","period","setTimeout","err","cancel","clearTimeout","privKey","firstRun","_republishEntries","initialBroadcastInterval","broadcastInterval","stop","privateKey","_republishEntry","errMsg","keys","listKeys","key","name","pem","exportKey","import","bytes","createFromPrivKey","value","_getPreviousValue","publishWithEOL","code","isPeerId","dsVal","get","getLocalKey","id","Uint8Array","record","unmarshal","notFound","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\n\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:republisher'), {\n  error: debug('ipfs:ipns:republisher:error')\n})\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n */\n\nconst minute = 60 * 1000\nconst hour = 60 * minute\n\nconst defaultBroadcastInterval = 4 * hour\nconst defaultRecordLifetime = 24 * hour\n\nclass IpnsRepublisher {\n  /**\n   * @param {import('./publisher')} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('libp2p/src/keychain')} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (publisher, datastore, peerId, keychain, options = { pass: '' }) {\n    this._publisher = publisher\n    this._datastore = datastore\n    this._peerId = peerId\n    this._keychain = keychain\n    this._options = options\n    this._republishHandle = null\n  }\n\n  async start () { // eslint-disable-line require-await\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING')\n    }\n\n    // TODO: this handler should be isolated in another module\n    const republishHandle = {\n      /** @type {null|(() => Promise<void>)} */\n      _task: null,\n      /** @type {null|Promise<void>} */\n      _inflightTask: null,\n      /** @type {null|NodeJS.Timeout} */\n      _timeoutId: null,\n      /**\n       * @param {function(): number} period\n       */\n      runPeriodically: (period) => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null\n\n          try {\n            // @ts-ignore - _task could be null\n            republishHandle._inflightTask = republishHandle._task()\n            await republishHandle._inflightTask\n\n            // Schedule next\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period)\n            }\n          } catch (err) {\n            log.error(err)\n          }\n        }, period())\n      },\n      cancel: async () => {\n        // do not run again\n        if (republishHandle._timeoutId != null) {\n          clearTimeout(republishHandle._timeoutId)\n        }\n        republishHandle._task = null\n\n        // wait for the currently in flight task to complete\n        await republishHandle._inflightTask\n      }\n    }\n\n    const { privKey } = this._peerId\n    const { pass } = this._options\n    let firstRun = true\n\n    republishHandle._task = () => this._republishEntries(privKey, pass)\n\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false\n        return this._options.initialBroadcastInterval || minute\n      }\n\n      return this._options.broadcastInterval || defaultBroadcastInterval\n    })\n\n    this._republishHandle = republishHandle\n  }\n\n  async stop () {\n    const republishHandle = this._republishHandle\n\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING')\n    }\n\n    this._republishHandle = null\n\n    await republishHandle.cancel()\n  }\n\n  /**\n   * @param {PrivateKey} privateKey\n   * @param {string} pass\n   */\n  async _republishEntries (privateKey, pass) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(privateKey)\n    } catch (err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key'\n\n      log.error(errMsg)\n      return\n    }\n\n    // keychain needs pass to get the cryptographic keys\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys()\n\n        for (const key of keys) {\n          if (key.name === 'self') {\n            continue\n          }\n          const pem = await this._keychain.exportKey(key.name, pass)\n          const privKey = await crypto.keys.import(pem, pass)\n\n          await this._republishEntry(privKey)\n        }\n      } catch (err) {\n        log.error(err)\n      }\n    }\n  }\n\n  /**\n   * @param {PrivateKey} privateKey\n   */\n  async _republishEntry (privateKey) {\n    if (!privateKey || !privateKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY')\n    }\n\n    try {\n      const peerId = await PeerId.createFromPrivKey(privateKey.bytes)\n      const value = await this._getPreviousValue(peerId)\n      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime)\n    } catch (err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _getPreviousValue (peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID')\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id))\n\n      if (!(dsVal instanceof Uint8Array)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD')\n      }\n\n      // unmarshal data\n      try {\n        const record = ipns.unmarshal(dsVal)\n\n        return record.value\n      } catch (err) {\n        log.error(err)\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD')\n      }\n    } catch (err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.id}`), 'ERR_NO_ENTRY_FOUND')\n      }\n\n      throw err\n    }\n  }\n}\n\nexports = module.exports = IpnsRepublisher\n"]},"metadata":{},"sourceType":"script"}