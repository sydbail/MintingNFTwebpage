{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass EventQueue {\n  constructor() {\n    this.pullQueue = [];\n    this.pushQueue = [];\n    this.eventHandlers = {};\n    this.isPaused = false;\n    this.isStopped = false;\n  }\n\n  push(value) {\n    if (this.isStopped) return;\n    const resolution = {\n      value,\n      done: false\n    };\n\n    if (this.pullQueue.length) {\n      const placeholder = this.pullQueue.shift();\n      if (placeholder) placeholder.resolve(resolution);\n    } else {\n      this.pushQueue.push(Promise.resolve(resolution));\n\n      if (this.highWaterMark !== undefined && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {\n        this.isPaused = true;\n\n        if (this.eventHandlers.highWater) {\n          this.eventHandlers.highWater();\n        } else if (console) {\n          console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n        }\n      }\n    }\n  }\n\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    this.remove();\n\n    for (const placeholder of this.pullQueue) {\n      placeholder.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this.pullQueue.length = 0;\n  }\n\n  fail(error) {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    this.remove();\n\n    if (this.pullQueue.length) {\n      for (const placeholder of this.pullQueue) {\n        placeholder.reject(error);\n      }\n\n      this.pullQueue.length = 0;\n    } else {\n      const rejection = Promise.reject(error);\n      /* Attach error handler to avoid leaking an unhandled promise rejection. */\n\n      rejection.catch(() => {});\n      this.pushQueue.push(rejection);\n    }\n  }\n\n  remove() {\n    Promise.resolve().then(() => {\n      if (this.removeCallback) this.removeCallback();\n    });\n  }\n\n  [Symbol.asyncIterator]() {\n    return {\n      next: value => {\n        const result = this.pushQueue.shift();\n\n        if (result) {\n          if (this.lowWaterMark !== undefined && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {\n            this.isPaused = false;\n\n            if (this.eventHandlers.lowWater) {\n              this.eventHandlers.lowWater();\n            }\n          }\n\n          return result;\n        } else if (this.isStopped) {\n          return Promise.resolve({\n            value: undefined,\n            done: true\n          });\n        } else {\n          return new Promise((resolve, reject) => {\n            this.pullQueue.push({\n              resolve,\n              reject\n            });\n          });\n        }\n      },\n      return: () => {\n        this.isStopped = true;\n        this.pushQueue.length = 0;\n        this.remove();\n        return Promise.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n    };\n  }\n\n}\n\nclass EventIterator {\n  constructor(listen, {\n    highWaterMark = 100,\n    lowWaterMark = 1\n  } = {}) {\n    const queue = new EventQueue();\n    queue.highWaterMark = highWaterMark;\n    queue.lowWaterMark = lowWaterMark;\n\n    queue.removeCallback = listen({\n      push: value => queue.push(value),\n      stop: () => queue.stop(),\n      fail: error => queue.fail(error),\n      on: (event, fn) => {\n        queue.eventHandlers[event] = fn;\n      }\n    }) || (() => {});\n\n    this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n\n    Object.freeze(this);\n  }\n\n}\n\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/event-iterator/lib/event-iterator.js"],"names":["Object","defineProperty","exports","value","EventQueue","constructor","pullQueue","pushQueue","eventHandlers","isPaused","isStopped","push","resolution","done","length","placeholder","shift","resolve","Promise","highWaterMark","undefined","highWater","console","warn","stop","remove","fail","error","reject","rejection","catch","then","removeCallback","Symbol","asyncIterator","next","result","lowWaterMark","lowWater","return","EventIterator","listen","queue","on","event","fn","freeze","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventQueue {\n    constructor() {\n        this.pullQueue = [];\n        this.pushQueue = [];\n        this.eventHandlers = {};\n        this.isPaused = false;\n        this.isStopped = false;\n    }\n    push(value) {\n        if (this.isStopped)\n            return;\n        const resolution = { value, done: false };\n        if (this.pullQueue.length) {\n            const placeholder = this.pullQueue.shift();\n            if (placeholder)\n                placeholder.resolve(resolution);\n        }\n        else {\n            this.pushQueue.push(Promise.resolve(resolution));\n            if (this.highWaterMark !== undefined &&\n                this.pushQueue.length >= this.highWaterMark &&\n                !this.isPaused) {\n                this.isPaused = true;\n                if (this.eventHandlers.highWater) {\n                    this.eventHandlers.highWater();\n                }\n                else if (console) {\n                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n                }\n            }\n        }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        for (const placeholder of this.pullQueue) {\n            placeholder.resolve({ value: undefined, done: true });\n        }\n        this.pullQueue.length = 0;\n    }\n    fail(error) {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        if (this.pullQueue.length) {\n            for (const placeholder of this.pullQueue) {\n                placeholder.reject(error);\n            }\n            this.pullQueue.length = 0;\n        }\n        else {\n            const rejection = Promise.reject(error);\n            /* Attach error handler to avoid leaking an unhandled promise rejection. */\n            rejection.catch(() => { });\n            this.pushQueue.push(rejection);\n        }\n    }\n    remove() {\n        Promise.resolve().then(() => {\n            if (this.removeCallback)\n                this.removeCallback();\n        });\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: (value) => {\n                const result = this.pushQueue.shift();\n                if (result) {\n                    if (this.lowWaterMark !== undefined &&\n                        this.pushQueue.length <= this.lowWaterMark &&\n                        this.isPaused) {\n                        this.isPaused = false;\n                        if (this.eventHandlers.lowWater) {\n                            this.eventHandlers.lowWater();\n                        }\n                    }\n                    return result;\n                }\n                else if (this.isStopped) {\n                    return Promise.resolve({ value: undefined, done: true });\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        this.pullQueue.push({ resolve, reject });\n                    });\n                }\n            },\n            return: () => {\n                this.isStopped = true;\n                this.pushQueue.length = 0;\n                this.remove();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n        };\n    }\n}\nclass EventIterator {\n    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {\n        const queue = new EventQueue();\n        queue.highWaterMark = highWaterMark;\n        queue.lowWaterMark = lowWaterMark;\n        queue.removeCallback =\n            listen({\n                push: value => queue.push(value),\n                stop: () => queue.stop(),\n                fail: error => queue.fail(error),\n                on: (event, fn) => {\n                    queue.eventHandlers[event] = fn;\n                },\n            }) || (() => { });\n        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n        Object.freeze(this);\n    }\n}\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;\n"]},"metadata":{},"sourceType":"script"}