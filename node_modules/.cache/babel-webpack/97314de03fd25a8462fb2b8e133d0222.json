{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n});\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst ipns = require('ipns');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nlet IpnsPublisher = /*#__PURE__*/(() => {\n  class IpnsPublisher {\n    /**\n     * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n     * @param {import('interface-datastore').Datastore} datastore\n     */\n    constructor(routing, datastore) {\n      this._routing = routing;\n      this._datastore = datastore;\n    }\n    /**\n     * Publish record with a eol\n     *\n     * @param {PrivateKey} privKey\n     * @param {Uint8Array} value\n     * @param {number} lifetime\n     */\n\n\n    publishWithEOL(privKey, value, lifetime) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        if (!privKey || !privKey.bytes) {\n          throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n        }\n\n        const peerId = yield PeerId.createFromPrivKey(privKey.bytes);\n        const record = yield _this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n        return _this._putRecordToRouting(record, peerId);\n      })();\n    }\n    /**\n     * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n     *\n     * @param {PrivateKey} privKey\n     * @param {Uint8Array} value\n     */\n\n\n    publish(privKey, value) {\n      return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n    }\n    /**\n     * @param {IPNSEntry} record\n     * @param {PeerId} peerId\n     */\n\n\n    _putRecordToRouting(record, peerId) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!PeerId.isPeerId(peerId)) {\n          const errMsg = 'peerId received is not valid';\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n        } // @ts-ignore - accessing private property isn't allowed\n\n\n        const publicKey = peerId._pubKey;\n        const embedPublicKeyRecord = yield ipns.embedPublicKey(publicKey, record);\n        const keys = ipns.getIdKeys(peerId.toBytes());\n        yield _this2._publishEntry(keys.routingKey, embedPublicKeyRecord || record); // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n        // We will be able to deprecate this part in the future, since the public keys will be only\n        // in IPNS record and the peerId.\n\n        yield _this2._publishPublicKey(keys.routingPubKey, publicKey);\n        return embedPublicKeyRecord || record;\n      })();\n    }\n    /**\n     * @param {Key} key\n     * @param {IPNSEntry} entry\n     */\n\n\n    _publishEntry(key, entry) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!(key instanceof Key)) {\n          const errMsg = 'datastore key does not have a valid format';\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n        }\n\n        let entryData;\n\n        try {\n          // Marshal record\n          entryData = ipns.marshal(entry);\n        } catch (err) {\n          log.error(err);\n          throw err;\n        } // Add record to routing (buffer key)\n\n\n        try {\n          const res = yield _this3._routing.put(key.uint8Array(), entryData);\n          log(`ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`);\n          return res;\n        } catch (err) {\n          const errMsg = `ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`;\n          log.error(errMsg);\n          log.error(err);\n          throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n        }\n      })();\n    }\n    /**\n     * @param {Key} key\n     * @param {PublicKey} publicKey\n     */\n\n\n    _publishPublicKey(key, publicKey) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!(key instanceof Key)) {\n          const errMsg = 'datastore key does not have a valid format';\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n        }\n\n        if (!publicKey || !publicKey.bytes) {\n          const errMsg = 'one or more of the provided parameters are not defined';\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER');\n        } // Add public key to routing (buffer key)\n\n\n        try {\n          const res = yield _this4._routing.put(key.uint8Array(), publicKey.bytes);\n          log(`public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`);\n          return res;\n        } catch (err) {\n          const errMsg = `public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`;\n          log.error(errMsg);\n          log.error(err);\n          throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n        }\n      })();\n    }\n    /**\n     * Returns the record this node has published corresponding to the given peer ID.\n     *\n     * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n     *\n     * @param {PeerId} peerId\n     * @param {object} options\n     * @param {boolean} [options.checkRouting]\n     */\n\n\n    _getPublished(peerId, options = {}) {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!PeerId.isPeerId(peerId)) {\n          const errMsg = 'peerId received is not valid';\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n        }\n\n        const checkRouting = options.checkRouting !== false;\n\n        try {\n          const dsVal = yield _this5._datastore.get(ipns.getLocalKey(peerId.id)); // unmarshal data\n\n          return _this5._unmarshalData(dsVal);\n        } catch (err) {\n          if (err.code !== ERR_NOT_FOUND) {\n            const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;\n            log.error(errMsg);\n            throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n          }\n\n          if (!checkRouting) {\n            throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n          } // Try to get from routing\n\n\n          try {\n            const keys = ipns.getIdKeys(peerId.toBytes());\n            const res = yield _this5._routing.get(keys.routingKey.uint8Array()); // unmarshal data\n\n            return _this5._unmarshalData(res);\n          } catch (err) {\n            log.error(err);\n            throw err;\n          }\n        }\n      })();\n    }\n    /**\n     * @param {Uint8Array} data\n     */\n\n\n    _unmarshalData(data) {\n      try {\n        return ipns.unmarshal(data);\n      } catch (err) {\n        throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n      }\n    }\n    /**\n     * @param {PrivateKey} privKey\n     * @param {Uint8Array} value\n     * @param {number} lifetime\n     * @param {PeerId} peerId\n     */\n\n\n    _updateOrCreateRecord(privKey, value, lifetime, peerId) {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!PeerId.isPeerId(peerId)) {\n          const errMsg = 'peerId received is not valid';\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n        }\n\n        const getPublishedOptions = {\n          checkRouting: true\n        };\n        let record;\n\n        try {\n          record = yield _this6._getPublished(peerId, getPublishedOptions);\n        } catch (err) {\n          if (err.code !== ERR_NOT_FOUND) {\n            const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`;\n            log.error(errMsg);\n            throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n          }\n        } // Determinate the record sequence number\n\n\n        let seqNumber = 0n;\n\n        if (record && record.sequence !== undefined) {\n          seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence);\n        }\n\n        let entryData;\n\n        try {\n          // Create record\n          entryData = yield ipns.create(privKey, value, seqNumber, lifetime);\n        } catch (err) {\n          const errMsg = `ipns record for ${value} could not be created`;\n          log.error(err);\n          throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n        } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n\n        try {\n          // Marshal record\n          const data = ipns.marshal(entryData); // Store the new record\n\n          yield _this6._datastore.put(ipns.getLocalKey(peerId.id), data);\n          log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`);\n          return entryData;\n        } catch (err) {\n          const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n        }\n      })();\n    }\n\n  }\n\n  IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\n  return IpnsPublisher;\n})();\nexports = module.exports = IpnsPublisher;","map":null,"metadata":{},"sourceType":"script"}