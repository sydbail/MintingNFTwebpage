{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../types/message/entry')} BitswapMessageEntry\n * @typedef {import('peer-id')} PeerId\n */\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  CID\n} = require('multiformats');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst Message = require('../types/message');\n\nconst WantType = Message.WantType;\n\nconst Wantlist = require('../types/wantlist');\n\nconst Ledger = require('./ledger');\n\nconst RequestQueue = require('./req-queue');\n\nconst TaskMerger = require('./task-merger');\n\nconst {\n  logger\n} = require('../utils'); // The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\n\n\nconst TARGET_MESSAGE_SIZE = 16 * 1024; // If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\n\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\n\nclass DecisionEngine {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('interface-blockstore').Blockstore} blockstore\n   * @param {import('../network')} network\n   * @param {import('../stats')} stats\n   * @param {Object} [opts]\n   * @param {number} [opts.targetMessageSize]\n   * @param {number} [opts.maxSizeReplaceHasWithBlock]\n   */\n  constructor(peerId, blockstore, network, stats, opts = {}) {\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats;\n    this._opts = this._processOpts(opts); // A list of of ledgers by their partner id\n\n    /** @type {Map<string, Ledger>} */\n\n    this.ledgerMap = new Map();\n    this._running = false; // Queue of want-have / want-block per peer\n\n    this._requestQueue = new RequestQueue(TaskMerger);\n  }\n  /**\n   * @template {Object} Opts\n   * @param {Opts} opts\n   * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}\n   * @private\n   */\n\n\n  _processOpts(opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    };\n  }\n\n  _scheduleProcessTasks() {\n    setTimeout(() => {\n      this._processTasks();\n    });\n  }\n  /**\n   * Pull tasks off the request queue and send a message to the corresponding\n   * peer\n   */\n\n\n  _processTasks() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this._running) {\n        return;\n      }\n\n      const {\n        peerId,\n        tasks,\n        pendingSize\n      } = _this._requestQueue.popTasks(_this._opts.targetMessageSize);\n\n      if (tasks.length === 0) {\n        return;\n      } // Create a new message\n\n\n      const msg = new Message(false); // Amount of data in the request queue still waiting to be popped\n\n      msg.setPendingBytes(pendingSize); // Split out want-blocks, want-haves and DONT_HAVEs\n\n      const blockCids = [];\n      const blockTasks = new Map();\n\n      for (const task of tasks) {\n        const cid = CID.parse(task.topic);\n\n        if (task.data.haveBlock) {\n          if (task.data.isWantBlock) {\n            blockCids.push(cid);\n            blockTasks.set(task.topic, task.data);\n          } else {\n            // Add HAVES to the message\n            msg.addHave(cid);\n          }\n        } else {\n          // Add DONT_HAVEs to the message\n          msg.addDontHave(cid);\n        }\n      }\n\n      const blocks = yield _this._getBlocks(blockCids);\n\n      for (const [topic, taskData] of blockTasks) {\n        const cid = CID.parse(topic);\n        const blk = blocks.get(topic); // If the block was found (it has not been removed)\n\n        if (blk) {\n          // Add the block to the message\n          msg.addBlock(cid, blk);\n        } else {\n          // The block was not found. If the client requested DONT_HAVE,\n          // add DONT_HAVE to the message.\n          if (taskData.sendDontHave) {\n            msg.addDontHave(cid);\n          }\n        }\n      } // If there's nothing in the message, bail out\n\n\n      if (msg.empty) {\n        peerId && _this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n        _this._scheduleProcessTasks();\n\n        return;\n      }\n\n      try {\n        // Send the message\n        peerId && (yield _this.network.sendMessage(peerId, msg)); // Peform sent message accounting\n\n        for (const [cidStr, block] of blocks.entries()) {\n          peerId && _this.messageSent(peerId, CID.parse(cidStr), block);\n        }\n      } catch (err) {\n        _this._log.error(err);\n      } // Free the tasks up from the request queue\n\n\n      peerId && _this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n      _this._scheduleProcessTasks();\n    })();\n  }\n  /**\n   * @param {PeerId} peerId\n   * @returns {Map<string, import('../types/wantlist/entry')>}\n   */\n\n\n  wantlistForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n    return ledger ? ledger.wantlist.sortedEntries() : new Map();\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  ledgerForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n\n    if (!ledger) {\n      return null;\n    }\n\n    return {\n      peer: ledger.partner,\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    };\n  }\n  /**\n   * @returns {PeerId[]}\n   */\n\n\n  peers() {\n    return Array.from(this.ledgerMap.values()).map(l => l.partner);\n  }\n  /**\n   * Receive blocks either from an incoming message from the network, or from\n   * blocks being added by the client on the localhost (eg IPFS add)\n   *\n   * @param {{ cid: CID, data: Uint8Array }[]} blocks\n   */\n\n\n  receivedBlocks(blocks) {\n    if (!blocks.length) {\n      return;\n    } // For each connected peer, check if it wants the block we received\n\n\n    for (const ledger of this.ledgerMap.values()) {\n      for (const block of blocks) {\n        // Filter out blocks that we don't want\n        const want = ledger.wantlistContains(block.cid);\n\n        if (!want) {\n          continue;\n        } // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n\n\n        const blockSize = block.data.length;\n\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n\n        let entrySize = blockSize;\n\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid);\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(base58btc),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }]);\n      }\n    }\n\n    this._scheduleProcessTasks();\n  }\n  /**\n   * Handle incoming messages\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<void>}\n   */\n\n\n  messageReceived(peerId, msg) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const ledger = _this2._findOrCreate(peerId);\n\n      if (msg.empty) {\n        return;\n      } // If the message has a full wantlist, clear the current wantlist\n\n\n      if (msg.full) {\n        ledger.wantlist = new Wantlist();\n      } // Record the amount of block data received\n\n\n      _this2._updateBlockAccounting(msg.blocks, ledger);\n\n      if (msg.wantlist.size === 0) {\n        _this2._scheduleProcessTasks();\n\n        return;\n      } // Clear cancelled wants and add new wants to the ledger\n\n      /** @type {CID[]} */\n\n\n      const cancels = [];\n      /** @type {BitswapMessageEntry[]} */\n\n      const wants = [];\n      msg.wantlist.forEach(entry => {\n        if (entry.cancel) {\n          ledger.cancelWant(entry.cid);\n          cancels.push(entry.cid);\n        } else {\n          ledger.wants(entry.cid, entry.priority, entry.wantType);\n          wants.push(entry);\n        }\n      });\n\n      _this2._cancelWants(peerId, cancels);\n\n      yield _this2._addWants(peerId, wants);\n\n      _this2._scheduleProcessTasks();\n    })();\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID[]} cids\n   * @returns {void}\n   */\n\n\n  _cancelWants(peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(base58btc), peerId);\n    }\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {BitswapMessageEntry[]} wants\n   * @returns {Promise<void>}\n   */\n\n\n  _addWants(peerId, wants) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // Get the size of each wanted block\n      const blockSizes = yield _this3._getBlockSizes(wants.map(w => w.cid));\n      const tasks = [];\n\n      for (const want of wants) {\n        const id = want.cid.toString(base58btc);\n        const blockSize = blockSizes.get(id); // If the block was not found\n\n        if (blockSize == null) {\n          // Only add the task to the queue if the requester wants a DONT_HAVE\n          if (want.sendDontHave) {\n            tasks.push({\n              topic: id,\n              priority: want.priority,\n              size: Message.blockPresenceSize(want.cid),\n              data: {\n                isWantBlock: want.wantType === WantType.Block,\n                blockSize: 0,\n                haveBlock: false,\n                sendDontHave: want.sendDontHave\n              }\n            });\n          }\n        } else {\n          // The block was found, add it to the queue\n          // If the block is small enough, just send the block, even if the\n          // client asked for a HAVE\n          const isWantBlock = _this3._sendAsBlock(want.wantType, blockSize); // entrySize is the amount of space the entry takes up in the\n          // message we send to the recipient. If we're sending a block, the\n          // entrySize is the size of the block. Otherwise it's the size of\n          // a block presence entry.\n\n\n          let entrySize = blockSize;\n\n          if (!isWantBlock) {\n            entrySize = Message.blockPresenceSize(want.cid);\n          }\n\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: entrySize,\n            data: {\n              isWantBlock,\n              blockSize,\n              haveBlock: true,\n              sendDontHave: want.sendDontHave\n            }\n          });\n        }\n\n        _this3._requestQueue.pushTasks(peerId, tasks);\n      }\n    })();\n  }\n  /**\n   * @private\n   * @param {import('../types/message/message').Message.Wantlist.WantType} wantType\n   * @param {number} blockSize\n   */\n\n\n  _sendAsBlock(wantType, blockSize) {\n    return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n  }\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, number>>}\n   */\n\n\n  _getBlockSizes(cids) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const blocks = yield _this4._getBlocks(cids);\n      return new Map([...blocks].map(([k, v]) => [k, v.length]));\n    })();\n  }\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, Uint8Array>>}\n   */\n\n\n  _getBlocks(cids) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const res = new Map();\n      yield Promise.all(cids.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (cid) {\n          try {\n            const block = yield _this5.blockstore.get(cid);\n            res.set(cid.toString(base58btc), block);\n          } catch (e) {\n            if (e.code !== 'ERR_NOT_FOUND') {\n              _this5._log.error('failed to query blockstore for %s: %s', cid, e);\n            }\n          }\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return res;\n    })();\n  }\n  /**\n   * @private\n   * @param {Map<string, Uint8Array>} blocksMap\n   * @param {Ledger} ledger\n   */\n\n\n  _updateBlockAccounting(blocksMap, ledger) {\n    for (const block of blocksMap.values()) {\n      this._log('got block (%s bytes)', block.length);\n\n      ledger.receivedBytes(block.length);\n    }\n  }\n  /**\n   * Clear up all accounting things after message was sent\n   *\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   */\n\n\n  messageSent(peerId, cid, block) {\n    const ledger = this._findOrCreate(peerId);\n\n    ledger.sentBytes(block.length);\n    ledger.wantlist.remove(cid);\n  }\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n\n\n  numBytesSentTo(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent;\n  }\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n\n\n  numBytesReceivedFrom(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv;\n  }\n  /**\n   *\n   * @param {PeerId} _peerId\n   * @returns {void}\n   */\n\n\n  peerDisconnected(_peerId) {// if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @returns {Ledger}\n   */\n\n\n  _findOrCreate(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n\n    if (ledger) {\n      return ledger;\n    }\n\n    const l = new Ledger(peerId);\n    this.ledgerMap.set(peerIdStr, l);\n\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1);\n    }\n\n    return l;\n  }\n\n  start() {\n    this._running = true;\n  }\n\n  stop() {\n    this._running = false;\n  }\n\n}\n\nmodule.exports = DecisionEngine;","map":null,"metadata":{},"sourceType":"script"}