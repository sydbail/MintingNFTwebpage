{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst b32 = require('multiformats/bases/base32');\n\nconst b36 = require('multiformats/bases/base36');\n\nconst b58 = require('multiformats/bases/base58');\n\nconst b64 = require('multiformats/bases/base64');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst {\n  base16\n} = require('multiformats/bases/base16');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst withIs = require('class-is');\n\nconst {\n  PeerIdProto\n} = require('./proto');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n\nconst bases = { ...b32,\n  ...b36,\n  ...b58,\n  ...b64\n};\nconst baseDecoder = Object.keys(bases).reduce((acc, curr) => acc.or(bases[curr]), base32.decoder); // these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\n\nconst DAG_PB_CODE = 0x70;\nconst LIBP2P_KEY_CODE = 0x72;\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided');\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = base58btc.encode(this.id).substring(1);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n\n    try {\n      const decoded = Digest.decode(this.id);\n\n      if (decoded.code === identity.code) {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return this._pubKey;\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  } // Return the protobuf version of the peer-id\n\n\n  marshal(excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    }).finish();\n  }\n\n  toPrint() {\n    let pid = this.toB58String(); // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n\n    let maxRunes = 6;\n\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return base16.encode(this.id).substring(1);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  } // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n\n  toString() {\n    if (!this._idCIDString) {\n      const cid = CID.createV1(LIBP2P_KEY_CODE, Digest.decode(this.id));\n      Object.defineProperty(this, '_idCIDString', {\n        value: cid.toString(),\n        enumerable: false\n      });\n    }\n\n    return this._idCIDString;\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  equals(id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.id, id);\n    } else if (id.id) {\n      return uint8ArrayEquals(this.id, id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @deprecated Use `.equals`\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  isEqual(id) {\n    return this.equals(id);\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid() {\n    // TODO: needs better checking\n    return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));\n  }\n  /**\n   * Check if the PeerId has an inline public key.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasInlinePublicKey() {\n    try {\n      const decoded = Digest.decode(this.id);\n\n      if (decoded.code === identity.code) {\n        return true;\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return false;\n  }\n\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nconst computeDigest = pubKey => {\n  if (pubKey.bytes.length <= 42) {\n    return Digest.create(identity.code, pubKey.bytes).bytes;\n  } else {\n    return pubKey.hash();\n  }\n};\n\nconst computePeerId = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (privKey, pubKey) {\n    const digest = yield computeDigest(pubKey);\n    return new PeerIdWithIs(digest, privKey, pubKey);\n  });\n\n  return function computePeerId(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // generation\n\n\nexports.create = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (opts) {\n    opts = opts || {};\n    opts.bits = opts.bits || 2048;\n    opts.keyType = opts.keyType || 'RSA';\n    const key = yield cryptoKeys.generateKeyPair(opts.keyType, opts.bits);\n    return computePeerId(key, key.public);\n  });\n\n  return function (_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.createFromHexString = str => {\n  return new PeerIdWithIs(base16.decode('f' + str));\n};\n\nexports.createFromBytes = buf => {\n  try {\n    const cid = CID.decode(buf);\n\n    if (!validMulticodec(cid)) {\n      throw new Error('Supplied PeerID CID is invalid');\n    }\n\n    return exports.createFromCID(cid);\n  } catch {\n    const digest = Digest.decode(buf);\n\n    if (digest.code !== identity.code) {\n      throw new Error('Supplied PeerID CID is invalid');\n    }\n\n    return new PeerIdWithIs(buf);\n  }\n};\n\nexports.createFromB58String = str => {\n  return exports.createFromBytes(base58btc.decode('z' + str));\n};\n\nconst validMulticodec = cid => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE;\n};\n\nexports.createFromCID = cid => {\n  cid = CID.asCID(cid);\n\n  if (!cid || !validMulticodec(cid)) {\n    throw new Error('Supplied PeerID CID is invalid');\n  }\n\n  return new PeerIdWithIs(cid.multihash.bytes);\n}; // Public Key input will be a Uint8Array\n\n\nexports.createFromPubKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (key) {\n    let buf = key;\n\n    if (typeof buf === 'string') {\n      buf = uint8ArrayFromString(key, 'base64pad');\n    }\n\n    if (!(buf instanceof Uint8Array)) {\n      throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n    }\n\n    const pubKey = yield cryptoKeys.unmarshalPublicKey(buf);\n    return computePeerId(undefined, pubKey);\n  });\n\n  return function (_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // Private key input will be a string\n\n\nexports.createFromPrivKey = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (key) {\n    if (typeof key === 'string') {\n      key = uint8ArrayFromString(key, 'base64pad');\n    }\n\n    if (!(key instanceof Uint8Array)) {\n      throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n    }\n\n    const privKey = yield cryptoKeys.unmarshalPrivateKey(key);\n    return computePeerId(privKey, privKey.public);\n  });\n\n  return function (_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.createFromJSON = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (obj) {\n    const id = base58btc.decode('z' + obj.id);\n    const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad');\n    const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad');\n    const pub = rawPubKey && (yield cryptoKeys.unmarshalPublicKey(rawPubKey));\n\n    if (!rawPrivKey) {\n      return new PeerIdWithIs(id, undefined, pub);\n    }\n\n    const privKey = yield cryptoKeys.unmarshalPrivateKey(rawPrivKey);\n    const privDigest = yield computeDigest(privKey.public);\n    let pubDigest;\n\n    if (pub) {\n      pubDigest = yield computeDigest(pub);\n    }\n\n    if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {\n      throw new Error('Public and private key do not match');\n    }\n\n    if (id && !uint8ArrayEquals(privDigest, id)) {\n      throw new Error('Id and private key do not match');\n    }\n\n    return new PeerIdWithIs(id, privKey, pub);\n  });\n\n  return function (_x6) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.createFromProtobuf = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator(function* (buf) {\n    if (typeof buf === 'string') {\n      buf = uint8ArrayFromString(buf, 'base16');\n    }\n\n    let {\n      id,\n      privKey,\n      pubKey\n    } = PeerIdProto.decode(buf);\n    privKey = privKey ? yield cryptoKeys.unmarshalPrivateKey(privKey) : false;\n    pubKey = pubKey ? yield cryptoKeys.unmarshalPublicKey(pubKey) : false;\n    let pubDigest;\n    let privDigest;\n\n    if (privKey) {\n      privDigest = yield computeDigest(privKey.public);\n    }\n\n    if (pubKey) {\n      pubDigest = yield computeDigest(pubKey);\n    }\n\n    if (privKey) {\n      if (pubKey) {\n        if (!uint8ArrayEquals(privDigest, pubDigest)) {\n          throw new Error('Public and private key do not match');\n        }\n      }\n\n      return new PeerIdWithIs(privDigest, privKey, privKey.public);\n    } // TODO: val id and pubDigest\n\n\n    if (pubKey) {\n      return new PeerIdWithIs(pubDigest, undefined, pubKey);\n    }\n\n    if (id) {\n      return new PeerIdWithIs(id);\n    }\n\n    throw new Error('Protobuf did not contain any usable key material');\n  });\n\n  return function (_x7) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nexports.parse = str => {\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519 key or sha2-256 hash of rsa public key\n    // base58btc encoded either way\n    str = `z${str}`;\n  }\n\n  return exports.createFromBytes(baseDecoder.decode(str));\n};\n\nexports.isPeerId = peerId => {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad');\n  }\n}","map":null,"metadata":{},"sourceType":"script"}