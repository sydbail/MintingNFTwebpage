{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst c = require('../constants');\n\nconst Message = require('../message');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\n\n\nmodule.exports = dht => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  const findPeerLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (peer) {\n      dht._log(`findPeerLocal ${peer.toB58String()}`);\n\n      const p = yield dht.routingTable.find(peer);\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n      const peerData = p && dht.peerStore.get(p);\n\n      if (peerData) {\n        return {\n          id: peerData.id,\n          multiaddrs: peerData.addresses.map(address => address.multiaddr)\n        };\n      }\n    });\n\n    return function findPeerLocal(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  const getValueSingle = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (peer, key) {\n      // eslint-disable-line require-await\n      const msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n      return dht.network.sendRequest(peer, msg);\n    });\n\n    return function getValueSingle(_x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n\n  const closerPeersSingle = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* (key, peer) {\n      dht._log(`closerPeersSingle ${uint8ArrayToString(key, 'base32')} from ${peer.toB58String()}`);\n\n      const msg = yield dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n      return msg.closerPeers.filter(peerData => !dht._isSelf(peerData.id)).map(peerData => {\n        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);\n        return peerData;\n      });\n    });\n\n    return function closerPeersSingle(_x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  const getPublicKeyFromNode = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator(function* (peer) {\n      const pkKey = utils.keyForPublicKey(peer);\n      const msg = yield getValueSingle(peer, pkKey);\n\n      if (!msg.record || !msg.record.value) {\n        throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD');\n      }\n\n      const recPeer = yield PeerId.createFromPubKey(msg.record.value); // compare hashes of the pub key\n\n      if (!recPeer.equals(peer)) {\n        throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n      }\n\n      return recPeer.pubKey;\n    });\n\n    return function getPublicKeyFromNode(_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     *\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    _findPeerSingle(peer, target) {\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        dht._log('findPeerSingle %s', peer.toB58String());\n\n        const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n        return dht.network.sendRequest(peer, msg);\n      })();\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    findPeer(id, options = {\n      timeout: 60000\n    }) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        options.timeout = options.timeout || c.minute;\n\n        dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n        const pi = yield findPeerLocal(id); // already got it\n\n        if (pi != null) {\n          dht._log('found local');\n\n          return pi;\n        }\n\n        const key = yield utils.convertPeerId(id);\n        const peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n        if (peers.length === 0) {\n          throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n        } // sanity check\n\n\n        const match = peers.find(p => p.isEqual(id));\n\n        if (match) {\n          /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n          const peer = dht.peerStore.get(id);\n\n          if (peer) {\n            dht._log('found in peerStore');\n\n            return {\n              id: peer.id,\n              multiaddrs: peer.addresses.map(address => address.multiaddr)\n            };\n          }\n        } // query the network\n\n\n        const query = new Query(dht, id.id, () => {\n          /**\n           * There is no distinction between the disjoint paths, so there are no per-path\n           * variables in dht scope. Just return the actual query function.\n           *\n           * @param {PeerId} peer\n           */\n          const queryFn = /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* (peer) {\n              const msg = yield _this._findPeerSingle(peer, id);\n              const match = msg.closerPeers.find(p => p.id.isEqual(id)); // found it\n\n              if (match) {\n                return {\n                  peer: match,\n                  queryComplete: true\n                };\n              }\n\n              return {\n                closerPeers: msg.closerPeers\n              };\n            });\n\n            return function queryFn(_x7) {\n              return _ref5.apply(this, arguments);\n            };\n          }();\n\n          return queryFn;\n        });\n        let result;\n\n        try {\n          result = yield pTimeout(query.run(peers), options.timeout);\n        } finally {\n          query.stop();\n        }\n\n        let success = false;\n        result.paths.forEach(result => {\n          if (result.success && result.peer) {\n            success = true;\n            dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs);\n          }\n        });\n\n        dht._log('findPeer %s: %s', id.toB58String(), success);\n\n        if (!success) {\n          throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n        }\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n        const peerData = dht.peerStore.get(id);\n\n        if (!peerData) {\n          throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND');\n        }\n\n        return {\n          id: peerData.id,\n          multiaddrs: peerData.addresses.map(address => address.multiaddr)\n        };\n      })();\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    getClosestPeers(key, options = {\n      shallow: false\n    }) {\n      return _wrapAsyncGenerator(function* () {\n        dht._log('getClosestPeers to %b', key);\n\n        const id = yield _awaitAsyncGenerator(utils.convertBuffer(key));\n        const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n        const q = new Query(dht, key, () => {\n          // There is no distinction between the disjoint paths,\n          // so there are no per-path variables in dht scope.\n          // Just return the actual query function.\n          return /*#__PURE__*/function () {\n            var _ref6 = _asyncToGenerator(function* (peer) {\n              const closer = yield closerPeersSingle(key, peer);\n              return {\n                closerPeers: closer,\n                pathComplete: options.shallow ? true : undefined\n              };\n            });\n\n            return function (_x8) {\n              return _ref6.apply(this, arguments);\n            };\n          }();\n        });\n        const res = yield _awaitAsyncGenerator(q.run(tablePeers));\n\n        if (!res || !res.finalSet) {\n          return [];\n        }\n\n        const sorted = yield _awaitAsyncGenerator(utils.sortClosestPeers(Array.from(res.finalSet), id));\n\n        for (const pId of sorted.slice(0, dht.kBucketSize)) {\n          yield pId;\n        }\n      })();\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    getPublicKey(peer) {\n      return _asyncToGenerator(function* () {\n        dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n        const peerData = dht.peerStore.get(peer);\n\n        if (peerData && peerData.id.pubKey) {\n          dht._log('getPublicKey: found local copy');\n\n          return peerData.id.pubKey;\n        } // try the node directly\n\n\n        let pk;\n\n        try {\n          pk = yield getPublicKeyFromNode(peer);\n        } catch (err) {\n          // try dht directly\n          const pkKey = utils.keyForPublicKey(peer);\n          const value = yield dht.get(pkKey);\n          pk = crypto.keys.unmarshalPublicKey(value);\n        }\n\n        const peerId = new PeerId(peer.id, undefined, pk);\n        const addrs = (peerData && peerData.addresses || []).map(address => address.multiaddr);\n        dht.peerStore.addressBook.add(peerId, addrs);\n        dht.peerStore.keyBook.set(peerId, pk);\n        return pk;\n      })();\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/libp2p-kad-dht/src/peer-routing/index.js"],"names":["errcode","require","pTimeout","PeerId","crypto","toString","uint8ArrayToString","c","Message","Query","utils","module","exports","dht","findPeerLocal","peer","_log","toB58String","p","routingTable","find","peerData","peerStore","get","id","multiaddrs","addresses","map","address","multiaddr","getValueSingle","key","msg","TYPES","GET_VALUE","network","sendRequest","closerPeersSingle","peerRouting","_findPeerSingle","closerPeers","filter","_isSelf","addressBook","add","getPublicKeyFromNode","pkKey","keyForPublicKey","record","value","Error","recPeer","createFromPubKey","equals","pubKey","target","FIND_NODE","findPeer","options","timeout","minute","pi","convertPeerId","peers","closestPeers","kBucketSize","length","match","isEqual","query","queryFn","queryComplete","result","run","stop","success","paths","forEach","getClosestPeers","shallow","convertBuffer","tablePeers","q","closer","pathComplete","undefined","res","finalSet","sorted","sortClosestPeers","Array","from","pId","slice","getPublicKey","pk","err","keys","unmarshalPublicKey","peerId","addrs","keyBook","set"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst c = require('../constants')\nconst Message = require('../message')\nconst Query = require('../query')\n\nconst utils = require('../utils')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  const findPeerLocal = async (peer) => {\n    dht._log(`findPeerLocal ${peer.toB58String()}`)\n    const p = await dht.routingTable.find(peer)\n\n    /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n    const peerData = p && dht.peerStore.get(p)\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    }\n  }\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n  const getValueSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log(`closerPeersSingle ${uint8ArrayToString(key, 'base32')} from ${peer.toB58String()}`)\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key))\n\n    return msg.closerPeers\n      .filter((peerData) => !dht._isSelf(peerData.id))\n      .map((peerData) => {\n        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs)\n\n        return peerData\n      })\n  }\n\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n  const getPublicKeyFromNode = async (peer) => {\n    const pkKey = utils.keyForPublicKey(peer)\n    const msg = await getValueSingle(peer, pkKey)\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD')\n    }\n\n    const recPeer = await PeerId.createFromPubKey(msg.record.value)\n\n    // compare hashes of the pub key\n    if (!recPeer.equals(peer)) {\n      throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n    }\n\n    return recPeer.pubKey\n  }\n\n  return {\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   *\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @returns {Promise<Message>}\n   * @private\n   */\n    async _findPeerSingle (peer, target) { // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String())\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)\n\n      return dht.network.sendRequest(peer, msg)\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer (id, options = { timeout: 60000 }) {\n      options.timeout = options.timeout || c.minute\n      dht._log('findPeer %s', id.toB58String())\n\n      // Try to find locally\n      const pi = await findPeerLocal(id)\n\n      // already got it\n      if (pi != null) {\n        dht._log('found local')\n        return pi\n      }\n\n      const key = await utils.convertPeerId(id)\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize)\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED')\n      }\n\n      // sanity check\n      const match = peers.find((p) => p.isEqual(id))\n      if (match) {\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n        const peer = dht.peerStore.get(id)\n\n        if (peer) {\n          dht._log('found in peerStore')\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map((address) => address.multiaddr)\n          }\n        }\n      }\n\n      // query the network\n      const query = new Query(dht, id.id, () => {\n        /**\n         * There is no distinction between the disjoint paths, so there are no per-path\n         * variables in dht scope. Just return the actual query function.\n         *\n         * @param {PeerId} peer\n         */\n        const queryFn = async (peer) => {\n          const msg = await this._findPeerSingle(peer, id)\n          const match = msg.closerPeers.find((p) => p.id.isEqual(id))\n\n          // found it\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            }\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          }\n        }\n\n        return queryFn\n      })\n\n      let result\n      try {\n        result = await pTimeout(query.run(peers), options.timeout)\n      } finally {\n        query.stop()\n      }\n\n      let success = false\n      result.paths.forEach((result) => {\n        if (result.success && result.peer) {\n          success = true\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs)\n        }\n      })\n      dht._log('findPeer %s: %s', id.toB58String(), success)\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND')\n      }\n\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n      const peerData = dht.peerStore.get(id)\n\n      if (!peerData) {\n        throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND')\n      }\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async * getClosestPeers (key, options = { shallow: false }) {\n      dht._log('getClosestPeers to %b', key)\n\n      const id = await utils.convertBuffer(key)\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const closer = await closerPeersSingle(key, peer)\n\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          }\n        }\n      })\n\n      const res = await q.run(tablePeers)\n      if (!res || !res.finalSet) {\n        return []\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id)\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    async getPublicKey (peer) {\n      dht._log('getPublicKey %s', peer.toB58String())\n\n      // local check\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n      const peerData = dht.peerStore.get(peer)\n\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy')\n        return peerData.id.pubKey\n      }\n\n      // try the node directly\n      let pk\n\n      try {\n        pk = await getPublicKeyFromNode(peer)\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer)\n        const value = await dht.get(pkKey)\n        pk = crypto.keys.unmarshalPublicKey(value)\n      }\n\n      const peerId = new PeerId(peer.id, undefined, pk)\n      const addrs = ((peerData && peerData.addresses) || []).map((address) => address.multiaddr)\n      dht.peerStore.addressBook.add(peerId, addrs)\n      dht.peerStore.keyBook.set(peerId, pk)\n\n      return pk\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}