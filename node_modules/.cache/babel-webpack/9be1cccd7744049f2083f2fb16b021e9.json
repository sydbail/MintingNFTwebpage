{"ast":null,"code":"'use strict';\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\n\nmodule.exports = function ({\n  repo,\n  codecs,\n  resolve,\n  preload\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  function refs(_x) {\n    return _refs.apply(this, arguments);\n  }\n\n  function _refs() {\n    _refs = _wrapAsyncGenerator(function* (ipfsPath, options = {}) {\n      if (options.maxDepth === 0) {\n        return;\n      }\n\n      if (options.edges && options.format && options.format !== Format.default) {\n        throw new Error('Cannot set edges to true and also specify format');\n      }\n\n      options.format = options.edges ? Format.edges : options.format;\n\n      if (typeof options.maxDepth !== 'number') {\n        options.maxDepth = options.recursive ? Infinity : 1;\n      }\n      /** @type {(string|CID)[]} */\n\n\n      const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n      const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n      for (const path of paths) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(refsStream(resolve, repo, codecs, path, options)), _awaitAsyncGenerator);\n      }\n    });\n    return _refs.apply(this, arguments);\n  }\n\n  return withTimeoutOption(refs);\n};\n\nmodule.exports.Format = Format;\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\nfunction getFullPath(preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath);\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return `/ipfs/${cid}${path || ''}`;\n}\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\n\nfunction refsStream(_x2, _x3, _x4, _x5, _x6) {\n  return _refsStream.apply(this, arguments);\n}\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\n\n\nfunction _refsStream() {\n  _refsStream = _wrapAsyncGenerator(function* (resolve, repo, codecs, path, options) {\n    // Resolve to the target CID of the path\n    const resPath = yield _awaitAsyncGenerator(resolve(path));\n    const {\n      cid\n    } = toCIDAndPath(resPath);\n    const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n    const unique = options.unique || false; // Traverse the DAG, converting it into a stream\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(objectStream(repo, codecs, cid, maxDepth, unique)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const obj = _value;\n\n        // Root object will not have a parent\n        if (!obj.parent) {\n          continue;\n        } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n        if (obj.isDuplicate) {\n          continue;\n        } // Format the links\n        // Clients expect refs to be in the format { ref: <ref> }\n\n\n        yield {\n          ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n        };\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return _refsStream.apply(this, arguments);\n}\n\nfunction formatLink(srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n */\n\n\nfunction objectStream(_x7, _x8, _x9, _x10, _x11) {\n  return _objectStream.apply(this, arguments);\n}\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {Array<string|number>} base\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\n\n\nfunction _objectStream() {\n  _objectStream = _wrapAsyncGenerator(function* (repo, codecs, rootCid, maxDepth, uniqueOnly) {\n    // eslint-disable-line require-await\n    const seen = new Set();\n    /**\n     * @param {Node} parent\n     * @param {number} depth\n     * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n     */\n\n    function traverseLevel(_x15, _x16) {\n      return _traverseLevel.apply(this, arguments);\n    }\n\n    function _traverseLevel() {\n      _traverseLevel = _wrapAsyncGenerator(function* (parent, depth) {\n        const nextLevelDepth = depth + 1; // Check the depth\n\n        if (nextLevelDepth > maxDepth) {\n          return;\n        } // Get this object's links\n\n\n        try {\n          // Look at each link, parent and the new depth\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n\n          var _iteratorError2;\n\n          try {\n            for (var _iterator2 = _asyncIterator(getLinks(repo, codecs, parent.cid)), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n              const link = _value2;\n              yield {\n                parent: parent,\n                node: link,\n                isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n              };\n\n              if (uniqueOnly) {\n                seen.add(link.cid.toString());\n              }\n\n              yield* _asyncGeneratorDelegate(_asyncIterator(traverseLevel(link, nextLevelDepth)), _awaitAsyncGenerator);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                yield _awaitAsyncGenerator(_iterator2.return());\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        } catch (err) {\n          if (err.code === ERR_NOT_FOUND) {\n            err.message = `Could not find object with CID: ${parent.cid}`;\n          }\n\n          throw err;\n        }\n      });\n      return _traverseLevel.apply(this, arguments);\n    }\n\n    yield* _asyncGeneratorDelegate(_asyncIterator(traverseLevel({\n      cid: rootCid\n    }, 0)), _awaitAsyncGenerator);\n  });\n  return _objectStream.apply(this, arguments);\n}\n\nfunction getLinks(_x12, _x13, _x14) {\n  return _getLinks.apply(this, arguments);\n}\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\n\n\nfunction _getLinks() {\n  _getLinks = _wrapAsyncGenerator(function* (repo, codecs, cid, base = []) {\n    const block = yield _awaitAsyncGenerator(repo.blocks.get(cid));\n    const codec = yield _awaitAsyncGenerator(codecs.getCodec(cid.code));\n    const value = codec.decode(block);\n    const isDagPb = cid.code === dagPb.code;\n\n    for (const [name, cid] of links(value, base)) {\n      // special case for dag-pb - use the name of the link\n      // instead of the path within the object\n      if (isDagPb) {\n        const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n\n        if (match) {\n          const index = Number(match[1]);\n\n          if (index < value.Links.length) {\n            yield {\n              name: value.Links[index].Name,\n              cid\n            };\n            continue;\n          }\n        }\n      }\n\n      yield {\n        name,\n        cid\n      };\n    }\n  });\n  return _getLinks.apply(this, arguments);\n}\n\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n\n  if (source instanceof Uint8Array) {\n    return;\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element); // eslint-disable-next-line max-depth\n\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  } // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n\n\n  return [];\n};","map":null,"metadata":{},"sourceType":"script"}