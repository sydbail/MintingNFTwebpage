{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n});\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst ipns = require('ipns');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nclass IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n  /**\n   * Publish record with a eol\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  publishWithEOL(privKey, value, lifetime) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!privKey || !privKey.bytes) {\n        throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n      }\n\n      const peerId = yield PeerId.createFromPrivKey(privKey.bytes);\n      const record = yield _this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n      return _this._putRecordToRouting(record, peerId);\n    })();\n  }\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n\n\n  publish(privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n  }\n  /**\n   * @param {IPNSEntry} record\n   * @param {PeerId} peerId\n   */\n\n\n  _putRecordToRouting(record, peerId) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!PeerId.isPeerId(peerId)) {\n        const errMsg = 'peerId received is not valid';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n      } // @ts-ignore - accessing private property isn't allowed\n\n\n      const publicKey = peerId._pubKey;\n      const embedPublicKeyRecord = yield ipns.embedPublicKey(publicKey, record);\n      const keys = ipns.getIdKeys(peerId.toBytes());\n      yield _this2._publishEntry(keys.routingKey, embedPublicKeyRecord || record); // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n      // We will be able to deprecate this part in the future, since the public keys will be only\n      // in IPNS record and the peerId.\n\n      yield _this2._publishPublicKey(keys.routingPubKey, publicKey);\n      return embedPublicKeyRecord || record;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {IPNSEntry} entry\n   */\n\n\n  _publishEntry(key, entry) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(key instanceof Key)) {\n        const errMsg = 'datastore key does not have a valid format';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n      }\n\n      let entryData;\n\n      try {\n        // Marshal record\n        entryData = ipns.marshal(entry);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      } // Add record to routing (buffer key)\n\n\n      try {\n        const res = yield _this3._routing.put(key.uint8Array(), entryData);\n        log(`ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`);\n        return res;\n      } catch (err) {\n        const errMsg = `ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`;\n        log.error(errMsg);\n        log.error(err);\n        throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n      }\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {PublicKey} publicKey\n   */\n\n\n  _publishPublicKey(key, publicKey) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(key instanceof Key)) {\n        const errMsg = 'datastore key does not have a valid format';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n      }\n\n      if (!publicKey || !publicKey.bytes) {\n        const errMsg = 'one or more of the provided parameters are not defined';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER');\n      } // Add public key to routing (buffer key)\n\n\n      try {\n        const res = yield _this4._routing.put(key.uint8Array(), publicKey.bytes);\n        log(`public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`);\n        return res;\n      } catch (err) {\n        const errMsg = `public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`;\n        log.error(errMsg);\n        log.error(err);\n        throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n      }\n    })();\n  }\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n\n\n  _getPublished(peerId, options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!PeerId.isPeerId(peerId)) {\n        const errMsg = 'peerId received is not valid';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n      }\n\n      const checkRouting = options.checkRouting !== false;\n\n      try {\n        const dsVal = yield _this5._datastore.get(ipns.getLocalKey(peerId.id)); // unmarshal data\n\n        return _this5._unmarshalData(dsVal);\n      } catch (err) {\n        if (err.code !== ERR_NOT_FOUND) {\n          const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n        }\n\n        if (!checkRouting) {\n          throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n        } // Try to get from routing\n\n\n        try {\n          const keys = ipns.getIdKeys(peerId.toBytes());\n          const res = yield _this5._routing.get(keys.routingKey.uint8Array()); // unmarshal data\n\n          return _this5._unmarshalData(res);\n        } catch (err) {\n          log.error(err);\n          throw err;\n        }\n      }\n    })();\n  }\n  /**\n   * @param {Uint8Array} data\n   */\n\n\n  _unmarshalData(data) {\n    try {\n      return ipns.unmarshal(data);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {PeerId} peerId\n   */\n\n\n  _updateOrCreateRecord(privKey, value, lifetime, peerId) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!PeerId.isPeerId(peerId)) {\n        const errMsg = 'peerId received is not valid';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n      }\n\n      const getPublishedOptions = {\n        checkRouting: true\n      };\n      let record;\n\n      try {\n        record = yield _this6._getPublished(peerId, getPublishedOptions);\n      } catch (err) {\n        if (err.code !== ERR_NOT_FOUND) {\n          const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`;\n          log.error(errMsg);\n          throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n        }\n      } // Determinate the record sequence number\n\n\n      let seqNumber = 0n;\n\n      if (record && record.sequence !== undefined) {\n        seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence);\n      }\n\n      let entryData;\n\n      try {\n        // Create record\n        entryData = yield ipns.create(privKey, value, seqNumber, lifetime);\n      } catch (err) {\n        const errMsg = `ipns record for ${value} could not be created`;\n        log.error(err);\n        throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n      } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n\n      try {\n        // Marshal record\n        const data = ipns.marshal(entryData); // Store the new record\n\n        yield _this6._datastore.put(ipns.getLocalKey(peerId.id), data);\n        log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`);\n        return entryData;\n      } catch (err) {\n        const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n      }\n    })();\n  }\n\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\nexports = module.exports = IpnsPublisher;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/ipns/publisher.js"],"names":["PeerId","require","Key","Errors","errcode","debug","log","Object","assign","error","toString","uint8ArrayToString","equals","uint8ArrayEquals","ipns","ERR_NOT_FOUND","notFoundError","code","defaultRecordLifetime","IpnsPublisher","constructor","routing","datastore","_routing","_datastore","publishWithEOL","privKey","value","lifetime","bytes","Error","peerId","createFromPrivKey","record","_updateOrCreateRecord","_putRecordToRouting","publish","isPeerId","errMsg","publicKey","_pubKey","embedPublicKeyRecord","embedPublicKey","keys","getIdKeys","toBytes","_publishEntry","routingKey","_publishPublicKey","routingPubKey","key","entry","entryData","marshal","err","res","put","uint8Array","_getPublished","options","checkRouting","dsVal","get","getLocalKey","id","_unmarshalData","data","unmarshal","getPublishedOptions","stack","seqNumber","sequence","undefined","BigInt","create","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Key, Errors } = require('interface-datastore')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n})\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst ipns = require('ipns')\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst defaultRecordLifetime = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nclass IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n  async publishWithEOL (privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY')\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes)\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId)\n\n    return this._putRecordToRouting(record, peerId)\n  }\n\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n  publish (privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime)\n  }\n\n  /**\n   * @param {IPNSEntry} record\n   * @param {PeerId} peerId\n   */\n  async _putRecordToRouting (record, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    // @ts-ignore - accessing private property isn't allowed\n    const publicKey = peerId._pubKey\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record)\n    const keys = ipns.getIdKeys(peerId.toBytes())\n\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record)\n\n    // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n    await this._publishPublicKey(keys.routingPubKey, publicKey)\n\n    return embedPublicKeyRecord || record\n  }\n\n  /**\n   * @param {Key} key\n   * @param {IPNSEntry} entry\n   */\n  async _publishEntry (key, entry) {\n    if (!(key instanceof Key)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    let entryData\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry)\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(key.uint8Array(), entryData)\n      log(`ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {PublicKey} publicKey\n   */\n  async _publishPublicKey (key, publicKey) {\n    if (!(key instanceof Key)) {\n      const errMsg = 'datastore key does not have a valid format'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER')\n    }\n\n    // Add public key to routing (buffer key)\n    try {\n      const res = await this._routing.put(key.uint8Array(), publicKey.bytes)\n      log(`public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n  async _getPublished (peerId, options = {}) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const checkRouting = options.checkRouting !== false\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id))\n\n      // unmarshal data\n      return this._unmarshalData(dsVal)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE')\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED')\n      }\n\n      // Try to get from routing\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes())\n        const res = await this._routing.get(keys.routingKey.uint8Array())\n\n        // unmarshal data\n        return this._unmarshalData(res)\n      } catch (err) {\n        log.error(err)\n\n        throw err\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _unmarshalData (data) {\n    try {\n      return ipns.unmarshal(data)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA')\n    }\n  }\n\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {PeerId} peerId\n   */\n  async _updateOrCreateRecord (privKey, value, lifetime, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    let record\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD')\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0n\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence)\n    }\n\n    let entryData\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, lifetime)\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`\n\n      log.error(err)\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD')\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData)\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data)\n\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`)\n\n      return entryData\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE')\n    }\n  }\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime\nexports = module.exports = IpnsPublisher\n"]},"metadata":{},"sourceType":"script"}