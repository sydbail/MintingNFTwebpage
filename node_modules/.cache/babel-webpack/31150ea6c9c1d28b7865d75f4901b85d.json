{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst cbor = require('cborg');\n\nconst pinset = require('./pin-set');\n\nconst {\n  cidToKey,\n  PIN_DS_KEY,\n  PinTypes\n} = require('./utils');\n\nconst length = require('it-length');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst mhd = require('multiformats/hashes/digest');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('../../src/types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\n\n\nfunction pinsToDatastore(_x, _x2, _x3, _x4) {\n  return _pinsToDatastore.apply(this, arguments);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\n\n\nfunction _pinsToDatastore() {\n  _pinsToDatastore = _asyncToGenerator(function* (blockstore, datastore, pinstore, onProgress) {\n    if (!(yield datastore.has(PIN_DS_KEY))) {\n      return;\n    }\n\n    const mh = yield datastore.get(PIN_DS_KEY);\n    const cid = CID.decode(mh);\n    const pinRootBuf = yield blockstore.get(cid);\n    const pinRoot = dagPb.decode(pinRootBuf);\n    let counter = 0;\n    const pinCount = (yield length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (yield length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)));\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const cid = _value;\n        counter++;\n        /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n\n        const pin = {\n          depth: Infinity\n        };\n\n        if (cid.version !== 0) {\n          pin.version = cid.version;\n        }\n\n        if (cid.code !== dagPb.code) {\n          pin.codec = cid.code;\n        }\n\n        yield pinstore.put(cidToKey(cid), cbor.encode(pin));\n        onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid}`);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n\n    var _iteratorError2;\n\n    try {\n      for (var _iterator2 = _asyncIterator(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n        const cid = _value2;\n        counter++;\n        /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n\n        const pin = {\n          depth: 0\n        };\n\n        if (cid.version !== 0) {\n          pin.version = cid.version;\n        }\n\n        if (cid.code !== dagPb.code) {\n          pin.codec = cid.code;\n        }\n\n        yield pinstore.put(cidToKey(cid), cbor.encode(pin));\n        onProgress(counter / pinCount * 100, `Migrated direct pin ${cid}`);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          yield _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    yield blockstore.delete(cid);\n    yield datastore.delete(PIN_DS_KEY);\n  });\n  return _pinsToDatastore.apply(this, arguments);\n}\n\nfunction pinsToDAG(_x5, _x6, _x7, _x8) {\n  return _pinsToDAG.apply(this, arguments);\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\n\n\nfunction _pinsToDAG() {\n  _pinsToDAG = _asyncToGenerator(function* (blockstore, datastore, pinstore, onProgress) {\n    const recursivePins = [];\n    const directPins = [];\n    let counter = 0;\n    const pinCount = yield length(pinstore.queryKeys({}));\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n\n    var _iteratorError3;\n\n    try {\n      for (var _iterator3 = _asyncIterator(pinstore.query({})), _step3, _value3; _step3 = yield _iterator3.next(), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _step3.value, !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n        const {\n          key,\n          value\n        } = _value3;\n        counter++;\n        const pin = cbor.decode(value);\n        const cid = CID.create(pin.version || 0, pin.codec || dagPb.code, mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop())));\n\n        if (pin.depth === 0) {\n          onProgress(counter / pinCount * 100, `Reverted direct pin ${cid}`);\n          directPins.push(cid);\n        } else {\n          onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid}`);\n          recursivePins.push(cid);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          yield _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    onProgress(100, 'Updating pin root');\n    const pinRoot = {\n      Links: [yield pinset.storeSet(blockstore, PinTypes.direct, directPins), yield pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)]\n    };\n    const buf = dagPb.encode(pinRoot);\n    const digest = yield sha256.digest(buf);\n    const cid = CID.createV0(digest);\n    yield blockstore.put(cid, buf);\n    yield datastore.put(PIN_DS_KEY, cid.bytes);\n  });\n  return _pinsToDAG.apply(this, arguments);\n}\n\nfunction process(_x9, _x10, _x11) {\n  return _process.apply(this, arguments);\n}\n/** @type {Migration} */\n\n\nfunction _process() {\n  _process = _asyncToGenerator(function* (backends, onProgress, fn) {\n    const blockstore = backends.blocks;\n    const datastore = backends.datastore;\n    const pinstore = backends.pins;\n    yield blockstore.open();\n    yield datastore.open();\n    yield pinstore.open();\n\n    try {\n      yield fn(blockstore, datastore, pinstore, onProgress);\n    } finally {\n      yield pinstore.close();\n      yield datastore.close();\n      yield blockstore.close();\n    }\n  });\n  return _process.apply(this, arguments);\n}\n\nmodule.exports = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDatastore);\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDAG);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}