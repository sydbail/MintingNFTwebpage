{"ast":null,"code":"'use strict'; // @ts-ignore - no types\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst mortice = require('mortice');\n/**\n * @typedef {object} Lock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} readLock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} writeLock\n */\n\n/** @type {Lock} */\n\n\nlet lock;\n/**\n * @param {boolean} [repoOwner]\n */\n\nmodule.exports = (repoOwner = false) => {\n  if (lock) {\n    return lock;\n  }\n\n  const mutex = mortice({\n    // ordinarily the main thread would store the read/write lock but\n    // if we are the thread that owns the repo, we can store the lock\n    // on this process even if we are a worker thread\n    singleProcess: repoOwner\n  });\n  lock = {\n    readLock: func => {\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (...args) {\n          const releaseLock = yield mutex.readLock();\n\n          try {\n            return yield func.apply(null, args);\n          } finally {\n            releaseLock();\n          }\n        });\n\n        return function () {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    },\n    writeLock: func => {\n      return /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (...args) {\n          const releaseLock = yield mutex.writeLock();\n\n          try {\n            return yield func.apply(null, args);\n          } finally {\n            releaseLock();\n          }\n        });\n\n        return function () {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n    }\n  };\n  return lock;\n};","map":null,"metadata":{},"sourceType":"script"}