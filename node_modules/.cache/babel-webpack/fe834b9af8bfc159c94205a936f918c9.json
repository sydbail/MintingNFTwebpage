{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.requiredSources = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst debug = debug_1.default(\"compile-common:profiler:requiredSources\");\n\nconst resolveAllSources_1 = require(\"./resolveAllSources\");\n\nfunction requiredSources({\n  allPaths,\n  updatedPaths,\n  resolve,\n  shouldIncludePath,\n  parseImports\n}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const allSources = {};\n    const compilationTargets = [];\n    debug(\"allPaths: %O\", allPaths);\n    debug(\"updatedPaths: %O\", updatedPaths); //before anything else: on Windows, make sure all paths are in native form\n    //(with backslashes) rather than slashes.  otherwise, resolution of relative\n    //paths can cause aliasing; you can end up with one source with slashes (as\n    //given) and one with backslashes (due to relative import resolution).\n\n    allPaths = allPaths.map(sourcePath => sourcePath.replace(/\\//g, path_1.default.sep));\n    updatedPaths = updatedPaths.map(sourcePath => sourcePath.replace(/\\//g, path_1.default.sep)); // Solidity test files might have been injected. Include them in the known set.\n\n    updatedPaths.forEach(_path => {\n      if (!allPaths.includes(_path)) {\n        allPaths.push(_path);\n      }\n    }); //exit out quickly if we've been asked to compile nothing\n\n    if (!updatedPaths.length) {\n      return {\n        allSources: {},\n        compilationTargets: []\n      };\n    }\n\n    const resolved = yield resolveAllSources_1.resolveAllSources({\n      resolve,\n      parseImports,\n      shouldIncludePath,\n      paths: allPaths\n    }); //exit out semi-quickly if we've been asked to compile everything\n\n    if (listsEqual(updatedPaths, allPaths)) {\n      for (const file of Object.keys(resolved)) {\n        if (shouldIncludePath(file)) {\n          allSources[file] = resolved[file].body;\n        }\n      }\n\n      return {\n        allSources,\n        compilationTargets: Object.keys(allSources)\n      };\n    } // Seed compilationTargets with known updates\n\n\n    for (const update of updatedPaths) {\n      if (shouldIncludePath(update)) {\n        compilationTargets.push(update);\n      }\n    }\n\n    debug(\"entering main loop\"); // While there are updated files in the queue, we take each one\n    // and search the entire file corpus to find any sources that import it.\n    // Those sources are added to list of compilation targets as well as\n    // the update queue because their own ancestors need to be discovered.\n\n    while (updatedPaths.length > 0) {\n      const currentUpdate = updatedPaths.shift();\n      const files = allPaths.slice(); // While files: dequeue and inspect their imports\n\n      while (files.length > 0) {\n        const currentFile = files.shift(); // Ignore targets already selected.\n\n        if (compilationTargets.includes(currentFile)) {\n          continue;\n        }\n\n        debug(\"currentFile: %s\", currentFile);\n        const imports = resolved[currentFile].imports;\n        debug(\"imports.length: %d\", imports.length); // If file imports a compilation target, add it\n        // to list of updates and compilation targets\n\n        if (imports.includes(currentUpdate)) {\n          updatedPaths.push(currentFile);\n          compilationTargets.push(currentFile);\n        }\n      }\n    }\n\n    debug(\"compilationTargets: %O\", compilationTargets); //now: crawl the tree downward from the compilation targets\n    //to get all the sources we need\n\n    const filesToProcess = compilationTargets.slice(); //clone\n\n    const required = [];\n\n    while (filesToProcess.length > 0) {\n      debug(\"filesToProcess: %O\", filesToProcess);\n      const file = filesToProcess.shift();\n      debug(\"file: %s\", file);\n\n      if (resolved[file]) {\n        required.push(file);\n\n        for (const importPath of resolved[file].imports) {\n          debug(\"importPath: %s\", importPath);\n\n          if (!required.includes(importPath)) {\n            //don't go into a loop!\n            filesToProcess.push(importPath);\n          }\n        }\n      }\n    }\n\n    debug(\"required: %O\", required); // Generate dictionary of all required sources, including external packages\n\n    for (const file of required) {\n      if (shouldIncludePath(file)) {\n        allSources[file] = resolved[file].body;\n      }\n    }\n\n    return {\n      allSources,\n      compilationTargets\n    };\n  });\n}\n\nexports.requiredSources = requiredSources;\n\nfunction listsEqual(listA, listB) {\n  const a = listA.sort();\n  const b = listB.sort();\n  return JSON.stringify(a) === JSON.stringify(b);\n} //# sourceMappingURL=requiredSources.js.map","map":null,"metadata":{},"sourceType":"script"}