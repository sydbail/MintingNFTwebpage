{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport { encode, prepare } from '@ipld/dag-pb';\nimport { UnixFS } from 'ipfs-unixfs';\nimport Dir from './dir.js';\nimport persist from './utils/persist.js';\n\nclass DirFlat extends Dir {\n  constructor(props, options) {\n    super(props, options);\n    this._children = {};\n  }\n\n  put(name, value) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3.cid = undefined;\n      _this3.size = undefined;\n      _this3._children[name] = value;\n    })();\n  }\n\n  get(name) {\n    return Promise.resolve(this._children[name]);\n  }\n\n  childCount() {\n    return Object.keys(this._children).length;\n  }\n\n  directChildrenCount() {\n    return this.childCount();\n  }\n\n  onlyChild() {\n    return this._children[Object.keys(this._children)[0]];\n  }\n\n  eachChildSeries() {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const keys = Object.keys(_this._children);\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        yield {\n          key: key,\n          child: _this._children[key]\n        };\n      }\n    })();\n  }\n\n  flush(block) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const children = Object.keys(_this2._children);\n      const links = [];\n\n      for (let i = 0; i < children.length; i++) {\n        let child = _this2._children[children[i]];\n\n        if (child instanceof Dir) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n\n          var _iteratorError;\n\n          try {\n            for (var _iterator = _asyncIterator(child.flush(block)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n              const entry = _value;\n              child = entry;\n              yield child;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                yield _awaitAsyncGenerator(_iterator.return());\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        if (child.size != null && child.cid) {\n          links.push({\n            Name: children[i],\n            Tsize: child.size,\n            Hash: child.cid\n          });\n        }\n      }\n\n      const unixfs = new UnixFS({\n        type: 'directory',\n        mtime: _this2.mtime,\n        mode: _this2.mode\n      });\n      const node = {\n        Data: unixfs.marshal(),\n        Links: links\n      };\n      const buffer = encode(prepare(node));\n      const cid = yield _awaitAsyncGenerator(persist(buffer, block, _this2.options));\n      const size = buffer.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);\n      _this2.cid = cid;\n      _this2.size = size;\n      yield {\n        cid,\n        unixfs,\n        path: _this2.path,\n        size\n      };\n    })();\n  }\n\n}\n\nexport default DirFlat;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js"],"names":["encode","prepare","UnixFS","Dir","persist","DirFlat","constructor","props","options","_children","put","name","value","cid","undefined","size","get","Promise","resolve","childCount","Object","keys","length","directChildrenCount","onlyChild","eachChildSeries","i","key","child","flush","block","children","links","entry","push","Name","Tsize","Hash","unixfs","type","mtime","mode","node","Data","marshal","Links","buffer","reduce","acc","curr","path"],"mappings":"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","sourcesContent":["import {\n  encode,\n  prepare\n} from '@ipld/dag-pb';\nimport { UnixFS } from 'ipfs-unixfs';\nimport Dir from './dir.js';\nimport persist from './utils/persist.js';\nclass DirFlat extends Dir {\n  constructor(props, options) {\n    super(props, options);\n    this._children = {};\n  }\n  async put(name, value) {\n    this.cid = undefined;\n    this.size = undefined;\n    this._children[name] = value;\n  }\n  get(name) {\n    return Promise.resolve(this._children[name]);\n  }\n  childCount() {\n    return Object.keys(this._children).length;\n  }\n  directChildrenCount() {\n    return this.childCount();\n  }\n  onlyChild() {\n    return this._children[Object.keys(this._children)[0]];\n  }\n  async *eachChildSeries() {\n    const keys = Object.keys(this._children);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      yield {\n        key: key,\n        child: this._children[key]\n      };\n    }\n  }\n  async *flush(block) {\n    const children = Object.keys(this._children);\n    const links = [];\n    for (let i = 0; i < children.length; i++) {\n      let child = this._children[children[i]];\n      if (child instanceof Dir) {\n        for await (const entry of child.flush(block)) {\n          child = entry;\n          yield child;\n        }\n      }\n      if (child.size != null && child.cid) {\n        links.push({\n          Name: children[i],\n          Tsize: child.size,\n          Hash: child.cid\n        });\n      }\n    }\n    const unixfs = new UnixFS({\n      type: 'directory',\n      mtime: this.mtime,\n      mode: this.mode\n    });\n    const node = {\n      Data: unixfs.marshal(),\n      Links: links\n    };\n    const buffer = encode(prepare(node));\n    const cid = await persist(buffer, block, this.options);\n    const size = buffer.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);\n    this.cid = cid;\n    this.size = size;\n    yield {\n      cid,\n      unixfs,\n      path: this.path,\n      size\n    };\n  }\n}\nexport default DirFlat;"]},"metadata":{},"sourceType":"module"}