{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst {\n  PinTypes\n} = require('ipfs-repo');\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = ({\n  repo,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  function addAll(_x) {\n    return _addAll.apply(this, arguments);\n  }\n\n  function _addAll() {\n    _addAll = _wrapAsyncGenerator(function* (source, options = {}) {\n      /**\n       * @returns {AsyncIterable<CID>}\n       */\n      const pinAdd = /*#__PURE__*/function () {\n        var _ref = _wrapAsyncGenerator(function* () {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n\n          var _iteratorError;\n\n          try {\n            for (var _iterator = _asyncIterator(normaliseInput(source)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n              const {\n                path,\n                recursive,\n                metadata\n              } = _value;\n              const {\n                cid\n              } = yield _awaitAsyncGenerator(resolvePath(repo, codecs, path)); // verify that each hash can be pinned\n\n              const {\n                reason\n              } = yield _awaitAsyncGenerator(repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]));\n\n              if (reason === 'recursive' && !recursive) {\n                // only disallow trying to override recursive pins\n                throw new Error(`${cid} already pinned recursively`);\n              }\n\n              if (recursive) {\n                yield _awaitAsyncGenerator(repo.pins.pinRecursively(cid, {\n                  metadata\n                }));\n              } else {\n                yield _awaitAsyncGenerator(repo.pins.pinDirectly(cid, {\n                  metadata\n                }));\n              }\n\n              yield cid;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                yield _awaitAsyncGenerator(_iterator.return());\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        });\n\n        return function pinAdd() {\n          return _ref.apply(this, arguments);\n        };\n      }(); // When adding a file, we take a lock that gets released after pinning\n      // is complete, so don't take a second lock here\n\n\n      const lock = Boolean(options.lock);\n\n      if (!lock) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(pinAdd()), _awaitAsyncGenerator);\n        return;\n      }\n\n      const release = yield _awaitAsyncGenerator(repo.gcLock.readLock());\n\n      try {\n        yield* _asyncGeneratorDelegate(_asyncIterator(pinAdd()), _awaitAsyncGenerator);\n      } finally {\n        release();\n      }\n    });\n    return _addAll.apply(this, arguments);\n  }\n\n  return withTimeoutOption(addAll);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/components/pin/add-all.js"],"names":["resolvePath","require","withTimeoutOption","normaliseInput","PinTypes","module","exports","repo","codecs","addAll","source","options","pinAdd","path","recursive","metadata","cid","reason","pins","isPinnedWithType","direct","Error","pinRecursively","pinDirectly","lock","Boolean","release","gcLock","readLock"],"mappings":"AAAA;AACA;;;;;;;;;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAkBC,OAAO,CAAC,aAAD,CAA/B;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,yCAAD,CAAjC;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAqBF,OAAO,CAAC,0CAAD,CAAlC;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAeH,OAAO,CAAC,WAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAAsB;AACrC;AACF;AACA;AAHuC,WAIpBC,MAJoB;AAAA;AAAA;;AAAA;AAAA,kCAIrC,WAAyBC,MAAzB,EAAiCC,OAAO,GAAG,EAA3C,EAA+C;AAC7C;AACJ;AACA;AACI,YAAMC,MAAM;AAAA,uCAAG,aAAoB;AAAA;AAAA;;AAAA;;AAAA;AACjC,gDAAkDT,cAAc,CAACO,MAAD,CAAhE,gOAA0E;AAAA,oBAAzD;AAAEG,gBAAAA,IAAF;AAAQC,gBAAAA,SAAR;AAAmBC,gBAAAA;AAAnB,eAAyD;AACxE,oBAAM;AAAEC,gBAAAA;AAAF,6CAAgBhB,WAAW,CAACO,IAAD,EAAOC,MAAP,EAAeK,IAAf,CAA3B,CAAN,CADwE,CAGxE;;AACA,oBAAM;AAAEI,gBAAAA;AAAF,6CAAmBV,IAAI,CAACW,IAAL,CAAUC,gBAAV,CAA2BH,GAA3B,EAAgC,CAACZ,QAAQ,CAACU,SAAV,EAAqBV,QAAQ,CAACgB,MAA9B,CAAhC,CAAnB,CAAN;;AAEA,kBAAIH,MAAM,KAAK,WAAX,IAA0B,CAACH,SAA/B,EAA0C;AACxC;AACA,sBAAM,IAAIO,KAAJ,CAAW,GAAEL,GAAI,6BAAjB,CAAN;AACD;;AAED,kBAAIF,SAAJ,EAAe;AACb,2CAAMP,IAAI,CAACW,IAAL,CAAUI,cAAV,CAAyBN,GAAzB,EAA8B;AAAED,kBAAAA;AAAF,iBAA9B,CAAN;AACD,eAFD,MAEO;AACL,2CAAMR,IAAI,CAACW,IAAL,CAAUK,WAAV,CAAsBP,GAAtB,EAA2B;AAAED,kBAAAA;AAAF,iBAA3B,CAAN;AACD;;AAED,oBAAMC,GAAN;AACD;AAnBgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBlC,SApBW;;AAAA,wBAANJ,MAAM;AAAA;AAAA;AAAA,SAAZ,CAJ6C,CA0B7C;AACA;;;AACA,YAAMY,IAAI,GAAGC,OAAO,CAACd,OAAO,CAACa,IAAT,CAApB;;AAEA,UAAI,CAACA,IAAL,EAAW;AACT,sDAAQZ,MAAM,EAAd;AACA;AACD;;AAED,YAAMc,OAAO,8BAASnB,IAAI,CAACoB,MAAL,CAAYC,QAAZ,EAAT,CAAb;;AAEA,UAAI;AACF,sDAAQhB,MAAM,EAAd;AACD,OAFD,SAEU;AACRc,QAAAA,OAAO;AACR;AACF,KA9CoC;AAAA;AAAA;;AAgDrC,SAAOxB,iBAAiB,CAACO,MAAD,CAAxB;AACD,CAjDD","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { resolvePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { normaliseInput } = require('ipfs-core-utils/src/pins/normalise-input')\nconst { PinTypes } = require('ipfs-repo')\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ repo, codecs }) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function * () {\n      for await (const { path, recursive, metadata } of normaliseInput(source)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n\n        // verify that each hash can be pinned\n        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct])\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`)\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, { metadata })\n        } else {\n          await repo.pins.pinDirectly(cid, { metadata })\n        }\n\n        yield cid\n      }\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      yield * pinAdd()\n      return\n    }\n\n    const release = await repo.gcLock.readLock()\n\n    try {\n      yield * pinAdd()\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n"]},"metadata":{},"sourceType":"script"}