{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst errCode = require('err-code');\n\nconst filter = require('it-filter');\n\nconst map = require('it-map');\n\nconst take = require('it-take');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\n\n\nfunction storeAddresses(source, peerStore) {\n  return map(source, peer => {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    return peer;\n  });\n}\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\n\n\nfunction uniquePeers(source) {\n  /** @type Set<string> */\n  const seen = new Set();\n  return filter(source, peer => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false;\n    }\n\n    seen.add(peer.id.toString());\n    return true;\n  });\n}\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\n\n\nfunction requirePeers(_x) {\n  return _requirePeers.apply(this, arguments);\n}\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\n\n\nfunction _requirePeers() {\n  _requirePeers = _wrapAsyncGenerator(function* (source, min = 1) {\n    let seen = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const peer = _value;\n        seen++;\n        yield peer;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (seen < min) {\n      throw errCode(new Error('not found'), 'NOT_FOUND');\n    }\n  });\n  return _requirePeers.apply(this, arguments);\n}\n\nfunction maybeLimitSource(source, max) {\n  if (max) {\n    return take(source, max);\n  }\n\n  return source;\n}\n\nmodule.exports = {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p/src/content-routing/utils.js"],"names":["errCode","require","filter","map","take","storeAddresses","source","peerStore","peer","addressBook","add","id","multiaddrs","uniquePeers","seen","Set","has","toString","requirePeers","min","Error","maybeLimitSource","max","module","exports"],"mappings":"AAAA;;;;;;;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,SAAD,CAApB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,cAAT,CAAyBC,MAAzB,EAAiCC,SAAjC,EAA4C;AAC1C,SAAOJ,GAAG,CAACG,MAAD,EAAUE,IAAD,IAAU;AAC3B;AACAD,IAAAA,SAAS,CAACE,WAAV,CAAsBC,GAAtB,CAA0BF,IAAI,CAACG,EAA/B,EAAmCH,IAAI,CAACI,UAAxC;AAEA,WAAOJ,IAAP;AACD,GALS,CAAV;AAMD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASK,WAAT,CAAsBP,MAAtB,EAA8B;AAC5B;AACA,QAAMQ,IAAI,GAAG,IAAIC,GAAJ,EAAb;AAEA,SAAOb,MAAM,CAACI,MAAD,EAAUE,IAAD,IAAU;AAC9B;AACA,QAAIM,IAAI,CAACE,GAAL,CAASR,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT,CAAJ,EAAkC;AAChC,aAAO,KAAP;AACD;;AAEDH,IAAAA,IAAI,CAACJ,GAAL,CAASF,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT;AAEA,WAAO,IAAP;AACD,GATY,CAAb;AAUD;AAED;AACA;AACA;AACA;AACA;AACA;;;SACiBC,Y;;;AAcjB;AACA;AACA;AACA;AACA;AACA;AACA;;;;sCApBA,WAA+BZ,MAA/B,EAAuCa,GAAG,GAAG,CAA7C,EAAgD;AAC9C,QAAIL,IAAI,GAAG,CAAX;AAD8C;AAAA;;AAAA;;AAAA;AAG9C,0CAAyBR,MAAzB,gOAAiC;AAAA,cAAhBE,IAAgB;AAC/BM,QAAAA,IAAI;AAEJ,cAAMN,IAAN;AACD;AAP6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAS9C,QAAIM,IAAI,GAAGK,GAAX,EAAgB;AACd,YAAMnB,OAAO,CAAC,IAAIoB,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAAb;AACD;AACF,G;;;;AASD,SAASC,gBAAT,CAA2Bf,MAA3B,EAAmCgB,GAAnC,EAAwC;AACtC,MAAIA,GAAJ,EAAS;AACP,WAAOlB,IAAI,CAACE,MAAD,EAASgB,GAAT,CAAX;AACD;;AAED,SAAOhB,MAAP;AACD;;AAEDiB,MAAM,CAACC,OAAP,GAAiB;AACfnB,EAAAA,cADe;AAEfQ,EAAAA,WAFe;AAGfK,EAAAA,YAHe;AAIfG,EAAAA;AAJe,CAAjB","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst filter = require('it-filter')\nconst map = require('it-map')\nconst take = require('it-take')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\nfunction storeAddresses (source, peerStore) {\n  return map(source, (peer) => {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs)\n\n    return peer\n  })\n}\n\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\nfunction uniquePeers (source) {\n  /** @type Set<string> */\n  const seen = new Set()\n\n  return filter(source, (peer) => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false\n    }\n\n    seen.add(peer.id.toString())\n\n    return true\n  })\n}\n\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\nasync function * requirePeers (source, min = 1) {\n  let seen = 0\n\n  for await (const peer of source) {\n    seen++\n\n    yield peer\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND')\n  }\n}\n\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\nfunction maybeLimitSource (source, max) {\n  if (max) {\n    return take(source, max)\n  }\n\n  return source\n}\n\nmodule.exports = {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n}\n"]},"metadata":{},"sourceType":"script"}