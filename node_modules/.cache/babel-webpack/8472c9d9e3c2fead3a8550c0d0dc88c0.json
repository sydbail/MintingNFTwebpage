{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction noop() {}\n\nexport function create() {\n  const chunkQueue = [];\n  let drainer = null;\n  let drainerResolver = noop;\n  let ended = false;\n  let outWait = null;\n  let outWaitResolver = noop;\n\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise(resolve => {\n        drainerResolver = () => {\n          drainer = null;\n          drainerResolver = noop;\n          resolve();\n        };\n      });\n    }\n\n    return drainer;\n  };\n\n  const writer = {\n    write(chunk) {\n      chunkQueue.push(chunk);\n      const drainer = makeDrainer();\n      outWaitResolver();\n      return drainer;\n    },\n\n    end() {\n      return _asyncToGenerator(function* () {\n        ended = true;\n        const drainer = makeDrainer();\n        outWaitResolver();\n        return drainer;\n      })();\n    }\n\n  };\n  const iterator = {\n    next() {\n      return _asyncToGenerator(function* () {\n        const chunk = chunkQueue.shift();\n\n        if (chunk) {\n          if (chunkQueue.length === 0) {\n            drainerResolver();\n          }\n\n          return {\n            done: false,\n            value: chunk\n          };\n        }\n\n        if (ended) {\n          drainerResolver();\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n\n        if (!outWait) {\n          outWait = new Promise(resolve => {\n            outWaitResolver = () => {\n              outWait = null;\n              outWaitResolver = noop;\n              return resolve(iterator.next());\n            };\n          });\n        }\n\n        return outWait;\n      })();\n    }\n\n  };\n  return {\n    writer,\n    iterator\n  };\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/@ipld/car/esm/lib/iterator-channel.js"],"names":["noop","create","chunkQueue","drainer","drainerResolver","ended","outWait","outWaitResolver","makeDrainer","Promise","resolve","writer","write","chunk","push","end","iterator","next","shift","length","done","value","undefined"],"mappings":";;AAAA,SAASA,IAAT,GAAgB,CACf;;AACD,OAAO,SAASC,MAAT,GAAkB;AACvB,QAAMC,UAAU,GAAG,EAAnB;AACA,MAAIC,OAAO,GAAG,IAAd;AACA,MAAIC,eAAe,GAAGJ,IAAtB;AACA,MAAIK,KAAK,GAAG,KAAZ;AACA,MAAIC,OAAO,GAAG,IAAd;AACA,MAAIC,eAAe,GAAGP,IAAtB;;AACA,QAAMQ,WAAW,GAAG,MAAM;AACxB,QAAI,CAACL,OAAL,EAAc;AACZA,MAAAA,OAAO,GAAG,IAAIM,OAAJ,CAAYC,OAAO,IAAI;AAC/BN,QAAAA,eAAe,GAAG,MAAM;AACtBD,UAAAA,OAAO,GAAG,IAAV;AACAC,UAAAA,eAAe,GAAGJ,IAAlB;AACAU,UAAAA,OAAO;AACR,SAJD;AAKD,OANS,CAAV;AAOD;;AACD,WAAOP,OAAP;AACD,GAXD;;AAYA,QAAMQ,MAAM,GAAG;AACbC,IAAAA,KAAK,CAACC,KAAD,EAAQ;AACXX,MAAAA,UAAU,CAACY,IAAX,CAAgBD,KAAhB;AACA,YAAMV,OAAO,GAAGK,WAAW,EAA3B;AACAD,MAAAA,eAAe;AACf,aAAOJ,OAAP;AACD,KANY;;AAOPY,IAAAA,GAAN,GAAY;AAAA;AACVV,QAAAA,KAAK,GAAG,IAAR;AACA,cAAMF,OAAO,GAAGK,WAAW,EAA3B;AACAD,QAAAA,eAAe;AACf,eAAOJ,OAAP;AAJU;AAKX;;AAZY,GAAf;AAcA,QAAMa,QAAQ,GAAG;AACTC,IAAAA,IAAN,GAAa;AAAA;AACX,cAAMJ,KAAK,GAAGX,UAAU,CAACgB,KAAX,EAAd;;AACA,YAAIL,KAAJ,EAAW;AACT,cAAIX,UAAU,CAACiB,MAAX,KAAsB,CAA1B,EAA6B;AAC3Bf,YAAAA,eAAe;AAChB;;AACD,iBAAO;AACLgB,YAAAA,IAAI,EAAE,KADD;AAELC,YAAAA,KAAK,EAAER;AAFF,WAAP;AAID;;AACD,YAAIR,KAAJ,EAAW;AACTD,UAAAA,eAAe;AACf,iBAAO;AACLgB,YAAAA,IAAI,EAAE,IADD;AAELC,YAAAA,KAAK,EAAEC;AAFF,WAAP;AAID;;AACD,YAAI,CAAChB,OAAL,EAAc;AACZA,UAAAA,OAAO,GAAG,IAAIG,OAAJ,CAAYC,OAAO,IAAI;AAC/BH,YAAAA,eAAe,GAAG,MAAM;AACtBD,cAAAA,OAAO,GAAG,IAAV;AACAC,cAAAA,eAAe,GAAGP,IAAlB;AACA,qBAAOU,OAAO,CAACM,QAAQ,CAACC,IAAT,EAAD,CAAd;AACD,aAJD;AAKD,WANS,CAAV;AAOD;;AACD,eAAOX,OAAP;AA3BW;AA4BZ;;AA7Bc,GAAjB;AA+BA,SAAO;AACLK,IAAAA,MADK;AAELK,IAAAA;AAFK,GAAP;AAID","sourcesContent":["function noop() {\n}\nexport function create() {\n  const chunkQueue = [];\n  let drainer = null;\n  let drainerResolver = noop;\n  let ended = false;\n  let outWait = null;\n  let outWaitResolver = noop;\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise(resolve => {\n        drainerResolver = () => {\n          drainer = null;\n          drainerResolver = noop;\n          resolve();\n        };\n      });\n    }\n    return drainer;\n  };\n  const writer = {\n    write(chunk) {\n      chunkQueue.push(chunk);\n      const drainer = makeDrainer();\n      outWaitResolver();\n      return drainer;\n    },\n    async end() {\n      ended = true;\n      const drainer = makeDrainer();\n      outWaitResolver();\n      return drainer;\n    }\n  };\n  const iterator = {\n    async next() {\n      const chunk = chunkQueue.shift();\n      if (chunk) {\n        if (chunkQueue.length === 0) {\n          drainerResolver();\n        }\n        return {\n          done: false,\n          value: chunk\n        };\n      }\n      if (ended) {\n        drainerResolver();\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n      if (!outWait) {\n        outWait = new Promise(resolve => {\n          outWaitResolver = () => {\n            outWait = null;\n            outWaitResolver = noop;\n            return resolve(iterator.next());\n          };\n        });\n      }\n      return outWait;\n    }\n  };\n  return {\n    writer,\n    iterator\n  };\n}"]},"metadata":{},"sourceType":"module"}