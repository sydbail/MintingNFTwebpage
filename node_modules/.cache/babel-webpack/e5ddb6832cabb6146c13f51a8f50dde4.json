{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncGeneratorDelegate from \"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\n\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n\n  const cid = CID.asCID(path);\n\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\nexport function walkPath(_x, _x2) {\n  return _walkPath.apply(this, arguments);\n}\n\nfunction _walkPath() {\n  _walkPath = _wrapAsyncGenerator(function* (path, blockstore, options = {}) {\n    let {\n      cid,\n      toResolve\n    } = cidAndRest(path);\n    let name = cid.toString();\n    let entryPath = name;\n    const startingDepth = toResolve.length;\n\n    while (true) {\n      const result = yield _awaitAsyncGenerator(resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options));\n\n      if (!result.entry && !result.next) {\n        throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n      }\n\n      if (result.entry) {\n        yield result.entry;\n      }\n\n      if (!result.next) {\n        return;\n      }\n\n      toResolve = result.next.toResolve;\n      cid = result.next.cid;\n      name = result.next.name;\n      entryPath = result.next.path;\n    }\n  });\n  return _walkPath.apply(this, arguments);\n}\n\nexport function exporter(_x7, _x8) {\n  return _exporter.apply(this, arguments);\n}\n\nfunction _exporter() {\n  _exporter = _asyncToGenerator(function* (path, blockstore, options = {}) {\n    const result = yield last(walkPath(path, blockstore, options));\n\n    if (!result) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    return result;\n  });\n  return _exporter.apply(this, arguments);\n}\n\nexport function recursive(_x3, _x4) {\n  return _recursive.apply(this, arguments);\n}\n\nfunction _recursive() {\n  _recursive = _wrapAsyncGenerator(function* (path, blockstore, options = {}) {\n    const node = yield _awaitAsyncGenerator(exporter(path, blockstore, options));\n\n    if (!node) {\n      return;\n    }\n\n    yield node;\n\n    if (node.type === 'directory') {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(recurse(node, options)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const child = _value;\n          yield child;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    function recurse(_x5, _x6) {\n      return _recurse.apply(this, arguments);\n    }\n\n    function _recurse() {\n      _recurse = _wrapAsyncGenerator(function* (node, options) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n\n        var _iteratorError2;\n\n        try {\n          for (var _iterator2 = _asyncIterator(node.content(options)), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n            const file = _value2;\n            yield file;\n\n            if (file instanceof Uint8Array) {\n              continue;\n            }\n\n            if (file.type === 'directory') {\n              yield* _asyncGeneratorDelegate(_asyncIterator(recurse(file, options)), _awaitAsyncGenerator);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              yield _awaitAsyncGenerator(_iterator2.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      });\n      return _recurse.apply(this, arguments);\n    }\n  });\n  return _recursive.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-unixfs-exporter/esm/src/index.js"],"names":["errCode","CID","resolve","last","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Uint8Array","cid","decode","toResolve","asCID","indexOf","substring","output","parse","slice","Error","walkPath","blockstore","options","name","toString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","type","recurse","child","content","file"],"mappings":"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","sourcesContent":["import errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid = CID.asCID(path);\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode(new Error(`Unknown path type ${ path }`), 'ERR_BAD_PATH');\n};\nexport async function* walkPath(path, blockstore, options = {}) {\n  let {cid, toResolve} = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n    }\n    if (result.entry) {\n      yield result.entry;\n    }\n    if (!result.next) {\n      return;\n    }\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\nexport async function exporter(path, blockstore, options = {}) {\n  const result = await last(walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\nexport async function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n  if (!node) {\n    return;\n  }\n  yield node;\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}