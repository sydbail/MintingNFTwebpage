{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst errCode = require('err-code');\n\nconst {\n  messages,\n  codes\n} = require('../errors');\n\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n} = require('./utils');\n\nconst merge = require('it-merge');\n\nconst {\n  pipe\n} = require('it-pipe');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\n\nclass ContentRouting {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  constructor(libp2p) {\n    this.libp2p = libp2p;\n    /** @type {ContentRoutingModule[]} */\n\n    this.routers = libp2p._modules.contentRouting || [];\n    this.dht = libp2p._dht; // If we have the dht, add it to the available content routers\n\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(this.dht);\n    }\n  }\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  findProviders(key, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      if (!_this.routers.length) {\n        throw errCode(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      yield* _asyncGeneratorDelegate(_asyncIterator(pipe(merge(..._this.routers.map(router => router.findProviders(key, options))), source => storeAddresses(source, _this.libp2p.peerStore), source => uniquePeers(source), source => maybeLimitSource(source, options.maxNumProviders), source => requirePeers(source))), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @returns {Promise<void>}\n   */\n\n\n  provide(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      yield Promise.all(_this2.routers.map(router => router.provide(key)));\n    })();\n  }\n  /**\n   * Store the given key/value pair in the DHT.\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {Object} [options] - put options\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n   * @returns {Promise<void>}\n   */\n\n\n  put(key, value, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    return this.dht.put(key, value, options);\n  }\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   *\n   * @param {Uint8Array} key\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData>}\n   */\n\n\n  get(key, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    return this.dht.get(key, options);\n  }\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {number} nVals\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData[]>}\n   */\n\n\n  getMany(key, nVals, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (!_this3.libp2p.isStarted() || !_this3.dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return _this3.dht.getMany(key, nVals, options);\n    })();\n  }\n\n}\n\nmodule.exports = ContentRouting;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p/src/content-routing/index.js"],"names":["errCode","require","messages","codes","storeAddresses","uniquePeers","requirePeers","maybeLimitSource","merge","pipe","ContentRouting","constructor","libp2p","routers","_modules","contentRouting","dht","_dht","_config","enabled","push","findProviders","key","options","length","Error","map","router","source","peerStore","maxNumProviders","provide","Promise","all","put","value","isStarted","NOT_STARTED_YET","DHT_NOT_STARTED","get","getMany","nVals","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { messages, codes } = require('../errors')\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n} = require('./utils')\n\nconst merge = require('it-merge')\nconst { pipe } = require('it-pipe')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\nclass ContentRouting {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  constructor (libp2p) {\n    this.libp2p = libp2p\n    /** @type {ContentRoutingModule[]} */\n    this.routers = libp2p._modules.contentRouting || []\n    this.dht = libp2p._dht\n\n    // If we have the dht, add it to the available content routers\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(this.dht)\n    }\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * findProviders (key, options = {}) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    yield * pipe(\n      merge(\n        ...this.routers.map(router => router.findProviders(key, options))\n      ),\n      (source) => storeAddresses(source, this.libp2p.peerStore),\n      (source) => uniquePeers(source),\n      (source) => maybeLimitSource(source, options.maxNumProviders),\n      (source) => requirePeers(source)\n    )\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    await Promise.all(this.routers.map((router) => router.provide(key)))\n  }\n\n  /**\n   * Store the given key/value pair in the DHT.\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {Object} [options] - put options\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n   * @returns {Promise<void>}\n   */\n  put (key, value, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.put(key, value, options)\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   *\n   * @param {Uint8Array} key\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData>}\n   */\n  get (key, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.get(key, options)\n  }\n\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {number} nVals\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData[]>}\n   */\n  async getMany (key, nVals, options) { // eslint-disable-line require-await\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.getMany(key, nVals, options)\n  }\n}\n\nmodule.exports = ContentRouting\n"]},"metadata":{},"sourceType":"script"}