{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst OS = require(\"os\");\n\nconst debug = require(\"debug\")(\"debug-utils\");\n\nconst util = require(\"util\");\n\nconst Codec = require(\"@truffle/codec\");\n\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\n\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\n\nhljsDefineSolidity(chromafi.hljs);\n\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\nconst commandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  \"p\": \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  \"l\": \"print additional source context\",\n  \"h\": \"print this help\",\n  \"v\": \"print variables and values\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  \"b\": \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  \"B\": \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  \"c\": \"continue until breakpoint\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load new transaction\",\n  \"T\": \"unload transaction\",\n  \"s\": \"print stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources except via `;`\",\n  \"y\": \"(if at end) reset & continue to final error\",\n  \"Y\": \"reset & continue to previous error\"\n};\nconst shortCommandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction\",\n  \"p\": \"print state\",\n  \"l\": \"print context\",\n  \"h\": \"print help\",\n  \"v\": \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  \"b\": \"add breakpoint\",\n  \"B\": \"remove breakpoint\",\n  \"c\": \"continue\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load\",\n  \"T\": \"unload\",\n  \"s\": \"stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources\",\n  \"y\": \"reset & go to final error\",\n  \"Y\": \"reset & go to previous error\"\n};\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\nconst DEFAULT_TAB_WIDTH = 8;\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  \"base\": chalk,\n  \"lineNumbers\": chalk,\n  \"trailingSpace\": chalk,\n\n  /* classes hljs-solidity actually uses */\n  \"keyword\": truffleColors.mint,\n  \"number\": truffleColors.red,\n  \"string\": truffleColors.green,\n  \"params\": truffleColors.pink,\n  \"builtIn\": truffleColors.watermelon,\n  \"built_in\": truffleColors.watermelon,\n  //just to be sure\n  \"literal\": truffleColors.watermelon,\n  \"function\": truffleColors.orange,\n  \"title\": truffleColors.orange,\n  \"class\": truffleColors.orange,\n  \"comment\": truffleColors.comment,\n  \"doctag\": truffleColors.comment,\n  \"operator\": truffleColors.blue,\n  \"punctuation\": truffleColors.purple,\n\n  /* classes it might soon use! */\n  \"meta\": truffleColors.pink,\n  \"metaString\": truffleColors.green,\n  \"meta-string\": truffleColors.green,\n  //similar\n\n  /* classes it doesn't currently use but notionally could */\n  \"type\": truffleColors.orange,\n  \"symbol\": truffleColors.orange,\n  \"metaKeyword\": truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint,\n  //again, to be sure\n  \"property\": chalk,\n  //not putting any highlighting here for now\n\n  /* classes that don't make sense for Solidity */\n  \"regexp\": chalk,\n  //solidity does not have regexps\n  \"subst\": chalk,\n  //or string interpolation\n  \"name\": chalk,\n  //or s-expressions\n  \"builtInName\": chalk,\n  //or s-expressions, again\n  \"builtin-name\": chalk,\n  //just to be sure\n\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  \"section\": chalk,\n  \"tag\": chalk,\n  \"attr\": chalk,\n  \"attribute\": chalk,\n  \"variable\": chalk,\n  \"bullet\": chalk,\n  \"code\": chalk,\n  \"emphasis\": chalk,\n  \"strong\": chalk,\n  \"formula\": chalk,\n  \"link\": chalk,\n  \"quote\": chalk,\n  \"selectorAttr\": chalk,\n  //lotta redundancy follows\n  \"selector-attr\": chalk,\n  \"selectorClass\": chalk,\n  \"selector-class\": chalk,\n  \"selectorId\": chalk,\n  \"selector-id\": chalk,\n  \"selectorPseudo\": chalk,\n  \"selector-pseudo\": chalk,\n  \"selectorTag\": chalk,\n  \"selector-tag\": chalk,\n  \"templateTag\": chalk,\n  \"template-tag\": chalk,\n  \"templateVariable\": chalk,\n  \"template-variable\": chalk,\n  \"addition\": chalk,\n  \"deletion\": chalk\n};\nvar DebugUtils = {\n  truffleColors,\n  //make these externally available\n  //panicCode may be either a number or a BN\n  panicString: function (panicCode, verbose = false) {\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n\n    return verbose ? verbosePanicTable[panicCode] || verboseUnknownString : panicTable[panicCode] || unknownString;\n  },\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    } //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n\n\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    const lowestInternalIndex = Math.min(...compilation.contracts.map(contract => {\n      //find first defined index\n      let lowestConstructor = (contract.generatedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestConstructor === -1) {\n        lowestConstructor = Infinity;\n      }\n\n      let lowestDeployed = (contract.deployedGeneratedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestDeployed === -1) {\n        lowestDeployed = Infinity;\n      }\n\n      return Math.min(lowestConstructor, lowestDeployed);\n    }));\n\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    } //check #4: are there any AST ID collisions?\n\n\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occured twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    }; //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n\n\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(source => !source || source.language !== \"Solidity\" || allIDsUnseenSoFar(source.ast));\n  },\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n  formatCommandDescription: function (commandId) {\n    return truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId];\n  },\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined ? `debug(${network}:${txHash.substring(0, 10)}...)> ` : `debug(${network})> `;\n  },\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(`${chalk.bold(\"Warning:\")} The source code for one or more contracts could not be found.`);\n    }\n\n    return lines.join(OS.EOL);\n  },\n  formatHelp: function (lastCommand = \"n\") {\n    var prefix = [\"Commands:\", truffleColors.mint(\"(enter)\") + \" last command entered (\" + shortCommandReference[lastCommand] + \")\"];\n    var commandSections = [[\"o\", \"i\", \"u\", \"n\"], [\"c\", \"Y\"], [\"y\"], [\";\"], [\"g\", \"G\"], [\"p\"], [\"l\", \"s\", \"h\"], [\"q\", \"r\", \"t\", \"T\"], [\"b\"], [\"B\"], [\"+\", \"-\"], [\"?\"], [\"v\", \":\"]].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n    var suffix = [\"\"];\n    var lines = prefix.concat(commandSections).concat(suffix);\n    return lines.join(OS.EOL);\n  },\n  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n\n    return line;\n  },\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n    return prefix + line;\n  },\n  formatLinePointer: function (line, startCol, endCol, padding, tabLength = DEFAULT_TAB_WIDTH) {\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n      let additional;\n\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (source, range, uncolorizedSource, contextBefore = 2, contextAfter = 0) {\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n    //note: beforeLines now includes the line itself\n\n    var beforeLines = source.slice(startIndex, range.start.line + 1).map((line, index) => {\n      let number = startIndex + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var afterLines = source.slice(range.start.line + 1, endIndex + 1).map((line, index) => {\n      let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var pointerStart = range.start.column;\n    var pointerEnd;\n    let uncolorizedLine = uncolorizedSource[range.start.line]; // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat([DebugUtils.formatLinePointer( //the line-pointer formatter doesn't work right with colorized\n    //lines, so we pass in the uncolored version\n    uncolorizedLine, pointerStart, pointerEnd, prefixLength)], afterLines);\n    return allLines.join(OS.EOL);\n  },\n  formatBreakpointLocation: function (breakpoint, here, currentSourceId, sourceNames) {\n    let baseMessage;\n\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here ? `this point in line ${breakpoint.line + 1}` : `a point in line ${breakpoint.line + 1}`; //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n  formatInstruction: function (traceIndex, traceLength, instruction) {\n    return \"(\" + traceIndex + \"/\" + traceLength + \") \" + truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"));\n  },\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n\n    return \"  PC = \" + pc.toString() + \" = 0x\" + hex;\n  },\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(2, ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n    let formatted = slots.map((slot, index) => {\n      if (index === 0 || !Codec.Conversion.toBN(slot).eq(Codec.Conversion.toBN(slots[index - 1]).addn(1))) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n\n    for (let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE; wordIndex < calldata.length; wordIndex += Codec.Evm.Utils.WORD_SIZE) {\n      words.push(calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE));\n    }\n\n    let maxWordIndex = (words.length - 1) * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n\n    let formattedSelector;\n\n    if (selector.length > 0) {\n      formattedSelector = \"Calldata:\\n\" + `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` + truffleColors.pink(Codec.Conversion.toHexString(selector).slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \"));\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word).slice(2).padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n    formatted.unshift(formattedSelector);\n    return formatted.join(OS.EOL);\n  },\n  formatValue: function (value, indent = 0, nativized = false) {\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized ? value : new Codec.Format.Utils.Inspect.ResultInspector(value);\n    return util.inspect(valueToInspect, inspectOptions).split(/\\r?\\n/g).map((line, i) => {\n      // don't indent first line\n      const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n      return padding + line;\n    }).join(OS.EOL);\n  },\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding, indent = 0) {\n    const name = decoding.definedIn ? `${decoding.definedIn.typeName}.${decoding.abi.name}` : decoding.abi.name;\n\n    if (decoding.arguments.length === 0) {\n      return `${name}()`;\n    }\n\n    const prefix = `${name}(`;\n    const formattedValues = decoding.arguments.map(({\n      name,\n      value\n    }) => {\n      const argumentPrefix = name ? `${name}: ` : \"\";\n      const typeString = ` (type: ${Codec.Format.Types.typeStringWithoutLocation(value.type)})`;\n      return (DebugUtils.formatValue(value, argumentPrefix.length) + typeString + \",\").split(/\\r?\\n/g).map(line => \" \".repeat(indent) + line).join(OS.EOL);\n    });\n    return [prefix, ...formattedValues, ')'].join(OS.EOL);\n  },\n  formatStacktrace: function (stacktrace, indent = 2) {\n    //get message or panic code from stacktrace\n    const {\n      message,\n      panic,\n      custom\n    } = stacktrace[0]; //we want to print inner to outer, so first, let's\n    //reverse\n\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n\n    let lines = stacktrace.map(({\n      functionName,\n      contractName,\n      address,\n      location,\n      type\n    }) => {\n      let name;\n\n      if (contractName && functionName) {\n        name = `${contractName}.${functionName}`;\n      } else if (contractName) {\n        name = contractName;\n      } else if (functionName) {\n        name = functionName;\n      } else {\n        name = \"unknown function\";\n      }\n\n      let locationString;\n\n      if (location) {\n        let {\n          source: {\n            sourcePath\n          },\n          sourceRange: {\n            lines: {\n              start: {\n                line,\n                column\n              }\n            }\n          }\n        } = location;\n        locationString = sourcePath ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n        : \"unknown location\";\n      } else {\n        locationString = \"unknown location\";\n      }\n\n      let addressString = type === \"external\" ? address !== undefined ? ` [address ${address}]` : \" [unknown address]\" : \"\";\n      return `at ${name}${addressString} (${locationString})`;\n    });\n    let status = stacktrace[0].status;\n\n    if (status != undefined) {\n      let statusLine;\n\n      if (message !== undefined) {\n        statusLine = status ? `Error: Improper return (caused message: ${message})` : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status ? `Panic: Improper return (caused ${DebugUtils.panicString(panic).toLowerCase()} (code 0x${panic.toString(16)}))` : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(16)})`;\n      } else if (custom !== undefined) {\n        statusLine = status ? `Error: Improper return (caused custom error)` : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status ? \"Error: Improper return (may be an unexpected self-destruct)\" : \"Error: Revert or exceptional halt\";\n      }\n\n      lines.unshift(statusLine);\n    }\n\n    let indented = lines.map((line, index) => index === 0 ? line : \" \".repeat(indent) + line);\n    return indented.join(OS.EOL);\n  },\n  colorize: function (code, language = \"Solidity\") {\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false,\n      //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false //NOTE: you might think you should pass highlight: true,\n      //but you'd be wrong!  I don't understand this either\n\n    };\n\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n\n        return chromafi(code, options);\n\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n\n        return chromafi(code, options);\n\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign({}, ...Object.entries(variables).map(([variable, value]) => variable === \"this\" ? {\n      [replacement]: value\n    } : {\n      [variable]: value\n    }));\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: function () {\n    var _ref = _asyncToGenerator(function* (bugger) {\n      yield bugger.reset();\n      let sources = {};\n      const {\n        controller\n      } = bugger.selectors;\n\n      while (!bugger.view(controller.current.trace.finished)) {\n        const source = bugger.view(controller.current.location.source);\n        const {\n          compilationId,\n          id,\n          internal\n        } = source; //stepInto should skip internal sources, but there still might be\n        //one at the end\n\n        if (!internal && compilationId !== undefined && id !== undefined) {\n          sources[compilationId] = { ...sources[compilationId],\n            [id]: source\n          };\n        }\n\n        yield bugger.stepInto();\n      }\n\n      yield bugger.reset(); //flatten sources before returning\n\n      return [].concat(...Object.values(sources).map(Object.values));\n    });\n\n    return function getTransactionSourcesBeforeStarting(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()\n};\nmodule.exports = DebugUtils;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/@truffle/debug-utils/index.js"],"names":["OS","require","debug","util","Codec","BN","chromafi","hljsDefineSolidity","hljs","chalk","panicTable","verbosePanicTable","commandReference","shortCommandReference","truffleColors","mint","hex","orange","pink","purple","green","red","yellow","blue","comment","hsl","watermelon","periwinkle","DEFAULT_TAB_WIDTH","trufflePalette","DebugUtils","panicString","panicCode","verbose","unknownString","verboseUnknownString","isBN","toNumber","_","isUsableCompilation","compilation","unreliableSourceOrder","sources","includes","undefined","lowestInternalIndex","Math","min","contracts","map","contract","lowestConstructor","generatedSources","findIndex","x","Infinity","lowestDeployed","deployedGeneratedSources","length","astIds","Set","allIDsUnseenSoFar","node","Array","isArray","every","id","has","add","Object","values","source","language","ast","formatStartMessage","withTransaction","formatTransactionStartMessage","formatCommandDescription","commandId","formatPrompt","network","txHash","substring","formatAffectedInstances","instances","hasAllSource","lines","keys","address","instance","contractName","push","bold","join","EOL","formatHelp","lastCommand","prefix","commandSections","shortcuts","suffix","concat","tabsToSpaces","inputLine","tabLength","line","counter","i","remaining","repeat","formatLineNumberPrefix","number","cols","String","padStart","formatLinePointer","startCol","endCol","padding","output","pointedAt","additional","replace","formatRangeLines","range","uncolorizedSource","contextBefore","contextAfter","startIndex","max","start","endIndex","prefixLength","beforeLines","slice","index","afterLines","pointerStart","column","pointerEnd","uncolorizedLine","end","allLines","formatBreakpointLocation","breakpoint","here","currentSourceId","sourceNames","baseMessage","sourceId","sourceName","formatInstruction","traceIndex","traceLength","instruction","name","pushData","formatPC","pc","toString","formatStack","stack","formatted","item","unshift","formatMemory","memory","maxPrefixLength","Evm","Utils","WORD_SIZE","word","formatStorage","storage","slots","sort","slot","Conversion","toBN","eq","addn","formatCalldata","calldata","selector","SELECTOR_SIZE","words","wordIndex","maxWordIndex","formattedSelector","toHexString","data","padEnd","formatValue","value","indent","nativized","inspectOptions","colors","depth","maxArrayLength","breakLength","valueToInspect","Format","Inspect","ResultInspector","inspect","split","formatCustomError","decoding","definedIn","typeName","abi","arguments","formattedValues","argumentPrefix","typeString","Types","typeStringWithoutLocation","type","formatStacktrace","stacktrace","message","panic","custom","reverse","functionName","location","locationString","sourcePath","sourceRange","addressString","status","statusLine","toLowerCase","indented","colorize","code","options","lang","lineNumbers","stripIndent","codePad","lineEndPad","cleanThis","variables","replacement","assign","entries","variable","getTransactionSourcesBeforeStarting","bugger","reset","controller","selectors","view","current","trace","finished","compilationId","internal","stepInto","module","exports"],"mappings":"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","sourcesContent":["const OS = require(\"os\");\nconst debug = require(\"debug\")(\"debug-utils\");\nconst util = require(\"util\");\nconst Codec = require(\"@truffle/codec\");\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\nhljsDefineSolidity(chromafi.hljs);\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\n\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\n\nconst commandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  \"p\": \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  \"l\": \"print additional source context\",\n  \"h\": \"print this help\",\n  \"v\": \"print variables and values\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  \"b\": \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  \"B\": \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  \"c\": \"continue until breakpoint\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load new transaction\",\n  \"T\": \"unload transaction\",\n  \"s\": \"print stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources except via `;`\",\n  \"y\": \"(if at end) reset & continue to final error\",\n  \"Y\": \"reset & continue to previous error\"\n};\n\nconst shortCommandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction\",\n  \"p\": \"print state\",\n  \"l\": \"print context\",\n  \"h\": \"print help\",\n  \"v\": \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  \"b\": \"add breakpoint\",\n  \"B\": \"remove breakpoint\",\n  \"c\": \"continue\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load\",\n  \"T\": \"unload\",\n  \"s\": \"stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources\",\n  \"y\": \"reset & go to final error\",\n  \"Y\": \"reset & go to previous error\"\n};\n\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\n\nconst DEFAULT_TAB_WIDTH = 8;\n\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  \"base\": chalk,\n  \"lineNumbers\": chalk,\n  \"trailingSpace\": chalk,\n  /* classes hljs-solidity actually uses */\n  \"keyword\": truffleColors.mint,\n  \"number\": truffleColors.red,\n  \"string\": truffleColors.green,\n  \"params\": truffleColors.pink,\n  \"builtIn\": truffleColors.watermelon,\n  \"built_in\": truffleColors.watermelon, //just to be sure\n  \"literal\": truffleColors.watermelon,\n  \"function\": truffleColors.orange,\n  \"title\": truffleColors.orange,\n  \"class\": truffleColors.orange,\n  \"comment\": truffleColors.comment,\n  \"doctag\": truffleColors.comment,\n  \"operator\": truffleColors.blue,\n  \"punctuation\": truffleColors.purple,\n  /* classes it might soon use! */\n  \"meta\": truffleColors.pink,\n  \"metaString\": truffleColors.green,\n  \"meta-string\": truffleColors.green, //similar\n  /* classes it doesn't currently use but notionally could */\n  \"type\": truffleColors.orange,\n  \"symbol\": truffleColors.orange,\n  \"metaKeyword\": truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint, //again, to be sure\n  \"property\": chalk, //not putting any highlighting here for now\n  /* classes that don't make sense for Solidity */\n  \"regexp\": chalk, //solidity does not have regexps\n  \"subst\": chalk, //or string interpolation\n  \"name\": chalk, //or s-expressions\n  \"builtInName\": chalk, //or s-expressions, again\n  \"builtin-name\": chalk, //just to be sure\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  \"section\": chalk,\n  \"tag\": chalk,\n  \"attr\": chalk,\n  \"attribute\": chalk,\n  \"variable\": chalk,\n  \"bullet\": chalk,\n  \"code\": chalk,\n  \"emphasis\": chalk,\n  \"strong\": chalk,\n  \"formula\": chalk,\n  \"link\": chalk,\n  \"quote\": chalk,\n  \"selectorAttr\": chalk, //lotta redundancy follows\n  \"selector-attr\": chalk,\n  \"selectorClass\": chalk,\n  \"selector-class\": chalk,\n  \"selectorId\": chalk,\n  \"selector-id\": chalk,\n  \"selectorPseudo\": chalk,\n  \"selector-pseudo\": chalk,\n  \"selectorTag\": chalk,\n  \"selector-tag\": chalk,\n  \"templateTag\": chalk,\n  \"template-tag\": chalk,\n  \"templateVariable\": chalk,\n  \"template-variable\": chalk,\n  \"addition\": chalk,\n  \"deletion\": chalk\n};\n\nvar DebugUtils = {\n  truffleColors, //make these externally available\n\n  //panicCode may be either a number or a BN\n  panicString: function (panicCode, verbose = false) {\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n    return verbose\n      ? verbosePanicTable[panicCode] || verboseUnknownString\n      : panicTable[panicCode] || unknownString;\n  },\n\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    }\n\n    //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    const lowestInternalIndex = Math.min(\n      ...compilation.contracts.map(contract => {\n        //find first defined index\n        let lowestConstructor = (contract.generatedSources || []).findIndex(\n          x => x !== undefined\n        );\n        if (lowestConstructor === -1) {\n          lowestConstructor = Infinity;\n        }\n        let lowestDeployed = (\n          contract.deployedGeneratedSources || []\n        ).findIndex(x => x !== undefined);\n        if (lowestDeployed === -1) {\n          lowestDeployed = Infinity;\n        }\n        return Math.min(lowestConstructor, lowestDeployed);\n      })\n    );\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    }\n\n    //check #4: are there any AST ID collisions?\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occured twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    };\n\n    //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(source =>\n      !source || source.language !== \"Solidity\" || allIDsUnseenSoFar(source.ast)\n    );\n  },\n\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n\n  formatCommandDescription: function (commandId) {\n    return (\n      truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId]\n    );\n  },\n\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined\n      ? `debug(${network}:${txHash.substring(0, 10)}...)> `\n      : `debug(${network})> `;\n  },\n\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\n        `${chalk.bold(\n          \"Warning:\"\n        )} The source code for one or more contracts could not be found.`\n      );\n    }\n\n    return lines.join(OS.EOL);\n  },\n\n  formatHelp: function (lastCommand = \"n\") {\n    var prefix = [\n      \"Commands:\",\n      truffleColors.mint(\"(enter)\") +\n        \" last command entered (\" +\n        shortCommandReference[lastCommand] +\n        \")\"\n    ];\n\n    var commandSections = [\n      [\"o\", \"i\", \"u\", \"n\"],\n      [\"c\", \"Y\"],\n      [\"y\"],\n      [\";\"],\n      [\"g\", \"G\"],\n      [\"p\"],\n      [\"l\", \"s\", \"h\"],\n      [\"q\", \"r\", \"t\", \"T\"],\n      [\"b\"],\n      [\"B\"],\n      [\"+\", \"-\"],\n      [\"?\"],\n      [\"v\", \":\"]\n    ].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n\n    var suffix = [\"\"];\n\n    var lines = prefix.concat(commandSections).concat(suffix);\n\n    return lines.join(OS.EOL);\n  },\n\n  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n    return line;\n  },\n\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n\n    return prefix + line;\n  },\n\n  formatLinePointer: function (\n    line,\n    startCol,\n    endCol,\n    padding,\n    tabLength = DEFAULT_TAB_WIDTH\n  ) {\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n\n      let additional;\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (\n    source,\n    range,\n    uncolorizedSource,\n    contextBefore = 2,\n    contextAfter = 0\n  ) {\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n\n    //note: beforeLines now includes the line itself\n    var beforeLines = source\n      .slice(startIndex, range.start.line + 1)\n      .map((line, index) => {\n        let number = startIndex + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n    var afterLines = source\n      .slice(range.start.line + 1, endIndex + 1)\n      .map((line, index) => {\n        let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n\n    var pointerStart = range.start.column;\n    var pointerEnd;\n\n    let uncolorizedLine = uncolorizedSource[range.start.line];\n\n    // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat(\n      [\n        DebugUtils.formatLinePointer(\n          //the line-pointer formatter doesn't work right with colorized\n          //lines, so we pass in the uncolored version\n          uncolorizedLine,\n          pointerStart,\n          pointerEnd,\n          prefixLength\n        )\n      ],\n      afterLines\n    );\n\n    return allLines.join(OS.EOL);\n  },\n\n  formatBreakpointLocation: function (\n    breakpoint,\n    here,\n    currentSourceId,\n    sourceNames\n  ) {\n    let baseMessage;\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here\n        ? `this point in line ${breakpoint.line + 1}`\n        : `a point in line ${breakpoint.line + 1}`;\n      //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n\n  formatInstruction: function (traceIndex, traceLength, instruction) {\n    return (\n      \"(\" +\n      traceIndex +\n      \"/\" +\n      traceLength +\n      \") \" +\n      truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"))\n    );\n  },\n\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n    return \"  PC = \" + pc.toString() + \" = 0x\" + hex;\n  },\n\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(\n      2,\n      ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length\n    );\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE)\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n\n    let formatted = slots.map((slot, index) => {\n      if (\n        index === 0 ||\n        !Codec.Conversion.toBN(slot).eq(\n          Codec.Conversion.toBN(slots[index - 1]).addn(1)\n        )\n      ) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n    for (\n      let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE;\n      wordIndex < calldata.length;\n      wordIndex += Codec.Evm.Utils.WORD_SIZE\n    ) {\n      words.push(\n        calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE)\n      );\n    }\n    let maxWordIndex =\n      (words.length - 1) * Codec.Evm.Utils.WORD_SIZE +\n      Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n    let formattedSelector;\n    if (selector.length > 0) {\n      formattedSelector =\n        \"Calldata:\\n\" +\n        `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` +\n        truffleColors.pink(\n          Codec.Conversion.toHexString(selector)\n            .slice(2)\n            .padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \")\n        );\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (\n        index * Codec.Evm.Utils.WORD_SIZE +\n        Codec.Evm.Utils.SELECTOR_SIZE\n      )\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word)\n        .slice(2)\n        .padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n\n    formatted.unshift(formattedSelector);\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatValue: function (value, indent = 0, nativized = false) {\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized\n      ? value\n      : new Codec.Format.Utils.Inspect.ResultInspector(value);\n    return util\n      .inspect(valueToInspect, inspectOptions)\n      .split(/\\r?\\n/g)\n      .map((line, i) => {\n        // don't indent first line\n        const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n        return padding + line;\n      })\n      .join(OS.EOL);\n  },\n\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding, indent = 0) {\n    const name = decoding.definedIn\n      ? `${decoding.definedIn.typeName}.${decoding.abi.name}`\n      : decoding.abi.name;\n    if (decoding.arguments.length === 0) {\n      return `${name}()`;\n    }\n    const prefix = `${name}(`;\n    const formattedValues = decoding.arguments.map(\n      ({ name, value }) => {\n        const argumentPrefix = name\n          ? `${name}: `\n          : \"\";\n        const typeString = ` (type: ${Codec.Format.Types.typeStringWithoutLocation(\n          value.type\n        )})`;\n        return (DebugUtils.formatValue(value, argumentPrefix.length) + typeString + \",\")\n          .split(/\\r?\\n/g)\n          .map(line => \" \".repeat(indent) + line)\n          .join(OS.EOL);\n      }\n    );\n    return [prefix, ...formattedValues, ')'].join(OS.EOL);\n  },\n\n  formatStacktrace: function (stacktrace, indent = 2) {\n    //get message or panic code from stacktrace\n    const { message, panic, custom } = stacktrace[0];\n    //we want to print inner to outer, so first, let's\n    //reverse\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n    let lines = stacktrace.map(\n      ({ functionName, contractName, address, location, type }) => {\n        let name;\n        if (contractName && functionName) {\n          name = `${contractName}.${functionName}`;\n        } else if (contractName) {\n          name = contractName;\n        } else if (functionName) {\n          name = functionName;\n        } else {\n          name = \"unknown function\";\n        }\n        let locationString;\n        if (location) {\n          let {\n            source: { sourcePath },\n            sourceRange: {\n              lines: {\n                start: { line, column }\n              }\n            }\n          } = location;\n          locationString = sourcePath\n            ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n            : \"unknown location\";\n        } else {\n          locationString = \"unknown location\";\n        }\n        let addressString =\n          type === \"external\"\n            ? address !== undefined\n              ? ` [address ${address}]`\n              : \" [unknown address]\"\n            : \"\";\n        return `at ${name}${addressString} (${locationString})`;\n      }\n    );\n    let status = stacktrace[0].status;\n    if (status != undefined) {\n      let statusLine;\n      if (message !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused message: ${message})`\n          : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status\n          ? `Panic: Improper return (caused ${DebugUtils.panicString(\n              panic\n            ).toLowerCase()} (code 0x${panic.toString(16)}))`\n          : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(\n              16\n            )})`;\n      } else if (custom !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused custom error)`\n          : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status\n          ? \"Error: Improper return (may be an unexpected self-destruct)\"\n          : \"Error: Revert or exceptional halt\";\n      }\n      lines.unshift(statusLine);\n    }\n    let indented = lines.map((line, index) =>\n      index === 0 ? line : \" \".repeat(indent) + line\n    );\n    return indented.join(OS.EOL);\n  },\n\n  colorize: function (code, language = \"Solidity\") {\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false, //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n      //NOTE: you might think you should pass highlight: true,\n      //but you'd be wrong!  I don't understand this either\n    };\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n        return chromafi(code, options);\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n        return chromafi(code, options);\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign(\n      {},\n      ...Object.entries(variables).map(([variable, value]) =>\n        variable === \"this\" ? { [replacement]: value } : { [variable]: value }\n      )\n    );\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const { controller } = bugger.selectors;\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const { compilationId, id, internal } = source;\n      //stepInto should skip internal sources, but there still might be\n      //one at the end\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = {\n          ...sources[compilationId],\n          [id]: source\n        };\n      }\n      await bugger.stepInto();\n    }\n    await bugger.reset();\n    //flatten sources before returning\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\n\nmodule.exports = DebugUtils;\n"]},"metadata":{},"sourceType":"script"}