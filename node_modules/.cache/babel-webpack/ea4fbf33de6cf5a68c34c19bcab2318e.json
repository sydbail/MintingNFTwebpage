{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Block = require('multiformats/block');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  CarWriter\n} = require('@ipld/car/writer');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst log = require('debug')('ipfs:components:dag:import');\n\nconst raw = require('multiformats/codecs/raw');\n\nconst json = require('multiformats/codecs/json'); // blocks that we're OK with not inspecting for links\n\n/** @type {number[]} */\n\n\nconst NO_LINKS_CODECS = [raw.code, // raw\njson.code // JSON\n];\n/**\n * @typedef {import('../../types').Preload} Preload\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('@ipld/car/api').BlockWriter} BlockWriter\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {IPFSRepo} config.repo\n * @param {Preload} config.preload\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\n\nmodule.exports = ({\n  repo,\n  preload,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API[\"export\"]}\n   */\n  function dagExport(_x) {\n    return _dagExport.apply(this, arguments);\n  }\n\n  function _dagExport() {\n    _dagExport = _wrapAsyncGenerator(function* (root, options = {}) {\n      if (options.preload !== false) {\n        preload(root);\n      }\n\n      const cid = CID.asCID(root);\n\n      if (!cid) {\n        throw new Error(`Unexpected error converting CID type: ${root}`);\n      }\n\n      log(`Exporting ${cid} as car`);\n      const {\n        writer,\n        out\n      } = yield _awaitAsyncGenerator(CarWriter.create([cid])); // we need to write with one async channel and send the CarWriter output\n      // with another to the caller, but if the write causes an error we capture\n      // that and make sure it gets propagated\n\n      /** @type {Error|null} */\n\n      let err = null;\n\n      _asyncToGenerator(function* () {\n        try {\n          yield traverseWrite(repo, {\n            signal: options.signal,\n            timeout: options.timeout\n          }, cid, writer, codecs);\n          writer.close();\n        } catch (e) {\n          err = e;\n        }\n      })();\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(out), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const chunk = _value;\n\n          if (err) {\n            break;\n          }\n\n          yield chunk;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (err) {\n        throw err;\n      }\n    });\n    return _dagExport.apply(this, arguments);\n  }\n\n  return withTimeoutOption(dagExport);\n};\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {CID} cid\n * @param {BlockWriter} writer\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {Set<string>} seen\n * @returns {Promise<void>}\n */\n\n\nfunction traverseWrite(_x2, _x3, _x4, _x5, _x6) {\n  return _traverseWrite.apply(this, arguments);\n}\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {CID} cid\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @returns {Promise<{cid:CID, bytes:Uint8Array, links:CID[]}>}\n */\n\n\nfunction _traverseWrite() {\n  _traverseWrite = _asyncToGenerator(function* (repo, options, cid, writer, codecs, seen = new Set()) {\n    const b58Cid = cid.toString(base58btc);\n\n    if (seen.has(b58Cid)) {\n      return;\n    }\n\n    const block = yield getBlock(repo, options, cid, codecs);\n    log(`Adding block ${cid} to car`);\n    yield writer.put(block);\n    seen.add(b58Cid); // recursive traversal of all links\n\n    for (const link of block.links) {\n      yield traverseWrite(repo, options, link, writer, codecs, seen);\n    }\n  });\n  return _traverseWrite.apply(this, arguments);\n}\n\nfunction getBlock(_x7, _x8, _x9, _x10) {\n  return _getBlock.apply(this, arguments);\n}\n\nfunction _getBlock() {\n  _getBlock = _asyncToGenerator(function* (repo, options, cid, codecs) {\n    const bytes = yield repo.blocks.get(cid, options);\n    /** @type {CID[]} */\n\n    let links = [];\n    const codec = yield codecs.getCodec(cid.code);\n\n    if (codec) {\n      const block = Block.createUnsafe({\n        bytes,\n        cid,\n        codec\n      });\n      links = [...block.links()].map(l => l[1]);\n    } else if (!NO_LINKS_CODECS.includes(cid.code)) {\n      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`);\n    }\n\n    return {\n      cid,\n      bytes,\n      links\n    };\n  });\n  return _getBlock.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}