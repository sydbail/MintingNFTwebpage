{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst set = require('just-safe-set');\n\nconst getDefaultConfig = require('../runtime/config-nodejs.js');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst log = require('debug')('ipfs:core:config');\n/**\n * @typedef {import('ipfs-core-types/src/config').Config} Config\n *\n * @typedef {object} Transformer\n * @property {string} description\n * @property {(config: Config) => Config} transform\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = ({\n  repo\n}) => {\n  return {\n    getAll: withTimeoutOption(getAll),\n    get: withTimeoutOption(get),\n    set: withTimeoutOption(set),\n    replace: withTimeoutOption(replace),\n    profiles: {\n      apply: withTimeoutOption(applyProfile),\n      list: withTimeoutOption(listProfiles)\n    }\n  };\n  /**\n   * @type {import('ipfs-core-types/src/config').API[\"getAll\"]}\n   */\n\n  function getAll() {\n    return _getAll.apply(this, arguments);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/config').API[\"get\"]}\n   */\n\n\n  function _getAll() {\n    _getAll = _asyncToGenerator(function* (options = {}) {\n      // eslint-disable-line require-await\n      // @ts-ignore TODO: move config typedefs into ipfs-repo\n      return repo.config.getAll(options);\n    });\n    return _getAll.apply(this, arguments);\n  }\n\n  function get(_x, _x2) {\n    return _get.apply(this, arguments);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/config').API[\"set\"]}\n   */\n\n\n  function _get() {\n    _get = _asyncToGenerator(function* (key, options) {\n      // eslint-disable-line require-await\n      if (!key) {\n        return Promise.reject(new Error('key argument is required'));\n      } // @ts-ignore TODO: move config typedefs into ipfs-repo\n\n\n      return repo.config.get(key, options);\n    });\n    return _get.apply(this, arguments);\n  }\n\n  function set(_x3, _x4, _x5) {\n    return _set.apply(this, arguments);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/config').API[\"replace\"]}\n   */\n\n\n  function _set() {\n    _set = _asyncToGenerator(function* (key, value, options) {\n      // eslint-disable-line require-await\n      return repo.config.set(key, value, options);\n    });\n    return _set.apply(this, arguments);\n  }\n\n  function replace(_x6, _x7) {\n    return _replace.apply(this, arguments);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/config/profiles').API[\"apply\"]}\n   */\n\n\n  function _replace() {\n    _replace = _asyncToGenerator(function* (value, options) {\n      // eslint-disable-line require-await\n      return repo.config.replace(value, options);\n    });\n    return _replace.apply(this, arguments);\n  }\n\n  function applyProfile(_x8) {\n    return _applyProfile.apply(this, arguments);\n  }\n\n  function _applyProfile() {\n    _applyProfile = _asyncToGenerator(function* (profileName, options = {\n      dryRun: false\n    }) {\n      const {\n        dryRun\n      } = options;\n      const profile = profiles[profileName];\n\n      if (!profile) {\n        throw new Error(`No profile with name '${profileName}' exists`);\n      }\n\n      try {\n        const oldCfg = yield repo.config.getAll(options);\n        let newCfg = JSON.parse(JSON.stringify(oldCfg)); // clone\n\n        newCfg = profile.transform(newCfg);\n\n        if (!dryRun) {\n          yield repo.config.replace(newCfg, options);\n        } // Scrub private key from output\n        // @ts-ignore `oldCfg.Identity` maybe undefined\n\n\n        delete oldCfg.Identity.PrivKey;\n        delete newCfg.Identity.PrivKey; // @ts-ignore TODO: move config typedefs into ipfs-repo\n\n        return {\n          original: oldCfg,\n          updated: newCfg\n        };\n      } catch (err) {\n        log(err);\n        throw new Error(`Could not apply profile '${profileName}' to config: ${err.message}`);\n      }\n    });\n    return _applyProfile.apply(this, arguments);\n  }\n};\n/**\n * @type {import('ipfs-core-types/src/config/profiles').API[\"list\"]}\n */\n\n\nfunction listProfiles(_x9) {\n  return _listProfiles.apply(this, arguments);\n}\n/**\n * @type {Record<string, Transformer>}\n */\n\n\nfunction _listProfiles() {\n  _listProfiles = _asyncToGenerator(function* (_options) {\n    // eslint-disable-line require-await\n    return Object.keys(profiles).map(name => ({\n      name,\n      description: profiles[name].description\n    }));\n  });\n  return _listProfiles.apply(this, arguments);\n}\n\nconst profiles = {\n  server: {\n    description: 'Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.',\n    transform: config => {\n      set(config, 'Discovery.MDNS.Enabled', false);\n      set(config, 'Discovery.webRTCStar.Enabled', false);\n      config.Swarm = { ...(config.Swarm || {}),\n        DisableNatPortMap: true\n      };\n      return config;\n    }\n  },\n  'local-discovery': {\n    description: 'Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.',\n    transform: config => {\n      set(config, 'Discovery.MDNS.Enabled', true);\n      set(config, 'Discovery.webRTCStar.Enabled', true);\n      set(config, 'Swarm', { ...(config.Swarm || {}),\n        DisableNatPortMap: false\n      });\n      return config;\n    }\n  },\n  test: {\n    description: 'Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won\\'t be able to talk to the rest of the network without manual bootstrap.',\n    transform: config => {\n      const defaultConfig = getDefaultConfig();\n      set(config, 'Addresses.API', defaultConfig.Addresses.API ? '/ip4/127.0.0.1/tcp/0' : '');\n      set(config, 'Addresses.Gateway', defaultConfig.Addresses.Gateway ? '/ip4/127.0.0.1/tcp/0' : '');\n      set(config, 'Addresses.Swarm', defaultConfig.Addresses.Swarm.length ? ['/ip4/127.0.0.1/tcp/0'] : []);\n      set(config, 'Addresses.Delegates', []);\n      set(config, 'Bootstrap', []);\n      set(config, 'Discovery.MDNS.Enabled', false);\n      set(config, 'Discovery.webRTCStar.Enabled', false);\n      set(config, 'Swarm', { ...(config.Swarm || {}),\n        DisableNatPortMap: true\n      });\n      return config;\n    }\n  },\n  'default-networking': {\n    description: 'Restores default network settings. Inverse profile of the `test` profile.',\n    transform: config => {\n      const defaultConfig = getDefaultConfig();\n      set(config, 'Addresses.API', defaultConfig.Addresses.API);\n      set(config, 'Addresses.Gateway', defaultConfig.Addresses.Gateway);\n      set(config, 'Addresses.Swarm', defaultConfig.Addresses.Swarm);\n      set(config, 'Addresses.Delegates', defaultConfig.Addresses.Delegates);\n      set(config, 'Bootstrap', defaultConfig.Bootstrap);\n      set(config, 'Discovery.MDNS.Enabled', defaultConfig.Discovery.MDNS.Enabled);\n      set(config, 'Discovery.webRTCStar.Enabled', defaultConfig.Discovery.webRTCStar.Enabled);\n      set(config, 'Swarm', { ...(config.Swarm || {}),\n        DisableNatPortMap: false\n      });\n      return config;\n    }\n  },\n  lowpower: {\n    description: 'Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.',\n    transform: config => {\n      const Swarm = config.Swarm || {};\n      const ConnMgr = Swarm.ConnMgr || {};\n      ConnMgr.LowWater = 20;\n      ConnMgr.HighWater = 40;\n      Swarm.ConnMgr = ConnMgr;\n      config.Swarm = Swarm;\n      return config;\n    }\n  },\n  'default-power': {\n    description: 'Inverse of \"lowpower\" profile.',\n    transform: config => {\n      const defaultConfig = getDefaultConfig();\n      config.Swarm = defaultConfig.Swarm;\n      return config;\n    }\n  }\n};\nmodule.exports.profiles = profiles;","map":null,"metadata":{},"sourceType":"script"}