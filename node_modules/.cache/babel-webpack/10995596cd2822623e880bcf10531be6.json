{"ast":null,"code":"'use strict';\n\nconst Entry = require('./entry');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n/**\n * @template T\n * @param {(v:T) => number} fn\n * @param {T[]} list\n * @returns {T[]}\n */\n\n\nconst sortBy = (fn, list) => {\n  return Array.prototype.slice.call(list, 0).sort((a, b) => {\n    const aa = fn(a);\n    const bb = fn(b);\n    return aa < bb ? -1 : aa > bb ? 1 : 0;\n  });\n};\n/**\n * @typedef {import('multiformats').CID} CID\n */\n\n\nlet Wantlist = /*#__PURE__*/(() => {\n  class Wantlist {\n    /**\n     *\n     * @param {import('../../stats')} [stats]\n     */\n    constructor(stats) {\n      /** @type {Map<string, Entry>} */\n      this.set = new Map();\n      this._stats = stats;\n    }\n\n    get length() {\n      return this.set.size;\n    }\n    /**\n     * @param {CID} cid\n     * @param {number} priority\n     * @param {import('../message/message').Message.Wantlist.WantType} wantType\n     */\n\n\n    add(cid, priority, wantType) {\n      // Have to import here to avoid circular reference\n      const Message = require('../message');\n\n      const cidStr = cid.toString(base58btc);\n      const entry = this.set.get(cidStr);\n\n      if (entry) {\n        entry.inc();\n        entry.priority = priority; // We can only overwrite want-have with want-block\n\n        if (entry.wantType === Message.WantType.Have && wantType === Message.WantType.Block) {\n          entry.wantType = wantType;\n        }\n      } else {\n        this.set.set(cidStr, new Entry(cid, priority, wantType));\n\n        if (this._stats) {\n          this._stats.push(null, 'wantListSize', 1);\n        }\n      }\n    }\n    /**\n     * @param {CID} cid\n     */\n\n\n    remove(cid) {\n      const cidStr = cid.toString(base58btc);\n      const entry = this.set.get(cidStr);\n\n      if (!entry) {\n        return;\n      }\n\n      entry.dec(); // only delete when no refs are held\n\n      if (entry.hasRefs()) {\n        return;\n      }\n\n      this.set.delete(cidStr);\n\n      if (this._stats) {\n        this._stats.push(null, 'wantListSize', -1);\n      }\n    }\n    /**\n     * @param {string} cidStr\n     */\n\n\n    removeForce(cidStr) {\n      if (this.set.has(cidStr)) {\n        this.set.delete(cidStr);\n      }\n    }\n    /**\n     * @param {(entry:Entry, key:string) => void} fn\n     */\n\n\n    forEach(fn) {\n      return this.set.forEach(fn);\n    }\n\n    entries() {\n      return this.set.entries();\n    }\n\n    sortedEntries() {\n      // TODO: Figure out if this is an actual bug.\n      // @ts-expect-error - Property 'key' does not exist on type 'WantListEntry'\n      return new Map(sortBy(o => o[1].key, Array.from(this.set.entries())));\n    }\n    /**\n     * @param {CID} cid\n     */\n\n\n    contains(cid) {\n      const cidStr = cid.toString(base58btc);\n      return this.set.has(cidStr);\n    }\n    /**\n     * @param {CID} cid\n     */\n\n\n    get(cid) {\n      const cidStr = cid.toString(base58btc);\n      return this.set.get(cidStr);\n    }\n\n  }\n\n  Wantlist.Entry = Entry;\n  return Wantlist;\n})();\nmodule.exports = Wantlist;","map":null,"metadata":{},"sourceType":"script"}