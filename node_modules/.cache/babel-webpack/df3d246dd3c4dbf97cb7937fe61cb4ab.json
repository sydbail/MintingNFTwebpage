{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst debug = require('debug');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst errcode = require('err-code');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst MulticodecTopology = require('../topology/multicodec-topology');\n\nconst {\n  codes\n} = require('./errors');\n\nconst {\n  RPC\n} = require('./message/rpc');\n\nconst PeerStreams = require('./peer-streams');\n\nconst {\n  SignaturePolicy\n} = require('./signature-policy');\n\nconst utils = require('./utils');\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign');\n/**\n * @typedef {any} Libp2p\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('bl')} BufferList\n * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('./signature-policy').SignaturePolicyType} SignaturePolicyType\n * @typedef {import('./message/rpc').IRPC} IRPC\n * @typedef {import('./message/rpc').RPC.SubOpts} RPCSubOpts\n * @typedef {import('./message/rpc').RPC.Message} RPCMessage\n */\n\n/**\n * @typedef {Object} InMessage\n * @property {string} [from]\n * @property {string} receivedFrom\n * @property {string[]} topicIDs\n * @property {Uint8Array} [seqno]\n * @property {Uint8Array} data\n * @property {Uint8Array} [signature]\n * @property {Uint8Array} [key]\n *\n * @typedef {Object} PubsubProperties\n * @property {string} debugName - log namespace\n * @property {Array<string>|string} multicodecs - protocol identificers to connect\n * @property {Libp2p} libp2p\n *\n * @typedef {Object} PubsubOptions\n * @property {SignaturePolicyType} [globalSignaturePolicy = SignaturePolicy.StrictSign] - defines how signatures should be handled\n * @property {boolean} [canRelayMessage = false] - if can relay messages not subscribed\n * @property {boolean} [emitSelf = false] - if publish should emit to self, if subscribed\n */\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n * and specifies the API that pubsub routers should have.\n */\n\n\nlet PubsubBaseProtocol = /*#__PURE__*/(() => {\n  class PubsubBaseProtocol extends EventEmitter {\n    /**\n     * @param {PubsubProperties & PubsubOptions} props\n     * @abstract\n     */\n    constructor({\n      debugName,\n      multicodecs,\n      libp2p,\n      globalSignaturePolicy = SignaturePolicy.StrictSign,\n      canRelayMessage = false,\n      emitSelf = false\n    }) {\n      if (typeof debugName !== 'string') {\n        throw new Error('a debugname `string` is required');\n      }\n\n      if (!multicodecs) {\n        throw new Error('multicodecs are required');\n      }\n\n      if (!libp2p) {\n        throw new Error('libp2p is required');\n      }\n\n      super();\n      this.log = Object.assign(debug(debugName), {\n        err: debug(`${debugName}:error`)\n      });\n      /**\n       * @type {Array<string>}\n       */\n\n      this.multicodecs = utils.ensureArray(multicodecs);\n      this._libp2p = libp2p;\n      this.registrar = libp2p.registrar;\n      /**\n       * @type {PeerId}\n       */\n\n      this.peerId = libp2p.peerId;\n      this.started = false;\n      /**\n       * Map of topics to which peers are subscribed to\n       *\n       * @type {Map<string, Set<string>>}\n       */\n\n      this.topics = new Map();\n      /**\n       * List of our subscriptions\n       *\n       * @type {Set<string>}\n       */\n\n      this.subscriptions = new Set();\n      /**\n       * Map of peer streams\n       *\n       * @type {Map<string, import('./peer-streams')>}\n       */\n\n      this.peers = new Map(); // validate signature policy\n\n      if (!SignaturePolicy[globalSignaturePolicy]) {\n        throw errcode(new Error('Invalid global signature policy'), codes.ERR_INVALID_SIGNATURE_POLICY);\n      }\n      /**\n       * The signature policy to follow by default\n       *\n       * @type {string}\n       */\n\n\n      this.globalSignaturePolicy = globalSignaturePolicy;\n      /**\n       * If router can relay received messages, even if not subscribed\n       *\n       * @type {boolean}\n       */\n\n      this.canRelayMessage = canRelayMessage;\n      /**\n       * if publish should emit to self, if subscribed\n       *\n       * @type {boolean}\n       */\n\n      this.emitSelf = emitSelf;\n      /**\n       * Topic validator function\n       *\n       * @typedef {function(string, InMessage): Promise<void>} validator\n       */\n\n      /**\n       * Topic validator map\n       *\n       * Keyed by topic\n       * Topic validators are functions with the following input:\n       *\n       * @type {Map<string, validator>}\n       */\n\n      this.topicValidators = new Map();\n      this._registrarId = undefined;\n      this._onIncomingStream = this._onIncomingStream.bind(this);\n      this._onPeerConnected = this._onPeerConnected.bind(this);\n      this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n    } // LIFECYCLE METHODS\n\n    /**\n     * Register the pubsub protocol onto the libp2p node.\n     *\n     * @returns {void}\n     */\n\n\n    start() {\n      if (this.started) {\n        return;\n      }\n\n      this.log('starting'); // Incoming streams\n      // Called after a peer dials us\n\n      this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n      // Topology callbacks called on connection manager changes\n\n      const topology = new MulticodecTopology({\n        multicodecs: this.multicodecs,\n        handlers: {\n          onConnect: this._onPeerConnected,\n          onDisconnect: this._onPeerDisconnected\n        }\n      });\n      this._registrarId = this.registrar.register(topology);\n      this.log('started');\n      this.started = true;\n    }\n    /**\n     * Unregister the pubsub protocol and the streams with other peers will be closed.\n     *\n     * @returns {void}\n     */\n\n\n    stop() {\n      if (!this.started) {\n        return;\n      } // unregister protocol and handlers\n\n\n      this.registrar.unregister(this._registrarId);\n      this.log('stopping');\n      this.peers.forEach(peerStreams => peerStreams.close());\n      this.peers = new Map();\n      this.subscriptions = new Set();\n      this.started = false;\n      this.log('stopped');\n    }\n    /**\n     * On an inbound stream opened.\n     *\n     * @protected\n     * @param {Object} props\n     * @param {string} props.protocol\n     * @param {MuxedStream} props.stream\n     * @param {Connection} props.connection - connection\n     */\n\n\n    _onIncomingStream({\n      protocol,\n      stream,\n      connection\n    }) {\n      const peerId = connection.remotePeer;\n      const idB58Str = peerId.toB58String();\n\n      const peer = this._addPeer(peerId, protocol);\n\n      const inboundStream = peer.attachInboundStream(stream);\n\n      this._processMessages(idB58Str, inboundStream, peer);\n    }\n    /**\n     * Registrar notifies an established connection with pubsub protocol.\n     *\n     * @protected\n     * @param {PeerId} peerId - remote peer-id\n     * @param {Connection} conn - connection to the peer\n     */\n\n\n    _onPeerConnected(peerId, conn) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const idB58Str = peerId.toB58String();\n\n        _this.log('connected', idB58Str);\n\n        try {\n          const {\n            stream,\n            protocol\n          } = yield conn.newStream(_this.multicodecs);\n\n          const peer = _this._addPeer(peerId, protocol);\n\n          yield peer.attachOutboundStream(stream);\n        } catch (err) {\n          _this.log.err(err);\n        } // Immediately send my own subscriptions to the newly established conn\n\n\n        _this._sendSubscriptions(idB58Str, Array.from(_this.subscriptions), true);\n      })();\n    }\n    /**\n     * Registrar notifies a closing connection with pubsub protocol.\n     *\n     * @protected\n     * @param {PeerId} peerId - peerId\n     * @param {Error} [err] - error for connection end\n     */\n\n\n    _onPeerDisconnected(peerId, err) {\n      const idB58Str = peerId.toB58String();\n      this.log('connection ended', idB58Str, err ? err.message : '');\n\n      this._removePeer(peerId);\n    }\n    /**\n     * Notifies the router that a peer has been connected\n     *\n     * @protected\n     * @param {PeerId} peerId\n     * @param {string} protocol\n     * @returns {PeerStreams}\n     */\n\n\n    _addPeer(peerId, protocol) {\n      const id = peerId.toB58String();\n      const existing = this.peers.get(id); // If peer streams already exists, do nothing\n\n      if (existing) {\n        return existing;\n      } // else create a new peer streams\n\n\n      this.log('new peer', id);\n      const peerStreams = new PeerStreams({\n        id: peerId,\n        protocol\n      });\n      this.peers.set(id, peerStreams);\n      peerStreams.once('close', () => this._removePeer(peerId));\n      return peerStreams;\n    }\n    /**\n     * Notifies the router that a peer has been disconnected.\n     *\n     * @protected\n     * @param {PeerId} peerId\n     * @returns {PeerStreams | undefined}\n     */\n\n\n    _removePeer(peerId) {\n      if (!peerId) return;\n      const id = peerId.toB58String();\n      const peerStreams = this.peers.get(id);\n      if (!peerStreams) return; // close peer streams\n\n      peerStreams.removeAllListeners();\n      peerStreams.close(); // delete peer streams\n\n      this.log('delete peer', id);\n      this.peers.delete(id); // remove peer from topics map\n\n      for (const peers of this.topics.values()) {\n        peers.delete(id);\n      }\n\n      return peerStreams;\n    } // MESSAGE METHODS\n\n    /**\n     * Responsible for processing each RPC message received by other peers.\n     *\n     * @param {string} idB58Str - peer id string in base58\n     * @param {AsyncIterable<Uint8Array|BufferList>} stream - inbound stream\n     * @param {PeerStreams} peerStreams - PubSub peer\n     * @returns {Promise<void>}\n     */\n\n\n    _processMessages(idB58Str, stream, peerStreams) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          yield pipe(stream, /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (source) {\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n\n              var _iteratorError;\n\n              try {\n                for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n                  const data = _value;\n                  const rpcBytes = data instanceof Uint8Array ? data : data.slice();\n\n                  const rpcMsg = _this2._decodeRpc(rpcBytes);\n\n                  yield _this2._processRpc(idB58Str, peerStreams, rpcMsg);\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    yield _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            });\n\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n        } catch (err) {\n          _this2._onPeerDisconnected(peerStreams.id, err);\n        }\n      })();\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @param {string} idB58Str\n     * @param {PeerStreams} peerStreams\n     * @param {RPC} rpc\n     * @returns {Promise<boolean>}\n     */\n\n\n    _processRpc(idB58Str, peerStreams, rpc) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        _this3.log('rpc from', idB58Str);\n\n        const subs = rpc.subscriptions;\n        const msgs = rpc.msgs;\n\n        if (subs.length) {\n          // update peer subscriptions\n          subs.forEach(subOpt => {\n            _this3._processRpcSubOpt(idB58Str, subOpt);\n          });\n\n          _this3.emit('pubsub:subscription-change', peerStreams.id, subs);\n        }\n\n        if (!_this3._acceptFrom(idB58Str)) {\n          _this3.log('received message from unacceptable peer %s', idB58Str);\n\n          return false;\n        }\n\n        if (msgs.length) {\n          // @ts-ignore RPC message is modified\n          for (const message of msgs) {\n            if (!(_this3.canRelayMessage || message.topicIDs && message.topicIDs.some(topic => _this3.subscriptions.has(topic)))) {\n              _this3.log('received message we didn\\'t subscribe to. Dropping.');\n\n              continue;\n            }\n\n            const msg = utils.normalizeInRpcMessage(message, idB58Str);\n            yield _this3._processRpcMessage(msg);\n          }\n        }\n\n        return true;\n      })();\n    }\n    /**\n     * Handles a subscription change from a peer\n     *\n     * @param {string} id\n     * @param {RPC.ISubOpts} subOpt\n     */\n\n\n    _processRpcSubOpt(id, subOpt) {\n      const t = subOpt.topicID;\n\n      if (!t) {\n        return;\n      }\n\n      let topicSet = this.topics.get(t);\n\n      if (!topicSet) {\n        topicSet = new Set();\n        this.topics.set(t, topicSet);\n      }\n\n      if (subOpt.subscribe) {\n        // subscribe peer to new topic\n        topicSet.add(id);\n      } else {\n        // unsubscribe from existing topic\n        topicSet.delete(id);\n      }\n    }\n    /**\n     * Handles an message from a peer\n     *\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n\n\n    _processRpcMessage(msg) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this4.peerId.toB58String() === msg.from && !_this4.emitSelf) {\n          return;\n        } // Ensure the message is valid before processing it\n\n\n        try {\n          yield _this4.validate(msg);\n        } catch (err) {\n          _this4.log('Message is invalid, dropping it. %O', err);\n\n          return;\n        } // Emit to self\n\n\n        _this4._emitMessage(msg);\n\n        return _this4._publish(utils.normalizeOutRpcMessage(msg));\n      })();\n    }\n    /**\n     * Emit a message from a peer\n     *\n     * @param {InMessage} message\n     */\n\n\n    _emitMessage(message) {\n      message.topicIDs.forEach(topic => {\n        if (this.subscriptions.has(topic)) {\n          this.emit(topic, message);\n        }\n      });\n    }\n    /**\n     * The default msgID implementation\n     * Child class can override this.\n     *\n     * @param {InMessage} msg - the message object\n     * @returns {Promise<Uint8Array> | Uint8Array} message id as bytes\n     */\n\n\n    getMsgId(msg) {\n      const signaturePolicy = this.globalSignaturePolicy;\n\n      switch (signaturePolicy) {\n        case SignaturePolicy.StrictSign:\n          // @ts-ignore seqno is optional in protobuf definition but it will exist\n          return utils.msgId(msg.from, msg.seqno);\n\n        case SignaturePolicy.StrictNoSign:\n          return utils.noSignMsgId(msg.data);\n\n        default:\n          throw errcode(new Error('Cannot get message id: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n      }\n    }\n    /**\n     * Whether to accept a message from a peer\n     * Override to create a graylist\n     *\n     * @param {string} id\n     * @returns {boolean}\n     */\n\n\n    _acceptFrom(id) {\n      return true;\n    }\n    /**\n     * Decode Uint8Array into an RPC object.\n     * This can be override to use a custom router protobuf.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {RPC}\n     */\n\n\n    _decodeRpc(bytes) {\n      return RPC.decode(bytes);\n    }\n    /**\n     * Encode RPC object into a Uint8Array.\n     * This can be override to use a custom router protobuf.\n     *\n     * @param {IRPC} rpc\n     * @returns {Uint8Array}\n     */\n\n\n    _encodeRpc(rpc) {\n      return RPC.encode(rpc).finish();\n    }\n    /**\n     * Send an rpc object to a peer\n     *\n     * @param {string} id - peer id\n     * @param {IRPC} rpc\n     * @returns {void}\n     */\n\n\n    _sendRpc(id, rpc) {\n      const peerStreams = this.peers.get(id);\n\n      if (!peerStreams || !peerStreams.isWritable) {\n        const msg = `Cannot send RPC to ${id} as there is no open stream to it available`;\n        this.log.err(msg);\n        return;\n      }\n\n      peerStreams.write(this._encodeRpc(rpc));\n    }\n    /**\n     * Send subscroptions to a peer\n     *\n     * @param {string} id - peer id\n     * @param {string[]} topics\n     * @param {boolean} subscribe - set to false for unsubscriptions\n     * @returns {void}\n     */\n\n\n    _sendSubscriptions(id, topics, subscribe) {\n      return this._sendRpc(id, {\n        subscriptions: topics.map(t => ({\n          topicID: t,\n          subscribe: subscribe\n        }))\n      });\n    }\n    /**\n     * Validates the given message. The signature will be checked for authenticity.\n     * Throws an error on invalid messages\n     *\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n\n\n    validate(message) {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        const signaturePolicy = _this5.globalSignaturePolicy;\n\n        switch (signaturePolicy) {\n          case SignaturePolicy.StrictNoSign:\n            if (message.from) {\n              throw errcode(new Error('StrictNoSigning: from should not be present'), codes.ERR_UNEXPECTED_FROM);\n            }\n\n            if (message.signature) {\n              throw errcode(new Error('StrictNoSigning: signature should not be present'), codes.ERR_UNEXPECTED_SIGNATURE);\n            }\n\n            if (message.key) {\n              throw errcode(new Error('StrictNoSigning: key should not be present'), codes.ERR_UNEXPECTED_KEY);\n            }\n\n            if (message.seqno) {\n              throw errcode(new Error('StrictNoSigning: seqno should not be present'), codes.ERR_UNEXPECTED_SEQNO);\n            }\n\n            break;\n\n          case SignaturePolicy.StrictSign:\n            if (!message.signature) {\n              throw errcode(new Error('StrictSigning: Signing required and no signature was present'), codes.ERR_MISSING_SIGNATURE);\n            }\n\n            if (!message.seqno) {\n              throw errcode(new Error('StrictSigning: Signing required and no seqno was present'), codes.ERR_MISSING_SEQNO);\n            }\n\n            if (!(yield verifySignature(message))) {\n              throw errcode(new Error('StrictSigning: Invalid message signature'), codes.ERR_INVALID_SIGNATURE);\n            }\n\n            break;\n\n          default:\n            throw errcode(new Error('Cannot validate message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n        }\n\n        for (const topic of message.topicIDs) {\n          const validatorFn = _this5.topicValidators.get(topic);\n\n          if (validatorFn) {\n            yield validatorFn(topic, message);\n          }\n        }\n      })();\n    }\n    /**\n     * Normalizes the message and signs it, if signing is enabled.\n     * Should be used by the routers to create the message to send.\n     *\n     * @protected\n     * @param {InMessage} message\n     * @returns {Promise<InMessage>}\n     */\n\n\n    _buildMessage(message) {\n      const signaturePolicy = this.globalSignaturePolicy;\n\n      switch (signaturePolicy) {\n        case SignaturePolicy.StrictSign:\n          message.from = this.peerId.toB58String();\n          message.seqno = utils.randomSeqno();\n          return signMessage(this.peerId, message);\n\n        case SignaturePolicy.StrictNoSign:\n          return Promise.resolve(message);\n\n        default:\n          throw errcode(new Error('Cannot build message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n      }\n    } // API METHODS\n\n    /**\n     * Get a list of the peer-ids that are subscribed to one topic.\n     *\n     * @param {string} topic\n     * @returns {Array<string>}\n     */\n\n\n    getSubscribers(topic) {\n      if (!this.started) {\n        throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n      }\n\n      if (!topic || typeof topic !== 'string') {\n        throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n      }\n\n      const peersInTopic = this.topics.get(topic);\n\n      if (!peersInTopic) {\n        return [];\n      }\n\n      return Array.from(peersInTopic);\n    }\n    /**\n     * Publishes messages to all subscribed peers\n     *\n     * @param {string} topic\n     * @param {Uint8Array} message\n     * @returns {Promise<void>}\n     */\n\n\n    publish(topic, message) {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this6.started) {\n          throw new Error('Pubsub has not started');\n        }\n\n        _this6.log('publish', topic, message);\n\n        const from = _this6.peerId.toB58String();\n\n        const msgObject = {\n          receivedFrom: from,\n          data: message,\n          topicIDs: [topic]\n        }; // ensure that the message follows the signature policy\n\n        const outMsg = yield _this6._buildMessage(msgObject); // @ts-ignore different type as from is converted\n\n        const msg = utils.normalizeInRpcMessage(outMsg); // Emit to self if I'm interested and emitSelf enabled\n\n        _this6.emitSelf && _this6._emitMessage(msg); // send to all the other peers\n\n        yield _this6._publish(msg);\n      })();\n    }\n    /**\n     * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n     *\n     * @abstract\n     * @param {InMessage|RPCMessage} message\n     * @returns {Promise<void>}\n     *\n     */\n\n\n    _publish(message) {\n      throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Subscribes to a given topic.\n     *\n     * @abstract\n     * @param {string} topic\n     * @returns {void}\n     */\n\n\n    subscribe(topic) {\n      if (!this.started) {\n        throw new Error('Pubsub has not started');\n      }\n\n      if (!this.subscriptions.has(topic)) {\n        this.subscriptions.add(topic);\n        this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true));\n      }\n    }\n    /**\n     * Unsubscribe from the given topic.\n     *\n     * @param {string} topic\n     * @returns {void}\n     */\n\n\n    unsubscribe(topic) {\n      if (!this.started) {\n        throw new Error('Pubsub is not started');\n      }\n\n      if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {\n        this.subscriptions.delete(topic);\n        this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false));\n      }\n    }\n    /**\n     * Get the list of topics which the peer is subscribed to.\n     *\n     * @returns {Array<string>}\n     */\n\n\n    getTopics() {\n      if (!this.started) {\n        throw new Error('Pubsub is not started');\n      }\n\n      return Array.from(this.subscriptions);\n    }\n\n  }\n\n  PubsubBaseProtocol.utils = utils;\n  PubsubBaseProtocol.SignaturePolicy = SignaturePolicy;\n  return PubsubBaseProtocol;\n})();\nmodule.exports = PubsubBaseProtocol;","map":null,"metadata":{},"sourceType":"script"}