{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as IPFS from 'ipfs';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\"; //test for cat method\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nexport class IpfsService {\n  _ipfsSource = new BehaviorSubject(null);\n  _createIPFSNodePromise;\n\n  get ipfs() {\n    var _this = this;\n\n    const getter = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        let node = _this._ipfsSource.getValue();\n\n        if (node == null) {\n          console.log(\"Waiting node creation...\");\n          node = yield _this._createIPFSNodePromise;\n\n          _this._ipfsSource.next(node);\n        }\n\n        return node;\n      });\n\n      return function getter() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    return getter();\n  }\n\n  constructor() {\n    console.log(\"Starting new node...\"); //should be only local now\n    //start: false stops daemon from connecting to peers\n\n    this._createIPFSNodePromise = IPFS.create({\n      start: false\n    });\n  }\n  /**\n   * @description Get the ID information about the current IPFS node\n   * @return {Promise<IPFS_ROOT_TYPES.IDResult>}\n   */\n\n\n  getId() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this2.ipfs;\n      return yield node.id();\n    })();\n  }\n  /**\n   * @description Get the version information about the current IPFS node\n   * @return {Promise<IPFS_ROOT_TYPES.VersionResult>}\n   */\n\n\n  getVersion() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this3.ipfs;\n      return yield node.version();\n    })();\n  }\n  /**\n   * @description Get the status of the current IPFS node\n   * @returns {Promise<boolean>}\n   */\n\n\n  getStatus() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this4.ipfs;\n      return yield node.isOnline();\n    })();\n  }\n  /*\n  * @description Get current connected Peers\n  * @returns {Promise<Array>} of Peer information\n  */\n\n\n  getPeers() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this5.ipfs;\n      return yield node.swarm.addrs();\n    })();\n  } //accept file blobs\n\n\n  addFile(content) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      //const content = Buffer.from(msg);\n      const node = yield _this6.ipfs;\n      const fileAdded = yield node.add(content);\n      let hash = fileAdded.cid.toString();\n      return hash;\n    })();\n  }\n\n  getFile(hash) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this7.ipfs;\n      /*const chunks = [];\n      for await (const chunk of node.cat(hash)) {\n        chunks.push(chunk);\n      }\n           return chunks; */\n\n      const data = uint8ArrayConcat(yield all(node.cat(hash)));\n      uint8ArrayToString(data);\n      return data;\n    })();\n  }\n\n  static ɵfac = function IpfsService_Factory(t) {\n    return new (t || IpfsService)();\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: IpfsService,\n    factory: IpfsService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/src/app/ipfs.service.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,IAAZ,MAAsB,MAAtB;AAGA,SAAS,eAAT,QAAiC,MAAjC;qCACA;;AACA,MAAM;AAAE,EAAA,MAAM,EAAE;AAAV,IAA+B,OAAO,CAAC,oBAAD,CAA5C;;AACA,MAAM;AAAE,EAAA,UAAU,EAAE;AAAd,IAAuC,OAAO,CAAC,yBAAD,CAApD;;AACA,MAAM;AAAE,EAAA,QAAQ,EAAE;AAAZ,IAAmC,OAAO,CAAC,uBAAD,CAAhD;;AAMA,OAAM,MAAO,WAAP,CAAkB;AACd,EAAA,WAAW,GAAG,IAAI,eAAJ,CAAsC,IAAtC,CAAH;AACX,EAAA,sBAAsB;;AAEd,MAAJ,IAAI,GAAA;AAAA;;AACd,UAAM,MAAM;AAAA,mCAAG,aAAW;AACxB,YAAI,IAAI,GAAG,KAAI,CAAC,WAAL,CAAiB,QAAjB,EAAX;;AAEA,YAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB,UAAA,OAAO,CAAC,GAAR,CAAY,0BAAZ;AAEA,UAAA,IAAI,SAAS,KAAI,CAAC,sBAAlB;;AACA,UAAA,KAAI,CAAC,WAAL,CAAiB,IAAjB,CAAsB,IAAtB;AACD;;AAED,eAAO,IAAP;AACD,OAXW;;AAAA,sBAAN,MAAM;AAAA;AAAA;AAAA,OAAZ;;AAaA,WAAO,MAAM,EAAb;AACD;;AAED,EAAA,WAAA,GAAA;AACE,IAAA,OAAO,CAAC,GAAR,CAAY,sBAAZ,EADF,CAGE;AACD;;AACC,SAAK,sBAAL,GAA8B,IAAI,CAAC,MAAL,CAAa;AAAE,MAAA,KAAK,EAAE;AAAT,KAAb,CAA9B;AACH;AACC;;;AAGG;;;AACG,EAAA,KAAK,GAAA;AAAA;;AAAA;AACT,YAAM,IAAI,SAAS,MAAI,CAAC,IAAxB;AACA,mBAAa,IAAI,CAAC,EAAL,EAAb;AAFS;AAGV;AAED;;;AAGG;;;AACG,EAAA,UAAU,GAAA;AAAA;;AAAA;AACd,YAAM,IAAI,SAAS,MAAI,CAAC,IAAxB;AACA,mBAAa,IAAI,CAAC,OAAL,EAAb;AAFc;AAGf;AAED;;;AAGG;;;AACG,EAAA,SAAS,GAAA;AAAA;;AAAA;AACb,YAAM,IAAI,SAAS,MAAI,CAAC,IAAxB;AACA,mBAAa,IAAI,CAAC,QAAL,EAAb;AAFa;AAGd;AAED;;;AAGE;;;AACI,EAAA,QAAQ,GAAA;AAAA;;AAAA;AACZ,YAAM,IAAI,SAAS,MAAI,CAAC,IAAxB;AACA,mBAAa,IAAI,CAAC,KAAL,CAAW,KAAX,EAAb;AAFY;AAGb,GA9DqB,CAgEtB;;;AACM,EAAA,OAAO,CAAC,OAAD,EAAuB;AAAA;;AAAA;AAClC;AACA,YAAM,IAAI,SAAS,MAAI,CAAC,IAAxB;AACA,YAAM,SAAS,SAAS,IAAI,CAAC,GAAL,CAAS,OAAT,CAAxB;AACA,UAAI,IAAI,GAAG,SAAS,CAAC,GAAV,CAAc,QAAd,EAAX;AACA,aAAO,IAAP;AALkC;AAMnC;;AAEK,EAAA,OAAO,CAAC,IAAD,EAAa;AAAA;;AAAA;AACxB,YAAM,IAAI,SAAS,MAAI,CAAC,IAAxB;AACA;;;;;;AAMA,YAAM,IAAI,GAAG,gBAAgB,OAAO,GAAG,CAAC,IAAI,CAAC,GAAL,CAAS,IAAT,CAAD,CAAV,CAA7B;AACA,MAAA,kBAAkB,CAAC,IAAD,CAAlB;AACA,aAAO,IAAP;AAVwB;AAWzB;;;qBApFU,W;AAAW,G;;WAAX,W;AAAW,IAAA,OAAA,EAAX,WAAW,CAAA,I;AAAA,IAAA,UAAA,EAFV;;AAEU","sourcesContent":["import { Injectable } from '@angular/core';\n\nimport * as IPFS from 'ipfs';\nimport * as IPFS_ROOT_TYPES from 'ipfs-core-types/src/root';\nimport * as IPFS_UTILS_TYPES from 'ipfs-core-types/src/utils';\nimport { BehaviorSubject, } from 'rxjs';\n//test for cat method\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat');\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string');\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string');\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class IpfsService {\n  private _ipfsSource = new BehaviorSubject<null | IPFS.IPFS>(null);\n  private _createIPFSNodePromise: Promise<IPFS.IPFS>;\n\n  private get ipfs() {\n    const getter = async () => {\n      let node = this._ipfsSource.getValue();\n\n      if (node == null) {\n        console.log(\"Waiting node creation...\")\n\n        node = await this._createIPFSNodePromise as IPFS.IPFS\n        this._ipfsSource.next(node);\n      }\n\n      return node;\n    }\n\n    return getter();\n  }\n\n  constructor() {\n    console.log(\"Starting new node...\")\n\n    //should be only local now\n   //start: false stops daemon from connecting to peers\n    this._createIPFSNodePromise = IPFS.create( { start: false });\n}\n  /**\n   * @description Get the ID information about the current IPFS node\n   * @return {Promise<IPFS_ROOT_TYPES.IDResult>}\n   */\n  async getId(): Promise<IPFS_ROOT_TYPES.IDResult> {\n    const node = await this.ipfs;\n    return await node.id();\n  }\n\n  /**\n   * @description Get the version information about the current IPFS node\n   * @return {Promise<IPFS_ROOT_TYPES.VersionResult>}\n   */\n  async getVersion(): Promise<IPFS_ROOT_TYPES.VersionResult> {\n    const node = await this.ipfs;\n    return await node.version();\n  }\n\n  /**\n   * @description Get the status of the current IPFS node\n   * @returns {Promise<boolean>}\n   */\n  async getStatus(): Promise<boolean> {\n    const node = await this.ipfs;\n    return await node.isOnline();\n  }\n\n  /*\n  * @description Get current connected Peers\n  * @returns {Promise<Array>} of Peer information\n  */\n  async getPeers(): Promise<Array<{ id: String, addrs: any[] }>> {\n    const node = await this.ipfs;\n    return await node.swarm.addrs();\n  }\n\n  //accept file blobs\n  async addFile(content: Blob | string): Promise<string> {\n    //const content = Buffer.from(msg);\n    const node = await this.ipfs;\n    const fileAdded = await node.add(content);\n    let hash = fileAdded.cid.toString();\n    return hash;\n  }\n\n  async getFile(hash: string): Promise<Uint8Array[]> {\n    const node = await this.ipfs;\n    /*const chunks = [];\n    for await (const chunk of node.cat(hash)) {\n      chunks.push(chunk);\n    }\n\n    return chunks; */\n    const data = uint8ArrayConcat(await all(node.cat(hash)));\n    uint8ArrayToString(data);\n    return data;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}