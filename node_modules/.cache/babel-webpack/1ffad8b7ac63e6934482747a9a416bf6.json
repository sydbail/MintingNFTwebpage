{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport * as IPFS from 'ipfs';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class IpfsService {\n  _ipfsSource = new BehaviorSubject(null);\n  _createIPFSNodePromise;\n\n  get ipfs() {\n    var _this = this;\n\n    const getter = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        let node = _this._ipfsSource.getValue();\n\n        if (node == null) {\n          console.log(\"Waiting node creation...\");\n          node = yield _this._createIPFSNodePromise;\n\n          _this._ipfsSource.next(node);\n        }\n\n        return node;\n      });\n\n      return function getter() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    return getter();\n  }\n\n  constructor() {\n    console.log(\"Starting new node...\"); //should be only local now\n    //start: false stops daemon from connecting to peers\n\n    this._createIPFSNodePromise = IPFS.create({\n      start: false\n    });\n  }\n  /**\n   * @description Get the ID information about the current IPFS node\n   * @return {Promise<IPFS_ROOT_TYPES.IDResult>} containing node IDs\n   */\n\n\n  getId() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this2.ipfs;\n      return yield node.id();\n    })();\n  }\n  /**\n   * @description Get the version information about the current IPFS node\n   * @return {Promise<IPFS_ROOT_TYPES.VersionResult>} containing node version\n   */\n\n\n  getVersion() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this3.ipfs;\n      return yield node.version();\n    })();\n  }\n  /**\n   * @description Get the status of the current IPFS node\n   * @returns {Promise<boolean>} representing if node is online (false = off)\n   */\n\n\n  getStatus() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this4.ipfs;\n      return yield node.isOnline();\n    })();\n  }\n  /*\n  * @description Get current connected Peers\n  * @returns {Promise<Array>} of Peer information\n  */\n\n\n  getPeers() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this5.ipfs;\n      return yield node.swarm.addrs();\n    })();\n  }\n  /* @description add a file to ipfs\n  *  @parameters: string or blob of content to upload\n  *  @returns {Promise<String>} containing CID of file added\n  */\n\n\n  addFile(content) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this6.ipfs;\n      const fileAdded = yield node.add(content);\n      let hash = fileAdded.cid.toString();\n      return hash;\n    })();\n  }\n  /* @description retrieve a file from ipfs\n  *  @parameters: string CID of the file\n  *  @returns {Promise<Uint8Array>} containing file contents\n  */\n\n\n  getFile(contentCID) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const node = yield _this7.ipfs;\n      const chunks = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(node.cat(contentCID)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const chunk = _value;\n          chunks.push(chunk);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return chunks;\n    })();\n  }\n\n  static ɵfac = function IpfsService_Factory(t) {\n    return new (t || IpfsService)();\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: IpfsService,\n    factory: IpfsService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":null,"metadata":{},"sourceType":"module"}