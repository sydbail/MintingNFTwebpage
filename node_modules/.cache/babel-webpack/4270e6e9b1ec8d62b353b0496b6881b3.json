{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst c = require('../constants');\n\nconst Message = require('../message');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\n\n\nmodule.exports = dht => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  const findPeerLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (peer) {\n      dht._log(`findPeerLocal ${peer.toB58String()}`);\n\n      const p = yield dht.routingTable.find(peer);\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n      const peerData = p && dht.peerStore.get(p);\n\n      if (peerData) {\n        return {\n          id: peerData.id,\n          multiaddrs: peerData.addresses.map(address => address.multiaddr)\n        };\n      }\n    });\n\n    return function findPeerLocal(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  const getValueSingle = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (peer, key) {\n      // eslint-disable-line require-await\n      const msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n      return dht.network.sendRequest(peer, msg);\n    });\n\n    return function getValueSingle(_x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n\n  const closerPeersSingle = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* (key, peer) {\n      dht._log(`closerPeersSingle ${uint8ArrayToString(key, 'base32')} from ${peer.toB58String()}`);\n\n      const msg = yield dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n      return msg.closerPeers.filter(peerData => !dht._isSelf(peerData.id)).map(peerData => {\n        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);\n        return peerData;\n      });\n    });\n\n    return function closerPeersSingle(_x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  const getPublicKeyFromNode = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator(function* (peer) {\n      const pkKey = utils.keyForPublicKey(peer);\n      const msg = yield getValueSingle(peer, pkKey);\n\n      if (!msg.record || !msg.record.value) {\n        throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD');\n      }\n\n      const recPeer = yield PeerId.createFromPubKey(msg.record.value); // compare hashes of the pub key\n\n      if (!recPeer.equals(peer)) {\n        throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n      }\n\n      return recPeer.pubKey;\n    });\n\n    return function getPublicKeyFromNode(_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     *\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    _findPeerSingle(peer, target) {\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        dht._log('findPeerSingle %s', peer.toB58String());\n\n        const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n        return dht.network.sendRequest(peer, msg);\n      })();\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    findPeer(id, options = {\n      timeout: 60000\n    }) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        options.timeout = options.timeout || c.minute;\n\n        dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n        const pi = yield findPeerLocal(id); // already got it\n\n        if (pi != null) {\n          dht._log('found local');\n\n          return pi;\n        }\n\n        const key = yield utils.convertPeerId(id);\n        const peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n        if (peers.length === 0) {\n          throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n        } // sanity check\n\n\n        const match = peers.find(p => p.isEqual(id));\n\n        if (match) {\n          /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n          const peer = dht.peerStore.get(id);\n\n          if (peer) {\n            dht._log('found in peerStore');\n\n            return {\n              id: peer.id,\n              multiaddrs: peer.addresses.map(address => address.multiaddr)\n            };\n          }\n        } // query the network\n\n\n        const query = new Query(dht, id.id, () => {\n          /**\n           * There is no distinction between the disjoint paths, so there are no per-path\n           * variables in dht scope. Just return the actual query function.\n           *\n           * @param {PeerId} peer\n           */\n          const queryFn = /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* (peer) {\n              const msg = yield _this._findPeerSingle(peer, id);\n              const match = msg.closerPeers.find(p => p.id.isEqual(id)); // found it\n\n              if (match) {\n                return {\n                  peer: match,\n                  queryComplete: true\n                };\n              }\n\n              return {\n                closerPeers: msg.closerPeers\n              };\n            });\n\n            return function queryFn(_x7) {\n              return _ref5.apply(this, arguments);\n            };\n          }();\n\n          return queryFn;\n        });\n        let result;\n\n        try {\n          result = yield pTimeout(query.run(peers), options.timeout);\n        } finally {\n          query.stop();\n        }\n\n        let success = false;\n        result.paths.forEach(result => {\n          if (result.success && result.peer) {\n            success = true;\n            dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs);\n          }\n        });\n\n        dht._log('findPeer %s: %s', id.toB58String(), success);\n\n        if (!success) {\n          throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n        }\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n        const peerData = dht.peerStore.get(id);\n\n        if (!peerData) {\n          throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND');\n        }\n\n        return {\n          id: peerData.id,\n          multiaddrs: peerData.addresses.map(address => address.multiaddr)\n        };\n      })();\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    getClosestPeers(key, options = {\n      shallow: false\n    }) {\n      return _wrapAsyncGenerator(function* () {\n        dht._log('getClosestPeers to %b', key);\n\n        const id = yield _awaitAsyncGenerator(utils.convertBuffer(key));\n        const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n        const q = new Query(dht, key, () => {\n          // There is no distinction between the disjoint paths,\n          // so there are no per-path variables in dht scope.\n          // Just return the actual query function.\n          return /*#__PURE__*/function () {\n            var _ref6 = _asyncToGenerator(function* (peer) {\n              const closer = yield closerPeersSingle(key, peer);\n              return {\n                closerPeers: closer,\n                pathComplete: options.shallow ? true : undefined\n              };\n            });\n\n            return function (_x8) {\n              return _ref6.apply(this, arguments);\n            };\n          }();\n        });\n        const res = yield _awaitAsyncGenerator(q.run(tablePeers));\n\n        if (!res || !res.finalSet) {\n          return [];\n        }\n\n        const sorted = yield _awaitAsyncGenerator(utils.sortClosestPeers(Array.from(res.finalSet), id));\n\n        for (const pId of sorted.slice(0, dht.kBucketSize)) {\n          yield pId;\n        }\n      })();\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    getPublicKey(peer) {\n      return _asyncToGenerator(function* () {\n        dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n        const peerData = dht.peerStore.get(peer);\n\n        if (peerData && peerData.id.pubKey) {\n          dht._log('getPublicKey: found local copy');\n\n          return peerData.id.pubKey;\n        } // try the node directly\n\n\n        let pk;\n\n        try {\n          pk = yield getPublicKeyFromNode(peer);\n        } catch (err) {\n          // try dht directly\n          const pkKey = utils.keyForPublicKey(peer);\n          const value = yield dht.get(pkKey);\n          pk = crypto.keys.unmarshalPublicKey(value);\n        }\n\n        const peerId = new PeerId(peer.id, undefined, pk);\n        const addrs = (peerData && peerData.addresses || []).map(address => address.multiaddr);\n        dht.peerStore.addressBook.add(peerId, addrs);\n        dht.peerStore.keyBook.set(peerId, pk);\n        return pk;\n      })();\n    }\n\n  };\n};","map":null,"metadata":{},"sourceType":"script"}