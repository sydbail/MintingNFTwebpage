{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.commands = void 0;\n\nconst Stream_1 = require(\"../../../stream/Stream\");\n\nconst Arbitrary_1 = require(\"../../arbitrary/definition/Arbitrary\");\n\nconst Shrinkable_1 = require(\"../../arbitrary/definition/Shrinkable\");\n\nconst nat_1 = require(\"../../../arbitrary/nat\");\n\nconst oneof_1 = require(\"../../../arbitrary/oneof\");\n\nconst ReplayPath_1 = require(\"../ReplayPath\");\n\nconst CommandsIterable_1 = require(\"./CommandsIterable\");\n\nconst CommandWrapper_1 = require(\"./CommandWrapper\");\n\nconst LazyIterableIterator_1 = require(\"../../../stream/LazyIterableIterator\");\n\nclass CommandsArbitrary extends Arbitrary_1.Arbitrary {\n  constructor(commandArbs, maxCommands, sourceReplayPath, disableReplayLog) {\n    super();\n    this.sourceReplayPath = sourceReplayPath;\n    this.disableReplayLog = disableReplayLog;\n    this.oneCommandArb = oneof_1.oneof(...commandArbs).map(c => new CommandWrapper_1.CommandWrapper(c));\n    this.lengthArb = nat_1.nat(maxCommands);\n    this.replayPath = [];\n    this.replayPathPosition = 0;\n  }\n\n  metadataForReplay() {\n    return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath_1.ReplayPath.stringify(this.replayPath))}`;\n  }\n\n  wrapper(items, shrunkOnce) {\n    return new Shrinkable_1.Shrinkable(new CommandsIterable_1.CommandsIterable(items.map(s => s.value_), () => this.metadataForReplay()), () => this.shrinkImpl(items, shrunkOnce).map(v => this.wrapper(v, true)));\n  }\n\n  generate(mrng) {\n    const size = this.lengthArb.generate(mrng);\n    const items = Array(size.value_);\n\n    for (let idx = 0; idx !== size.value_; ++idx) {\n      const item = this.oneCommandArb.generate(mrng);\n      items[idx] = item;\n    }\n\n    this.replayPathPosition = 0;\n    return this.wrapper(items, false);\n  }\n\n  filterOnExecution(itemsRaw) {\n    const items = [];\n\n    for (const c of itemsRaw) {\n      if (c.value_.hasRan) {\n        this.replayPath.push(true);\n        items.push(c);\n      } else this.replayPath.push(false);\n    }\n\n    return items;\n  }\n\n  filterOnReplay(itemsRaw) {\n    return itemsRaw.filter((c, idx) => {\n      const state = this.replayPath[this.replayPathPosition + idx];\n      if (state === undefined) throw new Error(`Too short replayPath`);\n      if (!state && c.value_.hasRan) throw new Error(`Mismatch between replayPath and real execution`);\n      return state;\n    });\n  }\n\n  filterForShrinkImpl(itemsRaw) {\n    if (this.replayPathPosition === 0) {\n      this.replayPath = this.sourceReplayPath !== null ? ReplayPath_1.ReplayPath.parse(this.sourceReplayPath) : [];\n    }\n\n    const items = this.replayPathPosition < this.replayPath.length ? this.filterOnReplay(itemsRaw) : this.filterOnExecution(itemsRaw);\n    this.replayPathPosition += itemsRaw.length;\n    return items;\n  }\n\n  shrinkImpl(itemsRaw, shrunkOnce) {\n    const items = this.filterForShrinkImpl(itemsRaw);\n\n    if (items.length === 0) {\n      return Stream_1.Stream.nil();\n    }\n\n    const rootShrink = shrunkOnce ? Stream_1.Stream.nil() : new Stream_1.Stream([[]][Symbol.iterator]());\n    const nextShrinks = [];\n\n    for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {\n      nextShrinks.push(LazyIterableIterator_1.makeLazy(() => {\n        const size = this.lengthArb.contextualShrinkableFor(items.length - 1 - numToKeep);\n        const fixedStart = items.slice(0, numToKeep);\n        return size.shrink().map(l => fixedStart.concat(items.slice(items.length - (l.value + 1))));\n      }));\n    }\n\n    for (let itemAt = 0; itemAt !== items.length; ++itemAt) {\n      nextShrinks.push(LazyIterableIterator_1.makeLazy(() => items[itemAt].shrink().map(v => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));\n    }\n\n    return rootShrink.join(...nextShrinks).map(shrinkables => {\n      return shrinkables.map(c => {\n        return new Shrinkable_1.Shrinkable(c.value_.clone(), c.shrink);\n      });\n    });\n  }\n\n}\n\nfunction commands(commandArbs, constraints) {\n  const config = constraints == null ? {} : typeof constraints === 'number' ? {\n    maxCommands: constraints\n  } : constraints;\n  return new CommandsArbitrary(commandArbs, config.maxCommands != null ? config.maxCommands : 10, config.replayPath != null ? config.replayPath : null, !!config.disableReplayLog);\n}\n\nexports.commands = commands;","map":null,"metadata":{},"sourceType":"script"}