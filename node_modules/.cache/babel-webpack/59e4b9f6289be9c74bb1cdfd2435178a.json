{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst _get = require('just-safe-get');\n\nconst debug = require('debug');\n\nconst errCode = require('err-code');\n\nconst migrator = require('ipfs-repo-migrations');\n\nconst bytes = require('bytes');\n\nconst merge = require('merge-options');\n\nconst constants = require('./constants');\n\nconst version = require('./version');\n\nconst config = require('./config');\n\nconst spec = require('./spec');\n\nconst apiAddr = require('./api-addr');\n\nconst createIdstore = require('./idstore');\n\nconst defaultOptions = require('./default-options');\n\nconst defaultDatastore = require('./default-datastore');\n\nconst ERRORS = require('./errors');\n\nconst {\n  PinManager,\n  PinTypes\n} = require('./pins');\n\nconst createPinnedBlockstore = require('./pinned-blockstore'); // @ts-ignore - no types\n\n\nconst mortice = require('mortice');\n\nconst gc = require('./gc');\n\nconst MemoryLock = require('./locks/memory');\n\nconst FSLock = require('./locks/fs');\n\nconst log = debug('ipfs:repo');\nconst noLimit = Number.MAX_SAFE_INTEGER;\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\n\nclass Repo {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  constructor(path, loadCodec, backends, options) {\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path');\n    }\n\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader');\n    }\n    /** @type {Options} */\n\n\n    this.options = merge(defaultOptions, options);\n    this.closed = true;\n    this.path = path;\n    this.root = backends.root;\n    this.datastore = backends.datastore;\n    this.keys = backends.keys;\n    const blockstore = backends.blocks;\n    const pinstore = backends.pins;\n    this.pins = new PinManager({\n      pinstore,\n      blockstore,\n      loadCodec\n    }); // this blockstore will not delete blocks that have been pinned\n\n    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore); // this blockstore will extract blocks from multihashes with the identity codec\n\n    this.blocks = createIdstore(pinnedBlockstore);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n    /** @type {GCLock} */\n\n    this.gcLock = mortice(path, {\n      singleProcess: this.options.repoOwner !== false\n    });\n    this.gc = gc({\n      gcLock: this.gcLock,\n      pins: this.pins,\n      blockstore: this.blocks,\n      root: this.root,\n      loadCodec\n    });\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  init(config) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      log('initializing at: %s', _this.path);\n      yield _this._openRoot();\n      yield _this.config.replace(buildConfig(config));\n      yield _this.spec.set(buildDatastoreSpec(config));\n      yield _this.version.set(constants.repoVersion);\n    })();\n  }\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  isInitialized() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.closed) {\n        // repo is open, must be initialized\n        return true;\n      }\n\n      try {\n        // have to open the root datastore in the browser before\n        // we can check whether it's been initialized\n        yield _this2._openRoot();\n        yield _this2._checkInitialized();\n        yield _this2.root.close();\n        return true;\n      } catch (err) {\n        // FIXME: do not use exceptions for flow control\n        return false;\n      }\n    })();\n  }\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  open() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this3.closed) {\n        throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n      }\n\n      log('opening at: %s', _this3.path); // check if the repo is already initialized\n\n      try {\n        yield _this3._openRoot();\n        yield _this3._checkInitialized();\n        _this3._lockfile = yield _this3._openLock();\n        log('acquired repo.lock');\n        const isCompatible = yield _this3.version.check(constants.repoVersion);\n\n        if (!isCompatible) {\n          if (yield _this3._isAutoMigrationEnabled()) {\n            yield _this3._migrate(constants.repoVersion, {\n              root: _this3.root,\n              datastore: _this3.datastore,\n              pins: _this3.pins.pinstore,\n              blocks: _this3.pins.blockstore,\n              keys: _this3.keys\n            });\n          } else {\n            throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n          }\n        }\n\n        log('creating datastore');\n        yield _this3.datastore.open();\n        log('creating blocks');\n\n        _this3.blocks.open();\n\n        log('creating keystore');\n        yield _this3.keys.open();\n        log('creating pins');\n        yield _this3.pins.pinstore.open();\n        _this3.closed = false;\n        log('all opened');\n      } catch (err) {\n        if (_this3._lockfile) {\n          try {\n            yield _this3._closeLock();\n            _this3._lockfile = null;\n          } catch (err2) {\n            log('error removing lock', err2);\n          }\n        }\n\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   *\n   * @private\n   */\n\n\n  _openRoot() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this4.root.open();\n      } catch (err) {\n        if (err.message !== 'Already open') {\n          throw err;\n        }\n      }\n    })();\n  }\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @private\n   * @returns {Promise<LockCloser>}\n   */\n\n\n  _openLock() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const lockfile = yield _this5.options.repoLock.lock(_this5.path);\n\n      if (typeof lockfile.close !== 'function') {\n        throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n      }\n\n      return lockfile;\n    })();\n  }\n  /**\n   * Closes the lock on the repo\n   *\n   * @private\n   */\n\n\n  _closeLock() {\n    return this._lockfile && this._lockfile.close();\n  }\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   */\n\n\n  _checkInitialized() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      log('init check');\n      let config;\n\n      try {\n        [config] = yield Promise.all([_this6.config.exists(), _this6.spec.exists(), _this6.version.exists()]);\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n            path: _this6.path\n          });\n        }\n\n        throw err;\n      }\n\n      if (!config) {\n        throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: _this6.path\n        });\n      }\n    })();\n  }\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  close() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this7.closed) {\n        throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n      }\n\n      log('closing at: %s', _this7.path);\n\n      try {\n        // Delete api, ignoring irrelevant errors\n        yield _this7.apiAddr.delete();\n      } catch (err) {\n        if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n          throw err;\n        }\n      }\n\n      yield Promise.all([_this7.root, _this7.blocks, _this7.keys, _this7.datastore, _this7.pins.pinstore].map(store => store && store.close()));\n      log('unlocking');\n      _this7.closed = true;\n      yield _this7._closeLock();\n    })();\n  }\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  exists() {\n    return this.version.exists();\n  }\n  /**\n   * Get repo status.\n   *\n   * @returns {Promise<Stat>}\n   */\n\n\n  stat() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this8.datastore && _this8.keys) {\n        const [storageMax, blocks, version, datastore, keys] = yield Promise.all([_this8._storageMaxStat(), _this8._blockStat(), _this8.version.get(), getSize(_this8.datastore), getSize(_this8.keys)]);\n        const size = blocks.size + datastore + keys;\n        return {\n          repoPath: _this8.path,\n          storageMax,\n          version: version,\n          numObjects: blocks.count,\n          repoSize: size\n        };\n      }\n\n      throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: _this8.path\n      });\n    })();\n  }\n  /**\n   * @private\n   */\n\n\n  _isAutoMigrationEnabled() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this9.options.autoMigrate !== undefined) {\n        return _this9.options.autoMigrate;\n      } // TODO we need to figure out the priority here, between repo options and config.\n\n\n      let autoMigrateConfig;\n\n      try {\n        autoMigrateConfig = yield _this9.config.get(AUTO_MIGRATE_CONFIG_KEY);\n      } catch (e) {\n        if (e.code === ERRORS.NotFoundError.code) {\n          autoMigrateConfig = true; // Config's default value is True\n        } else {\n          throw e;\n        }\n      }\n\n      return autoMigrateConfig;\n    })();\n  }\n  /**\n   * Internal migration\n   *\n   * @private\n   * @param {number} toVersion\n   * @param {Backends} backends\n   */\n\n\n  _migrate(toVersion, backends) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const currentRepoVersion = yield _this10.version.get();\n\n      if (currentRepoVersion > toVersion) {\n        log(`reverting to version ${toVersion}`);\n        return migrator.revert(_this10.path, backends, _this10.options, toVersion, {\n          ignoreLock: true,\n          onProgress: _this10.options.onMigrationProgress\n        });\n      } else {\n        log(`migrating to version ${toVersion}`);\n        return migrator.migrate(_this10.path, backends, _this10.options, toVersion, {\n          ignoreLock: true,\n          onProgress: _this10.options.onMigrationProgress\n        });\n      }\n    })();\n  }\n  /**\n   * @private\n   */\n\n\n  _storageMaxStat() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const max = yield _this11.config.get('Datastore.StorageMax');\n        return BigInt(bytes(max));\n      } catch (err) {\n        return BigInt(noLimit);\n      }\n    })();\n  }\n  /**\n   * @private\n   */\n\n\n  _blockStat() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      let count = BigInt(0);\n      let size = BigInt(0);\n\n      if (_this12.blocks) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(_this12.blocks.query({})), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const {\n              key,\n              value\n            } = _value;\n            count += BigInt(1);\n            size += BigInt(value.byteLength);\n            size += BigInt(key.bytes.byteLength);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return {\n        count,\n        size\n      };\n    })();\n  }\n\n}\n/**\n * @param {Datastore} datastore\n */\n\n\nfunction getSize(_x) {\n  return _getSize.apply(this, arguments);\n}\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\n\n\nfunction _getSize() {\n  _getSize = _asyncToGenerator(function* (datastore) {\n    let sum = BigInt(0);\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n\n    var _iteratorError2;\n\n    try {\n      for (var _iterator2 = _asyncIterator(datastore.query({})), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n        const block = _value2;\n        sum += BigInt(block.value.byteLength);\n        sum += BigInt(block.key.uint8Array().byteLength);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          yield _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return sum;\n  });\n  return _getSize.apply(this, arguments);\n}\n\nfunction createRepo(path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options);\n}\n\nmodule.exports = {\n  createRepo,\n  repoVersion: constants.repoVersion,\n  errors: ERRORS,\n  utils: {\n    blockstore: require('./utils/blockstore')\n  },\n  locks: {\n    memory: MemoryLock,\n    fs: FSLock\n  },\n  PinTypes\n};\n/**\n * @param {import('./types').Config} _config\n */\n\nfunction buildConfig(_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'));\n  return _config;\n}\n/**\n * @param {import('./types').Config} _config\n */\n\n\nfunction buildDatastoreSpec(_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  const spec = { ...defaultDatastore.Spec,\n    ..._get(_config, 'Datastore.Spec')\n  };\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(mounting => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  };\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/ipfs-repo/src/index.js"],"names":["_get","require","debug","errCode","migrator","bytes","merge","constants","version","config","spec","apiAddr","createIdstore","defaultOptions","defaultDatastore","ERRORS","PinManager","PinTypes","createPinnedBlockstore","mortice","gc","MemoryLock","FSLock","log","noLimit","Number","MAX_SAFE_INTEGER","AUTO_MIGRATE_CONFIG_KEY","Repo","constructor","path","loadCodec","backends","options","Error","closed","root","datastore","keys","blockstore","blocks","pinstore","pins","pinnedBlockstore","gcLock","singleProcess","repoOwner","init","_openRoot","replace","buildConfig","set","buildDatastoreSpec","repoVersion","isInitialized","_checkInitialized","close","err","open","ERR_REPO_ALREADY_OPEN","_lockfile","_openLock","isCompatible","check","_isAutoMigrationEnabled","_migrate","InvalidRepoVersionError","_closeLock","err2","message","lockfile","repoLock","lock","Promise","all","exists","code","ERR_REPO_NOT_INITIALIZED","ERR_REPO_ALREADY_CLOSED","delete","startsWith","map","store","stat","storageMax","_storageMaxStat","_blockStat","get","getSize","size","repoPath","numObjects","count","repoSize","autoMigrate","undefined","autoMigrateConfig","e","NotFoundError","toVersion","currentRepoVersion","revert","ignoreLock","onProgress","onMigrationProgress","migrate","max","BigInt","query","key","value","byteLength","sum","block","uint8Array","createRepo","module","exports","errors","utils","locks","memory","fs","_config","Datastore","Object","assign","Spec","type","mounts","mounting","mountpoint","child","shardFunc"],"mappings":"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","sourcesContent":["'use strict'\n\nconst _get = require('just-safe-get')\nconst debug = require('debug')\nconst errCode = require('err-code')\nconst migrator = require('ipfs-repo-migrations')\nconst bytes = require('bytes')\nconst merge = require('merge-options')\nconst constants = require('./constants')\nconst version = require('./version')\nconst config = require('./config')\nconst spec = require('./spec')\nconst apiAddr = require('./api-addr')\nconst createIdstore = require('./idstore')\nconst defaultOptions = require('./default-options')\nconst defaultDatastore = require('./default-datastore')\nconst ERRORS = require('./errors')\nconst { PinManager, PinTypes } = require('./pins')\nconst createPinnedBlockstore = require('./pinned-blockstore')\n// @ts-ignore - no types\nconst mortice = require('mortice')\nconst gc = require('./gc')\nconst MemoryLock = require('./locks/memory')\nconst FSLock = require('./locks/fs')\n\nconst log = debug('ipfs:repo')\n\nconst noLimit = Number.MAX_SAFE_INTEGER\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate'\n\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\nclass Repo {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  constructor (path, loadCodec, backends, options) {\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path')\n    }\n\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader')\n    }\n\n    /** @type {Options} */\n    this.options = merge(defaultOptions, options)\n    this.closed = true\n    this.path = path\n    this.root = backends.root\n    this.datastore = backends.datastore\n    this.keys = backends.keys\n\n    const blockstore = backends.blocks\n    const pinstore = backends.pins\n\n    this.pins = new PinManager({ pinstore, blockstore, loadCodec })\n\n    // this blockstore will not delete blocks that have been pinned\n    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore)\n\n    // this blockstore will extract blocks from multihashes with the identity codec\n    this.blocks = createIdstore(pinnedBlockstore)\n\n    this.version = version(this.root)\n    this.config = config(this.root)\n    this.spec = spec(this.root)\n    this.apiAddr = apiAddr(this.root)\n\n    /** @type {GCLock} */\n    this.gcLock = mortice(path, {\n      singleProcess: this.options.repoOwner !== false\n    })\n\n    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec })\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n  async init (config) {\n    log('initializing at: %s', this.path)\n    await this._openRoot()\n    await this.config.replace(buildConfig(config))\n    await this.spec.set(buildDatastoreSpec(config))\n    await this.version.set(constants.repoVersion)\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @returns {Promise<boolean>}\n   */\n  async isInitialized () {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot()\n      await this._checkInitialized()\n      await this.root.close()\n\n      return true\n    } catch (err) {\n      // FIXME: do not use exceptions for flow control\n      return false\n    }\n  }\n\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n  async open () {\n    if (!this.closed) {\n      throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN)\n    }\n    log('opening at: %s', this.path)\n\n    // check if the repo is already initialized\n    try {\n      await this._openRoot()\n      await this._checkInitialized()\n\n      this._lockfile = await this._openLock()\n      log('acquired repo.lock')\n\n      const isCompatible = await this.version.check(constants.repoVersion)\n\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(constants.repoVersion, {\n            root: this.root,\n            datastore: this.datastore,\n            pins: this.pins.pinstore,\n            blocks: this.pins.blockstore,\n            keys: this.keys\n          })\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.')\n        }\n      }\n\n      log('creating datastore')\n      await this.datastore.open()\n\n      log('creating blocks')\n      this.blocks.open()\n\n      log('creating keystore')\n      await this.keys.open()\n\n      log('creating pins')\n      await this.pins.pinstore.open()\n\n      this.closed = false\n      log('all opened')\n    } catch (err) {\n      if (this._lockfile) {\n        try {\n          await this._closeLock()\n          this._lockfile = null\n        } catch (err2) {\n          log('error removing lock', err2)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   *\n   * @private\n   */\n  async _openRoot () {\n    try {\n      await this.root.open()\n    } catch (err) {\n      if (err.message !== 'Already open') {\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @private\n   * @returns {Promise<LockCloser>}\n   */\n  async _openLock () {\n    const lockfile = await this.options.repoLock.lock(this.path)\n\n    if (typeof lockfile.close !== 'function') {\n      throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION')\n    }\n\n    return lockfile\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @private\n   */\n  _closeLock () {\n    return this._lockfile && this._lockfile.close()\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   */\n  async _checkInitialized () {\n    log('init check')\n    let config\n    try {\n      [config] = await Promise.all([\n        this.config.exists(),\n        this.spec.exists(),\n        this.version.exists()\n      ])\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        })\n      }\n\n      throw err\n    }\n\n    if (!config) {\n      throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      })\n    }\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this.closed) {\n      throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED)\n    }\n    log('closing at: %s', this.path)\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete()\n    } catch (err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err\n      }\n    }\n\n    await Promise.all([\n      this.root,\n      this.blocks,\n      this.keys,\n      this.datastore,\n      this.pins.pinstore\n    ].map((store) => store && store.close()))\n\n    log('unlocking')\n    this.closed = true\n    await this._closeLock()\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<boolean>}\n   */\n  exists () {\n    return this.version.exists()\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @returns {Promise<Stat>}\n   */\n  async stat () {\n    if (this.datastore && this.keys) {\n      const [storageMax, blocks, version, datastore, keys] = await Promise.all([\n        this._storageMaxStat(),\n        this._blockStat(),\n        this.version.get(),\n        getSize(this.datastore),\n        getSize(this.keys)\n      ])\n      const size = blocks.size + datastore + keys\n\n      return {\n        repoPath: this.path,\n        storageMax,\n        version: version,\n        numObjects: blocks.count,\n        repoSize: size\n      }\n    }\n    throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n      path: this.path\n    })\n  }\n\n  /**\n   * @private\n   */\n  async _isAutoMigrationEnabled () {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate\n    }\n\n    // TODO we need to figure out the priority here, between repo options and config.\n    let autoMigrateConfig\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY)\n    } catch (e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true // Config's default value is True\n      } else {\n        throw e\n      }\n    }\n\n    return autoMigrateConfig\n  }\n\n  /**\n   * Internal migration\n   *\n   * @private\n   * @param {number} toVersion\n   * @param {Backends} backends\n   */\n  async _migrate (toVersion, backends) {\n    const currentRepoVersion = await this.version.get()\n\n    if (currentRepoVersion > toVersion) {\n      log(`reverting to version ${toVersion}`)\n      return migrator.revert(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      })\n    } else {\n      log(`migrating to version ${toVersion}`)\n      return migrator.migrate(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _storageMaxStat () {\n    try {\n      const max = /** @type {number} */(await this.config.get('Datastore.StorageMax'))\n      return BigInt(bytes(max))\n    } catch (err) {\n      return BigInt(noLimit)\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _blockStat () {\n    let count = BigInt(0)\n    let size = BigInt(0)\n\n    if (this.blocks) {\n      for await (const { key, value } of this.blocks.query({})) {\n        count += BigInt(1)\n        size += BigInt(value.byteLength)\n        size += BigInt(key.bytes.byteLength)\n      }\n    }\n\n    return { count, size }\n  }\n}\n\n/**\n * @param {Datastore} datastore\n */\nasync function getSize (datastore) {\n  let sum = BigInt(0)\n  for await (const block of datastore.query({})) {\n    sum += BigInt(block.value.byteLength)\n    sum += BigInt(block.key.uint8Array().byteLength)\n  }\n  return sum\n}\n\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\nfunction createRepo (path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options)\n}\n\nmodule.exports = {\n  createRepo,\n  repoVersion: constants.repoVersion,\n  errors: ERRORS,\n  utils: { blockstore: require('./utils/blockstore') },\n  locks: {\n    memory: MemoryLock,\n    fs: FSLock\n  },\n  PinTypes\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildConfig (_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'))\n\n  return _config\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildDatastoreSpec (_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  const spec = {\n    ...defaultDatastore.Spec,\n    ..._get(_config, 'Datastore.Spec')\n  }\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map((mounting) => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}