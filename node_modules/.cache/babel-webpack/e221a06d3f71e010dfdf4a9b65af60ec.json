{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst log = require('debug')('ipfs:components:peer:storage');\n\nconst createRepo = require('../runtime/repo-nodejs');\n\nconst getDefaultConfig = require('../runtime/config-nodejs');\n\nconst {\n  ERR_REPO_NOT_INITIALIZED\n} = require('ipfs-repo').errors;\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst PeerId = require('peer-id');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst configService = require('./config');\n\nconst {\n  NotEnabledError,\n  NotInitializedError\n} = require('../errors');\n\nconst createLibP2P = require('./libp2p');\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n\n\n  static start(print, codecs, options) {\n    return _asyncToGenerator(function* () {\n      const {\n        repoAutoMigrate,\n        repo: inputRepo,\n        onMigrationProgress\n      } = options;\n      const repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      }) : inputRepo;\n      const {\n        peerId,\n        keychain,\n        isNew\n      } = yield loadRepo(print, repo, options); // TODO: throw error?\n      // @ts-ignore On start, keychain will always be available\n\n      return new Storage(peerId, keychain, repo, print, isNew);\n    })();\n  }\n\n}\n\nmodule.exports = Storage;\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\n\nconst loadRepo = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (print, repo, options) {\n    if (!repo.closed) {\n      return { ...(yield configureRepo(repo, options)),\n        isNew: false\n      };\n    }\n\n    try {\n      yield repo.open();\n      return { ...(yield configureRepo(repo, options)),\n        isNew: false\n      };\n    } catch (err) {\n      if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n        throw err;\n      }\n\n      if (options.init && options.init.allowNew === false) {\n        throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n      }\n\n      return { ...(yield initRepo(print, repo, options)),\n        isNew: true\n      };\n    }\n  });\n\n  return function loadRepo(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst initRepo = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (print, repo, options) {\n    const initOptions = options.init || {}; // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n\n    const exists = yield repo.exists();\n    log('repo exists?', exists);\n\n    if (exists === true) {\n      throw new Error('repo already exists');\n    } // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n\n\n    const peerId = initOptions.privateKey ? yield decodePeerId(initOptions.privateKey) : yield initPeerId(print, initOptions);\n    const identity = peerIdToIdentity(peerId);\n    log('peer identity: %s', identity.PeerID); // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n\n    const config = { ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n      Identity: identity\n    };\n    yield repo.init(config); // 4. Open initialized repo.\n\n    yield repo.open();\n    log('repo opened');\n    /** @type {import('./libp2p').KeychainConfig} */\n\n    const keychainConfig = {\n      pass: options.pass\n    };\n\n    try {\n      keychainConfig.dek = yield repo.config.get('Keychain.DEK');\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    } // Create libp2p for Keychain creation\n\n\n    const libp2p = yield createLibP2P({\n      options: undefined,\n      multiaddrs: undefined,\n      peerId,\n      repo,\n      config,\n      keychainConfig\n    });\n\n    if (libp2p.keychain && libp2p.keychain.opts) {\n      yield libp2p.loadKeychain();\n      yield repo.config.set('Keychain', {\n        DEK: libp2p.keychain.opts.dek\n      });\n    }\n\n    return {\n      peerId,\n      keychain: libp2p.keychain\n    };\n  });\n\n  return function initRepo(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\n\n\nconst decodePeerId = peerId => {\n  log('using user-supplied private-key');\n  return typeof peerId === 'object' ? peerId : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'));\n};\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\n\n\nconst initPeerId = (print, {\n  algorithm = 'Ed25519',\n  bits = 2048\n}) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm);\n  return PeerId.create({\n    keyType: algorithm,\n    bits\n  });\n};\n/**\n * @param {PeerId} peerId\n */\n\n\nconst peerIdToIdentity = peerId => ({\n  PeerID: peerId.toB58String(),\n\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n});\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst configureRepo = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (repo, options) {\n    const config = options.config;\n    const profiles = options.init && options.init.profiles || [];\n    const pass = options.pass;\n    const original = yield repo.config.getAll();\n    const changed = mergeConfigs(applyProfiles(original, profiles), config);\n\n    if (original !== changed) {\n      yield repo.config.replace(changed);\n    }\n\n    if (!changed.Identity || !changed.Identity.PrivKey) {\n      throw new NotInitializedError('No private key was found in the config, please intialize the repo');\n    }\n\n    const peerId = yield PeerId.createFromPrivKey(changed.Identity.PrivKey);\n    const libp2p = yield createLibP2P({\n      options: undefined,\n      multiaddrs: undefined,\n      peerId,\n      repo,\n      config: changed,\n      keychainConfig: {\n        pass,\n        ...changed.Keychain\n      }\n    });\n\n    if (libp2p.keychain) {\n      yield libp2p.loadKeychain();\n    }\n\n    return {\n      peerId,\n      keychain: libp2p.keychain\n    };\n  });\n\n  return function configureRepo(_x7, _x8) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\n\n\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\n\n\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name];\n\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`);\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};","map":null,"metadata":{},"sourceType":"script"}