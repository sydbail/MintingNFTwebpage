{"ast":null,"code":"'use strict';\n/**\n * Stop iteration after n items have been received.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n * @param {number} limit\n * @returns {AsyncIterable<T>}\n */\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst take = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (source, limit) {\n    let items = 0;\n\n    if (limit < 1) {\n      return;\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const entry = _value;\n        yield entry;\n        items++;\n\n        if (items === limit) {\n          return;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n\n  return function take(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = take;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/it-take/index.js"],"names":["take","source","limit","items","entry","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACA,MAAMA,IAAI;AAAA,iCAAG,WAAkBC,MAAlB,EAA0BC,KAA1B,EAAiC;AAC5C,QAAIC,KAAK,GAAG,CAAZ;;AAEA,QAAID,KAAK,GAAG,CAAZ,EAAe;AACb;AACD;;AAL2C;AAAA;;AAAA;;AAAA;AAO5C,0CAA0BD,MAA1B,gOAAkC;AAAA,cAAjBG,KAAiB;AAChC,cAAMA,KAAN;AAEAD,QAAAA,KAAK;;AAEL,YAAIA,KAAK,KAAKD,KAAd,EAAqB;AACnB;AACD;AACF;AAf2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgB7C,GAhBS;;AAAA,kBAAJF,IAAI;AAAA;AAAA;AAAA,GAAV;;AAkBAK,MAAM,CAACC,OAAP,GAAiBN,IAAjB","sourcesContent":["'use strict'\n\n/**\n * Stop iteration after n items have been received.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n * @param {number} limit\n * @returns {AsyncIterable<T>}\n */\nconst take = async function * (source, limit) {\n  let items = 0\n\n  if (limit < 1) {\n    return\n  }\n\n  for await (const entry of source) {\n    yield entry\n\n    items++\n\n    if (items === limit) {\n      return\n    }\n  }\n}\n\nmodule.exports = take\n"]},"metadata":{},"sourceType":"script"}