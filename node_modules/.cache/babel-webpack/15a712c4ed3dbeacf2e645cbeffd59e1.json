{"ast":null,"code":"/* eslint-disable no-unreachable */\n'use strict'; // @ts-ignore\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst {\n  default: parseDuration\n} = require('parse-duration');\n\nconst {\n  TimeoutError\n} = require('./errors');\n/**\n * @template {any[]} Args\n * @template {Promise<any> | AsyncIterable<any>} R - The return type of `fn`\n * @param {(...args:Args) => R} fn\n * @param {number} [optionsArgIndex]\n * @returns {(...args:Args) => R}\n */\n\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  // eslint-disable-next-line\n  return (\n    /** @returns {R} */\n    (\n    /** @type {Args} */\n    ...args) => {\n      const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n      if (!options || !options.timeout) return fn(...args);\n      const timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n      const controller = new TimeoutController(timeout);\n      options.signal = anySignal([options.signal, controller.signal]);\n      const fnRes = fn(...args); // eslint-disable-next-line promise/param-names\n\n      const timeoutPromise = new Promise((_resolve, reject) => {\n        controller.signal.addEventListener('abort', () => {\n          reject(new TimeoutError());\n        });\n      });\n      const start = Date.now();\n\n      const maybeThrowTimeoutError = () => {\n        if (controller.signal.aborted) {\n          throw new TimeoutError();\n        }\n\n        const timeTaken = Date.now() - start; // if we have starved the event loop by adding microtasks, we could have\n        // timed out already but the TimeoutController will never know because it's\n        // setTimeout will not fire until we stop adding microtasks\n\n        if (timeTaken > timeout) {\n          controller.abort();\n          throw new TimeoutError();\n        }\n      }; // @ts-ignore\n\n\n      if (fnRes[Symbol.asyncIterator]) {\n        // @ts-ignore\n        return _wrapAsyncGenerator(function* () {\n          // @ts-ignore\n          const it = fnRes[Symbol.asyncIterator]();\n\n          try {\n            while (true) {\n              const {\n                value,\n                done\n              } = yield _awaitAsyncGenerator(Promise.race([it.next(), timeoutPromise]));\n\n              if (done) {\n                break;\n              }\n\n              maybeThrowTimeoutError();\n              yield value;\n            }\n          } catch (err) {\n            maybeThrowTimeoutError();\n            throw err;\n          } finally {\n            controller.clear();\n\n            if (it.return) {\n              it.return();\n            }\n          }\n        })();\n      } // @ts-ignore\n\n\n      return _asyncToGenerator(function* () {\n        try {\n          const res = yield Promise.race([fnRes, timeoutPromise]);\n          maybeThrowTimeoutError();\n          return res;\n        } catch (err) {\n          maybeThrowTimeoutError();\n          throw err;\n        } finally {\n          controller.clear();\n        }\n      })();\n    }\n  );\n}\n\nmodule.exports = withTimeoutOption;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core-utils/src/with-timeout-option.js"],"names":["TimeoutController","require","anySignal","default","parseDuration","TimeoutError","withTimeoutOption","fn","optionsArgIndex","args","options","length","timeout","controller","signal","fnRes","timeoutPromise","Promise","_resolve","reject","addEventListener","start","Date","now","maybeThrowTimeoutError","aborted","timeTaken","abort","Symbol","asyncIterator","it","value","done","race","next","err","clear","return","res","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-unreachable */\n'use strict'\n\n// @ts-ignore\nconst TimeoutController = require('timeout-abort-controller')\nconst { anySignal } = require('any-signal')\nconst { default: parseDuration } = require('parse-duration')\nconst { TimeoutError } = require('./errors')\n\n/**\n * @template {any[]} Args\n * @template {Promise<any> | AsyncIterable<any>} R - The return type of `fn`\n * @param {(...args:Args) => R} fn\n * @param {number} [optionsArgIndex]\n * @returns {(...args:Args) => R}\n */\nfunction withTimeoutOption (fn, optionsArgIndex) {\n  // eslint-disable-next-line\n  return /** @returns {R} */(/** @type {Args} */...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex]\n    if (!options || !options.timeout) return fn(...args)\n\n    const timeout = typeof options.timeout === 'string'\n      ? parseDuration(options.timeout)\n      : options.timeout\n\n    const controller = new TimeoutController(timeout)\n\n    options.signal = anySignal([options.signal, controller.signal])\n\n    const fnRes = fn(...args)\n    // eslint-disable-next-line promise/param-names\n    const timeoutPromise = new Promise((_resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new TimeoutError())\n      })\n    })\n\n    const start = Date.now()\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new TimeoutError()\n      }\n\n      const timeTaken = Date.now() - start\n\n      // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n      if (timeTaken > timeout) {\n        controller.abort()\n        throw new TimeoutError()\n      }\n    }\n\n    // @ts-ignore\n    if (fnRes[Symbol.asyncIterator]) {\n      // @ts-ignore\n      return (async function * () {\n        // @ts-ignore\n        const it = fnRes[Symbol.asyncIterator]()\n\n        try {\n          while (true) {\n            const { value, done } = await Promise.race([it.next(), timeoutPromise])\n\n            if (done) {\n              break\n            }\n\n            maybeThrowTimeoutError()\n\n            yield value\n          }\n        } catch (err) {\n          maybeThrowTimeoutError()\n\n          throw err\n        } finally {\n          controller.clear()\n\n          if (it.return) {\n            it.return()\n          }\n        }\n      })()\n    }\n\n    // @ts-ignore\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise])\n\n        maybeThrowTimeoutError()\n\n        return res\n      } catch (err) {\n        maybeThrowTimeoutError()\n\n        throw err\n      } finally {\n        controller.clear()\n      }\n    })()\n  }\n}\n\nmodule.exports = withTimeoutOption\n"]},"metadata":{},"sourceType":"script"}