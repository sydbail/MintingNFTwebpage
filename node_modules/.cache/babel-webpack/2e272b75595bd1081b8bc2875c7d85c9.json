{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAllSources = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"compile-common:profiler:resolveAllSources\");\n\nconst getImports_1 = require(\"./getImports\"); // Resolves sources in several async passes. For each resolved set it detects unknown\n// imports from external packages and adds them to the set of files to resolve.\n\n\nfunction resolveAllSources({\n  resolve,\n  paths,\n  shouldIncludePath,\n  parseImports\n}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const mapping = {};\n    const allPaths = paths.slice();\n    debug(\"resolveAllSources called\"); // Begin generateMapping\n\n    function generateMapping() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const promises = []; // Dequeue all the known paths, generating resolver promises,\n        // We'll add paths if we discover external package imports.\n\n        while (allPaths.length) {\n          let filePath;\n          let importedFrom = null;\n          const candidate = allPaths.shift(); // Some paths will have been extracted as imports from a file\n          // and have information about their parent location we need to track.\n\n          if (typeof candidate === \"object\") {\n            filePath = candidate.filePath;\n            importedFrom = candidate.importedFrom;\n          } else {\n            filePath = candidate;\n          }\n\n          promises.push(resolve({\n            filePath,\n            importedFrom\n          }));\n        } // Resolve everything known and add it to the map, then inspect each file's\n        // imports and add those to the list of paths to resolve if we don't have it.\n\n\n        const results = yield Promise.all(promises); // Queue unknown imports for the next resolver cycle\n\n        while (results.length) {\n          const source = results.shift();\n\n          if (!source || mapping[source.filePath]) {\n            //skip ones that couldn't be resolved, or are already recorded\n            continue;\n          }\n\n          const imports = shouldIncludePath(source.filePath) ? yield getImports_1.getImports({\n            source,\n            parseImports,\n            shouldIncludePath\n          }) : [];\n          debug(\"imports: %O\", imports); // Generate the sources mapping\n\n          mapping[source.filePath] = Object.assign(Object.assign({}, source), {\n            imports\n          }); // Detect unknown external packages / add them to the list of files to resolve\n          // Keep track of location of this import because we need to report that.\n\n          for (const item of imports) {\n            if (!mapping[item]) {\n              allPaths.push({\n                filePath: item,\n                importedFrom: source.filePath\n              });\n            }\n          }\n        }\n      });\n    } // End generateMapping\n\n\n    while (allPaths.length) {\n      yield generateMapping();\n    }\n\n    return mapping;\n  });\n}\n\nexports.resolveAllSources = resolveAllSources;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/@truffle/compile-common/dist/src/profiler/resolveAllSources.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","resolveAllSources","debug_1","require","debug","default","getImports_1","paths","shouldIncludePath","parseImports","mapping","allPaths","slice","generateMapping","promises","length","filePath","importedFrom","candidate","shift","push","results","all","source","imports","getImports","assign","item"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveAllSources = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"compile-common:profiler:resolveAllSources\");\nconst getImports_1 = require(\"./getImports\");\n// Resolves sources in several async passes. For each resolved set it detects unknown\n// imports from external packages and adds them to the set of files to resolve.\nfunction resolveAllSources({ resolve, paths, shouldIncludePath, parseImports }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const mapping = {};\n        const allPaths = paths.slice();\n        debug(\"resolveAllSources called\");\n        // Begin generateMapping\n        function generateMapping() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const promises = [];\n                // Dequeue all the known paths, generating resolver promises,\n                // We'll add paths if we discover external package imports.\n                while (allPaths.length) {\n                    let filePath;\n                    let importedFrom = null;\n                    const candidate = allPaths.shift();\n                    // Some paths will have been extracted as imports from a file\n                    // and have information about their parent location we need to track.\n                    if (typeof candidate === \"object\") {\n                        filePath = candidate.filePath;\n                        importedFrom = candidate.importedFrom;\n                    }\n                    else {\n                        filePath = candidate;\n                    }\n                    promises.push(resolve({ filePath, importedFrom }));\n                }\n                // Resolve everything known and add it to the map, then inspect each file's\n                // imports and add those to the list of paths to resolve if we don't have it.\n                const results = yield Promise.all(promises);\n                // Queue unknown imports for the next resolver cycle\n                while (results.length) {\n                    const source = results.shift();\n                    if (!source || mapping[source.filePath]) {\n                        //skip ones that couldn't be resolved, or are already recorded\n                        continue;\n                    }\n                    const imports = shouldIncludePath(source.filePath)\n                        ? yield getImports_1.getImports({ source, parseImports, shouldIncludePath })\n                        : [];\n                    debug(\"imports: %O\", imports);\n                    // Generate the sources mapping\n                    mapping[source.filePath] = Object.assign(Object.assign({}, source), { imports });\n                    // Detect unknown external packages / add them to the list of files to resolve\n                    // Keep track of location of this import because we need to report that.\n                    for (const item of imports) {\n                        if (!mapping[item]) {\n                            allPaths.push({ filePath: item, importedFrom: source.filePath });\n                        }\n                    }\n                }\n            });\n        }\n        // End generateMapping\n        while (allPaths.length) {\n            yield generateMapping();\n        }\n        return mapping;\n    });\n}\nexports.resolveAllSources = resolveAllSources;\n"]},"metadata":{},"sourceType":"script"}