{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncGeneratorDelegate from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\n\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n\n  const cid = CID.asCID(path);\n\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\nexport function walkPath(_x, _x2) {\n  return _walkPath.apply(this, arguments);\n}\n\nfunction _walkPath() {\n  _walkPath = _wrapAsyncGenerator(function* (path, blockstore, options = {}) {\n    let {\n      cid,\n      toResolve\n    } = cidAndRest(path);\n    let name = cid.toString();\n    let entryPath = name;\n    const startingDepth = toResolve.length;\n\n    while (true) {\n      const result = yield _awaitAsyncGenerator(resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options));\n\n      if (!result.entry && !result.next) {\n        throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n      }\n\n      if (result.entry) {\n        yield result.entry;\n      }\n\n      if (!result.next) {\n        return;\n      }\n\n      toResolve = result.next.toResolve;\n      cid = result.next.cid;\n      name = result.next.name;\n      entryPath = result.next.path;\n    }\n  });\n  return _walkPath.apply(this, arguments);\n}\n\nexport function exporter(_x7, _x8) {\n  return _exporter.apply(this, arguments);\n}\n\nfunction _exporter() {\n  _exporter = _asyncToGenerator(function* (path, blockstore, options = {}) {\n    const result = yield last(walkPath(path, blockstore, options));\n\n    if (!result) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    return result;\n  });\n  return _exporter.apply(this, arguments);\n}\n\nexport function recursive(_x3, _x4) {\n  return _recursive.apply(this, arguments);\n}\n\nfunction _recursive() {\n  _recursive = _wrapAsyncGenerator(function* (path, blockstore, options = {}) {\n    const node = yield _awaitAsyncGenerator(exporter(path, blockstore, options));\n\n    if (!node) {\n      return;\n    }\n\n    yield node;\n\n    if (node.type === 'directory') {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(recurse(node, options)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const child = _value;\n          yield child;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    function recurse(_x5, _x6) {\n      return _recurse.apply(this, arguments);\n    }\n\n    function _recurse() {\n      _recurse = _wrapAsyncGenerator(function* (node, options) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n\n        var _iteratorError2;\n\n        try {\n          for (var _iterator2 = _asyncIterator(node.content(options)), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n            const file = _value2;\n            yield file;\n\n            if (file instanceof Uint8Array) {\n              continue;\n            }\n\n            if (file.type === 'directory') {\n              yield* _asyncGeneratorDelegate(_asyncIterator(recurse(file, options)), _awaitAsyncGenerator);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              yield _awaitAsyncGenerator(_iterator2.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      });\n      return _recurse.apply(this, arguments);\n    }\n  });\n  return _recursive.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}