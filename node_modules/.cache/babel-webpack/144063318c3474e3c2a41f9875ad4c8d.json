{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sparseArray = void 0;\n\nconst nat_1 = require(\"../../arbitrary/nat\");\n\nconst set_1 = require(\"../../arbitrary/set\");\n\nconst tuple_1 = require(\"../../arbitrary/tuple\");\n\nconst MaxLengthFromMinLength_1 = require(\"../../arbitrary/_internals/helpers/MaxLengthFromMinLength\");\n\nfunction extractMaxIndex(indexesAndValues) {\n  let maxIndex = -1;\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n\n  return maxIndex;\n}\n\nfunction arrayFromItems(length, indexesAndValues) {\n  const array = Array(length);\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    const it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n\n  return array;\n}\n\nfunction sparseArray(arb, constraints = {}) {\n  const {\n    minNumElements = 0,\n    maxNumElements = MaxLengthFromMinLength_1.maxLengthFromMinLength(minNumElements),\n    maxLength = Math.min(MaxLengthFromMinLength_1.maxLengthFromMinLength(maxNumElements), 4294967295),\n    noTrailingHole\n  } = constraints;\n\n  if (minNumElements > maxLength) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n  }\n\n  if (minNumElements > maxNumElements) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n  }\n\n  const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n\n  if (noTrailingHole) {\n    const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n    return set_1.set(tuple_1.tuple(nat_1.nat(maxIndexAuthorized), arb), {\n      minLength: minNumElements,\n      maxLength: resultedMaxNumElements,\n      compare: (itemA, itemB) => itemA[0] === itemB[0]\n    }).map(items => {\n      const lastIndex = extractMaxIndex(items);\n      return arrayFromItems(lastIndex + 1, items);\n    });\n  }\n\n  return set_1.set(tuple_1.tuple(nat_1.nat(maxLength), arb), {\n    minLength: minNumElements + 1,\n    maxLength: resultedMaxNumElements + 1,\n    compare: (itemA, itemB) => itemA[0] === itemB[0]\n  }).map(items => {\n    const length = extractMaxIndex(items);\n    return arrayFromItems(length, items);\n  });\n}\n\nexports.sparseArray = sparseArray;","map":null,"metadata":{},"sourceType":"script"}