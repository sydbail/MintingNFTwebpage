{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TupleArbitrary = void 0;\n\nconst Stream_1 = require(\"../../stream/Stream\");\n\nconst symbols_1 = require(\"../../check/symbols\");\n\nconst NextArbitrary_1 = require(\"../../check/arbitrary/definition/NextArbitrary\");\n\nconst NextValue_1 = require(\"../../check/arbitrary/definition/NextValue\");\n\nclass TupleArbitrary extends NextArbitrary_1.NextArbitrary {\n  constructor(arbs) {\n    super();\n    this.arbs = arbs;\n\n    for (let idx = 0; idx !== arbs.length; ++idx) {\n      const arb = arbs[idx];\n      if (arb == null || arb.generate == null) throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n    }\n  }\n\n  static makeItCloneable(vs, values) {\n    return Object.defineProperty(vs, symbols_1.cloneMethod, {\n      value: () => {\n        const cloned = [];\n\n        for (let idx = 0; idx !== values.length; ++idx) {\n          cloned.push(values[idx].value);\n        }\n\n        TupleArbitrary.makeItCloneable(cloned, values);\n        return cloned;\n      }\n    });\n  }\n\n  static wrapper(values) {\n    let cloneable = false;\n    const vs = [];\n    const ctxs = [];\n\n    for (let idx = 0; idx !== values.length; ++idx) {\n      const v = values[idx];\n      cloneable = cloneable || v.hasToBeCloned;\n      vs.push(v.value);\n      ctxs.push(v.context);\n    }\n\n    if (cloneable) {\n      TupleArbitrary.makeItCloneable(vs, values);\n    }\n\n    return new NextValue_1.NextValue(vs, ctxs);\n  }\n\n  generate(mrng, biasFactor) {\n    return TupleArbitrary.wrapper(this.arbs.map(a => a.generate(mrng, biasFactor)));\n  }\n\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || value.length !== this.arbs.length) {\n      return false;\n    }\n\n    for (let index = 0; index !== this.arbs.length; ++index) {\n      if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  shrink(value, context) {\n    let s = Stream_1.Stream.nil();\n    const safeContext = Array.isArray(context) ? context : [];\n\n    for (let idx = 0; idx !== this.arbs.length; ++idx) {\n      const shrinksForIndex = this.arbs[idx].shrink(value[idx], safeContext[idx]).map(v => {\n        const nextValues = value.map((v, idx) => new NextValue_1.NextValue(symbols_1.cloneIfNeeded(v), safeContext[idx]));\n        return nextValues.slice(0, idx).concat([v]).concat(nextValues.slice(idx + 1));\n      }).map(values => TupleArbitrary.wrapper(values));\n      s = s.join(shrinksForIndex);\n    }\n\n    return s;\n  }\n\n}\n\nexports.TupleArbitrary = TupleArbitrary;","map":null,"metadata":{},"sourceType":"script"}