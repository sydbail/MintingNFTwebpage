{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst c = require('../constants');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nconst Record = libp2pRecord.Record;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\n\nmodule.exports = dht => {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  const putLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (key, rec) {\n      // eslint-disable-line require-await\n      return dht.datastore.put(utils.bufferToKey(key), rec);\n    });\n\n    return function putLocal(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  const getLocal = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (key) {\n      dht._log(`getLocal ${uint8ArrayToString(key, 'base32')}`);\n\n      const raw = yield dht.datastore.get(utils.bufferToKey(key));\n\n      dht._log(`found ${uint8ArrayToString(key, 'base32')} in local datastore`);\n\n      const rec = Record.deserialize(raw);\n      yield dht._verifyRecordLocally(rec);\n      return rec;\n    });\n\n    return function getLocal(_x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n\n\n  const sendCorrectionRecord = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* (key, vals, best) {\n      const fixupRec = yield utils.createPutRecord(key, best);\n      return Promise.all(vals.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (v) {\n          // no need to do anything\n          if (uint8ArrayEquals(v.val, best)) {\n            return;\n          } // correct ourself\n\n\n          if (dht._isSelf(v.from)) {\n            try {\n              yield dht._putLocal(key, fixupRec);\n            } catch (err) {\n              dht._log.error('Failed error correcting self', err);\n            }\n\n            return;\n          } // send correction\n\n\n          try {\n            yield dht._putValueToPeer(key, fixupRec, v.from);\n          } catch (err) {\n            dht._log.error('Failed error correcting entry', err);\n          }\n        });\n\n        return function (_x7) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n    });\n\n    return function sendCorrectionRecord(_x4, _x5, _x6) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    _putLocal(key, rec) {\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        return putLocal(key, rec);\n      })();\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    put(key, value, options = {}) {\n      return _asyncToGenerator(function* () {\n        dht._log('PutValue %b', key); // create record in the dht format\n\n\n        const record = yield utils.createPutRecord(key, value); // store the record locally\n\n        yield putLocal(key, record); // put record to the closest peers\n\n        let counterAll = 0;\n        let counterSuccess = 0;\n        yield utils.mapParallel(dht.getClosestPeers(key, {\n          shallow: true\n        }), /*#__PURE__*/function () {\n          var _ref5 = _asyncToGenerator(function* (peer) {\n            try {\n              counterAll += 1;\n              yield dht._putValueToPeer(key, record, peer);\n              counterSuccess += 1;\n            } catch (err) {\n              dht._log.error('Failed to put to peer (%b): %s', peer.id, err);\n            }\n          });\n\n          return function (_x8) {\n            return _ref5.apply(this, arguments);\n          };\n        }()); // verify if we were able to put to enough peers\n\n        const minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`\n\n        if (minPeers > counterSuccess) {\n          const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n          dht._log.error(error);\n\n          throw error;\n        }\n      })();\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    get(key, options = {}) {\n      return _asyncToGenerator(function* () {\n        options.timeout = options.timeout || c.minute;\n\n        dht._log('_get %b', key);\n\n        const vals = yield dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);\n        const recs = vals.map(v => v.val);\n        let i = 0;\n\n        try {\n          i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n        } catch (err) {\n          // Assume the first record if no selector available\n          if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n            throw err;\n          }\n        }\n\n        const best = recs[i];\n\n        dht._log('GetValue %b %s', key, best);\n\n        if (!best) {\n          throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n        }\n\n        yield sendCorrectionRecord(key, vals, best);\n        return best;\n      })();\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    getMany(key, nvals, options = {}) {\n      return _asyncToGenerator(function* () {\n        options.timeout = options.timeout || c.minute;\n\n        dht._log('getMany %b (%s)', key, nvals);\n\n        const vals = [];\n        let localRec;\n\n        try {\n          localRec = yield getLocal(key);\n        } catch (err) {\n          if (nvals === 0) {\n            throw err;\n          }\n        }\n\n        if (localRec) {\n          vals.push({\n            val: localRec.value,\n            from: dht.peerId\n          });\n        }\n\n        if (vals.length >= nvals) {\n          return vals;\n        }\n\n        const id = yield utils.convertBuffer(key);\n        const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize);\n\n        dht._log('peers in rt: %d', rtp.length);\n\n        if (rtp.length === 0) {\n          const errMsg = 'Failed to lookup key! No peers from routing table!';\n\n          dht._log.error(errMsg);\n\n          if (vals.length === 0) {\n            throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n          }\n\n          return vals;\n        }\n\n        const valsLength = vals.length;\n        /**\n         * @param {number} pathIndex\n         * @param {number} numPaths\n         */\n\n        function createQuery(pathIndex, numPaths) {\n          // This function body runs once per disjoint path\n          const pathSize = utils.pathSize(nvals - valsLength, numPaths);\n          let queryResults = 0;\n          /**\n           * Here we return the query function to use on this particular disjoint path\n           *\n           * @param {PeerId} peer\n           */\n\n          function disjointPathQuery(_x9) {\n            return _disjointPathQuery.apply(this, arguments);\n          }\n\n          function _disjointPathQuery() {\n            _disjointPathQuery = _asyncToGenerator(function* (peer) {\n              let rec, peers, lookupErr;\n\n              try {\n                const results = yield dht._getValueOrPeers(peer, key);\n                rec = results.record;\n                peers = results.peers;\n              } catch (err) {\n                // If we have an invalid record we just want to continue and fetch a new one.\n                if (err.code !== 'ERR_INVALID_RECORD') {\n                  throw err;\n                }\n\n                lookupErr = err;\n              }\n              /** @type {import('../query').QueryResult} */\n\n\n              const res = {\n                closerPeers: peers\n              };\n\n              if (rec && rec.value) {\n                vals.push({\n                  val: rec.value,\n                  from: peer\n                });\n                queryResults++;\n              } else if (lookupErr) {\n                vals.push({\n                  err: lookupErr,\n                  from: peer\n                });\n                queryResults++;\n              } // enough is enough\n\n\n              if (queryResults >= pathSize) {\n                res.pathComplete = true;\n              }\n\n              return res;\n            });\n            return _disjointPathQuery.apply(this, arguments);\n          }\n\n          return disjointPathQuery;\n        } // we have peers, lets send the actual query to them\n\n\n        const query = new Query(dht, key, createQuery);\n\n        try {\n          yield pTimeout(query.run(rtp), options.timeout);\n        } catch (err) {\n          if (vals.length === 0) {\n            throw err;\n          }\n        } finally {\n          query.stop();\n        }\n\n        return vals;\n      })();\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p-kad-dht/src/content-fetching/index.js"],"names":["errcode","require","pTimeout","equals","uint8ArrayEquals","toString","uint8ArrayToString","libp2pRecord","c","Query","utils","Record","module","exports","dht","putLocal","key","rec","datastore","put","bufferToKey","getLocal","_log","raw","get","deserialize","_verifyRecordLocally","sendCorrectionRecord","vals","best","fixupRec","createPutRecord","Promise","all","map","v","val","_isSelf","from","_putLocal","err","error","_putValueToPeer","value","options","record","counterAll","counterSuccess","mapParallel","getClosestPeers","shallow","peer","id","minPeers","Error","timeout","minute","getMany","GET_MANY_RECORD_COUNT","recs","i","selection","bestRecord","selectors","code","nvals","localRec","push","peerId","length","convertBuffer","rtp","routingTable","closestPeers","kBucketSize","errMsg","valsLength","createQuery","pathIndex","numPaths","pathSize","queryResults","disjointPathQuery","peers","lookupErr","results","_getValueOrPeers","res","closerPeers","pathComplete","query","run","stop"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst libp2pRecord = require('libp2p-record')\nconst c = require('../constants')\nconst Query = require('../query')\nconst utils = require('../utils')\nconst Record = libp2pRecord.Record\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  const putLocal = async (key, rec) => { // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec)\n  }\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n  const getLocal = async (key) => {\n    dht._log(`getLocal ${uint8ArrayToString(key, 'base32')}`)\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key))\n    dht._log(`found ${uint8ArrayToString(key, 'base32')} in local datastore`)\n\n    const rec = Record.deserialize(raw)\n\n    await dht._verifyRecordLocally(rec)\n\n    return rec\n  }\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best)\n\n    return Promise.all(vals.map(async (v) => {\n      // no need to do anything\n      if (uint8ArrayEquals(v.val, best)) {\n        return\n      }\n\n      // correct ourself\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec)\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err)\n        }\n        return\n      }\n\n      // send correction\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from)\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err)\n      }\n    }))\n  }\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    async _putLocal (key, rec) { // eslint-disable-line require-await\n      return putLocal(key, rec)\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    async put (key, value, options = {}) {\n      dht._log('PutValue %b', key)\n\n      // create record in the dht format\n      const record = await utils.createPutRecord(key, value)\n\n      // store the record locally\n      await putLocal(key, record)\n\n      // put record to the closest peers\n      let counterAll = 0\n      let counterSuccess = 0\n\n      await utils.mapParallel(dht.getClosestPeers(key, { shallow: true }), async (peer) => {\n        try {\n          counterAll += 1\n          await dht._putValueToPeer(key, record, peer)\n          counterSuccess += 1\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err)\n        }\n      })\n\n      // verify if we were able to put to enough peers\n      const minPeers = options.minPeers || counterAll // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS')\n        dht._log.error(error)\n        throw error\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async get (key, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('_get %b', key)\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options)\n      const recs = vals.map((v) => v.val)\n      let i = 0\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err\n        }\n      }\n\n      const best = recs[i]\n      dht._log('GetValue %b %s', key, best)\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n      }\n\n      await sendCorrectionRecord(key, vals, best)\n\n      return best\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async getMany (key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('getMany %b (%s)', key, nvals)\n\n      const vals = []\n      let localRec\n\n      try {\n        localRec = await getLocal(key)\n      } catch (err) {\n        if (nvals === 0) {\n          throw err\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        })\n      }\n\n      if (vals.length >= nvals) {\n        return vals\n      }\n\n      const id = await utils.convertBuffer(key)\n      const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      dht._log('peers in rt: %d', rtp.length)\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!'\n\n        dht._log.error(errMsg)\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE')\n        }\n        return vals\n      }\n\n      const valsLength = vals.length\n\n      /**\n       * @param {number} pathIndex\n       * @param {number} numPaths\n       */\n      function createQuery (pathIndex, numPaths) {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - valsLength, numPaths)\n        let queryResults = 0\n\n        /**\n         * Here we return the query function to use on this particular disjoint path\n         *\n         * @param {PeerId} peer\n         */\n        async function disjointPathQuery (peer) {\n          let rec, peers, lookupErr\n          try {\n            const results = await dht._getValueOrPeers(peer, key)\n            rec = results.record\n            peers = results.peers\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err\n            }\n            lookupErr = err\n          }\n\n          /** @type {import('../query').QueryResult} */\n          const res = {\n            closerPeers: peers\n          }\n\n          if (rec && rec.value) {\n            vals.push({\n              val: rec.value,\n              from: peer\n            })\n\n            queryResults++\n          } else if (lookupErr) {\n            vals.push({\n              err: lookupErr,\n              from: peer\n            })\n\n            queryResults++\n          }\n\n          // enough is enough\n          if (queryResults >= pathSize) {\n            res.pathComplete = true\n          }\n\n          return res\n        }\n\n        return disjointPathQuery\n      }\n\n      // we have peers, lets send the actual query to them\n      const query = new Query(dht, key, createQuery)\n\n      try {\n        await pTimeout(query.run(rtp), options.timeout)\n      } catch (err) {\n        if (vals.length === 0) {\n          throw err\n        }\n      } finally {\n        query.stop()\n      }\n\n      return vals\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}