{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-envelope\"] || ($protobuf.roots[\"libp2p-envelope\"] = {});\n\n$root.Envelope = function () {\n  /**\n   * Properties of an Envelope.\n   * @exports IEnvelope\n   * @interface IEnvelope\n   * @property {Uint8Array|null} [publicKey] Envelope publicKey\n   * @property {Uint8Array|null} [payloadType] Envelope payloadType\n   * @property {Uint8Array|null} [payload] Envelope payload\n   * @property {Uint8Array|null} [signature] Envelope signature\n   */\n\n  /**\n   * Constructs a new Envelope.\n   * @exports Envelope\n   * @classdesc Represents an Envelope.\n   * @implements IEnvelope\n   * @constructor\n   * @param {IEnvelope=} [p] Properties to set\n   */\n  function Envelope(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Envelope publicKey.\n   * @member {Uint8Array} publicKey\n   * @memberof Envelope\n   * @instance\n   */\n\n\n  Envelope.prototype.publicKey = $util.newBuffer([]);\n  /**\n   * Envelope payloadType.\n   * @member {Uint8Array} payloadType\n   * @memberof Envelope\n   * @instance\n   */\n\n  Envelope.prototype.payloadType = $util.newBuffer([]);\n  /**\n   * Envelope payload.\n   * @member {Uint8Array} payload\n   * @memberof Envelope\n   * @instance\n   */\n\n  Envelope.prototype.payload = $util.newBuffer([]);\n  /**\n   * Envelope signature.\n   * @member {Uint8Array} signature\n   * @memberof Envelope\n   * @instance\n   */\n\n  Envelope.prototype.signature = $util.newBuffer([]);\n  /**\n   * Encodes the specified Envelope message. Does not implicitly {@link Envelope.verify|verify} messages.\n   * @function encode\n   * @memberof Envelope\n   * @static\n   * @param {IEnvelope} m Envelope message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Envelope.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.publicKey != null && Object.hasOwnProperty.call(m, \"publicKey\")) w.uint32(10).bytes(m.publicKey);\n    if (m.payloadType != null && Object.hasOwnProperty.call(m, \"payloadType\")) w.uint32(18).bytes(m.payloadType);\n    if (m.payload != null && Object.hasOwnProperty.call(m, \"payload\")) w.uint32(26).bytes(m.payload);\n    if (m.signature != null && Object.hasOwnProperty.call(m, \"signature\")) w.uint32(42).bytes(m.signature);\n    return w;\n  };\n  /**\n   * Decodes an Envelope message from the specified reader or buffer.\n   * @function decode\n   * @memberof Envelope\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Envelope} Envelope\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Envelope.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Envelope();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.publicKey = r.bytes();\n          break;\n\n        case 2:\n          m.payloadType = r.bytes();\n          break;\n\n        case 3:\n          m.payload = r.bytes();\n          break;\n\n        case 5:\n          m.signature = r.bytes();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates an Envelope message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Envelope\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Envelope} Envelope\n   */\n\n\n  Envelope.fromObject = function fromObject(d) {\n    if (d instanceof $root.Envelope) return d;\n    var m = new $root.Envelope();\n\n    if (d.publicKey != null) {\n      if (typeof d.publicKey === \"string\") $util.base64.decode(d.publicKey, m.publicKey = $util.newBuffer($util.base64.length(d.publicKey)), 0);else if (d.publicKey.length) m.publicKey = d.publicKey;\n    }\n\n    if (d.payloadType != null) {\n      if (typeof d.payloadType === \"string\") $util.base64.decode(d.payloadType, m.payloadType = $util.newBuffer($util.base64.length(d.payloadType)), 0);else if (d.payloadType.length) m.payloadType = d.payloadType;\n    }\n\n    if (d.payload != null) {\n      if (typeof d.payload === \"string\") $util.base64.decode(d.payload, m.payload = $util.newBuffer($util.base64.length(d.payload)), 0);else if (d.payload.length) m.payload = d.payload;\n    }\n\n    if (d.signature != null) {\n      if (typeof d.signature === \"string\") $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);else if (d.signature.length) m.signature = d.signature;\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from an Envelope message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Envelope\n   * @static\n   * @param {Envelope} m Envelope\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Envelope.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.defaults) {\n      if (o.bytes === String) d.publicKey = \"\";else {\n        d.publicKey = [];\n        if (o.bytes !== Array) d.publicKey = $util.newBuffer(d.publicKey);\n      }\n      if (o.bytes === String) d.payloadType = \"\";else {\n        d.payloadType = [];\n        if (o.bytes !== Array) d.payloadType = $util.newBuffer(d.payloadType);\n      }\n      if (o.bytes === String) d.payload = \"\";else {\n        d.payload = [];\n        if (o.bytes !== Array) d.payload = $util.newBuffer(d.payload);\n      }\n      if (o.bytes === String) d.signature = \"\";else {\n        d.signature = [];\n        if (o.bytes !== Array) d.signature = $util.newBuffer(d.signature);\n      }\n    }\n\n    if (m.publicKey != null && m.hasOwnProperty(\"publicKey\")) {\n      d.publicKey = o.bytes === String ? $util.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;\n    }\n\n    if (m.payloadType != null && m.hasOwnProperty(\"payloadType\")) {\n      d.payloadType = o.bytes === String ? $util.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;\n    }\n\n    if (m.payload != null && m.hasOwnProperty(\"payload\")) {\n      d.payload = o.bytes === String ? $util.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;\n    }\n\n    if (m.signature != null && m.hasOwnProperty(\"signature\")) {\n      d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Envelope to JSON.\n   * @function toJSON\n   * @memberof Envelope\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Envelope.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Envelope;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}