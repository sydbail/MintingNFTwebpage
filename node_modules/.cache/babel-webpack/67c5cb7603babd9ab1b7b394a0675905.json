{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst ipns = require('ipns');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst PubsubDatastore = require('datastore-pubsub');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:pubsub'), {\n  error: debug('ipfs:ipns:pubsub:error')\n}); // Pubsub datastore aims to manage the pubsub subscriptions for IPNS\n\nclass IpnsPubsubDatastore {\n  /**\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub\n   * @param {import('interface-datastore').Datastore} localDatastore\n   * @param {import('peer-id')} peerId\n   */\n  constructor(pubsub, localDatastore, peerId) {\n    /** @type {Record<string, string>} */\n    this._subscriptions = {}; // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this); // @ts-ignore will be fixed by https://github.com/ipfs/js-datastore-pubsub/pull/74\n\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);\n  }\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n\n\n  put(key, value) {\n    // @ts-ignore datastores take Key keys, this one takes Uint8Array keys\n    return this._pubsubDs.put(key, value);\n  }\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   */\n\n\n  get(key) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let res;\n      let err;\n\n      try {\n        // @ts-ignore datastores take Key keys, this one takes Uint8Array keys\n        res = yield _this._pubsubDs.get(key);\n      } catch (e) {\n        err = e;\n      } // Add topic subscribed\n\n\n      const ns = key.slice(0, ipns.namespaceLength);\n\n      if (uint8ArrayToString(ns) === ipns.namespace) {\n        const stringifiedTopic = base58btc.encode(key).substring(1);\n        const id = base58btc.encode(key.slice(ipns.namespaceLength)).substring(1);\n        _this._subscriptions[stringifiedTopic] = id;\n        log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);\n      } // If no data was obtained, after storing the subscription, return the error.\n\n\n      if (err) {\n        throw err;\n      }\n\n      return res;\n    })();\n  }\n  /**\n   * Modify subscription key to have a proper encoding\n   *\n   * @param {Uint8Array | string} key\n   */\n\n\n  _handleSubscriptionKey(key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc');\n    }\n\n    const subscriber = this._subscriptions[key];\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY');\n    }\n\n    let keys;\n\n    try {\n      keys = ipns.getIdKeys(uint8ArrayFromString(subscriber, 'base58btc'));\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return keys.routingKey.uint8Array();\n  }\n  /**\n   * Get pubsub subscriptions related to ipns.\n   */\n\n\n  getSubscriptions() {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean);\n    return subscriptions.map(sub => `${ipns.namespace}${sub}`);\n  }\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   *\n   * @param {string} name - ipns path to cancel the pubsub subscription.\n   */\n\n\n  cancel(name) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (typeof name !== 'string') {\n        throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');\n      } // Trim /ipns/ prefix from the name\n\n\n      if (name.startsWith(ipns.namespace)) {\n        name = name.substring(ipns.namespaceLength);\n      }\n\n      const stringifiedTopic = Object.keys(_this2._subscriptions).find(key => _this2._subscriptions[key] === name); // Not found topic\n\n      if (!stringifiedTopic) {\n        return {\n          canceled: false\n        };\n      } // Unsubscribe topic\n\n\n      const bufTopic = uint8ArrayFromString(stringifiedTopic);\n\n      _this2._pubsubDs.unsubscribe(bufTopic);\n\n      delete _this2._subscriptions[stringifiedTopic];\n      log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`);\n      return {\n        canceled: true\n      };\n    })();\n  }\n\n}\n\nmodule.exports = IpnsPubsubDatastore;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-core/src/ipns/routing/pubsub-datastore.js"],"names":["ipns","require","base58btc","PubsubDatastore","fromString","uint8ArrayFromString","toString","uint8ArrayToString","errcode","debug","log","Object","assign","error","IpnsPubsubDatastore","constructor","pubsub","localDatastore","peerId","_subscriptions","_handleSubscriptionKey","bind","_pubsubDs","validator","put","key","value","get","res","err","e","ns","slice","namespaceLength","namespace","stringifiedTopic","encode","substring","id","Uint8Array","subscriber","Error","keys","getIdKeys","routingKey","uint8Array","getSubscriptions","subscriptions","values","filter","Boolean","map","sub","cancel","name","startsWith","find","canceled","bufTopic","unsubscribe","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst { base58btc } = require('multiformats/bases/base58')\nconst PubsubDatastore = require('datastore-pubsub')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:pubsub'), {\n  error: debug('ipfs:ipns:pubsub:error')\n})\n\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\nclass IpnsPubsubDatastore {\n  /**\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub\n   * @param {import('interface-datastore').Datastore} localDatastore\n   * @param {import('peer-id')} peerId\n   */\n  constructor (pubsub, localDatastore, peerId) {\n    /** @type {Record<string, string>} */\n    this._subscriptions = {}\n\n    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this)\n\n    // @ts-ignore will be fixed by https://github.com/ipfs/js-datastore-pubsub/pull/74\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey)\n  }\n\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n  put (key, value) {\n    // @ts-ignore datastores take Key keys, this one takes Uint8Array keys\n    return this._pubsubDs.put(key, value)\n  }\n\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   */\n  async get (key) {\n    let res\n    let err\n\n    try {\n      // @ts-ignore datastores take Key keys, this one takes Uint8Array keys\n      res = await this._pubsubDs.get(key)\n    } catch (e) {\n      err = e\n    }\n\n    // Add topic subscribed\n    const ns = key.slice(0, ipns.namespaceLength)\n\n    if (uint8ArrayToString(ns) === ipns.namespace) {\n      const stringifiedTopic = base58btc.encode(key).substring(1)\n      const id = base58btc.encode(key.slice(ipns.namespaceLength)).substring(1)\n\n      this._subscriptions[stringifiedTopic] = id\n\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`)\n    }\n\n    // If no data was obtained, after storing the subscription, return the error.\n    if (err) {\n      throw err\n    }\n\n    return res\n  }\n\n  /**\n   * Modify subscription key to have a proper encoding\n   *\n   * @param {Uint8Array | string} key\n   */\n  _handleSubscriptionKey (key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc')\n    }\n\n    const subscriber = this._subscriptions[key]\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY')\n    }\n\n    let keys\n    try {\n      keys = ipns.getIdKeys(uint8ArrayFromString(subscriber, 'base58btc'))\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    return keys.routingKey.uint8Array()\n  }\n\n  /**\n   * Get pubsub subscriptions related to ipns.\n   */\n  getSubscriptions () {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean)\n\n    return subscriptions.map((sub) => `${ipns.namespace}${sub}`)\n  }\n\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   *\n   * @param {string} name - ipns path to cancel the pubsub subscription.\n   */\n  async cancel (name) { // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME')\n    }\n\n    // Trim /ipns/ prefix from the name\n    if (name.startsWith(ipns.namespace)) {\n      name = name.substring(ipns.namespaceLength)\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name)\n\n    // Not found topic\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      }\n    }\n\n    // Unsubscribe topic\n    const bufTopic = uint8ArrayFromString(stringifiedTopic)\n\n    this._pubsubDs.unsubscribe(bufTopic)\n\n    delete this._subscriptions[stringifiedTopic]\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`)\n\n    return {\n      canceled: true\n    }\n  }\n}\n\nmodule.exports = IpnsPubsubDatastore\n"]},"metadata":{},"sourceType":"script"}