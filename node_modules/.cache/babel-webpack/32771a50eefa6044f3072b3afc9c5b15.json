{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst WantManager = require('./want-manager');\n\nconst Network = require('./network');\n\nconst DecisionEngine = require('./decision-engine');\n\nconst Notifications = require('./notifications');\n\nconst logger = require('./utils').logger;\n\nconst Stats = require('./stats');\n\nconst {\n  AbortController\n} = require('native-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst {\n  BlockstoreAdapter\n} = require('interface-blockstore');\n\nconst {\n  CID\n} = require('multiformats');\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types/message')} BitswapMessage\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\n\nclass Bitswap extends BlockstoreAdapter {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {Blockstore} blockstore\n   * @param {Object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor(libp2p, blockstore, options = {}) {\n    super();\n    this._libp2p = libp2p;\n    this._log = logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, this._stats, {\n      hashers: options.hashers\n    }); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerId, this.network, this._stats);\n    this.notifications = new Notifications(this.peerId);\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * @type {PeerId}\n   */\n\n\n  get peerId() {\n    return this._libp2p.peerId;\n  }\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n\n\n  _receiveMessage(peerId, incoming) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // Note: this allows the engine to respond to any wants in the message.\n        // Processing of the blocks in the message happens below, after the\n        // blocks have been added to the blockstore.\n        yield _this3.engine.messageReceived(peerId, incoming);\n      } catch (err) {\n        // Log instead of throwing an error so as to process as much as\n        // possible of the message. Currently `messageReceived` does not\n        // throw any errors, but this could change in the future.\n        _this3._log('failed to receive message', incoming);\n      }\n\n      if (incoming.blocks.size === 0) {\n        return;\n      }\n      /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n\n\n      const received = [];\n\n      for (const [cidStr, data] of incoming.blocks.entries()) {\n        const cid = CID.parse(cidStr);\n        received.push({\n          wasWanted: _this3.wm.wantlist.contains(cid),\n          cid,\n          data\n        });\n      } // quickly send out cancels, reduces chances of duplicate block receives\n\n\n      _this3.wm.cancelWants(received.filter(({\n        wasWanted\n      }) => wasWanted).map(({\n        cid\n      }) => cid));\n\n      yield Promise.all(received.map(({\n        cid,\n        wasWanted,\n        data\n      }) => _this3._handleReceivedBlock(peerId, cid, data, wasWanted)));\n    })();\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n\n\n  _handleReceivedBlock(peerId, cid, data, wasWanted) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4._log('received block');\n\n      const has = yield _this4.blockstore.has(cid);\n\n      _this4._updateReceiveCounters(peerId.toB58String(), cid, data, has);\n\n      if (!wasWanted) {\n        return;\n      }\n\n      yield _this4.put(cid, data);\n    })();\n  }\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n\n\n  _updateReceiveCounters(peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1);\n\n    this._stats.push(peerIdStr, 'dataReceived', data.length);\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n    }\n  }\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n\n\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  }\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  }\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n\n    this._stats.disconnected(peerId);\n  }\n\n  enableStats() {\n    this._stats.enable();\n  }\n\n  disableStats() {\n    this._stats.disable();\n  }\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n\n\n  wantlistForPeer(peerId, _options) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  get(cid, options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      /**\n       * @param {CID} cid\n       * @param {Object} options\n       * @param {AbortSignal} options.signal\n       */\n      const fetchFromNetwork = (cid, options) => {\n        // add it to the want list - n.b. later we will abort the AbortSignal\n        // so no need to remove the blocks from the wantlist after we have it\n        _this5.wm.wantBlocks([cid], options);\n\n        return _this5.notifications.wantBlock(cid, options);\n      };\n\n      let promptedNetwork = false;\n      /**\n       *\n       * @param {CID} cid\n       * @param {Object} options\n       * @param {AbortSignal} options.signal\n       */\n\n      const loadOrFetchFromNetwork = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (cid, options) {\n          try {\n            // have to await here as we want to handle ERR_NOT_FOUND\n            const block = yield _this5.blockstore.get(cid, options);\n            return block;\n          } catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n              throw err;\n            }\n\n            if (!promptedNetwork) {\n              promptedNetwork = true;\n\n              _this5.network.findAndConnect(cid).catch(err => _this5._log.error(err));\n            } // we don't have the block locally so fetch it from the network\n\n\n            return fetchFromNetwork(cid, options);\n          }\n        });\n\n        return function loadOrFetchFromNetwork(_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }(); // depending on implementation it's possible for blocks to come in while\n      // we do the async operations to get them from the blockstore leading to\n      // a race condition, so register for incoming block notifications as well\n      // as trying to get it from the datastore\n\n\n      const controller = new AbortController();\n      const signal = options.signal ? anySignal([options.signal, controller.signal]) : controller.signal;\n      const block = yield Promise.race([_this5.notifications.wantBlock(cid, {\n        signal\n      }), loadOrFetchFromNetwork(cid, {\n        signal\n      })]); // since we have the block we can now remove our listener\n\n      controller.abort();\n      return block;\n    })();\n  }\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  getMany(cids, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(cids), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const cid = _value;\n          yield _this.get(cid, options);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n\n\n  unwant(cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids];\n    this.wm.unwantBlocks(cidsArray);\n    cidsArray.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n\n\n  cancelWants(cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n  }\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n\n\n  put(cid, block, _options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6.blockstore.put(cid, block);\n\n      _this6._sendHaveBlockNotifications(cid, block);\n    })();\n  }\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n\n\n  putMany(source, options) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this2.blockstore.putMany(source, options)), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const {\n            key,\n            value\n          } = _value2;\n\n          _this2._sendHaveBlockNotifications(key, value);\n\n          yield {\n            key,\n            value\n          };\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n\n\n  _sendHaveBlockNotifications(cid, data) {\n    this.notifications.hasBlock(cid, data);\n    this.engine.receivedBlocks([{\n      cid,\n      data\n    }]); // Note: Don't wait for provide to finish before returning\n\n    this.network.provide(cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n  /**\n   * Get the current list of wants\n   */\n\n\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n  /**\n   * Get the current list of partners\n   */\n\n\n  peers() {\n    return this.engine.peers();\n  }\n  /**\n   * Get stats about the bitswap node\n   */\n\n\n  stat() {\n    return this._stats;\n  }\n  /**\n   * Start the bitswap node\n   */\n\n\n  start() {\n    this.wm.start();\n    this.network.start();\n    this.engine.start();\n    this.started = true;\n  }\n  /**\n   * Stop the bitswap node\n   */\n\n\n  stop() {\n    this._stats.stop();\n\n    this.wm.stop();\n    this.network.stop();\n    this.engine.stop();\n    this.started = false;\n  }\n\n  unwrap() {\n    return this.blockstore;\n  }\n\n}\n\nmodule.exports = Bitswap;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-bitswap/src/bitswap.js"],"names":["WantManager","require","Network","DecisionEngine","Notifications","logger","Stats","AbortController","anySignal","BlockstoreAdapter","CID","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","constructor","libp2p","blockstore","options","_libp2p","_log","peerId","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","hashers","engine","wm","notifications","started","isStarted","_receiveMessage","incoming","messageReceived","err","blocks","size","received","cidStr","data","entries","cid","parse","push","wasWanted","wantlist","contains","cancelWants","filter","map","Promise","all","_handleReceivedBlock","has","_updateReceiveCounters","toB58String","put","peerIdStr","exists","length","_receiveError","error","message","_onPeerConnected","connected","_onPeerDisconnected","disconnected","peerDisconnected","enableStats","enable","disableStats","disable","wantlistForPeer","ledgerForPeer","get","fetchFromNetwork","wantBlocks","wantBlock","promptedNetwork","loadOrFetchFromNetwork","block","code","findAndConnect","catch","controller","signal","race","abort","getMany","cids","unwant","cidsArray","Array","isArray","unwantBlocks","forEach","unwantBlock","_sendHaveBlockNotifications","putMany","source","key","value","hasBlock","receivedBlocks","provide","getWantlist","peers","stat","start","stop","unwrap","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst WantManager = require('./want-manager')\nconst Network = require('./network')\nconst DecisionEngine = require('./decision-engine')\nconst Notifications = require('./notifications')\nconst logger = require('./utils').logger\nconst Stats = require('./stats')\nconst { AbortController } = require('native-abort-controller')\nconst { anySignal } = require('any-signal')\nconst { BlockstoreAdapter } = require('interface-blockstore')\nconst { CID } = require('multiformats')\n\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types/message')} BitswapMessage\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\nclass Bitswap extends BlockstoreAdapter {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {Blockstore} blockstore\n   * @param {Object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor (libp2p, blockstore, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._log = logger(this.peerId)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, this._stats, {\n      hashers: options.hashers\n    })\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats)\n\n    this.notifications = new Notifications(this.peerId)\n\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * @type {PeerId}\n   */\n  get peerId () {\n    return this._libp2p.peerId\n  }\n\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n  async _receiveMessage (peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n    const received = []\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      })\n    }\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    this.wm.cancelWants(\n      received\n        .filter(({ wasWanted }) => wasWanted)\n        .map(({ cid }) => cid)\n    )\n\n    await Promise.all(\n      received.map(\n        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)\n      )\n    )\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n  async _handleReceivedBlock (peerId, cid, data, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(cid)\n\n    this._updateReceiveCounters(peerId.toB58String(), cid, data, has)\n\n    if (!wasWanted) {\n      return\n    }\n\n    await this.put(cid, data)\n  }\n\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n  _updateReceiveCounters (peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1)\n    this._stats.push(peerIdStr, 'dataReceived', data.length)\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1)\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length)\n    }\n  }\n\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  enableStats () {\n    this._stats.enable()\n  }\n\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n  wantlistForPeer (peerId, _options) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async get (cid, options = {}) {\n    /**\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options)\n\n      return this.notifications.wantBlock(cid, options)\n    }\n\n    let promptedNetwork = false\n\n    /**\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.signal\n     */\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options)\n\n        return block\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true\n\n          this.network.findAndConnect(cid)\n            .catch((err) => this._log.error(err))\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options)\n      }\n    }\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController()\n    const signal = options.signal\n      ? anySignal([options.signal, controller.signal])\n      : controller.signal\n\n    const block = await Promise.race([\n      this.notifications.wantBlock(cid, {\n        signal\n      }),\n      loadOrFetchFromNetwork(cid, {\n        signal\n      })\n    ])\n\n    // since we have the block we can now remove our listener\n    controller.abort()\n\n    return block\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * getMany (cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n  unwant (cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids]\n\n    this.wm.unwantBlocks(cidsArray)\n    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n  cancelWants (cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids])\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n  async put (cid, block, _options) {\n    await this.blockstore.put(cid, block)\n    this._sendHaveBlockNotifications(cid, block)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n  async * putMany (source, options) {\n    for await (const { key, value } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value)\n\n      yield { key, value }\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n  _sendHaveBlockNotifications (cid, data) {\n    this.notifications.hasBlock(cid, data)\n    this.engine.receivedBlocks([{ cid, data }])\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(cid).catch((err) => {\n      this._log.error('Failed to provide: %s', err.message)\n    })\n  }\n\n  /**\n   * Get the current list of wants\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node\n   */\n  start () {\n    this.wm.start()\n    this.network.start()\n    this.engine.start()\n    this.started = true\n  }\n\n  /**\n   * Stop the bitswap node\n   */\n  stop () {\n    this._stats.stop()\n    this.wm.stop()\n    this.network.stop()\n    this.engine.stop()\n    this.started = false\n  }\n\n  unwrap () {\n    return this.blockstore\n  }\n}\n\nmodule.exports = Bitswap\n"]},"metadata":{},"sourceType":"script"}