{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BigIntArbitrary = void 0;\n\nconst Stream_1 = require(\"../../stream/Stream\");\n\nconst NextArbitrary_1 = require(\"../../check/arbitrary/definition/NextArbitrary\");\n\nconst NextValue_1 = require(\"../../check/arbitrary/definition/NextValue\");\n\nconst BiasNumericRange_1 = require(\"./helpers/BiasNumericRange\");\n\nconst ShrinkBigInt_1 = require(\"./helpers/ShrinkBigInt\");\n\nclass BigIntArbitrary extends NextArbitrary_1.NextArbitrary {\n  constructor(min, max) {\n    super();\n    this.min = min;\n    this.max = max;\n  }\n\n  generate(mrng, biasFactor) {\n    const range = this.computeGenerateRange(mrng, biasFactor);\n    return new NextValue_1.NextValue(mrng.nextBigInt(range.min, range.max), undefined);\n  }\n\n  computeGenerateRange(mrng, biasFactor) {\n    if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n      return {\n        min: this.min,\n        max: this.max\n      };\n    }\n\n    const ranges = BiasNumericRange_1.biasNumericRange(this.min, this.max, BiasNumericRange_1.bigIntLogLike);\n\n    if (ranges.length === 1) {\n      return ranges[0];\n    }\n\n    const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n    return id < 0 ? ranges[0] : ranges[id + 1];\n  }\n\n  canShrinkWithoutContext(value) {\n    return typeof value === 'bigint' && this.min <= value && value <= this.max;\n  }\n\n  shrink(current, context) {\n    if (!BigIntArbitrary.isValidContext(current, context)) {\n      const target = this.defaultTarget();\n      return ShrinkBigInt_1.shrinkBigInt(current, target, true);\n    }\n\n    if (this.isLastChanceTry(current, context)) {\n      return Stream_1.Stream.of(new NextValue_1.NextValue(context, undefined));\n    }\n\n    return ShrinkBigInt_1.shrinkBigInt(current, context, false);\n  }\n\n  defaultTarget() {\n    if (this.min <= 0 && this.max >= 0) {\n      return BigInt(0);\n    }\n\n    return this.min < 0 ? this.max : this.min;\n  }\n\n  isLastChanceTry(current, context) {\n    if (current > 0) return current === context + BigInt(1) && current > this.min;\n    if (current < 0) return current === context - BigInt(1) && current < this.max;\n    return false;\n  }\n\n  static isValidContext(current, context) {\n    if (context === undefined) {\n      return false;\n    }\n\n    if (typeof context !== 'bigint') {\n      throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);\n    }\n\n    const differentSigns = current > 0 && context < 0 || current < 0 && context > 0;\n\n    if (context !== BigInt(0) && differentSigns) {\n      throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);\n    }\n\n    return true;\n  }\n\n}\n\nexports.BigIntArbitrary = BigIntArbitrary;","map":null,"metadata":{},"sourceType":"script"}