{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  Adapter,\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst sh = require('./shard');\n\nconst KeytransformStore = require('./keytransform');\n\nconst shardKey = new Key(sh.SHARDING_FN);\nconst shardReadmeKey = new Key(sh.README_FN);\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nclass ShardingDatastore extends Adapter {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor(store, shard) {\n    super();\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  open() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.child.open();\n      _this4.shard = yield ShardingDatastore.create(_this4.child, _this4.shard);\n    })();\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _convertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    const parent = new Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _invertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    return Key.withNamespaces(key.list().slice(1));\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static createOrOpen(store, shard) {\n    return _asyncToGenerator(function* () {\n      try {\n        yield ShardingDatastore.create(store, shard);\n      } catch (err) {\n        if (err && err.message !== 'datastore exists') throw err;\n      }\n\n      return ShardingDatastore.open(store);\n    })();\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n\n\n  static open(store) {\n    return _asyncToGenerator(function* () {\n      const shard = yield sh.readShardFun('/', store);\n      return new ShardingDatastore(store, shard);\n    })();\n  }\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static create(store, shard) {\n    return _asyncToGenerator(function* () {\n      const hasShard = yield store.has(shardKey);\n\n      if (!hasShard && !shard) {\n        throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n      }\n\n      if (!hasShard) {\n        // @ts-ignore i have no idea what putRaw is or saw any implementation\n        const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n        yield Promise.all([put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')), put(shardReadmeKey, new TextEncoder().encode(sh.readme))]);\n        return shard;\n      } // test shards\n\n\n      const diskShard = yield sh.readShardFun('/', store);\n      const a = (diskShard || '').toString();\n      const b = shard.toString();\n\n      if (a !== b) {\n        throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n      }\n\n      return diskShard;\n    })();\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n\n\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  putMany(source, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this.child.putMany(source, options)), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n\n\n  getMany(source, options = {}) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this2.child.getMany(source, options)), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n\n\n  deleteMany(source, options = {}) {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this3.child.deleteMany(source, options)), _awaitAsyncGenerator);\n    })();\n  }\n\n  batch() {\n    return this.child.batch();\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n\n      /** @type {QueryOrder[]} */\n      orders: [],\n\n      /** @type {QueryFilter[]} */\n      filters: [\n      /** @type {QueryFilter} */\n      e => e.key.toString() !== shardKey.toString(),\n      /** @type {QueryFilter} */\n      e => e.key.toString() !== shardReadmeKey.toString()]\n    };\n    const {\n      prefix\n    } = q;\n\n    if (prefix != null) {\n      tq.filters.push(e => {\n        return this._invertKey(e.key).toString().startsWith(prefix);\n      });\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {QueryFilter} */\n        const filter = ({\n          key,\n          value\n        }) => {\n          return f({\n            key: this._invertKey(key),\n            value\n          });\n        };\n\n        return filter;\n      });\n      tq.filters = tq.filters.concat(filters);\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {QueryOrder} */\n        const order = (a, b) => {\n          return o({\n            key: this._invertKey(a.key),\n            value: a.value\n          }, {\n            key: this._invertKey(b.key),\n            value: b.value\n          });\n        };\n\n        return order;\n      });\n    }\n\n    return this.child.query(tq, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n\n      /** @type {KeyQueryOrder[]} */\n      orders: [],\n\n      /** @type {KeyQueryFilter[]} */\n      filters: [\n      /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardKey.toString(),\n      /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardReadmeKey.toString()]\n    };\n    const {\n      prefix\n    } = q;\n\n    if (prefix != null) {\n      tq.filters.push(key => {\n        return this._invertKey(key).toString().startsWith(prefix);\n      });\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {KeyQueryFilter} */\n        const filter = key => {\n          return f(this._invertKey(key));\n        };\n\n        return filter;\n      });\n      tq.filters = tq.filters.concat(filters);\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {KeyQueryOrder} */\n        const order = (a, b) => o(this._invertKey(a), this._invertKey(b));\n\n        return order;\n      });\n    }\n\n    return this.child.queryKeys(tq, options);\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n}\n\nmodule.exports = ShardingDatastore;","map":null,"metadata":{},"sourceType":"script"}