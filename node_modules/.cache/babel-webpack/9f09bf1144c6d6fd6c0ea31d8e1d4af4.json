{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst c = require('../constants');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nconst Record = libp2pRecord.Record;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\n\nmodule.exports = dht => {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  const putLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (key, rec) {\n      // eslint-disable-line require-await\n      return dht.datastore.put(utils.bufferToKey(key), rec);\n    });\n\n    return function putLocal(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  const getLocal = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (key) {\n      dht._log(`getLocal ${uint8ArrayToString(key, 'base32')}`);\n\n      const raw = yield dht.datastore.get(utils.bufferToKey(key));\n\n      dht._log(`found ${uint8ArrayToString(key, 'base32')} in local datastore`);\n\n      const rec = Record.deserialize(raw);\n      yield dht._verifyRecordLocally(rec);\n      return rec;\n    });\n\n    return function getLocal(_x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n\n\n  const sendCorrectionRecord = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* (key, vals, best) {\n      const fixupRec = yield utils.createPutRecord(key, best);\n      return Promise.all(vals.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (v) {\n          // no need to do anything\n          if (uint8ArrayEquals(v.val, best)) {\n            return;\n          } // correct ourself\n\n\n          if (dht._isSelf(v.from)) {\n            try {\n              yield dht._putLocal(key, fixupRec);\n            } catch (err) {\n              dht._log.error('Failed error correcting self', err);\n            }\n\n            return;\n          } // send correction\n\n\n          try {\n            yield dht._putValueToPeer(key, fixupRec, v.from);\n          } catch (err) {\n            dht._log.error('Failed error correcting entry', err);\n          }\n        });\n\n        return function (_x7) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n    });\n\n    return function sendCorrectionRecord(_x4, _x5, _x6) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    _putLocal(key, rec) {\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        return putLocal(key, rec);\n      })();\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    put(key, value, options = {}) {\n      return _asyncToGenerator(function* () {\n        dht._log('PutValue %b', key); // create record in the dht format\n\n\n        const record = yield utils.createPutRecord(key, value); // store the record locally\n\n        yield putLocal(key, record); // put record to the closest peers\n\n        let counterAll = 0;\n        let counterSuccess = 0;\n        yield utils.mapParallel(dht.getClosestPeers(key, {\n          shallow: true\n        }), /*#__PURE__*/function () {\n          var _ref5 = _asyncToGenerator(function* (peer) {\n            try {\n              counterAll += 1;\n              yield dht._putValueToPeer(key, record, peer);\n              counterSuccess += 1;\n            } catch (err) {\n              dht._log.error('Failed to put to peer (%b): %s', peer.id, err);\n            }\n          });\n\n          return function (_x8) {\n            return _ref5.apply(this, arguments);\n          };\n        }()); // verify if we were able to put to enough peers\n\n        const minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`\n\n        if (minPeers > counterSuccess) {\n          const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n          dht._log.error(error);\n\n          throw error;\n        }\n      })();\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    get(key, options = {}) {\n      return _asyncToGenerator(function* () {\n        options.timeout = options.timeout || c.minute;\n\n        dht._log('_get %b', key);\n\n        const vals = yield dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);\n        const recs = vals.map(v => v.val);\n        let i = 0;\n\n        try {\n          i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n        } catch (err) {\n          // Assume the first record if no selector available\n          if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n            throw err;\n          }\n        }\n\n        const best = recs[i];\n\n        dht._log('GetValue %b %s', key, best);\n\n        if (!best) {\n          throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n        }\n\n        yield sendCorrectionRecord(key, vals, best);\n        return best;\n      })();\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    getMany(key, nvals, options = {}) {\n      return _asyncToGenerator(function* () {\n        options.timeout = options.timeout || c.minute;\n\n        dht._log('getMany %b (%s)', key, nvals);\n\n        const vals = [];\n        let localRec;\n\n        try {\n          localRec = yield getLocal(key);\n        } catch (err) {\n          if (nvals === 0) {\n            throw err;\n          }\n        }\n\n        if (localRec) {\n          vals.push({\n            val: localRec.value,\n            from: dht.peerId\n          });\n        }\n\n        if (vals.length >= nvals) {\n          return vals;\n        }\n\n        const id = yield utils.convertBuffer(key);\n        const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize);\n\n        dht._log('peers in rt: %d', rtp.length);\n\n        if (rtp.length === 0) {\n          const errMsg = 'Failed to lookup key! No peers from routing table!';\n\n          dht._log.error(errMsg);\n\n          if (vals.length === 0) {\n            throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n          }\n\n          return vals;\n        }\n\n        const valsLength = vals.length;\n        /**\n         * @param {number} pathIndex\n         * @param {number} numPaths\n         */\n\n        function createQuery(pathIndex, numPaths) {\n          // This function body runs once per disjoint path\n          const pathSize = utils.pathSize(nvals - valsLength, numPaths);\n          let queryResults = 0;\n          /**\n           * Here we return the query function to use on this particular disjoint path\n           *\n           * @param {PeerId} peer\n           */\n\n          function disjointPathQuery(_x9) {\n            return _disjointPathQuery.apply(this, arguments);\n          }\n\n          function _disjointPathQuery() {\n            _disjointPathQuery = _asyncToGenerator(function* (peer) {\n              let rec, peers, lookupErr;\n\n              try {\n                const results = yield dht._getValueOrPeers(peer, key);\n                rec = results.record;\n                peers = results.peers;\n              } catch (err) {\n                // If we have an invalid record we just want to continue and fetch a new one.\n                if (err.code !== 'ERR_INVALID_RECORD') {\n                  throw err;\n                }\n\n                lookupErr = err;\n              }\n              /** @type {import('../query').QueryResult} */\n\n\n              const res = {\n                closerPeers: peers\n              };\n\n              if (rec && rec.value) {\n                vals.push({\n                  val: rec.value,\n                  from: peer\n                });\n                queryResults++;\n              } else if (lookupErr) {\n                vals.push({\n                  err: lookupErr,\n                  from: peer\n                });\n                queryResults++;\n              } // enough is enough\n\n\n              if (queryResults >= pathSize) {\n                res.pathComplete = true;\n              }\n\n              return res;\n            });\n            return _disjointPathQuery.apply(this, arguments);\n          }\n\n          return disjointPathQuery;\n        } // we have peers, lets send the actual query to them\n\n\n        const query = new Query(dht, key, createQuery);\n\n        try {\n          yield pTimeout(query.run(rtp), options.timeout);\n        } catch (err) {\n          if (vals.length === 0) {\n            throw err;\n          }\n        } finally {\n          query.stop();\n        }\n\n        return vals;\n      })();\n    }\n\n  };\n};","map":null,"metadata":{},"sourceType":"script"}