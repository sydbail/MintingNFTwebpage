{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  BlockstoreAdapter\n} = require('interface-blockstore');\n\nconst merge = require('it-merge');\n\nconst pushable = require('it-pushable');\n\nconst filter = require('it-filter');\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-bitswap').IPFSBitswap} Bitswap\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/block').RmOptions} RmOptions\n */\n\n/**\n * BlockStorage is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n *\n * @implements {Blockstore}\n */\n\n\nclass BlockStorage extends BlockstoreAdapter {\n  /**\n   * Create a new BlockStorage\n   *\n   * @param {Blockstore} blockstore\n   * @param {Bitswap} bitswap\n   */\n  constructor(blockstore, bitswap) {\n    super();\n    this.child = blockstore;\n    this.bitswap = bitswap;\n  }\n\n  open() {\n    return this.child.open();\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n  unwrap() {\n    return this.child;\n  }\n  /**\n   * Put a block to the underlying datastore\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {AbortOptions} [options]\n   */\n\n\n  put(cid, block, options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (yield _this6.has(cid)) {\n        return;\n      }\n\n      if (_this6.bitswap.isStarted()) {\n        yield _this6.bitswap.put(cid, block, options);\n      } else {\n        yield _this6.child.put(cid, block, options);\n      }\n    })();\n  }\n  /**\n   * Put a multiple blocks to the underlying datastore\n   *\n   * @param {AsyncIterable<{ key: CID, value: Uint8Array }> | Iterable<{ key: CID, value: Uint8Array }>} blocks\n   * @param {AbortOptions} [options]\n   */\n\n\n  putMany(blocks, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const missingBlocks = filter(blocks, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* ({\n          key\n        }) {\n          return !(yield _this.has(key));\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n\n      if (_this.bitswap.isStarted()) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(_this.bitswap.putMany(missingBlocks, options)), _awaitAsyncGenerator);\n      } else {\n        yield* _asyncGeneratorDelegate(_asyncIterator(_this.child.putMany(missingBlocks, options)), _awaitAsyncGenerator);\n      }\n    })();\n  }\n  /**\n   * Get a block by cid\n   *\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n\n\n  get(cid, options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(yield _this7.has(cid)) && _this7.bitswap.isStarted()) {\n        return _this7.bitswap.get(cid, options);\n      } else {\n        return _this7.child.get(cid, options);\n      }\n    })();\n  }\n  /**\n   * Get multiple blocks back from an array of cids\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {AbortOptions} [options]\n   */\n\n\n  getMany(cids, options = {}) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const getFromBitswap = pushable();\n      const getFromChild = pushable();\n      Promise.resolve().then( /*#__PURE__*/_asyncToGenerator(function* () {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(cids), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const cid = _value;\n\n            if (!(yield _this2.has(cid)) && _this2.bitswap.isStarted()) {\n              getFromBitswap.push(cid);\n            } else {\n              getFromChild.push(cid);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        getFromBitswap.end();\n        getFromChild.end();\n      }));\n      yield* _asyncGeneratorDelegate(_asyncIterator(merge(_this2.bitswap.getMany(getFromBitswap, options), _this2.child.getMany(getFromChild, options))), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * Delete a block from the blockstore\n   *\n   * @param {CID} cid\n   * @param {RmOptions} [options]\n   */\n\n\n  delete(cid, options) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this8.child.delete(cid, options);\n    })();\n  }\n  /**\n   * Delete multiple blocks from the blockstore\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {RmOptions} [options]\n   */\n\n\n  deleteMany(cids, options) {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this3.child.deleteMany(cids, options)), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n\n\n  has(cid, options = {}) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this9.child.has(cid, options);\n    })();\n  }\n  /**\n   * @param {Query} q\n   * @param {AbortOptions} options\n   */\n\n\n  query(q, options = {}) {\n    var _this4 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this4.child.query(q, options)), _awaitAsyncGenerator);\n    })();\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {AbortOptions} options\n   */\n\n\n  queryKeys(q, options = {}) {\n    var _this5 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this5.child.queryKeys(q, options)), _awaitAsyncGenerator);\n    })();\n  }\n\n}\n\nmodule.exports = BlockStorage;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/block-storage.js"],"names":["BlockstoreAdapter","require","merge","pushable","filter","BlockStorage","constructor","blockstore","bitswap","child","open","close","unwrap","put","cid","block","options","has","isStarted","putMany","blocks","missingBlocks","key","get","getMany","cids","getFromBitswap","getFromChild","Promise","resolve","then","push","end","delete","deleteMany","query","q","queryKeys","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { BlockstoreAdapter } = require('interface-blockstore')\nconst merge = require('it-merge')\nconst pushable = require('it-pushable')\nconst filter = require('it-filter')\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-bitswap').IPFSBitswap} Bitswap\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/block').RmOptions} RmOptions\n */\n\n/**\n * BlockStorage is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n *\n * @implements {Blockstore}\n */\nclass BlockStorage extends BlockstoreAdapter {\n  /**\n   * Create a new BlockStorage\n   *\n   * @param {Blockstore} blockstore\n   * @param {Bitswap} bitswap\n   */\n  constructor (blockstore, bitswap) {\n    super()\n\n    this.child = blockstore\n    this.bitswap = bitswap\n  }\n\n  open () {\n    return this.child.open()\n  }\n\n  close () {\n    return this.child.close()\n  }\n\n  unwrap () {\n    return this.child\n  }\n\n  /**\n   * Put a block to the underlying datastore\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {AbortOptions} [options]\n   */\n  async put (cid, block, options = {}) {\n    if (await this.has(cid)) {\n      return\n    }\n\n    if (this.bitswap.isStarted()) {\n      await this.bitswap.put(cid, block, options)\n    } else {\n      await this.child.put(cid, block, options)\n    }\n  }\n\n  /**\n   * Put a multiple blocks to the underlying datastore\n   *\n   * @param {AsyncIterable<{ key: CID, value: Uint8Array }> | Iterable<{ key: CID, value: Uint8Array }>} blocks\n   * @param {AbortOptions} [options]\n   */\n  async * putMany (blocks, options = {}) {\n    const missingBlocks = filter(blocks, async ({ key }) => { return !(await this.has(key)) })\n\n    if (this.bitswap.isStarted()) {\n      yield * this.bitswap.putMany(missingBlocks, options)\n    } else {\n      yield * this.child.putMany(missingBlocks, options)\n    }\n  }\n\n  /**\n   * Get a block by cid\n   *\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n  async get (cid, options = {}) {\n    if (!(await this.has(cid)) && this.bitswap.isStarted()) {\n      return this.bitswap.get(cid, options)\n    } else {\n      return this.child.get(cid, options)\n    }\n  }\n\n  /**\n   * Get multiple blocks back from an array of cids\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {AbortOptions} [options]\n   */\n  async * getMany (cids, options = {}) {\n    const getFromBitswap = pushable()\n    const getFromChild = pushable()\n\n    Promise.resolve().then(async () => {\n      for await (const cid of cids) {\n        if (!(await this.has(cid)) && this.bitswap.isStarted()) {\n          getFromBitswap.push(cid)\n        } else {\n          getFromChild.push(cid)\n        }\n      }\n\n      getFromBitswap.end()\n      getFromChild.end()\n    })\n\n    yield * merge(\n      this.bitswap.getMany(getFromBitswap, options),\n      this.child.getMany(getFromChild, options)\n    )\n  }\n\n  /**\n   * Delete a block from the blockstore\n   *\n   * @param {CID} cid\n   * @param {RmOptions} [options]\n   */\n  async delete (cid, options) {\n    await this.child.delete(cid, options)\n  }\n\n  /**\n   * Delete multiple blocks from the blockstore\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {RmOptions} [options]\n   */\n  async * deleteMany (cids, options) {\n    yield * this.child.deleteMany(cids, options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n  async has (cid, options = {}) {\n    return this.child.has(cid, options)\n  }\n\n  /**\n   * @param {Query} q\n   * @param {AbortOptions} options\n   */\n  async * query (q, options = {}) {\n    yield * this.child.query(q, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {AbortOptions} options\n   */\n  async * queryKeys (q, options = {}) {\n    yield * this.child.queryKeys(q, options)\n  }\n}\n\nmodule.exports = BlockStorage\n"]},"metadata":{},"sourceType":"script"}