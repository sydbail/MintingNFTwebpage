{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  PinTypes\n} = require('ipfs-repo');\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\n\n\nmodule.exports = ({\n  repo,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"rmAll\"]}\n   */\n  function rmAll(_x) {\n    return _rmAll.apply(this, arguments);\n  }\n\n  function _rmAll() {\n    _rmAll = _wrapAsyncGenerator(function* (source, _options = {}) {\n      const release = yield _awaitAsyncGenerator(repo.gcLock.readLock());\n\n      try {\n        // verify that each hash can be unpinned\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(normaliseInput(source)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const {\n              path,\n              recursive\n            } = _value;\n            const {\n              cid\n            } = yield _awaitAsyncGenerator(resolvePath(repo, codecs, path));\n            const {\n              pinned,\n              reason\n            } = yield _awaitAsyncGenerator(repo.pins.isPinnedWithType(cid, PinTypes.all));\n\n            if (!pinned) {\n              throw new Error(`${cid} is not pinned`);\n            }\n\n            switch (reason) {\n              case PinTypes.recursive:\n                if (!recursive) {\n                  throw new Error(`${cid} is pinned recursively`);\n                }\n\n                yield _awaitAsyncGenerator(repo.pins.unpin(cid));\n                yield cid;\n                break;\n\n              case PinTypes.direct:\n                yield _awaitAsyncGenerator(repo.pins.unpin(cid));\n                yield cid;\n                break;\n\n              default:\n                throw new Error(`${cid} is pinned indirectly under ${reason}`);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } finally {\n        release();\n      }\n    });\n    return _rmAll.apply(this, arguments);\n  }\n\n  return withTimeoutOption(rmAll);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/ipfs-core/src/components/pin/rm-all.js"],"names":["normaliseInput","require","resolvePath","withTimeoutOption","PinTypes","module","exports","repo","codecs","rmAll","source","_options","release","gcLock","readLock","path","recursive","cid","pinned","reason","pins","isPinnedWithType","all","Error","unpin","direct"],"mappings":"AAAA;;;;;;;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAqBC,OAAO,CAAC,0CAAD,CAAlC;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAkBD,OAAO,CAAC,aAAD,CAA/B;;AACA,MAAME,iBAAiB,GAAGF,OAAO,CAAC,yCAAD,CAAjC;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAeH,OAAO,CAAC,WAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAAsB;AACrC;AACF;AACA;AAHuC,WAIpBC,KAJoB;AAAA;AAAA;;AAAA;AAAA,iCAIrC,WAAwBC,MAAxB,EAAgCC,QAAQ,GAAG,EAA3C,EAA+C;AAC7C,YAAMC,OAAO,8BAASL,IAAI,CAACM,MAAL,CAAYC,QAAZ,EAAT,CAAb;;AAEA,UAAI;AACF;AADE;AAAA;;AAAA;;AAAA;AAEF,8CAAwCd,cAAc,CAACU,MAAD,CAAtD,gOAAgE;AAAA,kBAA/C;AAAEK,cAAAA,IAAF;AAAQC,cAAAA;AAAR,aAA+C;AAC9D,kBAAM;AAAEC,cAAAA;AAAF,2CAAgBf,WAAW,CAACK,IAAD,EAAOC,MAAP,EAAeO,IAAf,CAA3B,CAAN;AACA,kBAAM;AAAEG,cAAAA,MAAF;AAAUC,cAAAA;AAAV,2CAA2BZ,IAAI,CAACa,IAAL,CAAUC,gBAAV,CAA2BJ,GAA3B,EAAgCb,QAAQ,CAACkB,GAAzC,CAA3B,CAAN;;AAEA,gBAAI,CAACJ,MAAL,EAAa;AACX,oBAAM,IAAIK,KAAJ,CAAW,GAAEN,GAAI,gBAAjB,CAAN;AACD;;AAED,oBAAQE,MAAR;AACE,mBAAMf,QAAQ,CAACY,SAAf;AACE,oBAAI,CAACA,SAAL,EAAgB;AACd,wBAAM,IAAIO,KAAJ,CAAW,GAAEN,GAAI,wBAAjB,CAAN;AACD;;AAED,2CAAMV,IAAI,CAACa,IAAL,CAAUI,KAAV,CAAgBP,GAAhB,CAAN;AAEA,sBAAMA,GAAN;AAEA;;AACF,mBAAMb,QAAQ,CAACqB,MAAf;AACE,2CAAMlB,IAAI,CAACa,IAAL,CAAUI,KAAV,CAAgBP,GAAhB,CAAN;AAEA,sBAAMA,GAAN;AAEA;;AACF;AACE,sBAAM,IAAIM,KAAJ,CAAW,GAAEN,GAAI,+BAA8BE,MAAO,EAAtD,CAAN;AAlBJ;AAoBD;AA9BC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BH,OA/BD,SA+BU;AACRP,QAAAA,OAAO;AACR;AACF,KAzCoC;AAAA;AAAA;;AA2CrC,SAAOT,iBAAiB,CAACM,KAAD,CAAxB;AACD,CA5CD","sourcesContent":["'use strict'\n\nconst { normaliseInput } = require('ipfs-core-utils/src/pins/normalise-input')\nconst { resolvePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { PinTypes } = require('ipfs-repo')\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\nmodule.exports = ({ repo, codecs }) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"rmAll\"]}\n   */\n  async function * rmAll (source, _options = {}) {\n    const release = await repo.gcLock.readLock()\n\n    try {\n      // verify that each hash can be unpinned\n      for await (const { path, recursive } of normaliseInput(source)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n        const { pinned, reason } = await repo.pins.isPinnedWithType(cid, PinTypes.all)\n\n        if (!pinned) {\n          throw new Error(`${cid} is not pinned`)\n        }\n\n        switch (reason) {\n          case (PinTypes.recursive):\n            if (!recursive) {\n              throw new Error(`${cid} is pinned recursively`)\n            }\n\n            await repo.pins.unpin(cid)\n\n            yield cid\n\n            break\n          case (PinTypes.direct):\n            await repo.pins.unpin(cid)\n\n            yield cid\n\n            break\n          default:\n            throw new Error(`${cid} is pinned indirectly under ${reason}`)\n        }\n      }\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(rmAll)\n}\n"]},"metadata":{},"sourceType":"script"}