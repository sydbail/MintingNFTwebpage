{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  Multiaddr\n} = require('multiaddr'); // @ts-ignore timeout-abourt-controles does not export types\n\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst DialRequest = require('./dial-request');\n\nconst {\n  publicAddressesFirst\n} = require('libp2p-utils/src/address-sort');\n\nconst getPeer = require('../get-peer');\n\nconst {\n  codes\n} = require('../errors');\n\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store')} PeerStore\n * @typedef {import('../peer-store/address-book').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {DialRequest} dialRequest\n * @property {TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor({\n    transportManager,\n    peerStore,\n    addressSorter = publicAddressesFirst,\n    maxParallelDials = MAX_PARALLEL_DIALS,\n    maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n    dialTimeout = DIAL_TIMEOUT,\n    maxDialsPerPeer = MAX_PER_PEER_DIALS,\n    resolvers = {}\n  }) {\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.addressSorter = addressSorter;\n    this.maxParallelDials = maxParallelDials;\n    this.maxAddrsToDial = maxAddrsToDial;\n    this.timeout = dialTimeout;\n    this.maxDialsPerPeer = maxDialsPerPeer;\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index);\n    this._pendingDials = new Map();\n    this._pendingDialTargets = new Map();\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value);\n    }\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  destroy() {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (err) {\n        log.error(err);\n      }\n    }\n\n    this._pendingDials.clear();\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'));\n    }\n\n    this._pendingDialTargets.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n\n\n  connectToPeer(peer, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const dialTarget = yield _this._createCancellableDialTarget(peer);\n\n      if (!dialTarget.addrs.length) {\n        throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n      }\n\n      const pendingDial = _this._pendingDials.get(dialTarget.id) || _this._createPendingDial(dialTarget, options);\n\n      try {\n        const connection = yield pendingDial.promise;\n        log('dial succeeded to %s', dialTarget.id);\n        return connection;\n      } catch (err) {\n        // Error is a timeout\n        if (pendingDial.controller.signal.aborted) {\n          err.code = codes.ERR_TIMEOUT;\n        }\n\n        log.error(err);\n        throw err;\n      } finally {\n        pendingDial.destroy();\n      }\n    })();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  _createCancellableDialTarget(peer) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Make dial target promise cancellable\n      const id = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;\n      const cancellablePromise = new Promise((resolve, reject) => {\n        _this2._pendingDialTargets.set(id, {\n          resolve,\n          reject\n        });\n      });\n      const dialTarget = yield Promise.race([_this2._createDialTarget(peer), cancellablePromise]);\n\n      _this2._pendingDialTargets.delete(id);\n\n      return dialTarget;\n    })();\n  }\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  _createDialTarget(peer) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        id,\n        multiaddrs\n      } = getPeer(peer);\n\n      if (multiaddrs) {\n        _this3.peerStore.addressBook.add(id, multiaddrs);\n      }\n\n      let knownAddrs = _this3.peerStore.addressBook.getMultiaddrsForPeer(id, _this3.addressSorter) || []; // If received a multiaddr to dial, it should be the first to use\n      // But, if we know other multiaddrs for the peer, we should try them too.\n\n      if (Multiaddr.isMultiaddr(peer)) {\n        knownAddrs = knownAddrs.filter(addr => !peer.equals(addr));\n        knownAddrs.unshift(peer);\n      }\n      /** @type {Multiaddr[]} */\n\n\n      const addrs = [];\n\n      for (const a of knownAddrs) {\n        const resolvedAddrs = yield _this3._resolve(a);\n        resolvedAddrs.forEach(ra => addrs.push(ra));\n      } // Multiaddrs not supported by the available transports will be filtered out.\n\n\n      const supportedAddrs = addrs.filter(a => _this3.transportManager.transportForMultiaddr(a));\n\n      if (supportedAddrs.length > _this3.maxAddrsToDial) {\n        _this3.peerStore.delete(id);\n\n        throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n      }\n\n      return {\n        id: id.toB58String(),\n        addrs: supportedAddrs\n      };\n    })();\n  }\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n\n\n  _createPendingDial(dialTarget, options = {}) {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      return this.transportManager.dial(addr, options);\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals);\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n\n        this._pendingDials.delete(dialTarget.id);\n      }\n    };\n\n    this._pendingDials.set(dialTarget.id, pendingDial);\n\n    return pendingDial;\n  }\n  /**\n   * @param {number} num\n   */\n\n\n  getTokens(num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n  /**\n   * @param {number} token\n   */\n\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return;\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  _resolve(ma) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n      // Now only supporting resolve for dnsaddr\n      const resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n\n      if (!resolvableProto) {\n        return [ma];\n      }\n\n      const resolvedMultiaddrs = yield _this4._resolveRecord(ma);\n      const recursiveMultiaddrs = yield Promise.all(resolvedMultiaddrs.map(nm => {\n        return _this4._resolve(nm);\n      }));\n      const addrs = recursiveMultiaddrs.flat();\n      return addrs.reduce((array, newM) => {\n        if (!array.find(m => m.equals(newM))) {\n          array.push(newM);\n        }\n\n        return array;\n      }, []);\n    })();\n  }\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  _resolveRecord(ma) {\n    return _asyncToGenerator(function* () {\n      try {\n        ma = new Multiaddr(ma.toString()); // Use current multiaddr module\n\n        const multiaddrs = yield ma.resolve();\n        return multiaddrs;\n      } catch (_) {\n        log.error(`multiaddr ${ma} could not be resolved`);\n        return [];\n      }\n    })();\n  }\n\n}\n\nmodule.exports = Dialer;","map":null,"metadata":{},"sourceType":"script"}