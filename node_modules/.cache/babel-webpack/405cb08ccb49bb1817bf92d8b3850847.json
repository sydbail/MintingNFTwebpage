{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst pkgversion = require('../../package.json').version;\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst PeerId = require('peer-id');\n\nconst {\n  NotStartedError\n} = require('../errors');\n/**\n * @param {Object} config\n * @param {import('peer-id')} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\n\n\nmodule.exports = ({\n  peerId,\n  network\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"id\"]}\n   */\n  function id() {\n    return _id.apply(this, arguments);\n  }\n\n  function _id() {\n    _id = _asyncToGenerator(function* (options = {}) {\n      // eslint-disable-line require-await\n      if (options.peerId === peerId.toB58String()) {\n        delete options.peerId;\n      }\n\n      const net = network.try();\n\n      if (!net) {\n        if (options.peerId) {\n          throw new NotStartedError();\n        }\n\n        const idStr = peerId.toB58String();\n        return {\n          id: idStr,\n          publicKey: uint8ArrayToString(peerId.pubKey.bytes, 'base64pad'),\n          addresses: [],\n          agentVersion: `js-ipfs/${pkgversion}`,\n          protocolVersion: '9000',\n          protocols: []\n        };\n      }\n\n      const id = options.peerId ? PeerId.createFromB58String(options.peerId.toString()) : peerId;\n      const {\n        libp2p\n      } = net;\n      const publicKey = options.peerId ? libp2p.peerStore.keyBook.get(id) : id.pubKey;\n      const addresses = options.peerId ? libp2p.peerStore.addressBook.getMultiaddrsForPeer(id) : libp2p.multiaddrs;\n      const protocols = options.peerId ? libp2p.peerStore.protoBook.get(id) : Array.from(libp2p.upgrader.protocols.keys());\n      const agentVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'AgentVersion') || new Uint8Array());\n      const protocolVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'ProtocolVersion') || new Uint8Array());\n      const idStr = id.toB58String();\n      return {\n        id: idStr,\n        publicKey: uint8ArrayToString(publicKey.bytes, 'base64pad'),\n        addresses: (addresses || []).map(ma => {\n          const str = ma.toString(); // some relay-style transports add our peer id to the ma for us\n          // so don't double-add\n\n          if (str.endsWith(`/p2p/${idStr}`)) {\n            return str;\n          }\n\n          return `${str}/p2p/${idStr}`;\n        }).sort().map(ma => new Multiaddr(ma)),\n        agentVersion,\n        protocolVersion,\n        protocols: (protocols || []).sort()\n      };\n    });\n    return _id.apply(this, arguments);\n  }\n\n  return withTimeoutOption(id);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/components/id.js"],"names":["pkgversion","require","version","Multiaddr","withTimeoutOption","toString","uint8ArrayToString","PeerId","NotStartedError","module","exports","peerId","network","id","options","toB58String","net","try","idStr","publicKey","pubKey","bytes","addresses","agentVersion","protocolVersion","protocols","createFromB58String","libp2p","peerStore","keyBook","get","addressBook","getMultiaddrsForPeer","multiaddrs","protoBook","Array","from","upgrader","keys","metadataBook","getValue","Uint8Array","map","ma","str","endsWith","sort"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pkgversion = require('../../package.json').version\nconst { Multiaddr } = require('multiaddr')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst PeerId = require('peer-id')\nconst { NotStartedError } = require('../errors')\n\n/**\n * @param {Object} config\n * @param {import('peer-id')} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\nmodule.exports = ({ peerId, network }) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"id\"]}\n   */\n  async function id (options = {}) { // eslint-disable-line require-await\n    if (options.peerId === peerId.toB58String()) {\n      delete options.peerId\n    }\n\n    const net = network.try()\n\n    if (!net) {\n      if (options.peerId) {\n        throw new NotStartedError()\n      }\n\n      const idStr = peerId.toB58String()\n\n      return {\n        id: idStr,\n        publicKey: uint8ArrayToString(peerId.pubKey.bytes, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${pkgversion}`,\n        protocolVersion: '9000',\n        protocols: []\n      }\n    }\n\n    const id = options.peerId ? PeerId.createFromB58String(options.peerId.toString()) : peerId\n    const { libp2p } = net\n\n    const publicKey = options.peerId ? libp2p.peerStore.keyBook.get(id) : id.pubKey\n    const addresses = options.peerId ? libp2p.peerStore.addressBook.getMultiaddrsForPeer(id) : libp2p.multiaddrs\n    const protocols = options.peerId ? libp2p.peerStore.protoBook.get(id) : Array.from(libp2p.upgrader.protocols.keys())\n    const agentVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'AgentVersion') || new Uint8Array())\n    const protocolVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'ProtocolVersion') || new Uint8Array())\n    const idStr = id.toB58String()\n\n    return {\n      id: idStr,\n      publicKey: uint8ArrayToString(publicKey.bytes, 'base64pad'),\n      addresses: (addresses || [])\n        .map(ma => {\n          const str = ma.toString()\n\n          // some relay-style transports add our peer id to the ma for us\n          // so don't double-add\n          if (str.endsWith(`/p2p/${idStr}`)) {\n            return str\n          }\n\n          return `${str}/p2p/${idStr}`\n        })\n        .sort()\n        .map(ma => new Multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (protocols || []).sort()\n    }\n  }\n  return withTimeoutOption(id)\n}\n"]},"metadata":{},"sourceType":"script"}