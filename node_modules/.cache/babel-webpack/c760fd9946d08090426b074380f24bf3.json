{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-address-book\"] || ($protobuf.roots[\"libp2p-address-book\"] = {});\n\n$root.Addresses = function () {\n  /**\n   * Properties of an Addresses.\n   * @exports IAddresses\n   * @interface IAddresses\n   * @property {Array.<Addresses.IAddress>|null} [addrs] Addresses addrs\n   * @property {Addresses.ICertifiedRecord|null} [certifiedRecord] Addresses certifiedRecord\n   */\n\n  /**\n   * Constructs a new Addresses.\n   * @exports Addresses\n   * @classdesc Represents an Addresses.\n   * @implements IAddresses\n   * @constructor\n   * @param {IAddresses=} [p] Properties to set\n   */\n  function Addresses(p) {\n    this.addrs = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Addresses addrs.\n   * @member {Array.<Addresses.IAddress>} addrs\n   * @memberof Addresses\n   * @instance\n   */\n\n\n  Addresses.prototype.addrs = $util.emptyArray;\n  /**\n   * Addresses certifiedRecord.\n   * @member {Addresses.ICertifiedRecord|null|undefined} certifiedRecord\n   * @memberof Addresses\n   * @instance\n   */\n\n  Addresses.prototype.certifiedRecord = null;\n  /**\n   * Encodes the specified Addresses message. Does not implicitly {@link Addresses.verify|verify} messages.\n   * @function encode\n   * @memberof Addresses\n   * @static\n   * @param {IAddresses} m Addresses message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Addresses.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n\n    if (m.addrs != null && m.addrs.length) {\n      for (var i = 0; i < m.addrs.length; ++i) $root.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();\n    }\n\n    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, \"certifiedRecord\")) $root.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();\n    return w;\n  };\n  /**\n   * Decodes an Addresses message from the specified reader or buffer.\n   * @function decode\n   * @memberof Addresses\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Addresses} Addresses\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Addresses.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Addresses();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          if (!(m.addrs && m.addrs.length)) m.addrs = [];\n          m.addrs.push($root.Addresses.Address.decode(r, r.uint32()));\n          break;\n\n        case 2:\n          m.certifiedRecord = $root.Addresses.CertifiedRecord.decode(r, r.uint32());\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates an Addresses message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Addresses\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Addresses} Addresses\n   */\n\n\n  Addresses.fromObject = function fromObject(d) {\n    if (d instanceof $root.Addresses) return d;\n    var m = new $root.Addresses();\n\n    if (d.addrs) {\n      if (!Array.isArray(d.addrs)) throw TypeError(\".Addresses.addrs: array expected\");\n      m.addrs = [];\n\n      for (var i = 0; i < d.addrs.length; ++i) {\n        if (typeof d.addrs[i] !== \"object\") throw TypeError(\".Addresses.addrs: object expected\");\n        m.addrs[i] = $root.Addresses.Address.fromObject(d.addrs[i]);\n      }\n    }\n\n    if (d.certifiedRecord != null) {\n      if (typeof d.certifiedRecord !== \"object\") throw TypeError(\".Addresses.certifiedRecord: object expected\");\n      m.certifiedRecord = $root.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from an Addresses message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Addresses\n   * @static\n   * @param {Addresses} m Addresses\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Addresses.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.arrays || o.defaults) {\n      d.addrs = [];\n    }\n\n    if (o.defaults) {\n      d.certifiedRecord = null;\n    }\n\n    if (m.addrs && m.addrs.length) {\n      d.addrs = [];\n\n      for (var j = 0; j < m.addrs.length; ++j) {\n        d.addrs[j] = $root.Addresses.Address.toObject(m.addrs[j], o);\n      }\n    }\n\n    if (m.certifiedRecord != null && m.hasOwnProperty(\"certifiedRecord\")) {\n      d.certifiedRecord = $root.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Addresses to JSON.\n   * @function toJSON\n   * @memberof Addresses\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Addresses.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  Addresses.Address = function () {\n    /**\n     * Properties of an Address.\n     * @memberof Addresses\n     * @interface IAddress\n     * @property {Uint8Array|null} [multiaddr] Address multiaddr\n     * @property {boolean|null} [isCertified] Address isCertified\n     */\n\n    /**\n     * Constructs a new Address.\n     * @memberof Addresses\n     * @classdesc Represents an Address.\n     * @implements IAddress\n     * @constructor\n     * @param {Addresses.IAddress=} [p] Properties to set\n     */\n    function Address(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * Address multiaddr.\n     * @member {Uint8Array} multiaddr\n     * @memberof Addresses.Address\n     * @instance\n     */\n\n\n    Address.prototype.multiaddr = $util.newBuffer([]);\n    /**\n     * Address isCertified.\n     * @member {boolean} isCertified\n     * @memberof Addresses.Address\n     * @instance\n     */\n\n    Address.prototype.isCertified = false;\n    /**\n     * Encodes the specified Address message. Does not implicitly {@link Addresses.Address.verify|verify} messages.\n     * @function encode\n     * @memberof Addresses.Address\n     * @static\n     * @param {Addresses.IAddress} m Address message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    Address.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.multiaddr != null && Object.hasOwnProperty.call(m, \"multiaddr\")) w.uint32(10).bytes(m.multiaddr);\n      if (m.isCertified != null && Object.hasOwnProperty.call(m, \"isCertified\")) w.uint32(16).bool(m.isCertified);\n      return w;\n    };\n    /**\n     * Decodes an Address message from the specified reader or buffer.\n     * @function decode\n     * @memberof Addresses.Address\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Addresses.Address} Address\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Address.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.Addresses.Address();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.multiaddr = r.bytes();\n            break;\n\n          case 2:\n            m.isCertified = r.bool();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates an Address message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Addresses.Address\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Addresses.Address} Address\n     */\n\n\n    Address.fromObject = function fromObject(d) {\n      if (d instanceof $root.Addresses.Address) return d;\n      var m = new $root.Addresses.Address();\n\n      if (d.multiaddr != null) {\n        if (typeof d.multiaddr === \"string\") $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);else if (d.multiaddr.length) m.multiaddr = d.multiaddr;\n      }\n\n      if (d.isCertified != null) {\n        m.isCertified = Boolean(d.isCertified);\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from an Address message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Addresses.Address\n     * @static\n     * @param {Addresses.Address} m Address\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Address.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.defaults) {\n        if (o.bytes === String) d.multiaddr = \"\";else {\n          d.multiaddr = [];\n          if (o.bytes !== Array) d.multiaddr = $util.newBuffer(d.multiaddr);\n        }\n        d.isCertified = false;\n      }\n\n      if (m.multiaddr != null && m.hasOwnProperty(\"multiaddr\")) {\n        d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;\n      }\n\n      if (m.isCertified != null && m.hasOwnProperty(\"isCertified\")) {\n        d.isCertified = m.isCertified;\n      }\n\n      return d;\n    };\n    /**\n     * Converts this Address to JSON.\n     * @function toJSON\n     * @memberof Addresses.Address\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Address.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Address;\n  }();\n\n  Addresses.CertifiedRecord = function () {\n    /**\n     * Properties of a CertifiedRecord.\n     * @memberof Addresses\n     * @interface ICertifiedRecord\n     * @property {number|null} [seq] CertifiedRecord seq\n     * @property {Uint8Array|null} [raw] CertifiedRecord raw\n     */\n\n    /**\n     * Constructs a new CertifiedRecord.\n     * @memberof Addresses\n     * @classdesc Represents a CertifiedRecord.\n     * @implements ICertifiedRecord\n     * @constructor\n     * @param {Addresses.ICertifiedRecord=} [p] Properties to set\n     */\n    function CertifiedRecord(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * CertifiedRecord seq.\n     * @member {number} seq\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     */\n\n\n    CertifiedRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * CertifiedRecord raw.\n     * @member {Uint8Array} raw\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     */\n\n    CertifiedRecord.prototype.raw = $util.newBuffer([]);\n    /**\n     * Encodes the specified CertifiedRecord message. Does not implicitly {@link Addresses.CertifiedRecord.verify|verify} messages.\n     * @function encode\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Addresses.ICertifiedRecord} m CertifiedRecord message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    CertifiedRecord.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.seq != null && Object.hasOwnProperty.call(m, \"seq\")) w.uint32(8).uint64(m.seq);\n      if (m.raw != null && Object.hasOwnProperty.call(m, \"raw\")) w.uint32(18).bytes(m.raw);\n      return w;\n    };\n    /**\n     * Decodes a CertifiedRecord message from the specified reader or buffer.\n     * @function decode\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Addresses.CertifiedRecord} CertifiedRecord\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CertifiedRecord.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.Addresses.CertifiedRecord();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.seq = r.uint64();\n            break;\n\n          case 2:\n            m.raw = r.bytes();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a CertifiedRecord message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Addresses.CertifiedRecord} CertifiedRecord\n     */\n\n\n    CertifiedRecord.fromObject = function fromObject(d) {\n      if (d instanceof $root.Addresses.CertifiedRecord) return d;\n      var m = new $root.Addresses.CertifiedRecord();\n\n      if (d.seq != null) {\n        if ($util.Long) (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;else if (typeof d.seq === \"string\") m.seq = parseInt(d.seq, 10);else if (typeof d.seq === \"number\") m.seq = d.seq;else if (typeof d.seq === \"object\") m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);\n      }\n\n      if (d.raw != null) {\n        if (typeof d.raw === \"string\") $util.base64.decode(d.raw, m.raw = $util.newBuffer($util.base64.length(d.raw)), 0);else if (d.raw.length) m.raw = d.raw;\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a CertifiedRecord message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Addresses.CertifiedRecord} m CertifiedRecord\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CertifiedRecord.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.defaults) {\n        if ($util.Long) {\n          var n = new $util.Long(0, 0, true);\n          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n        } else d.seq = o.longs === String ? \"0\" : 0;\n\n        if (o.bytes === String) d.raw = \"\";else {\n          d.raw = [];\n          if (o.bytes !== Array) d.raw = $util.newBuffer(d.raw);\n        }\n      }\n\n      if (m.seq != null && m.hasOwnProperty(\"seq\")) {\n        if (typeof m.seq === \"number\") d.seq = o.longs === String ? String(m.seq) : m.seq;else d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;\n      }\n\n      if (m.raw != null && m.hasOwnProperty(\"raw\")) {\n        d.raw = o.bytes === String ? $util.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;\n      }\n\n      return d;\n    };\n    /**\n     * Converts this CertifiedRecord to JSON.\n     * @function toJSON\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CertifiedRecord.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CertifiedRecord;\n  }();\n\n  return Addresses;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}