{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doubleNext = exports.indexToDouble = exports.doubleToIndex = exports.decomposeDouble = void 0;\n\nconst ArrayInt64_1 = require(\"./helpers/ArrayInt64\");\n\nconst ArrayInt64Arbitrary_1 = require(\"./helpers/ArrayInt64Arbitrary\");\n\nconst INDEX_POSITIVE_INFINITY = {\n  sign: 1,\n  data: [2146435072, 0]\n};\nconst INDEX_NEGATIVE_INFINITY = {\n  sign: -1,\n  data: [2146435072, 1]\n};\n\nfunction decomposeDouble(d) {\n  const maxSignificand = 2 - Number.EPSILON;\n\n  for (let exponent = -1022; exponent !== 1024; ++exponent) {\n    const powExponent = 2 ** exponent;\n    const maxForExponent = maxSignificand * powExponent;\n\n    if (Math.abs(d) <= maxForExponent) {\n      return {\n        exponent,\n        significand: d / powExponent\n      };\n    }\n  }\n\n  return {\n    exponent: Number.NaN,\n    significand: Number.NaN\n  };\n}\n\nexports.decomposeDouble = decomposeDouble;\n\nfunction positiveNumberToInt64(n) {\n  return [~~(n / 0x100000000), n >>> 0];\n}\n\nfunction indexInDoubleFromDecomp(exponent, significand) {\n  if (exponent === -1022) {\n    const rescaledSignificand = significand * 2 ** 52;\n    return positiveNumberToInt64(rescaledSignificand);\n  }\n\n  const rescaledSignificand = (significand - 1) * 2 ** 52;\n  const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;\n  const index = positiveNumberToInt64(rescaledSignificand);\n  index[0] += exponentOnlyHigh;\n  return index;\n}\n\nfunction doubleToIndex(d) {\n  if (d === Number.POSITIVE_INFINITY) {\n    return ArrayInt64_1.clone64(INDEX_POSITIVE_INFINITY);\n  }\n\n  if (d === Number.NEGATIVE_INFINITY) {\n    return ArrayInt64_1.clone64(INDEX_NEGATIVE_INFINITY);\n  }\n\n  const decomp = decomposeDouble(d);\n  const exponent = decomp.exponent;\n  const significand = decomp.significand;\n\n  if (d > 0 || d === 0 && 1 / d === Number.POSITIVE_INFINITY) {\n    return {\n      sign: 1,\n      data: indexInDoubleFromDecomp(exponent, significand)\n    };\n  } else {\n    const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);\n\n    if (indexOpposite[1] === 0xffffffff) {\n      indexOpposite[0] += 1;\n      indexOpposite[1] = 0;\n    } else {\n      indexOpposite[1] += 1;\n    }\n\n    return {\n      sign: -1,\n      data: indexOpposite\n    };\n  }\n}\n\nexports.doubleToIndex = doubleToIndex;\n\nfunction indexToDouble(index) {\n  if (index.sign === -1) {\n    const indexOpposite = {\n      sign: 1,\n      data: [index.data[0], index.data[1]]\n    };\n\n    if (indexOpposite.data[1] === 0) {\n      indexOpposite.data[0] -= 1;\n      indexOpposite.data[1] = 0xffffffff;\n    } else {\n      indexOpposite.data[1] -= 1;\n    }\n\n    return -indexToDouble(indexOpposite);\n  }\n\n  if (ArrayInt64_1.isEqual64(index, INDEX_POSITIVE_INFINITY)) {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  if (index.data[0] < 0x200000) {\n    return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;\n  }\n\n  const postIndexHigh = index.data[0] - 0x200000;\n  const exponent = -1021 + (postIndexHigh >> 20);\n  const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * Number.EPSILON;\n  return significand * 2 ** exponent;\n}\n\nexports.indexToDouble = indexToDouble;\n\nfunction safeDoubleToIndex(d, constraintsLabel) {\n  if (Number.isNaN(d)) {\n    throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');\n  }\n\n  return doubleToIndex(d);\n}\n\nfunction doubleNext(constraints = {}) {\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeDoubleToIndex(min, 'min');\n  const maxIndex = safeDoubleToIndex(max, 'max');\n\n  if (ArrayInt64_1.isStrictlySmaller64(maxIndex, minIndex)) {\n    throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return ArrayInt64Arbitrary_1.arrayInt64(minIndex, maxIndex).map(indexToDouble);\n  }\n\n  const positiveMaxIdx = ArrayInt64_1.isStrictlyPositive64(maxIndex);\n  const minIndexWithNaN = positiveMaxIdx ? minIndex : ArrayInt64_1.substract64(minIndex, ArrayInt64_1.Unit64);\n  const maxIndexWithNaN = positiveMaxIdx ? ArrayInt64_1.add64(maxIndex, ArrayInt64_1.Unit64) : maxIndex;\n  return ArrayInt64Arbitrary_1.arrayInt64(minIndexWithNaN, maxIndexWithNaN).map(index => {\n    if (ArrayInt64_1.isStrictlySmaller64(maxIndex, index) || ArrayInt64_1.isStrictlySmaller64(index, minIndex)) return Number.NaN;else return indexToDouble(index);\n  });\n}\n\nexports.doubleNext = doubleNext;","map":null,"metadata":{},"sourceType":"script"}