{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Key = require('interface-datastore').Key;\n\nconst log = require('debug')('ipfs:repo:migrator:migration-8');\n\nconst length = require('it-length');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst raw = require('multiformats/codecs/raw');\n\nconst mhd = require('multiformats/hashes/digest');\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\n\n\nfunction unwrap(blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child);\n  }\n\n  return blockstore;\n}\n/**\n * @param {Key} key\n */\n\n\nfunction keyToMultihash(key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`); // Extract multihash from CID\n\n    const multihash = CID.decode(buf).multihash.bytes; // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n\n    const multihashStr = base32.encode(multihash).slice(1).toUpperCase();\n    return new Key(`/${multihashStr}`, false);\n  } catch (err) {\n    return key;\n  }\n}\n/**\n * @param {Key} key\n */\n\n\nfunction keyToCid(key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);\n    const digest = mhd.decode(buf); // CID to Key\n\n    const multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1);\n    return new Key(`/${multihash.toUpperCase()}`, false);\n  } catch {\n    return key;\n  }\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\n\n\nfunction process(_x, _x2, _x3) {\n  return _process.apply(this, arguments);\n}\n/** @type {Migration} */\n\n\nfunction _process() {\n  _process = _asyncToGenerator(function* (backends, onProgress, keyFunction) {\n    const blockstore = backends.blocks;\n    yield blockstore.open();\n    const unwrapped = unwrap(blockstore);\n    const blockCount = yield length(unwrapped.queryKeys({\n      filters: [key => {\n        const newKey = keyFunction(key);\n        return newKey.toString() !== key.toString();\n      }]\n    }));\n\n    try {\n      let counter = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(unwrapped.query({})), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const block = _value;\n          const newKey = keyFunction(block.key); // If the Key is base32 CIDv0 then there's nothing to do\n\n          if (newKey.toString() !== block.key.toString()) {\n            counter += 1;\n            log(`Migrating Block from ${block.key} to ${newKey}`, yield unwrapped.has(block.key));\n            yield unwrapped.delete(block.key);\n            yield unwrapped.put(newKey, block.value);\n            onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } finally {\n      yield blockstore.close();\n    }\n  });\n  return _process.apply(this, arguments);\n}\n\nmodule.exports = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToMultihash);\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToCid);\n  }\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-repo-migrations/migrations/migration-8/index.js"],"names":["CID","require","Key","log","length","base32","raw","mhd","unwrap","blockstore","child","keyToMultihash","key","buf","decode","toString","toLowerCase","slice","multihash","bytes","multihashStr","encode","toUpperCase","err","keyToCid","digest","createV1","code","process","backends","onProgress","keyFunction","blocks","open","unwrapped","blockCount","queryKeys","filters","newKey","counter","query","block","has","delete","put","value","close","module","exports","version","description","migrate","revert"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst Key = require('interface-datastore').Key\nconst log = require('debug')('ipfs:repo:migrator:migration-8')\n\nconst length = require('it-length')\nconst { base32 } = require('multiformats/bases/base32')\nconst raw = require('multiformats/codecs/raw')\nconst mhd = require('multiformats/hashes/digest')\n\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\nfunction unwrap (blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child)\n  }\n\n  return blockstore\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToMultihash (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n\n    // Extract multihash from CID\n    const multihash = CID.decode(buf).multihash.bytes\n\n    // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n    const multihashStr = base32.encode(multihash).slice(1).toUpperCase()\n\n    return new Key(`/${multihashStr}`, false)\n  } catch (err) {\n    return key\n  }\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToCid (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n    const digest = mhd.decode(buf)\n\n    // CID to Key\n    const multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1)\n\n    return new Key(`/${multihash.toUpperCase()}`, false)\n  } catch {\n    return key\n  }\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\nasync function process (backends, onProgress, keyFunction) {\n  const blockstore = backends.blocks\n  await blockstore.open()\n\n  const unwrapped = unwrap(blockstore)\n\n  const blockCount = await length(unwrapped.queryKeys({\n    filters: [(key) => {\n      const newKey = keyFunction(key)\n\n      return newKey.toString() !== key.toString()\n    }]\n  }))\n\n  try {\n    let counter = 0\n\n    for await (const block of unwrapped.query({})) {\n      const newKey = keyFunction(block.key)\n\n      // If the Key is base32 CIDv0 then there's nothing to do\n      if (newKey.toString() !== block.key.toString()) {\n        counter += 1\n        log(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key))\n\n        await unwrapped.delete(block.key)\n        await unwrapped.put(newKey, block.value)\n\n        onProgress((counter / blockCount) * 100, `Migrated Block from ${block.key} to ${newKey}`)\n      }\n    }\n  } finally {\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nmodule.exports = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToMultihash)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToCid)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}