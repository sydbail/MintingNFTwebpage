{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"ipfs-ipns\"] || ($protobuf.roots[\"ipfs-ipns\"] = {});\n\n$root.IpnsEntry = function () {\n  /**\n   * Properties of an IpnsEntry.\n   * @exports IIpnsEntry\n   * @interface IIpnsEntry\n   * @property {Uint8Array|null} [value] IpnsEntry value\n   * @property {Uint8Array|null} [signature] IpnsEntry signature\n   * @property {IpnsEntry.ValidityType|null} [validityType] IpnsEntry validityType\n   * @property {Uint8Array|null} [validity] IpnsEntry validity\n   * @property {number|Long|null} [sequence] IpnsEntry sequence\n   * @property {number|Long|null} [ttl] IpnsEntry ttl\n   * @property {Uint8Array|null} [pubKey] IpnsEntry pubKey\n   * @property {Uint8Array|null} [signatureV2] IpnsEntry signatureV2\n   * @property {Uint8Array|null} [data] IpnsEntry data\n   */\n\n  /**\n   * Constructs a new IpnsEntry.\n   * @exports IpnsEntry\n   * @classdesc Represents an IpnsEntry.\n   * @implements IIpnsEntry\n   * @constructor\n   * @param {IIpnsEntry=} [p] Properties to set\n   */\n  function IpnsEntry(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * IpnsEntry value.\n   * @member {Uint8Array} value\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n\n  IpnsEntry.prototype.value = $util.newBuffer([]);\n  /**\n   * IpnsEntry signature.\n   * @member {Uint8Array} signature\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n  IpnsEntry.prototype.signature = $util.newBuffer([]);\n  /**\n   * IpnsEntry validityType.\n   * @member {IpnsEntry.ValidityType} validityType\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n  IpnsEntry.prototype.validityType = 0;\n  /**\n   * IpnsEntry validity.\n   * @member {Uint8Array} validity\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n  IpnsEntry.prototype.validity = $util.newBuffer([]);\n  /**\n   * IpnsEntry sequence.\n   * @member {number|Long} sequence\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n  IpnsEntry.prototype.sequence = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * IpnsEntry ttl.\n   * @member {number|Long} ttl\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n  IpnsEntry.prototype.ttl = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * IpnsEntry pubKey.\n   * @member {Uint8Array} pubKey\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n  IpnsEntry.prototype.pubKey = $util.newBuffer([]);\n  /**\n   * IpnsEntry signatureV2.\n   * @member {Uint8Array} signatureV2\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n  IpnsEntry.prototype.signatureV2 = $util.newBuffer([]);\n  /**\n   * IpnsEntry data.\n   * @member {Uint8Array} data\n   * @memberof IpnsEntry\n   * @instance\n   */\n\n  IpnsEntry.prototype.data = $util.newBuffer([]);\n  /**\n   * Encodes the specified IpnsEntry message. Does not implicitly {@link IpnsEntry.verify|verify} messages.\n   * @function encode\n   * @memberof IpnsEntry\n   * @static\n   * @param {IIpnsEntry} m IpnsEntry message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  IpnsEntry.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.value != null && Object.hasOwnProperty.call(m, \"value\")) w.uint32(10).bytes(m.value);\n    if (m.signature != null && Object.hasOwnProperty.call(m, \"signature\")) w.uint32(18).bytes(m.signature);\n    if (m.validityType != null && Object.hasOwnProperty.call(m, \"validityType\")) w.uint32(24).int32(m.validityType);\n    if (m.validity != null && Object.hasOwnProperty.call(m, \"validity\")) w.uint32(34).bytes(m.validity);\n    if (m.sequence != null && Object.hasOwnProperty.call(m, \"sequence\")) w.uint32(40).uint64(m.sequence);\n    if (m.ttl != null && Object.hasOwnProperty.call(m, \"ttl\")) w.uint32(48).uint64(m.ttl);\n    if (m.pubKey != null && Object.hasOwnProperty.call(m, \"pubKey\")) w.uint32(58).bytes(m.pubKey);\n    if (m.signatureV2 != null && Object.hasOwnProperty.call(m, \"signatureV2\")) w.uint32(66).bytes(m.signatureV2);\n    if (m.data != null && Object.hasOwnProperty.call(m, \"data\")) w.uint32(74).bytes(m.data);\n    return w;\n  };\n  /**\n   * Decodes an IpnsEntry message from the specified reader or buffer.\n   * @function decode\n   * @memberof IpnsEntry\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {IpnsEntry} IpnsEntry\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  IpnsEntry.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.IpnsEntry();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.value = r.bytes();\n          break;\n\n        case 2:\n          m.signature = r.bytes();\n          break;\n\n        case 3:\n          m.validityType = r.int32();\n          break;\n\n        case 4:\n          m.validity = r.bytes();\n          break;\n\n        case 5:\n          m.sequence = r.uint64();\n          break;\n\n        case 6:\n          m.ttl = r.uint64();\n          break;\n\n        case 7:\n          m.pubKey = r.bytes();\n          break;\n\n        case 8:\n          m.signatureV2 = r.bytes();\n          break;\n\n        case 9:\n          m.data = r.bytes();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates an IpnsEntry message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof IpnsEntry\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {IpnsEntry} IpnsEntry\n   */\n\n\n  IpnsEntry.fromObject = function fromObject(d) {\n    if (d instanceof $root.IpnsEntry) return d;\n    var m = new $root.IpnsEntry();\n\n    if (d.value != null) {\n      if (typeof d.value === \"string\") $util.base64.decode(d.value, m.value = $util.newBuffer($util.base64.length(d.value)), 0);else if (d.value.length) m.value = d.value;\n    }\n\n    if (d.signature != null) {\n      if (typeof d.signature === \"string\") $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);else if (d.signature.length) m.signature = d.signature;\n    }\n\n    switch (d.validityType) {\n      case \"EOL\":\n      case 0:\n        m.validityType = 0;\n        break;\n    }\n\n    if (d.validity != null) {\n      if (typeof d.validity === \"string\") $util.base64.decode(d.validity, m.validity = $util.newBuffer($util.base64.length(d.validity)), 0);else if (d.validity.length) m.validity = d.validity;\n    }\n\n    if (d.sequence != null) {\n      if ($util.Long) (m.sequence = $util.Long.fromValue(d.sequence)).unsigned = true;else if (typeof d.sequence === \"string\") m.sequence = parseInt(d.sequence, 10);else if (typeof d.sequence === \"number\") m.sequence = d.sequence;else if (typeof d.sequence === \"object\") m.sequence = new $util.LongBits(d.sequence.low >>> 0, d.sequence.high >>> 0).toNumber(true);\n    }\n\n    if (d.ttl != null) {\n      if ($util.Long) (m.ttl = $util.Long.fromValue(d.ttl)).unsigned = true;else if (typeof d.ttl === \"string\") m.ttl = parseInt(d.ttl, 10);else if (typeof d.ttl === \"number\") m.ttl = d.ttl;else if (typeof d.ttl === \"object\") m.ttl = new $util.LongBits(d.ttl.low >>> 0, d.ttl.high >>> 0).toNumber(true);\n    }\n\n    if (d.pubKey != null) {\n      if (typeof d.pubKey === \"string\") $util.base64.decode(d.pubKey, m.pubKey = $util.newBuffer($util.base64.length(d.pubKey)), 0);else if (d.pubKey.length) m.pubKey = d.pubKey;\n    }\n\n    if (d.signatureV2 != null) {\n      if (typeof d.signatureV2 === \"string\") $util.base64.decode(d.signatureV2, m.signatureV2 = $util.newBuffer($util.base64.length(d.signatureV2)), 0);else if (d.signatureV2.length) m.signatureV2 = d.signatureV2;\n    }\n\n    if (d.data != null) {\n      if (typeof d.data === \"string\") $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);else if (d.data.length) m.data = d.data;\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from an IpnsEntry message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof IpnsEntry\n   * @static\n   * @param {IpnsEntry} m IpnsEntry\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  IpnsEntry.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.defaults) {\n      if (o.bytes === String) d.value = \"\";else {\n        d.value = [];\n        if (o.bytes !== Array) d.value = $util.newBuffer(d.value);\n      }\n      if (o.bytes === String) d.signature = \"\";else {\n        d.signature = [];\n        if (o.bytes !== Array) d.signature = $util.newBuffer(d.signature);\n      }\n      d.validityType = o.enums === String ? \"EOL\" : 0;\n      if (o.bytes === String) d.validity = \"\";else {\n        d.validity = [];\n        if (o.bytes !== Array) d.validity = $util.newBuffer(d.validity);\n      }\n\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.sequence = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else d.sequence = o.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.ttl = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else d.ttl = o.longs === String ? \"0\" : 0;\n\n      if (o.bytes === String) d.pubKey = \"\";else {\n        d.pubKey = [];\n        if (o.bytes !== Array) d.pubKey = $util.newBuffer(d.pubKey);\n      }\n      if (o.bytes === String) d.signatureV2 = \"\";else {\n        d.signatureV2 = [];\n        if (o.bytes !== Array) d.signatureV2 = $util.newBuffer(d.signatureV2);\n      }\n      if (o.bytes === String) d.data = \"\";else {\n        d.data = [];\n        if (o.bytes !== Array) d.data = $util.newBuffer(d.data);\n      }\n    }\n\n    if (m.value != null && m.hasOwnProperty(\"value\")) {\n      d.value = o.bytes === String ? $util.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;\n    }\n\n    if (m.signature != null && m.hasOwnProperty(\"signature\")) {\n      d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;\n    }\n\n    if (m.validityType != null && m.hasOwnProperty(\"validityType\")) {\n      d.validityType = o.enums === String ? $root.IpnsEntry.ValidityType[m.validityType] : m.validityType;\n    }\n\n    if (m.validity != null && m.hasOwnProperty(\"validity\")) {\n      d.validity = o.bytes === String ? $util.base64.encode(m.validity, 0, m.validity.length) : o.bytes === Array ? Array.prototype.slice.call(m.validity) : m.validity;\n    }\n\n    if (m.sequence != null && m.hasOwnProperty(\"sequence\")) {\n      if (typeof m.sequence === \"number\") d.sequence = o.longs === String ? String(m.sequence) : m.sequence;else d.sequence = o.longs === String ? $util.Long.prototype.toString.call(m.sequence) : o.longs === Number ? new $util.LongBits(m.sequence.low >>> 0, m.sequence.high >>> 0).toNumber(true) : m.sequence;\n    }\n\n    if (m.ttl != null && m.hasOwnProperty(\"ttl\")) {\n      if (typeof m.ttl === \"number\") d.ttl = o.longs === String ? String(m.ttl) : m.ttl;else d.ttl = o.longs === String ? $util.Long.prototype.toString.call(m.ttl) : o.longs === Number ? new $util.LongBits(m.ttl.low >>> 0, m.ttl.high >>> 0).toNumber(true) : m.ttl;\n    }\n\n    if (m.pubKey != null && m.hasOwnProperty(\"pubKey\")) {\n      d.pubKey = o.bytes === String ? $util.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;\n    }\n\n    if (m.signatureV2 != null && m.hasOwnProperty(\"signatureV2\")) {\n      d.signatureV2 = o.bytes === String ? $util.base64.encode(m.signatureV2, 0, m.signatureV2.length) : o.bytes === Array ? Array.prototype.slice.call(m.signatureV2) : m.signatureV2;\n    }\n\n    if (m.data != null && m.hasOwnProperty(\"data\")) {\n      d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this IpnsEntry to JSON.\n   * @function toJSON\n   * @memberof IpnsEntry\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  IpnsEntry.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  /**\n   * ValidityType enum.\n   * @name IpnsEntry.ValidityType\n   * @enum {number}\n   * @property {number} EOL=0 EOL value\n   */\n\n\n  IpnsEntry.ValidityType = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"EOL\"] = 0;\n    return values;\n  }();\n\n  return IpnsEntry;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}