{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst ipns = require('ipns');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:resolver'), {\n  error: debug('ipfs:ipns:resolver:error')\n});\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\n\nclass IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor(routing) {\n    this._routing = routing;\n  }\n  /**\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.recursive]\n   */\n\n\n  resolve(name, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof name !== 'string') {\n        throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n      }\n\n      const recursive = options.recursive && options.recursive.toString() === 'true';\n      const nameSegments = name.split('/');\n\n      if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n        throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n      }\n\n      const key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n      let depth = Infinity;\n\n      if (recursive) {\n        depth = defaultMaximumRecursiveDepth;\n      }\n\n      const res = yield _this.resolver(key, depth);\n      log(`${name} was locally resolved correctly`);\n      return res;\n    })();\n  }\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @returns {Promise<string>}\n   */\n\n\n  resolver(name, depth) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Exceeded recursive maximum depth\n      if (depth === 0) {\n        const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n      }\n\n      const res = yield _this2._resolveName(name);\n      const nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n      if (nameSegments[1] === 'ipfs' || !depth) {\n        return res;\n      } // continue recursively until depth equals 0\n\n\n      return _this2.resolver(nameSegments[2], depth - 1);\n    })();\n  }\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   */\n\n\n  _resolveName(name) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const peerId = PeerId.parse(name);\n      const {\n        routingKey\n      } = ipns.getIdKeys(peerId.toBytes());\n      let record;\n\n      try {\n        record = yield _this3._routing.get(routingKey.uint8Array());\n      } catch (err) {\n        log.error('could not get record from routing', err);\n\n        if (err.code === ERR_NOT_FOUND) {\n          throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n        }\n\n        throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      } // IPNS entry\n\n\n      let ipnsEntry;\n\n      try {\n        ipnsEntry = ipns.unmarshal(record);\n      } catch (err) {\n        log.error('could not unmarshal record', err);\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n      } // We should have the public key by now (inline, or in the entry)\n\n\n      return _this3._validateRecord(peerId, ipnsEntry);\n    })();\n  }\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {import('ipns').IPNSEntry} ipnsEntry\n   */\n\n\n  _validateRecord(peerId, ipnsEntry) {\n    return _asyncToGenerator(function* () {\n      const pubKey = yield ipns.extractPublicKey(peerId, ipnsEntry); // IPNS entry validation\n\n      yield ipns.validate(pubKey, ipnsEntry);\n      return uint8ArrayToString(ipnsEntry.value);\n    })();\n  }\n\n}\n\nexports = module.exports = IpnsResolver;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/ipns/resolver.js"],"names":["ipns","require","PeerId","errcode","debug","log","Object","assign","error","toString","uint8ArrayToString","Errors","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","constructor","routing","_routing","resolve","name","options","Error","recursive","nameSegments","split","length","key","depth","Infinity","res","resolver","errMsg","_resolveName","peerId","parse","routingKey","getIdKeys","toBytes","record","get","uint8Array","err","ipnsEntry","unmarshal","_validateRecord","pubKey","extractPublicKey","validate","value","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:resolver'), {\n  error: debug('ipfs:ipns:resolver:error')\n})\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nclass IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.recursive]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth = Infinity\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @returns {Promise<string>}\n   */\n  async resolver (name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1)\n  }\n\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   */\n  async _resolveName (name) {\n    const peerId = PeerId.parse(name)\n    const { routingKey } = ipns.getIdKeys(peerId.toBytes())\n    let record\n\n    try {\n      record = await this._routing.get(routingKey.uint8Array())\n    } catch (err) {\n      log.error('could not get record from routing', err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // IPNS entry\n    let ipnsEntry\n    try {\n      ipnsEntry = ipns.unmarshal(record)\n    } catch (err) {\n      log.error('could not unmarshal record', err)\n\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    // We should have the public key by now (inline, or in the entry)\n    return this._validateRecord(peerId, ipnsEntry)\n  }\n\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {import('ipns').IPNSEntry} ipnsEntry\n   */\n  async _validateRecord (peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry)\n\n    // IPNS entry validation\n    await ipns.validate(pubKey, ipnsEntry)\n\n    return uint8ArrayToString(ipnsEntry.value)\n  }\n}\n\nexports = module.exports = IpnsResolver\n"]},"metadata":{},"sourceType":"script"}