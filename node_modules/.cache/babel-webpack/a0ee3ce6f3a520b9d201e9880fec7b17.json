{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst {\n  default: parseDuration\n} = require('parse-duration');\n\nconst errCode = require('err-code');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {Object} BWOptions\n * @property {PeerId} [peer] - Specifies a peer to print bandwidth for\n * @property {string} [proto] - Specifies a protocol to print bandwidth for\n * @property {boolean} [poll] - Is used to yield bandwidth info at an interval\n * @property {number|string} [interval=1000] - The time interval to wait between updating output, if `poll` is `true`.\n *\n * @typedef {Object} BandwidthInfo\n * @property {bigint} totalIn\n * @property {bigint} totalOut\n * @property {number} rateIn\n * @property {number} rateOut\n *\n * @typedef {import('libp2p')} libp2p\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {libp2p} libp2p\n * @param {BWOptions} opts\n * @returns {BandwidthInfo}\n */\n\n\nfunction getBandwidthStats(libp2p, opts) {\n  let stats;\n\n  if (!libp2p.metrics) {\n    stats = undefined;\n  } else if (opts.peer) {\n    stats = libp2p.metrics.forPeer(opts.peer);\n  } else if (opts.proto) {\n    stats = libp2p.metrics.forProtocol(opts.proto);\n  } else {\n    stats = libp2p.metrics.global;\n  }\n\n  if (!stats) {\n    return {\n      totalIn: BigInt(0),\n      totalOut: BigInt(0),\n      rateIn: 0.0,\n      rateOut: 0.0\n    };\n  }\n\n  const {\n    movingAverages,\n    snapshot\n  } = stats;\n  return {\n    totalIn: BigInt(snapshot.dataReceived.integerValue().toString()),\n    totalOut: BigInt(snapshot.dataSent.integerValue().toString()),\n    rateIn: movingAverages.dataReceived[60000].movingAverage() / 60,\n    rateOut: movingAverages.dataSent[60000].movingAverage() / 60\n  };\n}\n/**\n * @param {Object} config\n * @param {import('../../types').NetworkService} config.network\n */\n\n\nmodule.exports = ({\n  network\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/stats').API[\"bw\"]}\n   */\n  const bw = /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator(function* (options = {}) {\n      const {\n        libp2p\n      } = yield _awaitAsyncGenerator(network.use(options));\n\n      if (!options.poll) {\n        yield getBandwidthStats(libp2p, options);\n        return;\n      }\n\n      const interval = options.interval || 1000;\n      let ms = -1;\n\n      try {\n        ms = typeof interval === 'string' ? parseDuration(interval) || -1 : interval;\n        if (!ms || ms < 0) throw new Error('invalid duration');\n      } catch (err) {\n        throw errCode(err, 'ERR_INVALID_POLL_INTERVAL');\n      }\n\n      let timeoutId;\n\n      try {\n        while (true) {\n          yield getBandwidthStats(libp2p, options); // eslint-disable-next-line no-loop-func\n\n          yield _awaitAsyncGenerator(new Promise(resolve => {\n            timeoutId = setTimeout(resolve, ms);\n          }));\n        }\n      } finally {\n        clearTimeout(timeoutId);\n      }\n    });\n\n    return function bw() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return withTimeoutOption(bw);\n};","map":null,"metadata":{},"sourceType":"script"}