{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst pkgversion = require('../../package.json').version;\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst PeerId = require('peer-id');\n\nconst {\n  NotStartedError\n} = require('../errors');\n/**\n * @param {Object} config\n * @param {import('peer-id')} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\n\n\nmodule.exports = ({\n  peerId,\n  network\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"id\"]}\n   */\n  function id() {\n    return _id.apply(this, arguments);\n  }\n\n  function _id() {\n    _id = _asyncToGenerator(function* (options = {}) {\n      // eslint-disable-line require-await\n      if (options.peerId === peerId.toB58String()) {\n        delete options.peerId;\n      }\n\n      const net = network.try();\n\n      if (!net) {\n        if (options.peerId) {\n          throw new NotStartedError();\n        }\n\n        const idStr = peerId.toB58String();\n        return {\n          id: idStr,\n          publicKey: uint8ArrayToString(peerId.pubKey.bytes, 'base64pad'),\n          addresses: [],\n          agentVersion: `js-ipfs/${pkgversion}`,\n          protocolVersion: '9000',\n          protocols: []\n        };\n      }\n\n      const id = options.peerId ? PeerId.createFromB58String(options.peerId.toString()) : peerId;\n      const {\n        libp2p\n      } = net;\n      const publicKey = options.peerId ? libp2p.peerStore.keyBook.get(id) : id.pubKey;\n      const addresses = options.peerId ? libp2p.peerStore.addressBook.getMultiaddrsForPeer(id) : libp2p.multiaddrs;\n      const protocols = options.peerId ? libp2p.peerStore.protoBook.get(id) : Array.from(libp2p.upgrader.protocols.keys());\n      const agentVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'AgentVersion') || new Uint8Array());\n      const protocolVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'ProtocolVersion') || new Uint8Array());\n      const idStr = id.toB58String();\n      return {\n        id: idStr,\n        publicKey: uint8ArrayToString(publicKey.bytes, 'base64pad'),\n        addresses: (addresses || []).map(ma => {\n          const str = ma.toString(); // some relay-style transports add our peer id to the ma for us\n          // so don't double-add\n\n          if (str.endsWith(`/p2p/${idStr}`)) {\n            return str;\n          }\n\n          return `${str}/p2p/${idStr}`;\n        }).sort().map(ma => new Multiaddr(ma)),\n        agentVersion,\n        protocolVersion,\n        protocols: (protocols || []).sort()\n      };\n    });\n    return _id.apply(this, arguments);\n  }\n\n  return withTimeoutOption(id);\n};","map":null,"metadata":{},"sourceType":"script"}