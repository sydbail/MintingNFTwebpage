{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst webcrypto = require('../webcrypto');\n\nconst randomBytes = require('../random-bytes');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nexports.utils = require('./rsa-utils');\n\nexports.generateKey = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (bits) {\n    const pair = yield webcrypto.get().subtle.generateKey({\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: {\n        name: 'SHA-256'\n      }\n    }, true, ['sign', 'verify']);\n    const keys = yield exportKey(pair);\n    return {\n      privateKey: keys[0],\n      publicKey: keys[1]\n    };\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}(); // Takes a jwk key\n\n\nexports.unmarshalPrivateKey = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (key) {\n    const privateKey = yield webcrypto.get().subtle.importKey('jwk', key, {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, true, ['sign']);\n    const pair = [privateKey, yield derivePublicFromPrivate(key)];\n    const keys = yield exportKey({\n      privateKey: pair[0],\n      publicKey: pair[1]\n    });\n    return {\n      privateKey: keys[0],\n      publicKey: keys[1]\n    };\n  });\n\n  return function (_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.getRandomValues = randomBytes;\n\nexports.hashAndSign = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (key, msg) {\n    const privateKey = yield webcrypto.get().subtle.importKey('jwk', key, {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, false, ['sign']);\n    const sig = yield webcrypto.get().subtle.sign({\n      name: 'RSASSA-PKCS1-v1_5'\n    }, privateKey, Uint8Array.from(msg));\n    return new Uint8Array(sig, sig.byteOffset, sig.byteLength);\n  });\n\n  return function (_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.hashAndVerify = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (key, sig, msg) {\n    const publicKey = yield webcrypto.get().subtle.importKey('jwk', key, {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, false, ['verify']);\n    return webcrypto.get().subtle.verify({\n      name: 'RSASSA-PKCS1-v1_5'\n    }, publicKey, sig, msg);\n  });\n\n  return function (_x5, _x6, _x7) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nfunction exportKey(pair) {\n  return Promise.all([webcrypto.get().subtle.exportKey('jwk', pair.privateKey), webcrypto.get().subtle.exportKey('jwk', pair.publicKey)]);\n}\n\nfunction derivePublicFromPrivate(jwKey) {\n  return webcrypto.get().subtle.importKey('jwk', {\n    kty: jwKey.kty,\n    n: jwKey.n,\n    e: jwKey.e\n  }, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['verify']);\n}\n/*\n\nRSA encryption/decryption for the browser with webcrypto workarround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg Uint8Array to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our Uint8Array a binary string\n  - Convert resulting nodeForge buffer to Uint8Array: it returns a binary string, turn that into a Uint8Array\n\n*/\n\n\nconst {\n  jwk2pub,\n  jwk2priv\n} = require('./jwk2pem');\n\nfunction convertKey(key, pub, msg, handle) {\n  const fkey = pub ? jwk2pub(key) : jwk2priv(key);\n  const fmsg = uint8ArrayToString(Uint8Array.from(msg), 'ascii');\n  const fomsg = handle(fmsg, fkey);\n  return uint8ArrayFromString(fomsg, 'ascii');\n}\n\nexports.encrypt = function (key, msg) {\n  return convertKey(key, true, msg, (msg, key) => key.encrypt(msg));\n};\n\nexports.decrypt = function (key, msg) {\n  return convertKey(key, false, msg, (msg, key) => key.decrypt(msg));\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-crypto/src/keys/rsa-browser.js"],"names":["webcrypto","require","randomBytes","toString","uint8ArrayToString","fromString","uint8ArrayFromString","exports","utils","generateKey","bits","pair","get","subtle","name","modulusLength","publicExponent","Uint8Array","hash","keys","exportKey","privateKey","publicKey","unmarshalPrivateKey","key","importKey","derivePublicFromPrivate","getRandomValues","hashAndSign","msg","sig","sign","from","byteOffset","byteLength","hashAndVerify","verify","Promise","all","jwKey","kty","n","e","jwk2pub","jwk2priv","convertKey","pub","handle","fkey","fmsg","fomsg","encrypt","decrypt"],"mappings":"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","sourcesContent":["'use strict'\n\nconst webcrypto = require('../webcrypto')\nconst randomBytes = require('../random-bytes')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\nexports.utils = require('./rsa-utils')\n\nexports.generateKey = async function (bits) {\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign', 'verify']\n  )\n\n  const keys = await exportKey(pair)\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\n// Takes a jwk key\nexports.unmarshalPrivateKey = async function (key) {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign']\n  )\n\n  const pair = [\n    privateKey,\n    await derivePublicFromPrivate(key)\n  ]\n\n  const keys = await exportKey({\n    privateKey: pair[0],\n    publicKey: pair[1]\n  })\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\nexports.getRandomValues = randomBytes\n\nexports.hashAndSign = async function (key, msg) {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['sign']\n  )\n\n  const sig = await webcrypto.get().subtle.sign(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    privateKey,\n    Uint8Array.from(msg)\n  )\n\n  return new Uint8Array(sig, sig.byteOffset, sig.byteLength)\n}\n\nexports.hashAndVerify = async function (key, sig, msg) {\n  const publicKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['verify']\n  )\n\n  return webcrypto.get().subtle.verify(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    publicKey,\n    sig,\n    msg\n  )\n}\n\nfunction exportKey (pair) {\n  return Promise.all([\n    webcrypto.get().subtle.exportKey('jwk', pair.privateKey),\n    webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n  ])\n}\n\nfunction derivePublicFromPrivate (jwKey) {\n  return webcrypto.get().subtle.importKey(\n    'jwk',\n    {\n      kty: jwKey.kty,\n      n: jwKey.n,\n      e: jwKey.e\n    },\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['verify']\n  )\n}\n\n/*\n\nRSA encryption/decryption for the browser with webcrypto workarround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg Uint8Array to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our Uint8Array a binary string\n  - Convert resulting nodeForge buffer to Uint8Array: it returns a binary string, turn that into a Uint8Array\n\n*/\n\nconst { jwk2pub, jwk2priv } = require('./jwk2pem')\n\nfunction convertKey (key, pub, msg, handle) {\n  const fkey = pub ? jwk2pub(key) : jwk2priv(key)\n  const fmsg = uint8ArrayToString(Uint8Array.from(msg), 'ascii')\n  const fomsg = handle(fmsg, fkey)\n  return uint8ArrayFromString(fomsg, 'ascii')\n}\n\nexports.encrypt = function (key, msg) {\n  return convertKey(key, true, msg, (msg, key) => key.encrypt(msg))\n}\n\nexports.decrypt = function (key, msg) {\n  return convertKey(key, false, msg, (msg, key) => key.decrypt(msg))\n}\n"]},"metadata":{},"sourceType":"script"}