{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst log = require('debug')('ipfs:mfs:touch');\n\nconst errCode = require('err-code');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst toTrail = require('./utils/to-trail');\n\nconst addLink = require('./utils/add-link');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  cidVersion: 0,\n  hashAlg: 'sha2-256'\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"touch\"]}\n   */\n  function mfsTouch(_x) {\n    return _mfsTouch.apply(this, arguments);\n  }\n\n  function _mfsTouch() {\n    _mfsTouch = _asyncToGenerator(function* (path, options = {}) {\n      /** @type {DefaultOptions} */\n      const settings = mergeOptions(defaultOptions, options);\n      settings.mtime = settings.mtime || new Date();\n      log(`Touching ${path} mtime: ${settings.mtime}`);\n      const {\n        cid,\n        mfsDirectory,\n        name,\n        exists\n      } = yield toMfsPath(context, path, settings);\n      const hashAlg = options.hashAlg || defaultOptions.hashAlg;\n      const hasher = yield context.hashers.getHasher(hashAlg);\n      let updatedBlock;\n      let updatedCid;\n      let cidVersion = settings.cidVersion;\n\n      if (!exists) {\n        const metadata = new UnixFS({\n          type: 'file',\n          // @ts-ignore TODO: restore hrtime support to ipfs-unixfs constructor - it's in the code, just not the signature\n          mtime: settings.mtime\n        });\n        updatedBlock = dagPb.encode({\n          Data: metadata.marshal(),\n          Links: []\n        });\n        const hash = yield hasher.digest(updatedBlock);\n        updatedCid = CID.create(settings.cidVersion, dagPb.code, hash);\n\n        if (settings.flush) {\n          yield context.repo.blocks.put(updatedCid, updatedBlock);\n        }\n      } else {\n        if (cid.code !== dagPb.code) {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n        }\n\n        cidVersion = cid.version;\n        const block = yield context.repo.blocks.get(cid);\n        const node = dagPb.decode(block);\n\n        if (!node.Data) {\n          throw errCode(new Error(`${path} had no data`), 'ERR_INVALID_NODE');\n        }\n\n        const metadata = UnixFS.unmarshal(node.Data); // @ts-ignore TODO: restore setting all date types as mtime - it's in the code, just not the signature\n\n        metadata.mtime = settings.mtime;\n        updatedBlock = dagPb.encode({\n          Data: metadata.marshal(),\n          Links: node.Links\n        });\n        const hash = yield hasher.digest(updatedBlock);\n        updatedCid = CID.create(settings.cidVersion, dagPb.code, hash);\n\n        if (settings.flush) {\n          yield context.repo.blocks.put(updatedCid, updatedBlock);\n        }\n      }\n\n      const trail = yield toTrail(context, mfsDirectory);\n      const parent = trail[trail.length - 1];\n      const parentCid = parent.cid;\n      const parentBlock = yield context.repo.blocks.get(parentCid);\n      const parentNode = dagPb.decode(parentBlock);\n      const result = yield addLink(context, {\n        parent: parentNode,\n        name: name,\n        cid: updatedCid,\n        size: updatedBlock.length,\n        flush: settings.flush,\n        shardSplitThreshold: settings.shardSplitThreshold,\n        hashAlg: settings.hashAlg,\n        cidVersion\n      });\n      parent.cid = result.cid; // update the tree with the new child\n\n      const newRootCid = yield updateTree(context, trail, settings); // Update the MFS record with the new CID for the root of the tree\n\n      yield updateMfsRoot(context, newRootCid, settings);\n    });\n    return _mfsTouch.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsTouch);\n};","map":null,"metadata":{},"sourceType":"script"}