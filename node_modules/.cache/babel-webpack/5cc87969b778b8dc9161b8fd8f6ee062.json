{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst lp = require('it-length-prefixed');\n\nconst Message = require('../message');\n\nconst handlers = require('./handlers');\n\nconst utils = require('../utils');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @param {import('../index')} dht\n */\n\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerId, 'rpc');\n  const getMessageHandler = handlers(dht);\n  /**\n   * Process incoming DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n\n  function handleMessage(_x, _x2) {\n    return _handleMessage.apply(this, arguments);\n  }\n  /**\n   * Handle incoming streams on the dht protocol\n   *\n   * @param {object} props\n   * @param {MuxedStream} props.stream\n   * @param {import('libp2p-interfaces/src/connection').Connection} props.connection\n   */\n\n\n  function _handleMessage() {\n    _handleMessage = _asyncToGenerator(function* (peerId, msg) {\n      // get handler & execute it\n      const handler = getMessageHandler(msg.type);\n\n      try {\n        yield dht._add(peerId);\n      } catch (err) {\n        log.error('Failed to update the kbucket store', err);\n      }\n\n      if (!handler) {\n        log.error(`no handler found for message type: ${msg.type}`);\n        return;\n      }\n\n      return handler(peerId, msg);\n    });\n    return _handleMessage.apply(this, arguments);\n  }\n\n  function onIncomingStream(_x3) {\n    return _onIncomingStream.apply(this, arguments);\n  }\n\n  function _onIncomingStream() {\n    _onIncomingStream = _asyncToGenerator(function* ({\n      stream,\n      connection\n    }) {\n      const peerId = connection.remotePeer;\n\n      try {\n        yield dht._add(peerId);\n      } catch (err) {\n        log.error(err);\n      }\n\n      const idB58Str = peerId.toB58String();\n      log('from: %s', idB58Str);\n      yield pipe(stream.source, lp.decode(),\n      /**\n       * @param {AsyncIterable<Uint8Array>} source\n       */\n      source => _wrapAsyncGenerator(function* () {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const msg = _value;\n            // handle the message\n            const desMessage = Message.deserialize(msg.slice());\n            const res = yield _awaitAsyncGenerator(handleMessage(peerId, desMessage)); // Not all handlers will return a response\n\n            if (res) {\n              yield res.serialize();\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      })(), lp.encode(), stream.sink);\n    });\n    return _onIncomingStream.apply(this, arguments);\n  }\n\n  return onIncomingStream;\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p-kad-dht/src/rpc/index.js"],"names":["pipe","require","lp","Message","handlers","utils","module","exports","dht","log","logger","peerId","getMessageHandler","handleMessage","msg","handler","type","_add","err","error","onIncomingStream","stream","connection","remotePeer","idB58Str","toB58String","source","decode","desMessage","deserialize","slice","res","serialize","encode","sink"],"mappings":"AAAA;;;;;;;;;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAWC,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,oBAAD,CAAlB;;AAEA,MAAME,OAAO,GAAGF,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,UAAD,CAArB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACAK,MAAM,CAACC,OAAP,GAAkBC,GAAD,IAAS;AACxB,QAAMC,GAAG,GAAGJ,KAAK,CAACK,MAAN,CAAaF,GAAG,CAACG,MAAjB,EAAyB,KAAzB,CAAZ;AACA,QAAMC,iBAAiB,GAAGR,QAAQ,CAACI,GAAD,CAAlC;AAEA;AACF;AACA;AACA;AACA;AACA;;AAT0B,WAUTK,aAVS;AAAA;AAAA;AA4BxB;AACF;AACA;AACA;AACA;AACA;AACA;;;AAlC0B;AAAA,uCAUxB,WAA8BF,MAA9B,EAAsCG,GAAtC,EAA2C;AACzC;AACA,YAAMC,OAAO,GAAGH,iBAAiB,CAACE,GAAG,CAACE,IAAL,CAAjC;;AAEA,UAAI;AACF,cAAMR,GAAG,CAACS,IAAJ,CAASN,MAAT,CAAN;AACD,OAFD,CAEE,OAAOO,GAAP,EAAY;AACZT,QAAAA,GAAG,CAACU,KAAJ,CAAU,oCAAV,EAAgDD,GAAhD;AACD;;AAED,UAAI,CAACH,OAAL,EAAc;AACZN,QAAAA,GAAG,CAACU,KAAJ,CAAW,sCAAqCL,GAAG,CAACE,IAAK,EAAzD;AACA;AACD;;AAED,aAAOD,OAAO,CAACJ,MAAD,EAASG,GAAT,CAAd;AACD,KA1BuB;AAAA;AAAA;;AAAA,WAmCTM,gBAnCS;AAAA;AAAA;;AAAA;AAAA,0CAmCxB,WAAiC;AAAEC,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAAjC,EAAyD;AACvD,YAAMX,MAAM,GAAGW,UAAU,CAACC,UAA1B;;AAEA,UAAI;AACF,cAAMf,GAAG,CAACS,IAAJ,CAASN,MAAT,CAAN;AACD,OAFD,CAEE,OAAOO,GAAP,EAAY;AACZT,QAAAA,GAAG,CAACU,KAAJ,CAAUD,GAAV;AACD;;AAED,YAAMM,QAAQ,GAAGb,MAAM,CAACc,WAAP,EAAjB;AACAhB,MAAAA,GAAG,CAAC,UAAD,EAAae,QAAb,CAAH;AAEA,YAAMxB,IAAI,CACRqB,MAAM,CAACK,MADC,EAERxB,EAAE,CAACyB,MAAH,EAFQ;AAGR;AACN;AACA;AACMD,MAAAA,MAAM,IAAI,oBAAC,aAAoB;AAAA;AAAA;;AAAA;;AAAA;AAC7B,8CAAwBA,MAAxB,gOAAgC;AAAA,kBAAfZ,GAAe;AAC9B;AACA,kBAAMc,UAAU,GAAGzB,OAAO,CAAC0B,WAAR,CAAoBf,GAAG,CAACgB,KAAJ,EAApB,CAAnB;AACA,kBAAMC,GAAG,8BAASlB,aAAa,CAACF,MAAD,EAASiB,UAAT,CAAtB,CAAT,CAH8B,CAK9B;;AACA,gBAAIG,GAAJ,EAAS;AACP,oBAAMA,GAAG,CAACC,SAAJ,EAAN;AACD;AACF;AAV4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAW9B,OAXS,GANF,EAkBR9B,EAAE,CAAC+B,MAAH,EAlBQ,EAmBRZ,MAAM,CAACa,IAnBC,CAAV;AAqBD,KApEuB;AAAA;AAAA;;AAsExB,SAAOd,gBAAP;AACD,CAvED","sourcesContent":["'use strict'\n\nconst { pipe } = require('it-pipe')\nconst lp = require('it-length-prefixed')\n\nconst Message = require('../message')\nconst handlers = require('./handlers')\nconst utils = require('../utils')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @param {import('../index')} dht\n */\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerId, 'rpc')\n  const getMessageHandler = handlers(dht)\n\n  /**\n   * Process incoming DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   */\n  async function handleMessage (peerId, msg) {\n    // get handler & execute it\n    const handler = getMessageHandler(msg.type)\n\n    try {\n      await dht._add(peerId)\n    } catch (err) {\n      log.error('Failed to update the kbucket store', err)\n    }\n\n    if (!handler) {\n      log.error(`no handler found for message type: ${msg.type}`)\n      return\n    }\n\n    return handler(peerId, msg)\n  }\n\n  /**\n   * Handle incoming streams on the dht protocol\n   *\n   * @param {object} props\n   * @param {MuxedStream} props.stream\n   * @param {import('libp2p-interfaces/src/connection').Connection} props.connection\n   */\n  async function onIncomingStream ({ stream, connection }) {\n    const peerId = connection.remotePeer\n\n    try {\n      await dht._add(peerId)\n    } catch (err) {\n      log.error(err)\n    }\n\n    const idB58Str = peerId.toB58String()\n    log('from: %s', idB58Str)\n\n    await pipe(\n      stream.source,\n      lp.decode(),\n      /**\n       * @param {AsyncIterable<Uint8Array>} source\n       */\n      source => (async function * () {\n        for await (const msg of source) {\n          // handle the message\n          const desMessage = Message.deserialize(msg.slice())\n          const res = await handleMessage(peerId, desMessage)\n\n          // Not all handlers will return a response\n          if (res) {\n            yield res.serialize()\n          }\n        }\n      })(),\n      lp.encode(),\n      stream.sink\n    )\n  }\n\n  return onIncomingStream\n}\n"]},"metadata":{},"sourceType":"script"}