{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst errcode = require('err-code');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n\nconst crypto = require('./ed25519');\n\nconst pbm = require('./keys');\n\nconst exporter = require('./exporter');\n\nclass Ed25519PublicKey {\n  constructor(key) {\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n\n  verify(data, sig) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      return crypto.hashAndVerify(_this._key, sig, data);\n    })();\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  hash() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        bytes\n      } = yield sha256.digest(_this2.bytes);\n      return bytes;\n    })();\n  }\n\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor(key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n\n  sign(message) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      return crypto.hashAndSign(_this3._key, message);\n    })();\n  }\n\n  get public() {\n    return new Ed25519PublicKey(this._publicKey);\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  hash() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        bytes\n      } = yield sha256.digest(_this4.bytes);\n      return bytes;\n    })();\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the identity multihash containing its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  id() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const encoding = yield identity.digest(_this5.public.bytes);\n      return base58btc.encode(encoding.bytes).substring(1);\n    })();\n  }\n  /**\n   * Exports the key into a password protected `format`\n   *\n   * @param {string} password - The password to encrypt the key\n   * @param {string} [format=libp2p-key] - The format in which to export as\n   * @returns {Promise<Uint8Array>} The encrypted private key\n   */\n\n\n  export(password, format = 'libp2p-key') {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      if (format === 'libp2p-key') {\n        return exporter.export(_this6.bytes, password);\n      } else {\n        throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n      }\n    })();\n  }\n\n}\n\nfunction unmarshalEd25519PrivateKey(bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n    const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n    const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength);\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n  const publicKeyBytes = bytes.slice(crypto.publicKeyLength);\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\n\nfunction unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\n\nfunction generateKeyPair() {\n  return _generateKeyPair.apply(this, arguments);\n}\n\nfunction _generateKeyPair() {\n  _generateKeyPair = _asyncToGenerator(function* () {\n    const {\n      privateKey,\n      publicKey\n    } = yield crypto.generateKey();\n    return new Ed25519PrivateKey(privateKey, publicKey);\n  });\n  return _generateKeyPair.apply(this, arguments);\n}\n\nfunction generateKeyPairFromSeed(_x) {\n  return _generateKeyPairFromSeed.apply(this, arguments);\n}\n\nfunction _generateKeyPairFromSeed() {\n  _generateKeyPairFromSeed = _asyncToGenerator(function* (seed) {\n    const {\n      privateKey,\n      publicKey\n    } = yield crypto.generateKeyFromSeed(seed);\n    return new Ed25519PrivateKey(privateKey, publicKey);\n  });\n  return _generateKeyPairFromSeed.apply(this, arguments);\n}\n\nfunction ensureKey(key, length) {\n  key = Uint8Array.from(key || []);\n\n  if (key.length !== length) {\n    throw errcode(new Error(`Key must be a Uint8Array of length ${length}, got ${key.length}`), 'ERR_INVALID_KEY_TYPE');\n  }\n\n  return key;\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n};","map":null,"metadata":{},"sourceType":"script"}