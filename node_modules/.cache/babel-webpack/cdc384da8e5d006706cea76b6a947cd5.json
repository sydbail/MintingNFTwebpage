{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst ipns = require('ipns');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:resolver'), {\n  error: debug('ipfs:ipns:resolver:error')\n});\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\n\nclass IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor(routing) {\n    this._routing = routing;\n  }\n  /**\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.recursive]\n   */\n\n\n  resolve(name, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof name !== 'string') {\n        throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n      }\n\n      const recursive = options.recursive && options.recursive.toString() === 'true';\n      const nameSegments = name.split('/');\n\n      if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n        throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n      }\n\n      const key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n      let depth = Infinity;\n\n      if (recursive) {\n        depth = defaultMaximumRecursiveDepth;\n      }\n\n      const res = yield _this.resolver(key, depth);\n      log(`${name} was locally resolved correctly`);\n      return res;\n    })();\n  }\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @returns {Promise<string>}\n   */\n\n\n  resolver(name, depth) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Exceeded recursive maximum depth\n      if (depth === 0) {\n        const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n      }\n\n      const res = yield _this2._resolveName(name);\n      const nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n      if (nameSegments[1] === 'ipfs' || !depth) {\n        return res;\n      } // continue recursively until depth equals 0\n\n\n      return _this2.resolver(nameSegments[2], depth - 1);\n    })();\n  }\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   */\n\n\n  _resolveName(name) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const peerId = PeerId.parse(name);\n      const {\n        routingKey\n      } = ipns.getIdKeys(peerId.toBytes());\n      let record;\n\n      try {\n        record = yield _this3._routing.get(routingKey.uint8Array());\n      } catch (err) {\n        log.error('could not get record from routing', err);\n\n        if (err.code === ERR_NOT_FOUND) {\n          throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n        }\n\n        throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      } // IPNS entry\n\n\n      let ipnsEntry;\n\n      try {\n        ipnsEntry = ipns.unmarshal(record);\n      } catch (err) {\n        log.error('could not unmarshal record', err);\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n      } // We should have the public key by now (inline, or in the entry)\n\n\n      return _this3._validateRecord(peerId, ipnsEntry);\n    })();\n  }\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {import('ipns').IPNSEntry} ipnsEntry\n   */\n\n\n  _validateRecord(peerId, ipnsEntry) {\n    return _asyncToGenerator(function* () {\n      const pubKey = yield ipns.extractPublicKey(peerId, ipnsEntry); // IPNS entry validation\n\n      yield ipns.validate(pubKey, ipnsEntry);\n      return uint8ArrayToString(ipnsEntry.value);\n    })();\n  }\n\n}\n\nexports = module.exports = IpnsResolver;","map":null,"metadata":{},"sourceType":"script"}