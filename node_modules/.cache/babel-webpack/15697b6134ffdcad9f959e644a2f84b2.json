{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncProperty = void 0;\n\nconst PreconditionFailure_1 = require(\"../precondition/PreconditionFailure\");\n\nconst IRawProperty_1 = require(\"./IRawProperty\");\n\nconst GlobalParameters_1 = require(\"../runner/configuration/GlobalParameters\");\n\nconst ConverterFromNext_1 = require(\"../arbitrary/definition/ConverterFromNext\");\n\nclass AsyncProperty {\n  constructor(arb, predicate) {\n    this.arb = arb;\n    this.predicate = predicate;\n\n    this.isAsync = () => true;\n\n    const {\n      asyncBeforeEach,\n      asyncAfterEach,\n      beforeEach,\n      afterEach\n    } = GlobalParameters_1.readConfigureGlobal() || {};\n\n    if (asyncBeforeEach !== undefined && beforeEach !== undefined) {\n      throw Error('Global \"asyncBeforeEach\" and \"beforeEach\" parameters can\\'t be set at the same time when running async properties');\n    }\n\n    if (asyncAfterEach !== undefined && afterEach !== undefined) {\n      throw Error('Global \"asyncAfterEach\" and \"afterEach\" parameters can\\'t be set at the same time when running async properties');\n    }\n\n    this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;\n    this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;\n  }\n\n  generate(mrng, runId) {\n    if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(this.arb)) {\n      return this.arb.toShrinkable(this.arb.arb.generate(mrng, runId != null ? IRawProperty_1.runIdToFrequency(runId) : undefined));\n    }\n\n    return runId != null ? this.arb.withBias(IRawProperty_1.runIdToFrequency(runId)).generate(mrng) : this.arb.generate(mrng);\n  }\n\n  run(v) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.beforeEachHook();\n\n      try {\n        const output = yield _this.predicate(v);\n        return output == null || output === true ? null : 'Property failed by returning false';\n      } catch (err) {\n        if (PreconditionFailure_1.PreconditionFailure.isFailure(err)) return err;\n        if (err instanceof Error && err.stack) return `${err}\\n\\nStack trace: ${err.stack}`;\n        return `${err}`;\n      } finally {\n        yield _this.afterEachHook();\n      }\n    })();\n  }\n\n  beforeEach(hookFunction) {\n    const previousBeforeEachHook = this.beforeEachHook;\n\n    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);\n\n    return this;\n  }\n\n  afterEach(hookFunction) {\n    const previousAfterEachHook = this.afterEachHook;\n\n    this.afterEachHook = () => hookFunction(previousAfterEachHook);\n\n    return this;\n  }\n\n}\n\nexports.AsyncProperty = AsyncProperty;\n\nAsyncProperty.dummyHook = () => {};","map":null,"metadata":{},"sourceType":"script"}