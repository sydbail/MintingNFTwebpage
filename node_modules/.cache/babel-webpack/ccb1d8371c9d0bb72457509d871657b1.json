{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  ipfs: {\n    pin: {\n      Set: PinSet\n    }\n  }\n} = require('./pin'); // @ts-ignore\n\n\nconst fnv1a = require('fnv1a');\n\nconst varint = require('varint');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  DEFAULT_FANOUT,\n  MAX_ITEMS,\n  EMPTY_KEY\n} = require('./utils');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  compare: uint8ArrayCompare\n} = require('uint8arrays/compare');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\n\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data;\n\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n\n  const hdrLength = varint.decode(rootData);\n  const vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`);\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n/**\n * @param {number} seed\n * @param {CID} key\n */\n\n\nfunction hash(seed, key) {\n  const buffer = new Uint8Array(4);\n  const dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  const encodedKey = uint8ArrayFromString(key.toString());\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a(uint8ArrayToString(data));\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\n\n\nfunction walkItems(_x, _x2) {\n  return _walkItems.apply(this, arguments);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\n\n\nfunction _walkItems() {\n  _walkItems = _wrapAsyncGenerator(function* (blockstore, node) {\n    const pbh = readHeader(node);\n    let idx = 0;\n\n    for (const link of node.Links) {\n      if (idx < pbh.header.fanout) {\n        // the first pbh.header.fanout links are fanout bins\n        // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n        const linkHash = link.Hash;\n\n        if (!EMPTY_KEY.equals(linkHash)) {\n          // walk the links of this fanout bin\n          const buf = yield _awaitAsyncGenerator(blockstore.get(linkHash));\n          const node = dagPb.decode(buf);\n          yield* _asyncGeneratorDelegate(_asyncIterator(walkItems(blockstore, node)), _awaitAsyncGenerator);\n        }\n      } else {\n        // otherwise, the link is a pin\n        yield link.Hash;\n      }\n\n      idx++;\n    }\n  });\n  return _walkItems.apply(this, arguments);\n}\n\nfunction loadSet(_x3, _x4, _x5) {\n  return _loadSet.apply(this, arguments);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\n\n\nfunction _loadSet() {\n  _loadSet = _wrapAsyncGenerator(function* (blockstore, rootNode, name) {\n    const link = rootNode.Links.find(l => l.Name === name);\n\n    if (!link) {\n      throw new Error('No link found with name ' + name);\n    }\n\n    const buf = yield _awaitAsyncGenerator(blockstore.get(link.Hash));\n    const node = dagPb.decode(buf);\n    yield* _asyncGeneratorDelegate(_asyncIterator(walkItems(blockstore, node)), _awaitAsyncGenerator);\n  });\n  return _loadSet.apply(this, arguments);\n}\n\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n\n  function storePins(_x6, _x7) {\n    return _storePins.apply(this, arguments);\n  }\n\n  function _storePins() {\n    _storePins = _asyncToGenerator(function* (pins, depth) {\n      const pbHeader = PinSet.encode({\n        version: 1,\n        fanout: DEFAULT_FANOUT,\n        seed: depth\n      }).finish();\n      const header = varint.encode(pbHeader.length);\n      const headerBuf = uint8ArrayConcat([header, pbHeader]);\n      const fanoutLinks = [];\n\n      for (let i = 0; i < DEFAULT_FANOUT; i++) {\n        fanoutLinks.push({\n          Name: '',\n          Tsize: 1,\n          Hash: EMPTY_KEY\n        });\n      }\n\n      if (pins.length <= MAX_ITEMS) {\n        const nodes = pins.map(item => {\n          return {\n            link: {\n              Name: '',\n              Tsize: 1,\n              Hash: item.key\n            },\n            data: item.data || new Uint8Array()\n          };\n        }) // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);\n        });\n        const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n        const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)]);\n        return {\n          Data: rootData,\n          Links: rootLinks\n        };\n      } else {\n        // If the array of pins is > MAX_ITEMS, we:\n        //  - distribute the pins among `DEFAULT_FANOUT` bins\n        //    - create a DAGNode for each bin\n        //      - add each pin as a DAGLink to that bin\n        //  - create a root DAGNode\n        //    - add each bin as a DAGLink\n        //  - send that root DAGNode via callback\n        // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n        // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n        /** @type {Pin[][]} */\n        const bins = pins.reduce((bins, pin) => {\n          const n = hash(depth, pin.key) % DEFAULT_FANOUT; // @ts-ignore\n\n          bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n          return bins;\n        }, []);\n        let idx = 0;\n\n        for (const bin of bins) {\n          const child = yield storePins(bin, depth + 1);\n          yield storeChild(child, idx);\n          idx++;\n        }\n\n        return {\n          Data: headerBuf,\n          Links: fanoutLinks\n        };\n      }\n      /**\n       * @param {PBNode} child\n       * @param {number} binIdx\n       */\n\n\n      function storeChild(_x8, _x9) {\n        return _storeChild.apply(this, arguments);\n      }\n\n      function _storeChild() {\n        _storeChild = _asyncToGenerator(function* (child, binIdx) {\n          const buf = dagPb.encode(child);\n          const digest = yield sha256.digest(buf);\n          const cid = CID.createV0(digest);\n          yield blockstore.put(cid, buf);\n          const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;\n          fanoutLinks[binIdx] = {\n            Name: '',\n            Tsize: size,\n            Hash: cid\n          };\n        });\n        return _storeChild.apply(this, arguments);\n      }\n    });\n    return _storePins.apply(this, arguments);\n  }\n}\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\n\n\nfunction storeSet(_x10, _x11, _x12) {\n  return _storeSet.apply(this, arguments);\n}\n\nfunction _storeSet() {\n  _storeSet = _asyncToGenerator(function* (blockstore, type, cids) {\n    const rootNode = yield storeItems(blockstore, cids.map(cid => {\n      return {\n        key: cid\n      };\n    }));\n    const buf = dagPb.encode(rootNode);\n    const digest = yield sha256.digest(buf);\n    const cid = CID.createV0(digest);\n    yield blockstore.put(cid, buf);\n    const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;\n    return {\n      Name: type,\n      Tsize: size,\n      Hash: cid\n    };\n  });\n  return _storeSet.apply(this, arguments);\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js"],"names":["CID","require","ipfs","pin","Set","PinSet","fnv1a","varint","dagPb","DEFAULT_FANOUT","MAX_ITEMS","EMPTY_KEY","concat","uint8ArrayConcat","compare","uint8ArrayCompare","toString","uint8ArrayToString","fromString","uint8ArrayFromString","sha256","readHeader","rootNode","rootData","Data","Error","hdrLength","decode","vBytes","bytes","length","hdrSlice","slice","header","toObject","defaults","arrays","longs","Number","objects","version","fanout","Links","data","hash","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","blockstore","node","pbh","idx","link","linkHash","Hash","equals","buf","get","loadSet","name","find","l","Name","storeItems","items","storePins","pins","depth","pbHeader","encode","finish","headerBuf","fanoutLinks","i","push","Tsize","nodes","map","item","sort","a","b","rootLinks","bins","reduce","n","bin","child","storeChild","binIdx","digest","cid","createV0","put","size","acc","curr","storeSet","type","cids","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst {\n  ipfs: {\n    pin: {\n      Set: PinSet\n    }\n  }\n} = require('./pin')\n\n// @ts-ignore\nconst fnv1a = require('fnv1a')\nconst varint = require('varint')\nconst dagPb = require('@ipld/dag-pb')\nconst { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } = require('./utils')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { compare: uint8ArrayCompare } = require('uint8arrays/compare')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { sha256 } = require('multiformats/hashes/sha2')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n\n  if (!rootData) {\n    throw new Error('No data present')\n  }\n\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  })\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash (seed, key) {\n  const buffer = new Uint8Array(4)\n  const dataView = new DataView(buffer.buffer)\n  dataView.setUint32(0, seed, true)\n  const encodedKey = uint8ArrayFromString(key.toString())\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength)\n\n  return fnv1a(uint8ArrayToString(data))\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nasync function * walkItems (blockstore, node) {\n  const pbh = readHeader(node)\n  let idx = 0\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash)\n        const node = dagPb.decode(buf)\n\n        yield * walkItems(blockstore, node)\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash\n    }\n\n    idx++\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nasync function * loadSet (blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name)\n\n  if (!link) {\n    throw new Error('No link found with name ' + name)\n  }\n\n  const buf = await blockstore.get(link.Hash)\n  const node = dagPb.decode(buf)\n\n  yield * walkItems(blockstore, node)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction storeItems (blockstore, items) {\n  return storePins(items, 0)\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  async function storePins (pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish()\n\n    const header = varint.encode(pbHeader.length)\n    const headerBuf = uint8ArrayConcat([header, pbHeader])\n    const fanoutLinks = []\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      })\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins\n        .map(item => {\n          return ({\n            link: {\n              Name: '',\n              Tsize: 1,\n              Hash: item.key\n            },\n            data: item.data || new Uint8Array()\n          })\n        })\n        // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes)\n        })\n\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)])\n\n      return {\n        Data: rootData,\n        Links: rootLinks\n      }\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT\n        // @ts-ignore\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n        return bins\n      }, [])\n\n      let idx = 0\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1)\n\n        await storeChild(child, idx)\n\n        idx++\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      }\n    }\n\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n    async function storeChild (child, binIdx) {\n      const buf = dagPb.encode(child)\n      const digest = await sha256.digest(buf)\n      const cid = CID.createV0(digest)\n\n      await blockstore.put(cid, buf)\n\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length\n\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      }\n    }\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nasync function storeSet (blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    }\n  }))\n  const buf = dagPb.encode(rootNode)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length\n\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  }\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n}\n"]},"metadata":{},"sourceType":"script"}