{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst filter = require('it-filter');\n\nconst pushable = require('it-pushable');\n\nconst drain = require('it-drain');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n *\n * @param {Blockstore} blockstore\n */\n\n\nmodule.exports = createIdStore;\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\n\nfunction createIdStore(store) {\n  return {\n    open() {\n      return store.open();\n    },\n\n    close() {\n      return store.close();\n    },\n\n    query(query, options) {\n      return store.query(query, options);\n    },\n\n    queryKeys(query, options) {\n      return store.queryKeys(query, options);\n    },\n\n    get(cid, options) {\n      return _asyncToGenerator(function* () {\n        const extracted = extractContents(cid);\n\n        if (extracted.isIdentity) {\n          return Promise.resolve(extracted.digest);\n        }\n\n        return store.get(cid, options);\n      })();\n    },\n\n    getMany(cids, options) {\n      var _this = this;\n\n      return _wrapAsyncGenerator(function* () {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(cids), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const cid = _value;\n            yield _this.get(cid, options);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      })();\n    },\n\n    put(cid, buf, options) {\n      return _asyncToGenerator(function* () {\n        const {\n          isIdentity\n        } = extractContents(cid);\n\n        if (isIdentity) {\n          return;\n        }\n\n        yield store.put(cid, buf, options);\n      })();\n    },\n\n    putMany(pairs, options) {\n      return _wrapAsyncGenerator(function* () {\n        // in order to return all blocks. we're going to assemble a seperate iterable\n        // return rather than return the resolves of store.putMany using the same\n        // process used by blockstore.putMany\n        const output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n        // event loop iteration so is slower. Use process.nextTick if it is available.\n\n        const runner = process && process.nextTick ? process.nextTick : setImmediate;\n        runner( /*#__PURE__*/_asyncToGenerator(function* () {\n          try {\n            yield drain(store.putMany(_wrapAsyncGenerator(function* () {\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n\n              var _iteratorError2;\n\n              try {\n                for (var _iterator2 = _asyncIterator(pairs), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n                  const {\n                    key,\n                    value\n                  } = _value2;\n\n                  if (!extractContents(key).isIdentity) {\n                    yield {\n                      key,\n                      value\n                    };\n                  } // if non identity blocks successfully write, blocks are included in output\n\n\n                  output.push({\n                    key,\n                    value\n                  });\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    yield _awaitAsyncGenerator(_iterator2.return());\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            })()));\n            output.end();\n          } catch (err) {\n            output.end(err);\n          }\n        }));\n        yield* _asyncGeneratorDelegate(_asyncIterator(output), _awaitAsyncGenerator);\n      })();\n    },\n\n    has(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve(true);\n      }\n\n      return store.has(cid, options);\n    },\n\n    delete(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve();\n      }\n\n      return store.delete(cid, options);\n    },\n\n    deleteMany(cids, options) {\n      return store.deleteMany(filter(cids, cid => !extractContents(cid).isIdentity), options);\n    },\n\n    batch() {\n      const batch = store.batch();\n      return {\n        put(cid, buf) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.put(cid, buf);\n        },\n\n        delete(cid) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.delete(cid);\n        },\n\n        commit: options => {\n          return batch.commit(options);\n        }\n      };\n    }\n\n  };\n}\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\n\n\nfunction extractContents(k) {\n  const cid = CID.asCID(k);\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    };\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  };\n}","map":null,"metadata":{},"sourceType":"script"}