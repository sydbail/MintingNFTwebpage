{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst createLock = require('./utils/create-lock');\n\nconst isIpfs = require('is-ipfs');\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/src/multihashes')} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\n\n\nconst readOperations = {\n  stat: require('./stat')\n};\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\n\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n};\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\n\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\n\nconst wrap = ({\n  options,\n  mfs,\n  operations,\n  lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n};\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\n\nfunction createMfs(options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options);\n  const lock = createLock(repoOwner);\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n\n  const readLock = operation => {\n    return lock.readLock(operation);\n  };\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n\n\n  const writeLock = operation => {\n    return lock.writeLock(operation);\n  };\n  /** @type {Record<string, any>} */\n\n\n  const mfs = {};\n  wrap({\n    options,\n    mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options,\n    mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\n\n\nmodule.exports = ({\n  repo,\n  preload,\n  hashers,\n  options: constructorOptions\n}) => {\n  const methods = createMfs({\n    repo,\n    repoOwner: Boolean(constructorOptions.repoOwner),\n    hashers\n  });\n  /**\n   * @param {any} fn\n   */\n\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = (...args) => {\n      // @ts-ignore cannot derive type of arg\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));\n\n      if (paths.length) {\n        const options = args[args.length - 1]; // @ts-ignore it's a PreloadOptions, honest\n\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path));\n        }\n      }\n\n      return fn(...args);\n    };\n\n    return wrapped;\n  };\n\n  return { ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload( /*#__PURE__*/function () {\n      var _ref = _wrapAsyncGenerator(function* (\n      /** @type {...any} */\n      ...args) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(methods.ls(...args)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const file = _value;\n            yield { ...file,\n              size: file.size || 0\n            };\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n\n      return function () {\n        return _ref.apply(this, arguments);\n      };\n    }())\n  };\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/ipfs-core/src/components/files/index.js"],"names":["createLock","require","isIpfs","readOperations","stat","writeOperations","chmod","cp","flush","mkdir","mv","rm","touch","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","repo","createMfs","assign","readLock","operation","writeLock","module","exports","preload","hashers","constructorOptions","methods","Boolean","withPreload","fn","wrapped","args","paths","filter","arg","ipfsPath","cid","length","path","file","size"],"mappings":"AAAA;;;;;;;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,qBAAD,CAA1B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAME,cAAc,GAAG;AACrBC,EAAAA,IAAI,EAAEH,OAAO,CAAC,QAAD;AADQ,CAAvB;AAIA;AACA;AACA;AACA;AACA;;AACA,MAAMI,eAAe,GAAG;AACtBC,EAAAA,KAAK,EAAEL,OAAO,CAAC,SAAD,CADQ;AAEtBM,EAAAA,EAAE,EAAEN,OAAO,CAAC,MAAD,CAFW;AAGtBO,EAAAA,KAAK,EAAEP,OAAO,CAAC,SAAD,CAHQ;AAItBQ,EAAAA,KAAK,EAAER,OAAO,CAAC,SAAD,CAJQ;AAKtBS,EAAAA,EAAE,EAAET,OAAO,CAAC,MAAD,CALW;AAMtBU,EAAAA,EAAE,EAAEV,OAAO,CAAC,MAAD,CANW;AAOtBW,EAAAA,KAAK,EAAEX,OAAO,CAAC,SAAD;AAPQ,CAAxB;AAUA;AACA;AACA;AACA;AACA;;AACA,MAAMY,mBAAmB,GAAG;AAC1BC,EAAAA,KAAK,EAAEb,OAAO,CAAC,SAAD,CADY;AAE1Bc,EAAAA,IAAI,EAAEd,OAAO,CAAC,QAAD,CAFa;AAG1Be,EAAAA,EAAE,EAAEf,OAAO,CAAC,MAAD;AAHe,CAA5B;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMgB,IAAI,GAAG,CAAC;AACZC,EAAAA,OADY;AACHC,EAAAA,GADG;AACEC,EAAAA,UADF;AACcC,EAAAA;AADd,CAAD,KAEP;AACJC,EAAAA,MAAM,CAACC,IAAP,CAAYH,UAAZ,EAAwBI,OAAxB,CAAgCC,GAAG,IAAI;AACrCN,IAAAA,GAAG,CAACM,GAAD,CAAH,GAAWJ,IAAI,CAACD,UAAU,CAACK,GAAD,CAAV,CAAgBP,OAAhB,CAAD,CAAf;AACD,GAFD;AAGD,CAND;;AAQA,MAAMQ,cAAc,GAAG;AACrBC,EAAAA,SAAS,EAAE,IADU;AAErBC,EAAAA,IAAI,EAAE;AAFe,CAAvB;AAKA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAoBX,OAApB,EAA6B;AAC3B,QAAM;AACJS,IAAAA;AADI,MAEFL,MAAM,CAACQ,MAAP,CAAc,EAAd,EAAkBJ,cAAc,IAAI,EAApC,EAAwCR,OAAxC,CAFJ;AAIA,QAAMG,IAAI,GAAGrB,UAAU,CAAC2B,SAAD,CAAvB;AAEA;AACF;AACA;;AACE,QAAMI,QAAQ,GAAIC,SAAD,IAAe;AAC9B,WAAOX,IAAI,CAACU,QAAL,CAAcC,SAAd,CAAP;AACD,GAFD;AAIA;AACF;AACA;;;AACE,QAAMC,SAAS,GAAID,SAAD,IAAe;AAC/B,WAAOX,IAAI,CAACY,SAAL,CAAeD,SAAf,CAAP;AACD,GAFD;AAIA;;;AACA,QAAMb,GAAG,GAAG,EAAZ;AAEAF,EAAAA,IAAI,CAAC;AACHC,IAAAA,OADG;AACMC,IAAAA,GADN;AACWC,IAAAA,UAAU,EAAEjB,cADvB;AACuCkB,IAAAA,IAAI,EAAEU;AAD7C,GAAD,CAAJ;AAGAd,EAAAA,IAAI,CAAC;AACHC,IAAAA,OADG;AACMC,IAAAA,GADN;AACWC,IAAAA,UAAU,EAAEf,eADvB;AACwCgB,IAAAA,IAAI,EAAEY;AAD9C,GAAD,CAAJ;AAIAX,EAAAA,MAAM,CAACC,IAAP,CAAYV,mBAAZ,EAAiCW,OAAjC,CAAyCC,GAAG,IAAI;AAC9CN,IAAAA,GAAG,CAACM,GAAD,CAAH,GAAWZ,mBAAmB,CAACY,GAAD,CAAnB,CAAyBP,OAAzB,CAAX;AACD,GAFD;AAIA,SAAOC,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAe,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEP,EAAAA,IAAF;AAAQQ,EAAAA,OAAR;AAAiBC,EAAAA,OAAjB;AAA0BnB,EAAAA,OAAO,EAAEoB;AAAnC,CAAD,KAA6D;AAC5E,QAAMC,OAAO,GAAGV,SAAS,CAAC;AACxBD,IAAAA,IADwB;AAExBD,IAAAA,SAAS,EAAEa,OAAO,CAACF,kBAAkB,CAACX,SAApB,CAFM;AAGxBU,IAAAA;AAHwB,GAAD,CAAzB;AAMA;AACF;AACA;;AACE,QAAMI,WAAW,GAAGC,EAAE,IAAI;AACxB;AACJ;AACA;AACI,UAAMC,OAAO,GAAG,CAAC,GAAGC,IAAJ,KAAa;AAC3B;AACA,YAAMC,KAAK,GAAGD,IAAI,CAACE,MAAL,CAAYC,GAAG,IAAI7C,MAAM,CAAC8C,QAAP,CAAgBD,GAAhB,KAAwB7C,MAAM,CAAC+C,GAAP,CAAWF,GAAX,CAA3C,CAAd;;AAEA,UAAIF,KAAK,CAACK,MAAV,EAAkB;AAChB,cAAMhC,OAAO,GAAG0B,IAAI,CAACA,IAAI,CAACM,MAAL,GAAc,CAAf,CAApB,CADgB,CAEhB;;AACA,YAAIhC,OAAO,IAAIA,OAAO,CAACkB,OAAR,KAAoB,KAAnC,EAA0C;AACxCS,UAAAA,KAAK,CAACrB,OAAN,CAAc2B,IAAI,IAAIf,OAAO,CAACe,IAAD,CAA7B;AACD;AACF;;AAED,aAAOT,EAAE,CAAC,GAAGE,IAAJ,CAAT;AACD,KAbD;;AAeA,WAAOD,OAAP;AACD,GApBD;;AAsBA,SAAO,EACL,GAAGJ,OADE;AAELjC,IAAAA,KAAK,EAAEiC,OAAO,CAACjC,KAFV;AAGLC,IAAAA,EAAE,EAAEkC,WAAW,CAACF,OAAO,CAAChC,EAAT,CAHV;AAILE,IAAAA,KAAK,EAAE8B,OAAO,CAAC9B,KAJV;AAKLL,IAAAA,IAAI,EAAEqC,WAAW,CAACF,OAAO,CAACnC,IAAT,CALZ;AAMLO,IAAAA,EAAE,EAAE4B,OAAO,CAAC5B,EANP;AAOLI,IAAAA,IAAI,EAAE0B,WAAW,CAACF,OAAO,CAACxB,IAAT,CAPZ;AAQLH,IAAAA,KAAK,EAAE2B,OAAO,CAAC3B,KARV;AASLE,IAAAA,KAAK,EAAEyB,OAAO,CAACzB,KATV;AAULJ,IAAAA,EAAE,EAAE+B,WAAW,CAACF,OAAO,CAAC7B,EAAT,CAVV;AAWLF,IAAAA,KAAK,EAAE+B,OAAO,CAAC/B,KAXV;AAYLQ,IAAAA,EAAE,EAAEyB,WAAW;AAAA,qCAAC;AAAkB;AAAsB,SAAGG,IAA3C,EAAiD;AAAA;AAAA;;AAAA;;AAAA;AAC/D,8CAAyBL,OAAO,CAACvB,EAAR,CAAW,GAAG4B,IAAd,CAAzB,gOAA8C;AAAA,kBAA7BQ,IAA6B;AAC5C,kBAAM,EAAE,GAAGA,IAAL;AAAWC,cAAAA,IAAI,EAAED,IAAI,CAACC,IAAL,IAAa;AAA9B,aAAN;AACD;AAH8D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIhE,OAJc;;AAAA;AAAA;AAAA;AAAA;AAZV,GAAP;AAkBD,CAlDD","sourcesContent":["'use strict'\n\nconst createLock = require('./utils/create-lock')\nconst isIpfs = require('is-ipfs')\n\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/src/multihashes')} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\nconst readOperations = {\n  stat: require('./stat')\n}\n\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}\n\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n}\n\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n}\n\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\nfunction createMfs (options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  const lock = createLock(repoOwner)\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  /** @type {Record<string, any>} */\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\nmodule.exports = ({ repo, preload, hashers, options: constructorOptions }) => {\n  const methods = createMfs({\n    repo,\n    repoOwner: Boolean(constructorOptions.repoOwner),\n    hashers\n  })\n\n  /**\n   * @param {any} fn\n   */\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = (...args) => {\n      // @ts-ignore cannot derive type of arg\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg))\n\n      if (paths.length) {\n        const options = args[args.length - 1]\n        // @ts-ignore it's a PreloadOptions, honest\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path))\n        }\n      }\n\n      return fn(...args)\n    }\n\n    return wrapped\n  }\n\n  return {\n    ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function * (/** @type {...any} */ ...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file, size: file.size || 0 }\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}