{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst errCode = require('err-code');\n\nconst {\n  parallelMap,\n  filter\n} = require('streaming-iterables');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  cleanCid\n} = require('./utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst BLOCK_RM_CONCURRENCY = 8;\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\nmodule.exports = ({\n  repo\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/block').API[\"rm\"]}\n   */\n  function rm(_x) {\n    return _rm.apply(this, arguments);\n  }\n\n  function _rm() {\n    _rm = _wrapAsyncGenerator(function* (cids, options = {}) {\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      } // We need to take a write lock here to ensure that adding and removing\n      // blocks are exclusive operations\n\n\n      const release = yield _awaitAsyncGenerator(repo.gcLock.writeLock());\n\n      try {\n        yield* _asyncGeneratorDelegate(_asyncIterator(pipe(cids, parallelMap(BLOCK_RM_CONCURRENCY, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (cid) {\n            cid = cleanCid(cid);\n            /** @type {import('ipfs-core-types/src/block').RmResult} */\n\n            const result = {\n              cid\n            };\n\n            try {\n              const has = yield repo.blocks.has(cid);\n\n              if (!has) {\n                throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');\n              }\n\n              yield repo.blocks.delete(cid);\n            } catch (err) {\n              if (!options.force) {\n                err.message = `cannot remove ${cid}: ${err.message}`;\n                result.error = err;\n              }\n            }\n\n            return result;\n          });\n\n          return function (_x2) {\n            return _ref.apply(this, arguments);\n          };\n        }()), filter(() => !options.quiet))), _awaitAsyncGenerator);\n      } finally {\n        release();\n      }\n    });\n    return _rm.apply(this, arguments);\n  }\n\n  return withTimeoutOption(rm);\n};","map":null,"metadata":{},"sourceType":"script"}