{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst MAX_MSG_SIZE = 1 << 20; // 1MB\n\n/**\n * Creates an iterable transform that restricts message sizes to\n * the given maximum size.\n *\n * @param {number} [max] - The maximum message size. Defaults to 1MB\n * @returns {*} An iterable transform.\n */\n\nmodule.exports = max => {\n  max = max || MAX_MSG_SIZE;\n\n  const checkSize = msg => {\n    if (msg.data && msg.data.length > max) {\n      throw Object.assign(new Error('message size too large!'), {\n        code: 'ERR_MSG_TOO_BIG'\n      });\n    }\n  };\n\n  return source => {\n    return function () {\n      var _restrictSize = _wrapAsyncGenerator(function* () {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const msg = _value;\n\n            if (Array.isArray(msg)) {\n              msg.forEach(checkSize);\n            } else {\n              checkSize(msg);\n            }\n\n            yield msg;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n\n      function restrictSize() {\n        return _restrictSize.apply(this, arguments);\n      }\n\n      return restrictSize;\n    }()();\n  };\n};\n\nmodule.exports.MAX_MSG_SIZE = MAX_MSG_SIZE;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p-mplex/src/restrict-size.js"],"names":["MAX_MSG_SIZE","module","exports","max","checkSize","msg","data","length","Object","assign","Error","code","source","Array","isArray","forEach","restrictSize"],"mappings":"AAAA;;;;;;;;AAEA,MAAMA,YAAY,GAAG,KAAK,EAA1B,C,CAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiBC,GAAG,IAAI;AACtBA,EAAAA,GAAG,GAAGA,GAAG,IAAIH,YAAb;;AAEA,QAAMI,SAAS,GAAGC,GAAG,IAAI;AACvB,QAAIA,GAAG,CAACC,IAAJ,IAAYD,GAAG,CAACC,IAAJ,CAASC,MAAT,GAAkBJ,GAAlC,EAAuC;AACrC,YAAMK,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,yBAAV,CAAd,EAAoD;AAAEC,QAAAA,IAAI,EAAE;AAAR,OAApD,CAAN;AACD;AACF,GAJD;;AAMA,SAAOC,MAAM,IAAI;AACf,WAAO;AAAA,8CAAC,aAAiC;AAAA;AAAA;;AAAA;;AAAA;AACvC,8CAAwBA,MAAxB,gOAAgC;AAAA,kBAAfP,GAAe;;AAC9B,gBAAIQ,KAAK,CAACC,OAAN,CAAcT,GAAd,CAAJ,EAAwB;AACtBA,cAAAA,GAAG,CAACU,OAAJ,CAAYX,SAAZ;AACD,aAFD,MAEO;AACLA,cAAAA,SAAS,CAACC,GAAD,CAAT;AACD;;AACD,kBAAMA,GAAN;AACD;AARsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASxC,OATM;;AAAA,eAAkBW,YAAlB;AAAA;AAAA;;AAAA,aAAkBA,YAAlB;AAAA,SAAP;AAUD,GAXD;AAYD,CArBD;;AAuBAf,MAAM,CAACC,OAAP,CAAeF,YAAf,GAA8BA,YAA9B","sourcesContent":["'use strict'\n\nconst MAX_MSG_SIZE = 1 << 20 // 1MB\n\n/**\n * Creates an iterable transform that restricts message sizes to\n * the given maximum size.\n *\n * @param {number} [max] - The maximum message size. Defaults to 1MB\n * @returns {*} An iterable transform.\n */\nmodule.exports = max => {\n  max = max || MAX_MSG_SIZE\n\n  const checkSize = msg => {\n    if (msg.data && msg.data.length > max) {\n      throw Object.assign(new Error('message size too large!'), { code: 'ERR_MSG_TOO_BIG' })\n    }\n  }\n\n  return source => {\n    return (async function * restrictSize () {\n      for await (const msg of source) {\n        if (Array.isArray(msg)) {\n          msg.forEach(checkSize)\n        } else {\n          checkSize(msg)\n        }\n        yield msg\n      }\n    })()\n  }\n}\n\nmodule.exports.MAX_MSG_SIZE = MAX_MSG_SIZE\n"]},"metadata":{},"sourceType":"script"}