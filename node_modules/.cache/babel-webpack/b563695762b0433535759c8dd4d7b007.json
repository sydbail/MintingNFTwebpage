{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:connection-manager'), {\n  error: debug('libp2p:connection-manager:err')\n});\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options');\n\nconst LatencyMonitor = require('./latency-monitor'); // @ts-ignore retimer does not have types\n\n\nconst retimer = require('retimer');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst PeerId = require('peer-id');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('../errors');\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n */\n\n/**\n * @typedef {Object} ConnectionManagerOptions\n * @property {number} [maxConnections = Infinity] - The maximum number of connections allowed.\n * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning.\n * @property {number} [maxData = Infinity] - The max data (in and out), per average interval to allow.\n * @property {number} [maxSentData = Infinity] - The max outgoing data, per average interval to allow.\n * @property {number} [maxReceivedData = Infinity] - The max incoming data, per average interval to allow.\n * @property {number} [maxEventLoopDelay = Infinity] - The upper limit the event loop can take to run.\n * @property {number} [pollInterval = 2000] - How often, in milliseconds, metrics and latency should be checked.\n * @property {number} [movingAverageInterval = 60000] - How often, in milliseconds, to compute averages.\n * @property {number} [defaultPeerValue = 1] - The value of the peer.\n * @property {boolean} [autoDial = true] - Should preemptively guarantee connections are above the low watermark.\n * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark.\n */\n\n/**\n *\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\n\nclass ConnectionManager extends EventEmitter {\n  /**\n   * Responsible for managing known connections.\n   *\n   * @class\n   * @param {Libp2p} libp2p\n   * @param {ConnectionManagerOptions} options\n   */\n  constructor(libp2p, options = {}) {\n    super();\n    this._libp2p = libp2p;\n    this._peerId = libp2p.peerId.toB58String();\n    this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);\n    }\n\n    log('options: %j', this._options);\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     *\n     * @type {Map<string, number>}\n     */\n\n    this._peerValues = new Map();\n    /**\n     * Map of connections per peer\n     *\n     * @type {Map<string, Connection[]>}\n     */\n\n    this.connections = new Map();\n    this._started = false;\n    this._timer = null;\n    this._autoDialTimeout = null;\n    this._checkMetrics = this._checkMetrics.bind(this);\n    this._autoDial = this._autoDial.bind(this);\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    });\n  }\n  /**\n   * Get current number of open connections.\n   */\n\n\n  get size() {\n    return Array.from(this.connections.values()).reduce((accumulator, value) => accumulator + value.length, 0);\n  }\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n\n\n  start() {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);\n    } // latency monitor\n\n\n    this._latencyMonitor.start();\n\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n    this._latencyMonitor.on('data', this._onLatencyMeasure);\n\n    this._started = true;\n    log('started');\n    this._options.autoDial && this._autoDial();\n  }\n  /**\n   * Stops the Connection Manager\n   *\n   * @async\n   */\n\n\n  stop() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this._autoDialTimeout && _this._autoDialTimeout.clear();\n      _this._timer && _this._timer.clear();\n\n      _this._latencyMonitor.removeListener('data', _this._onLatencyMeasure);\n\n      _this._latencyMonitor.stop();\n\n      _this._started = false;\n      yield _this._close();\n      log('stopped');\n    })();\n  }\n  /**\n   * Cleans up the connections\n   *\n   * @async\n   */\n\n\n  _close() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Close all connections we're tracking\n      const tasks = [];\n\n      for (const connectionList of _this2.connections.values()) {\n        for (const connection of connectionList) {\n          tasks.push(connection.close());\n        }\n      }\n\n      yield Promise.all(tasks);\n\n      _this2.connections.clear();\n    })();\n  }\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   *\n   * @param {PeerId} peerId\n   * @param {number} value - A number between 0 and 1\n   * @returns {void}\n   */\n\n\n  setPeerValue(peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1');\n    }\n\n    this._peerValues.set(peerId.toB58String(), value);\n  }\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   *\n   * @private\n   */\n\n\n  _checkMetrics() {\n    if (this._libp2p.metrics) {\n      const movingAverages = this._libp2p.metrics.global.movingAverages; // @ts-ignore moving averages object types\n\n      const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n      this._checkMaxLimit('maxReceivedData', received); // @ts-ignore moving averages object types\n\n\n      const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();\n\n      this._checkMaxLimit('maxSentData', sent);\n\n      const total = received + sent;\n\n      this._checkMaxLimit('maxData', total);\n\n      log('metrics update', total);\n      this._timer = retimer(this._checkMetrics, this._options.pollInterval);\n    }\n  }\n  /**\n   * Tracks the incoming connection and check the connection limit\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n\n\n  onConnect(connection) {\n    const peerId = connection.remotePeer;\n    const peerIdStr = peerId.toB58String();\n    const storedConn = this.connections.get(peerIdStr);\n    this.emit('peer:connect', connection);\n\n    if (storedConn) {\n      storedConn.push(connection);\n    } else {\n      this.connections.set(peerIdStr, [connection]);\n    }\n\n    this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue);\n    }\n\n    this._checkMaxLimit('maxConnections', this.size);\n  }\n  /**\n   * Removes the connection from tracking\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n\n\n  onDisconnect(connection) {\n    const peerId = connection.remotePeer.toB58String();\n    let storedConn = this.connections.get(peerId);\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter(conn => conn.id !== connection.id);\n      this.connections.set(peerId, storedConn);\n    } else if (storedConn) {\n      this.connections.delete(peerId);\n\n      this._peerValues.delete(connection.remotePeer.toB58String());\n\n      this.emit('peer:disconnect', connection);\n    }\n  }\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection|null}\n   */\n\n\n  get(peerId) {\n    const connections = this.getAll(peerId);\n\n    if (connections.length) {\n      return connections[0];\n    }\n\n    return null;\n  }\n  /**\n   * Get all open connections with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection[]}\n   */\n\n\n  getAll(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = peerId.toB58String();\n    const connections = this.connections.get(id); // Return all open connections\n\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open');\n    }\n\n    return [];\n  }\n  /**\n   * If the event loop is slow, maybe close a connection\n   *\n   * @private\n   * @param {*} summary - The LatencyMonitor summary\n   */\n\n\n  _onLatencyMeasure(summary) {\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs);\n  }\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   *\n   * @private\n   * @param {string} name - The name of the field to check limits for\n   * @param {number} value - The current value of the field\n   */\n\n\n  _checkMaxLimit(name, value) {\n    const limit = this._options[name];\n    log('checking limit of %s. current value: %d of %d', name, value, limit);\n\n    if (value > limit) {\n      log('%s: limit exceeded: %s, %d', this._peerId, name, value);\n\n      this._maybeDisconnectOne();\n    }\n  }\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   *\n   * @async\n   * @private\n   */\n\n\n  _autoDial() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const minConnections = _this3._options.minConnections; // Already has enough connections\n\n      if (_this3.size >= minConnections) {\n        _this3._autoDialTimeout = retimer(_this3._autoDial, _this3._options.autoDialInterval);\n        return;\n      } // Sort peers on wether we know protocols of public keys for them\n\n\n      const peers = Array.from(_this3._libp2p.peerStore.peers.values()).sort((a, b) => {\n        if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {\n          return 1;\n        } else if (b.id.pubKey && !a.id.pubKey) {\n          return 1;\n        }\n\n        return -1;\n      });\n\n      for (let i = 0; i < peers.length && _this3.size < minConnections; i++) {\n        if (!_this3.get(peers[i].id)) {\n          log('connecting to a peerStore stored peer %s', peers[i].id.toB58String());\n\n          try {\n            yield _this3._libp2p.dialer.connectToPeer(peers[i].id); // Connection Manager was stopped\n\n            if (!_this3._started) {\n              return;\n            }\n          } catch (err) {\n            log.error('could not connect to peerStore stored peer', err);\n          }\n        }\n      }\n\n      _this3._autoDialTimeout = retimer(_this3._autoDial, _this3._options.autoDialInterval);\n    })();\n  }\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   *\n   * @private\n   */\n\n\n  _maybeDisconnectOne() {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(new Map([...this._peerValues.entries()].sort((a, b) => a[1] - b[1])));\n      log('%s: sorted peer values: %j', this._peerId, peerValues);\n      const disconnectPeer = peerValues[0];\n\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0];\n        log('%s: lowest value peer is %s', this._peerId, peerId);\n        log('%s: closing a connection to %j', this._peerId, peerId);\n\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close();\n            break;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/libp2p/src/connection-manager/index.js"],"names":["debug","require","log","Object","assign","error","errcode","mergeOptions","LatencyMonitor","retimer","EventEmitter","PeerId","codes","ERR_INVALID_PARAMETERS","defaultOptions","maxConnections","Infinity","minConnections","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","autoDialInterval","movingAverageInterval","defaultPeerValue","ConnectionManager","constructor","libp2p","options","_libp2p","_peerId","peerId","toB58String","_options","call","ignoreUndefined","Error","_peerValues","Map","connections","_started","_timer","_autoDialTimeout","_checkMetrics","bind","_autoDial","_latencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","size","Array","from","values","reduce","accumulator","value","length","start","metrics","_onLatencyMeasure","on","autoDial","stop","clear","removeListener","_close","tasks","connectionList","connection","push","close","Promise","all","setPeerValue","set","movingAverages","global","received","dataReceived","movingAverage","_checkMaxLimit","sent","dataSent","total","onConnect","remotePeer","peerIdStr","storedConn","get","emit","peerStore","keyBook","pubKey","has","onDisconnect","filter","conn","id","delete","getAll","isPeerId","stat","status","summary","avgMs","name","limit","_maybeDisconnectOne","peers","sort","a","b","protocols","i","dialer","connectToPeer","err","peerValues","entries","disconnectPeer","module","exports"],"mappings":"AAAA;;;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,2BAAD,CAAnB,EAAkD;AAC5DK,EAAAA,KAAK,EAAEL,KAAK,CAAC,+BAAD;AADgD,CAAlD,CAAZ;;AAIA,MAAMM,OAAO,GAAGL,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMM,YAAY,GAAGN,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAMO,cAAc,GAAGP,OAAO,CAAC,mBAAD,CAA9B,C,CACA;;;AACA,MAAMQ,OAAO,GAAGR,OAAO,CAAC,SAAD,CAAvB;;AAEA,MAAM;AAAES,EAAAA;AAAF,IAAmBT,OAAO,CAAC,QAAD,CAAhC;;AAEA,MAAMU,MAAM,GAAGV,OAAO,CAAC,SAAD,CAAtB;;AAEA,MAAM;AACJW,EAAAA,KAAK,EAAE;AAAEC,IAAAA;AAAF;AADH,IAEFZ,OAAO,CAAC,WAAD,CAFX;;AAIA,MAAMa,cAAc,GAAG;AACrBC,EAAAA,cAAc,EAAEC,QADK;AAErBC,EAAAA,cAAc,EAAE,CAFK;AAGrBC,EAAAA,OAAO,EAAEF,QAHY;AAIrBG,EAAAA,WAAW,EAAEH,QAJQ;AAKrBI,EAAAA,eAAe,EAAEJ,QALI;AAMrBK,EAAAA,iBAAiB,EAAEL,QANE;AAOrBM,EAAAA,YAAY,EAAE,IAPO;AAQrBC,EAAAA,gBAAgB,EAAE,KARG;AASrBC,EAAAA,qBAAqB,EAAE,KATF;AAUrBC,EAAAA,gBAAgB,EAAE;AAVG,CAAvB;AAaA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAN,SAAgChB,YAAhC,CAA6C;AAC3C;AACF;AACA;AACA;AACA;AACA;AACA;AACEiB,EAAAA,WAAW,CAAEC,MAAF,EAAUC,OAAO,GAAG,EAApB,EAAwB;AACjC;AAEA,SAAKC,OAAL,GAAeF,MAAf;AACA,SAAKG,OAAL,GAAeH,MAAM,CAACI,MAAP,CAAcC,WAAd,EAAf;AAEA,SAAKC,QAAL,GAAgB3B,YAAY,CAAC4B,IAAb,CAAkB;AAAEC,MAAAA,eAAe,EAAE;AAAnB,KAAlB,EAA6CtB,cAA7C,EAA6De,OAA7D,CAAhB;;AACA,QAAI,KAAKK,QAAL,CAAcnB,cAAd,GAA+B,KAAKmB,QAAL,CAAcjB,cAAjD,EAAiE;AAC/D,YAAMX,OAAO,CAAC,IAAI+B,KAAJ,CAAU,uEAAV,CAAD,EAAqFxB,sBAArF,CAAb;AACD;;AAEDX,IAAAA,GAAG,CAAC,aAAD,EAAgB,KAAKgC,QAArB,CAAH;AAEA;AACJ;AACA;AACA;AACA;;AACI,SAAKI,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;AAEA;AACJ;AACA;AACA;AACA;;AACI,SAAKC,WAAL,GAAmB,IAAID,GAAJ,EAAnB;AAEA,SAAKE,QAAL,GAAgB,KAAhB;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,aAAL,GAAqB,KAAKA,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAArB;AACA,SAAKC,SAAL,GAAiB,KAAKA,SAAL,CAAeD,IAAf,CAAoB,IAApB,CAAjB;AAEA,SAAKE,eAAL,GAAuB,IAAIvC,cAAJ,CAAmB;AACxCwC,MAAAA,sBAAsB,EAAE,KAAKd,QAAL,CAAcZ,YADE;AAExC2B,MAAAA,kBAAkB,EAAE,KAAKf,QAAL,CAAcZ;AAFM,KAAnB,CAAvB;AAID;AAED;AACF;AACA;;;AACU,MAAJ4B,IAAI,GAAI;AACV,WAAOC,KAAK,CAACC,IAAN,CAAW,KAAKZ,WAAL,CAAiBa,MAAjB,EAAX,EACJC,MADI,CACG,CAACC,WAAD,EAAcC,KAAd,KAAwBD,WAAW,GAAGC,KAAK,CAACC,MAD/C,EACuD,CADvD,CAAP;AAED;AAED;AACF;AACA;AACA;;;AACEC,EAAAA,KAAK,GAAI;AACP,QAAI,KAAK5B,OAAL,CAAa6B,OAAjB,EAA0B;AACxB,WAAKjB,MAAL,GAAc,KAAKA,MAAL,IAAejC,OAAO,CAAC,KAAKmC,aAAN,EAAqB,KAAKV,QAAL,CAAcZ,YAAnC,CAApC;AACD,KAHM,CAKP;;;AACA,SAAKyB,eAAL,CAAqBW,KAArB;;AACA,SAAKE,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBf,IAAvB,CAA4B,IAA5B,CAAzB;;AACA,SAAKE,eAAL,CAAqBc,EAArB,CAAwB,MAAxB,EAAgC,KAAKD,iBAArC;;AAEA,SAAKnB,QAAL,GAAgB,IAAhB;AACAvC,IAAAA,GAAG,CAAC,SAAD,CAAH;AAEA,SAAKgC,QAAL,CAAc4B,QAAd,IAA0B,KAAKhB,SAAL,EAA1B;AACD;AAED;AACF;AACA;AACA;AACA;;;AACQiB,EAAAA,IAAI,GAAI;AAAA;;AAAA;AACZ,MAAA,KAAI,CAACpB,gBAAL,IAAyB,KAAI,CAACA,gBAAL,CAAsBqB,KAAtB,EAAzB;AACA,MAAA,KAAI,CAACtB,MAAL,IAAe,KAAI,CAACA,MAAL,CAAYsB,KAAZ,EAAf;;AAEA,MAAA,KAAI,CAACjB,eAAL,CAAqBkB,cAArB,CAAoC,MAApC,EAA4C,KAAI,CAACL,iBAAjD;;AACA,MAAA,KAAI,CAACb,eAAL,CAAqBgB,IAArB;;AAEA,MAAA,KAAI,CAACtB,QAAL,GAAgB,KAAhB;AACA,YAAM,KAAI,CAACyB,MAAL,EAAN;AACAhE,MAAAA,GAAG,CAAC,SAAD,CAAH;AATY;AAUb;AAED;AACF;AACA;AACA;AACA;;;AACQgE,EAAAA,MAAM,GAAI;AAAA;;AAAA;AACd;AACA,YAAMC,KAAK,GAAG,EAAd;;AACA,WAAK,MAAMC,cAAX,IAA6B,MAAI,CAAC5B,WAAL,CAAiBa,MAAjB,EAA7B,EAAwD;AACtD,aAAK,MAAMgB,UAAX,IAAyBD,cAAzB,EAAyC;AACvCD,UAAAA,KAAK,CAACG,IAAN,CAAWD,UAAU,CAACE,KAAX,EAAX;AACD;AACF;;AAED,YAAMC,OAAO,CAACC,GAAR,CAAYN,KAAZ,CAAN;;AACA,MAAA,MAAI,CAAC3B,WAAL,CAAiBwB,KAAjB;AAVc;AAWf;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEU,EAAAA,YAAY,CAAE1C,MAAF,EAAUwB,KAAV,EAAiB;AAC3B,QAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,CAAzB,EAA4B;AAC1B,YAAM,IAAInB,KAAJ,CAAU,0CAAV,CAAN;AACD;;AACD,SAAKC,WAAL,CAAiBqC,GAAjB,CAAqB3C,MAAM,CAACC,WAAP,EAArB,EAA2CuB,KAA3C;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEZ,EAAAA,aAAa,GAAI;AACf,QAAI,KAAKd,OAAL,CAAa6B,OAAjB,EAA0B;AACxB,YAAMiB,cAAc,GAAG,KAAK9C,OAAL,CAAa6B,OAAb,CAAqBkB,MAArB,CAA4BD,cAAnD,CADwB,CAExB;;AACA,YAAME,QAAQ,GAAGF,cAAc,CAACG,YAAf,CAA4B,KAAK7C,QAAL,CAAcV,qBAA1C,EAAiEwD,aAAjE,EAAjB;;AACA,WAAKC,cAAL,CAAoB,iBAApB,EAAuCH,QAAvC,EAJwB,CAKxB;;;AACA,YAAMI,IAAI,GAAGN,cAAc,CAACO,QAAf,CAAwB,KAAKjD,QAAL,CAAcV,qBAAtC,EAA6DwD,aAA7D,EAAb;;AACA,WAAKC,cAAL,CAAoB,aAApB,EAAmCC,IAAnC;;AACA,YAAME,KAAK,GAAGN,QAAQ,GAAGI,IAAzB;;AACA,WAAKD,cAAL,CAAoB,SAApB,EAA+BG,KAA/B;;AACAlF,MAAAA,GAAG,CAAC,gBAAD,EAAmBkF,KAAnB,CAAH;AACA,WAAK1C,MAAL,GAAcjC,OAAO,CAAC,KAAKmC,aAAN,EAAqB,KAAKV,QAAL,CAAcZ,YAAnC,CAArB;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE+D,EAAAA,SAAS,CAAEhB,UAAF,EAAc;AACrB,UAAMrC,MAAM,GAAGqC,UAAU,CAACiB,UAA1B;AACA,UAAMC,SAAS,GAAGvD,MAAM,CAACC,WAAP,EAAlB;AACA,UAAMuD,UAAU,GAAG,KAAKhD,WAAL,CAAiBiD,GAAjB,CAAqBF,SAArB,CAAnB;AAEA,SAAKG,IAAL,CAAU,cAAV,EAA0BrB,UAA1B;;AACA,QAAImB,UAAJ,EAAgB;AACdA,MAAAA,UAAU,CAAClB,IAAX,CAAgBD,UAAhB;AACD,KAFD,MAEO;AACL,WAAK7B,WAAL,CAAiBmC,GAAjB,CAAqBY,SAArB,EAAgC,CAAClB,UAAD,CAAhC;AACD;;AAED,SAAKvC,OAAL,CAAa6D,SAAb,CAAuBC,OAAvB,CAA+BjB,GAA/B,CAAmC3C,MAAnC,EAA2CA,MAAM,CAAC6D,MAAlD;;AAEA,QAAI,CAAC,KAAKvD,WAAL,CAAiBwD,GAAjB,CAAqBP,SAArB,CAAL,EAAsC;AACpC,WAAKjD,WAAL,CAAiBqC,GAAjB,CAAqBY,SAArB,EAAgC,KAAKrD,QAAL,CAAcT,gBAA9C;AACD;;AAED,SAAKwD,cAAL,CAAoB,gBAApB,EAAsC,KAAK/B,IAA3C;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE6C,EAAAA,YAAY,CAAE1B,UAAF,EAAc;AACxB,UAAMrC,MAAM,GAAGqC,UAAU,CAACiB,UAAX,CAAsBrD,WAAtB,EAAf;AACA,QAAIuD,UAAU,GAAG,KAAKhD,WAAL,CAAiBiD,GAAjB,CAAqBzD,MAArB,CAAjB;;AAEA,QAAIwD,UAAU,IAAIA,UAAU,CAAC/B,MAAX,GAAoB,CAAtC,EAAyC;AACvC+B,MAAAA,UAAU,GAAGA,UAAU,CAACQ,MAAX,CAAmBC,IAAD,IAAUA,IAAI,CAACC,EAAL,KAAY7B,UAAU,CAAC6B,EAAnD,CAAb;AACA,WAAK1D,WAAL,CAAiBmC,GAAjB,CAAqB3C,MAArB,EAA6BwD,UAA7B;AACD,KAHD,MAGO,IAAIA,UAAJ,EAAgB;AACrB,WAAKhD,WAAL,CAAiB2D,MAAjB,CAAwBnE,MAAxB;;AACA,WAAKM,WAAL,CAAiB6D,MAAjB,CAAwB9B,UAAU,CAACiB,UAAX,CAAsBrD,WAAtB,EAAxB;;AACA,WAAKyD,IAAL,CAAU,iBAAV,EAA6BrB,UAA7B;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEoB,EAAAA,GAAG,CAAEzD,MAAF,EAAU;AACX,UAAMQ,WAAW,GAAG,KAAK4D,MAAL,CAAYpE,MAAZ,CAApB;;AACA,QAAIQ,WAAW,CAACiB,MAAhB,EAAwB;AACtB,aAAOjB,WAAW,CAAC,CAAD,CAAlB;AACD;;AACD,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE4D,EAAAA,MAAM,CAAEpE,MAAF,EAAU;AACd,QAAI,CAACrB,MAAM,CAAC0F,QAAP,CAAgBrE,MAAhB,CAAL,EAA8B;AAC5B,YAAM1B,OAAO,CAAC,IAAI+B,KAAJ,CAAU,uCAAV,CAAD,EAAqDxB,sBAArD,CAAb;AACD;;AAED,UAAMqF,EAAE,GAAGlE,MAAM,CAACC,WAAP,EAAX;AACA,UAAMO,WAAW,GAAG,KAAKA,WAAL,CAAiBiD,GAAjB,CAAqBS,EAArB,CAApB,CANc,CAQd;;AACA,QAAI1D,WAAJ,EAAiB;AACf,aAAOA,WAAW,CAACwD,MAAZ,CAAmB3B,UAAU,IAAIA,UAAU,CAACiC,IAAX,CAAgBC,MAAhB,KAA2B,MAA5D,CAAP;AACD;;AACD,WAAO,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE3C,EAAAA,iBAAiB,CAAE4C,OAAF,EAAW;AAC1B,SAAKvB,cAAL,CAAoB,mBAApB,EAAyCuB,OAAO,CAACC,KAAjD;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACExB,EAAAA,cAAc,CAAEyB,IAAF,EAAQlD,KAAR,EAAe;AAC3B,UAAMmD,KAAK,GAAG,KAAKzE,QAAL,CAAcwE,IAAd,CAAd;AACAxG,IAAAA,GAAG,CAAC,+CAAD,EAAkDwG,IAAlD,EAAwDlD,KAAxD,EAA+DmD,KAA/D,CAAH;;AACA,QAAInD,KAAK,GAAGmD,KAAZ,EAAmB;AACjBzG,MAAAA,GAAG,CAAC,4BAAD,EAA+B,KAAK6B,OAApC,EAA6C2E,IAA7C,EAAmDlD,KAAnD,CAAH;;AACA,WAAKoD,mBAAL;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ9D,EAAAA,SAAS,GAAI;AAAA;;AAAA;AACjB,YAAM7B,cAAc,GAAG,MAAI,CAACiB,QAAL,CAAcjB,cAArC,CADiB,CAGjB;;AACA,UAAI,MAAI,CAACiC,IAAL,IAAajC,cAAjB,EAAiC;AAC/B,QAAA,MAAI,CAAC0B,gBAAL,GAAwBlC,OAAO,CAAC,MAAI,CAACqC,SAAN,EAAiB,MAAI,CAACZ,QAAL,CAAcX,gBAA/B,CAA/B;AACA;AACD,OAPgB,CASjB;;;AACA,YAAMsF,KAAK,GAAG1D,KAAK,CAACC,IAAN,CAAW,MAAI,CAACtB,OAAL,CAAa6D,SAAb,CAAuBkB,KAAvB,CAA6BxD,MAA7B,EAAX,EACXyD,IADW,CACN,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACd,YAAIA,CAAC,CAACC,SAAF,IAAeD,CAAC,CAACC,SAAF,CAAYxD,MAA3B,KAAsC,CAACsD,CAAC,CAACE,SAAH,IAAgB,CAACF,CAAC,CAACE,SAAF,CAAYxD,MAAnE,CAAJ,EAAgF;AAC9E,iBAAO,CAAP;AACD,SAFD,MAEO,IAAIuD,CAAC,CAACd,EAAF,CAAKL,MAAL,IAAe,CAACkB,CAAC,CAACb,EAAF,CAAKL,MAAzB,EAAiC;AACtC,iBAAO,CAAP;AACD;;AACD,eAAO,CAAC,CAAR;AACD,OARW,CAAd;;AAUA,WAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACpD,MAAV,IAAoB,MAAI,CAACP,IAAL,GAAYjC,cAAhD,EAAgEiG,CAAC,EAAjE,EAAqE;AACnE,YAAI,CAAC,MAAI,CAACzB,GAAL,CAASoB,KAAK,CAACK,CAAD,CAAL,CAAShB,EAAlB,CAAL,EAA4B;AAC1BhG,UAAAA,GAAG,CAAC,0CAAD,EAA6C2G,KAAK,CAACK,CAAD,CAAL,CAAShB,EAAT,CAAYjE,WAAZ,EAA7C,CAAH;;AACA,cAAI;AACF,kBAAM,MAAI,CAACH,OAAL,CAAaqF,MAAb,CAAoBC,aAApB,CAAkCP,KAAK,CAACK,CAAD,CAAL,CAAShB,EAA3C,CAAN,CADE,CAGF;;AACA,gBAAI,CAAC,MAAI,CAACzD,QAAV,EAAoB;AAClB;AACD;AACF,WAPD,CAOE,OAAO4E,GAAP,EAAY;AACZnH,YAAAA,GAAG,CAACG,KAAJ,CAAU,4CAAV,EAAwDgH,GAAxD;AACD;AACF;AACF;;AAED,MAAA,MAAI,CAAC1E,gBAAL,GAAwBlC,OAAO,CAAC,MAAI,CAACqC,SAAN,EAAiB,MAAI,CAACZ,QAAL,CAAcX,gBAA/B,CAA/B;AApCiB;AAqClB;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEqF,EAAAA,mBAAmB,GAAI;AACrB,QAAI,KAAK1E,QAAL,CAAcjB,cAAd,GAA+B,KAAKuB,WAAL,CAAiBU,IAApD,EAA0D;AACxD,YAAMoE,UAAU,GAAGnE,KAAK,CAACC,IAAN,CAAW,IAAIb,GAAJ,CAAQ,CAAC,GAAG,KAAKD,WAAL,CAAiBiF,OAAjB,EAAJ,EAAgCT,IAAhC,CAAqC,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAvD,CAAR,CAAX,CAAnB;AACA9G,MAAAA,GAAG,CAAC,4BAAD,EAA+B,KAAK6B,OAApC,EAA6CuF,UAA7C,CAAH;AACA,YAAME,cAAc,GAAGF,UAAU,CAAC,CAAD,CAAjC;;AACA,UAAIE,cAAJ,EAAoB;AAClB,cAAMxF,MAAM,GAAGwF,cAAc,CAAC,CAAD,CAA7B;AACAtH,QAAAA,GAAG,CAAC,6BAAD,EAAgC,KAAK6B,OAArC,EAA8CC,MAA9C,CAAH;AACA9B,QAAAA,GAAG,CAAC,gCAAD,EAAmC,KAAK6B,OAAxC,EAAiDC,MAAjD,CAAH;;AACA,aAAK,MAAMQ,WAAX,IAA0B,KAAKA,WAAL,CAAiBa,MAAjB,EAA1B,EAAqD;AACnD,cAAIb,WAAW,CAAC,CAAD,CAAX,CAAe8C,UAAf,CAA0BrD,WAA1B,OAA4CD,MAAhD,EAAwD;AACtDQ,YAAAA,WAAW,CAAC,CAAD,CAAX,CAAe+B,KAAf;AACA;AACD;AACF;AACF;AACF;AACF;;AArU0C;;AAwU7CkD,MAAM,CAACC,OAAP,GAAiBhG,iBAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:connection-manager'), {\n  error: debug('libp2p:connection-manager:err')\n})\n\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst LatencyMonitor = require('./latency-monitor')\n// @ts-ignore retimer does not have types\nconst retimer = require('retimer')\n\nconst { EventEmitter } = require('events')\n\nconst PeerId = require('peer-id')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n}\n\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n */\n\n/**\n * @typedef {Object} ConnectionManagerOptions\n * @property {number} [maxConnections = Infinity] - The maximum number of connections allowed.\n * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning.\n * @property {number} [maxData = Infinity] - The max data (in and out), per average interval to allow.\n * @property {number} [maxSentData = Infinity] - The max outgoing data, per average interval to allow.\n * @property {number} [maxReceivedData = Infinity] - The max incoming data, per average interval to allow.\n * @property {number} [maxEventLoopDelay = Infinity] - The upper limit the event loop can take to run.\n * @property {number} [pollInterval = 2000] - How often, in milliseconds, metrics and latency should be checked.\n * @property {number} [movingAverageInterval = 60000] - How often, in milliseconds, to compute averages.\n * @property {number} [defaultPeerValue = 1] - The value of the peer.\n * @property {boolean} [autoDial = true] - Should preemptively guarantee connections are above the low watermark.\n * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark.\n */\n\n/**\n *\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\nclass ConnectionManager extends EventEmitter {\n  /**\n   * Responsible for managing known connections.\n   *\n   * @class\n   * @param {Libp2p} libp2p\n   * @param {ConnectionManagerOptions} options\n   */\n  constructor (libp2p, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId.toB58String()\n\n    this._options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, options)\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS)\n    }\n\n    log('options: %j', this._options)\n\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     *\n     * @type {Map<string, number>}\n     */\n    this._peerValues = new Map()\n\n    /**\n     * Map of connections per peer\n     *\n     * @type {Map<string, Connection[]>}\n     */\n    this.connections = new Map()\n\n    this._started = false\n    this._timer = null\n    this._autoDialTimeout = null\n    this._checkMetrics = this._checkMetrics.bind(this)\n    this._autoDial = this._autoDial.bind(this)\n\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    })\n  }\n\n  /**\n   * Get current number of open connections.\n   */\n  get size () {\n    return Array.from(this.connections.values())\n      .reduce((accumulator, value) => accumulator + value.length, 0)\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  start () {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval)\n    }\n\n    // latency monitor\n    this._latencyMonitor.start()\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this._latencyMonitor.on('data', this._onLatencyMeasure)\n\n    this._started = true\n    log('started')\n\n    this._options.autoDial && this._autoDial()\n  }\n\n  /**\n   * Stops the Connection Manager\n   *\n   * @async\n   */\n  async stop () {\n    this._autoDialTimeout && this._autoDialTimeout.clear()\n    this._timer && this._timer.clear()\n\n    this._latencyMonitor.removeListener('data', this._onLatencyMeasure)\n    this._latencyMonitor.stop()\n\n    this._started = false\n    await this._close()\n    log('stopped')\n  }\n\n  /**\n   * Cleans up the connections\n   *\n   * @async\n   */\n  async _close () {\n    // Close all connections we're tracking\n    const tasks = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    this.connections.clear()\n  }\n\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   *\n   * @param {PeerId} peerId\n   * @param {number} value - A number between 0 and 1\n   * @returns {void}\n   */\n  setPeerValue (peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1')\n    }\n    this._peerValues.set(peerId.toB58String(), value)\n  }\n\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   *\n   * @private\n   */\n  _checkMetrics () {\n    if (this._libp2p.metrics) {\n      const movingAverages = this._libp2p.metrics.global.movingAverages\n      // @ts-ignore moving averages object types\n      const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage()\n      this._checkMaxLimit('maxReceivedData', received)\n      // @ts-ignore moving averages object types\n      const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage()\n      this._checkMaxLimit('maxSentData', sent)\n      const total = received + sent\n      this._checkMaxLimit('maxData', total)\n      log('metrics update', total)\n      this._timer = retimer(this._checkMetrics, this._options.pollInterval)\n    }\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  onConnect (connection) {\n    const peerId = connection.remotePeer\n    const peerIdStr = peerId.toB58String()\n    const storedConn = this.connections.get(peerIdStr)\n\n    this.emit('peer:connect', connection)\n    if (storedConn) {\n      storedConn.push(connection)\n    } else {\n      this.connections.set(peerIdStr, [connection])\n    }\n\n    this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey)\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue)\n    }\n\n    this._checkMaxLimit('maxConnections', this.size)\n  }\n\n  /**\n   * Removes the connection from tracking\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  onDisconnect (connection) {\n    const peerId = connection.remotePeer.toB58String()\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn) {\n      this.connections.delete(peerId)\n      this._peerValues.delete(connection.remotePeer.toB58String())\n      this.emit('peer:disconnect', connection)\n    }\n  }\n\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection|null}\n   */\n  get (peerId) {\n    const connections = this.getAll(peerId)\n    if (connections.length) {\n      return connections[0]\n    }\n    return null\n  }\n\n  /**\n   * Get all open connections with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection[]}\n   */\n  getAll (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = peerId.toB58String()\n    const connections = this.connections.get(id)\n\n    // Return all open connections\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open')\n    }\n    return []\n  }\n\n  /**\n   * If the event loop is slow, maybe close a connection\n   *\n   * @private\n   * @param {*} summary - The LatencyMonitor summary\n   */\n  _onLatencyMeasure (summary) {\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs)\n  }\n\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   *\n   * @private\n   * @param {string} name - The name of the field to check limits for\n   * @param {number} value - The current value of the field\n   */\n  _checkMaxLimit (name, value) {\n    const limit = this._options[name]\n    log('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      log('%s: limit exceeded: %s, %d', this._peerId, name, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   *\n   * @async\n   * @private\n   */\n  async _autoDial () {\n    const minConnections = this._options.minConnections\n\n    // Already has enough connections\n    if (this.size >= minConnections) {\n      this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval)\n      return\n    }\n\n    // Sort peers on wether we know protocols of public keys for them\n    const peers = Array.from(this._libp2p.peerStore.peers.values())\n      .sort((a, b) => {\n        if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {\n          return 1\n        } else if (b.id.pubKey && !a.id.pubKey) {\n          return 1\n        }\n        return -1\n      })\n\n    for (let i = 0; i < peers.length && this.size < minConnections; i++) {\n      if (!this.get(peers[i].id)) {\n        log('connecting to a peerStore stored peer %s', peers[i].id.toB58String())\n        try {\n          await this._libp2p.dialer.connectToPeer(peers[i].id)\n\n          // Connection Manager was stopped\n          if (!this._started) {\n            return\n          }\n        } catch (err) {\n          log.error('could not connect to peerStore stored peer', err)\n        }\n      }\n    }\n\n    this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval)\n  }\n\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   *\n   * @private\n   */\n  _maybeDisconnectOne () {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(new Map([...this._peerValues.entries()].sort((a, b) => a[1] - b[1])))\n      log('%s: sorted peer values: %j', this._peerId, peerValues)\n      const disconnectPeer = peerValues[0]\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0]\n        log('%s: lowest value peer is %s', this._peerId, peerId)\n        log('%s: closing a connection to %j', this._peerId, peerId)\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close()\n            break\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = ConnectionManager\n"]},"metadata":{},"sourceType":"script"}