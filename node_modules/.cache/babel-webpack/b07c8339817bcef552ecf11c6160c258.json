{"ast":null,"code":"var _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst toDuplex = require('./duplex');\n\nmodule.exports = transform => /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (source) {\n    const duplex = toDuplex(transform); // In a transform the sink and source are connected, an error in the sink\n    // will be thrown in the source also. Catch the sink error to avoid unhandled\n    // rejections and yield from the source.\n\n    let sinkError;\n    duplex.sink(source).catch(err => {\n      sinkError = err;\n    });\n    yield* _asyncGeneratorDelegate(_asyncIterator(duplex.source), _awaitAsyncGenerator);\n    if (sinkError) throw sinkError;\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/stream-to-it/transform.js"],"names":["toDuplex","require","module","exports","transform","source","duplex","sinkError","sink","catch","err"],"mappings":";;;;;;;;AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,SAAS;AAAA,iCAAI,WAAkBC,MAAlB,EAA0B;AACtD,UAAMC,MAAM,GAAGN,QAAQ,CAACI,SAAD,CAAvB,CADsD,CAEtD;AACA;AACA;;AACA,QAAIG,SAAJ;AACAD,IAAAA,MAAM,CAACE,IAAP,CAAYH,MAAZ,EAAoBI,KAApB,CAA0BC,GAAG,IAAI;AAAEH,MAAAA,SAAS,GAAGG,GAAZ;AAAiB,KAApD;AAEA,kDAAQJ,MAAM,CAACD,MAAf;AACA,QAAIE,SAAJ,EAAe,MAAMA,SAAN;AAChB,GAVyB;;AAAA;AAAA;AAAA;AAAA,GAA1B","sourcesContent":["const toDuplex = require('./duplex')\n\nmodule.exports = transform => async function * (source) {\n  const duplex = toDuplex(transform)\n  // In a transform the sink and source are connected, an error in the sink\n  // will be thrown in the source also. Catch the sink error to avoid unhandled\n  // rejections and yield from the source.\n  let sinkError\n  duplex.sink(source).catch(err => { sinkError = err })\n\n  yield * duplex.source\n  if (sinkError) throw sinkError\n}\n"]},"metadata":{},"sourceType":"script"}