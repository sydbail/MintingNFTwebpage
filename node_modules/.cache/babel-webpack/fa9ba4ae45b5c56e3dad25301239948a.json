{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  source: abortable\n} = require('abortable-iterator');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:stream:converter');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n *\n * @typedef {Object} Timeline\n * @property {number} open - connection opening timestamp.\n * @property {number} [upgraded] - connection upgraded timestamp.\n * @property {number} [close]\n */\n\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n *\n * @param {object} streamProperties\n * @param {MuxedStream} streamProperties.stream\n * @param {Multiaddr} streamProperties.remoteAddr\n * @param {Multiaddr} streamProperties.localAddr\n * @param {object} [options]\n * @param {AbortSignal} [options.signal]\n * @returns {import('libp2p-interfaces/src/transport/types').MultiaddrConnection}\n */\n\nfunction streamToMaConnection({\n  stream,\n  remoteAddr,\n  localAddr\n}, options = {}) {\n  const {\n    sink,\n    source\n  } = stream;\n  const maConn = {\n    /**\n     * @param {Uint8Array} source\n     */\n    sink(source) {\n      return _asyncToGenerator(function* () {\n        if (options.signal) {\n          // @ts-ignore ts infers source template will be a number\n          source = abortable(source, options.signal);\n        }\n\n        try {\n          yield sink(source);\n        } catch (err) {\n          // If aborted we can safely ignore\n          if (err.type !== 'aborted') {\n            // If the source errored the socket will already have been destroyed by\n            // toIterable.duplex(). If the socket errored it will already be\n            // destroyed. There's nothing to do here except log the error & return.\n            log(err);\n          }\n        }\n\n        close();\n      })();\n    },\n\n    source: options.signal ? abortable(source, options.signal) : source,\n    conn: stream,\n    localAddr,\n    remoteAddr,\n\n    /** @type {Timeline} */\n    timeline: {\n      open: Date.now(),\n      close: undefined\n    },\n\n    close() {\n      sink(new Uint8Array(0));\n      return close();\n    }\n\n  };\n\n  function close() {\n    if (!maConn.timeline.close) {\n      maConn.timeline.close = Date.now();\n    }\n\n    return Promise.resolve();\n  }\n\n  return maConn;\n}\n\nmodule.exports = streamToMaConnection;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-utils/src/stream-to-ma-conn.js"],"names":["source","abortable","require","debug","log","streamToMaConnection","stream","remoteAddr","localAddr","options","sink","maConn","signal","err","type","close","conn","timeline","open","Date","now","undefined","Uint8Array","Promise","resolve","module","exports"],"mappings":"AAAA;;;;AAEA,MAAM;AAAEA,EAAAA,MAAM,EAAEC;AAAV,IAAwBC,OAAO,CAAC,oBAAD,CAArC;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,GAAG,GAAGD,KAAK,CAAC,yBAAD,CAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASE,oBAAT,CAA+B;AAAEC,EAAAA,MAAF;AAAUC,EAAAA,UAAV;AAAsBC,EAAAA;AAAtB,CAA/B,EAAkEC,OAAO,GAAG,EAA5E,EAAgF;AAC9E,QAAM;AAAEC,IAAAA,IAAF;AAAQV,IAAAA;AAAR,MAAmBM,MAAzB;AACA,QAAMK,MAAM,GAAG;AACb;AACJ;AACA;AACUD,IAAAA,IAAN,CAAYV,MAAZ,EAAoB;AAAA;AAClB,YAAIS,OAAO,CAACG,MAAZ,EAAoB;AAClB;AACAZ,UAAAA,MAAM,GAAGC,SAAS,CAACD,MAAD,EAASS,OAAO,CAACG,MAAjB,CAAlB;AACD;;AAED,YAAI;AACF,gBAAMF,IAAI,CAACV,MAAD,CAAV;AACD,SAFD,CAEE,OAAOa,GAAP,EAAY;AACZ;AACA,cAAIA,GAAG,CAACC,IAAJ,KAAa,SAAjB,EAA4B;AAC1B;AACA;AACA;AACAV,YAAAA,GAAG,CAACS,GAAD,CAAH;AACD;AACF;;AACDE,QAAAA,KAAK;AAjBa;AAkBnB,KAtBY;;AAuBbf,IAAAA,MAAM,EAAES,OAAO,CAACG,MAAR,GAAiBX,SAAS,CAACD,MAAD,EAASS,OAAO,CAACG,MAAjB,CAA1B,GAAqDZ,MAvBhD;AAwBbgB,IAAAA,IAAI,EAAEV,MAxBO;AAyBbE,IAAAA,SAzBa;AA0BbD,IAAAA,UA1Ba;;AA2Bb;AACAU,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,IAAI,EAAEC,IAAI,CAACC,GAAL,EAAR;AAAoBL,MAAAA,KAAK,EAAEM;AAA3B,KA5BG;;AA6BbN,IAAAA,KAAK,GAAI;AACPL,MAAAA,IAAI,CAAC,IAAIY,UAAJ,CAAe,CAAf,CAAD,CAAJ;AACA,aAAOP,KAAK,EAAZ;AACD;;AAhCY,GAAf;;AAmCA,WAASA,KAAT,GAAkB;AAChB,QAAI,CAACJ,MAAM,CAACM,QAAP,CAAgBF,KAArB,EAA4B;AAC1BJ,MAAAA,MAAM,CAACM,QAAP,CAAgBF,KAAhB,GAAwBI,IAAI,CAACC,GAAL,EAAxB;AACD;;AACD,WAAOG,OAAO,CAACC,OAAR,EAAP;AACD;;AAED,SAAOb,MAAP;AACD;;AAEDc,MAAM,CAACC,OAAP,GAAiBrB,oBAAjB","sourcesContent":["'use strict'\n\nconst { source: abortable } = require('abortable-iterator')\nconst debug = require('debug')\nconst log = debug('libp2p:stream:converter')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n *\n * @typedef {Object} Timeline\n * @property {number} open - connection opening timestamp.\n * @property {number} [upgraded] - connection upgraded timestamp.\n * @property {number} [close]\n */\n\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n *\n * @param {object} streamProperties\n * @param {MuxedStream} streamProperties.stream\n * @param {Multiaddr} streamProperties.remoteAddr\n * @param {Multiaddr} streamProperties.localAddr\n * @param {object} [options]\n * @param {AbortSignal} [options.signal]\n * @returns {import('libp2p-interfaces/src/transport/types').MultiaddrConnection}\n */\nfunction streamToMaConnection ({ stream, remoteAddr, localAddr }, options = {}) {\n  const { sink, source } = stream\n  const maConn = {\n    /**\n     * @param {Uint8Array} source\n     */\n    async sink (source) {\n      if (options.signal) {\n        // @ts-ignore ts infers source template will be a number\n        source = abortable(source, options.signal)\n      }\n\n      try {\n        await sink(source)\n      } catch (err) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log(err)\n        }\n      }\n      close()\n    },\n    source: options.signal ? abortable(source, options.signal) : source,\n    conn: stream,\n    localAddr,\n    remoteAddr,\n    /** @type {Timeline} */\n    timeline: { open: Date.now(), close: undefined },\n    close () {\n      sink(new Uint8Array(0))\n      return close()\n    }\n  }\n\n  function close () {\n    if (!maConn.timeline.close) {\n      maConn.timeline.close = Date.now()\n    }\n    return Promise.resolve()\n  }\n\n  return maConn\n}\n\nmodule.exports = streamToMaConnection\n"]},"metadata":{},"sourceType":"script"}