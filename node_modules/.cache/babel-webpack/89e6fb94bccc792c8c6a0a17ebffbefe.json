{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  concat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString\n} = require('uint8arrays/from-string');\n\nconst webcrypto = require('../webcrypto'); // Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {number} [options.nonceLength=12]\n * @param {number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {number} [options.saltLength=16]\n * @param {number} [options.iterations=32767]\n * @returns {*}\n */\n\n\nfunction create({\n  algorithm = 'AES-GCM',\n  nonceLength = 12,\n  keyLength = 16,\n  digest = 'SHA-256',\n  saltLength = 16,\n  iterations = 32767\n} = {}) {\n  const crypto = webcrypto.get();\n  keyLength *= 8; // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n  function encrypt(_x, _x2) {\n    return _encrypt.apply(this, arguments);\n  }\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  function _encrypt() {\n    _encrypt = _asyncToGenerator(function* (data, password) {\n      // eslint-disable-line require-await\n      const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n      const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n      const aesGcm = {\n        name: algorithm,\n        iv: nonce\n      }; // Derive a key using PBKDF2.\n\n      const deriveParams = {\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: {\n          name: digest\n        }\n      };\n      const rawKey = yield crypto.subtle.importKey('raw', fromString(password), {\n        name: 'PBKDF2'\n      }, false, ['deriveKey', 'deriveBits']);\n      const cryptoKey = yield crypto.subtle.deriveKey(deriveParams, rawKey, {\n        name: algorithm,\n        length: keyLength\n      }, true, ['encrypt']); // Encrypt the string.\n\n      const ciphertext = yield crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n      return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n    });\n    return _encrypt.apply(this, arguments);\n  }\n\n  function decrypt(_x3, _x4) {\n    return _decrypt.apply(this, arguments);\n  }\n\n  function _decrypt() {\n    _decrypt = _asyncToGenerator(function* (data, password) {\n      const salt = data.slice(0, saltLength);\n      const nonce = data.slice(saltLength, saltLength + nonceLength);\n      const ciphertext = data.slice(saltLength + nonceLength);\n      const aesGcm = {\n        name: algorithm,\n        iv: nonce\n      }; // Derive the key using PBKDF2.\n\n      const deriveParams = {\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: {\n          name: digest\n        }\n      };\n      const rawKey = yield crypto.subtle.importKey('raw', fromString(password), {\n        name: 'PBKDF2'\n      }, false, ['deriveKey', 'deriveBits']);\n      const cryptoKey = yield crypto.subtle.deriveKey(deriveParams, rawKey, {\n        name: algorithm,\n        length: keyLength\n      }, true, ['decrypt']); // Decrypt the string.\n\n      const plaintext = yield crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n      return new Uint8Array(plaintext);\n    });\n    return _decrypt.apply(this, arguments);\n  }\n\n  return {\n    encrypt,\n    decrypt\n  };\n}\n\nmodule.exports = {\n  create\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"],"names":["concat","require","fromString","webcrypto","create","algorithm","nonceLength","keyLength","digest","saltLength","iterations","crypto","get","encrypt","data","password","salt","getRandomValues","Uint8Array","nonce","aesGcm","name","iv","deriveParams","hash","rawKey","subtle","importKey","cryptoKey","deriveKey","length","ciphertext","decrypt","slice","plaintext","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { concat } = require('uint8arrays/concat')\nconst { fromString } = require('uint8arrays/from-string')\n\nconst webcrypto = require('../webcrypto')\n\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {number} [options.nonceLength=12]\n * @param {number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {number} [options.saltLength=16]\n * @param {number} [options.iterations=32767]\n * @returns {*}\n */\nfunction create ({\n  algorithm = 'AES-GCM',\n  nonceLength = 12,\n  keyLength = 16,\n  digest = 'SHA-256',\n  saltLength = 16,\n  iterations = 32767\n} = {}) {\n  const crypto = webcrypto.get()\n  keyLength *= 8 // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n  async function encrypt (data, password) { // eslint-disable-line require-await\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength))\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength))\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    // Derive a key using PBKDF2.\n    const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits'])\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt'])\n\n    // Encrypt the string.\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data)\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)])\n  }\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n  async function decrypt (data, password) {\n    const salt = data.slice(0, saltLength)\n    const nonce = data.slice(saltLength, saltLength + nonceLength)\n    const ciphertext = data.slice(saltLength + nonceLength)\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    // Derive the key using PBKDF2.\n    const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits'])\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt'])\n\n    // Decrypt the string.\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext)\n    return new Uint8Array(plaintext)\n  }\n\n  return {\n    encrypt,\n    decrypt\n  }\n}\n\nmodule.exports = {\n  create\n}\n"]},"metadata":{},"sourceType":"script"}