{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (iterable, mapper, {\n    concurrency = Infinity,\n    stopOnError = true\n  } = {}) {\n    return new Promise((resolve, reject) => {\n      if (typeof mapper !== 'function') {\n        throw new TypeError('Mapper function is required');\n      }\n\n      if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n        throw new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n      }\n\n      const result = [];\n      const errors = [];\n      const iterator = iterable[Symbol.iterator]();\n      let isRejected = false;\n      let isIterableDone = false;\n      let resolvingCount = 0;\n      let currentIndex = 0;\n\n      const next = () => {\n        if (isRejected) {\n          return;\n        }\n\n        const nextItem = iterator.next();\n        const index = currentIndex;\n        currentIndex++;\n\n        if (nextItem.done) {\n          isIterableDone = true;\n\n          if (resolvingCount === 0) {\n            if (!stopOnError && errors.length !== 0) {\n              reject(new AggregateError(errors));\n            } else {\n              resolve(result);\n            }\n          }\n\n          return;\n        }\n\n        resolvingCount++;\n\n        _asyncToGenerator(function* () {\n          try {\n            const element = yield nextItem.value;\n            result[index] = yield mapper(element, index);\n            resolvingCount--;\n            next();\n          } catch (error) {\n            if (stopOnError) {\n              isRejected = true;\n              reject(error);\n            } else {\n              errors.push(error);\n              resolvingCount--;\n              next();\n            }\n          }\n        })();\n      };\n\n      for (let i = 0; i < concurrency; i++) {\n        next();\n\n        if (isIterableDone) {\n          break;\n        }\n      }\n    });\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}