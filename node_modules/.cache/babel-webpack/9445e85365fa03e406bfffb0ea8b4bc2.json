{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  importer\n} = require('ipfs-unixfs-importer');\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/files/normalise-input/index');\n\nconst {\n  parseChunkerString\n} = require('./utils');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-unixfs-importer').ImportResult} ImportResult\n */\n\n/**\n * @typedef {Object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../../types').Preload} preload\n * @property {import('ipfs-core-types/src/root').ShardingOptions} [options]\n *\n * @param {Context} context\n */\n\n\nmodule.exports = ({\n  repo,\n  preload,\n  options\n}) => {\n  const isShardingEnabled = options && options.sharding;\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"addAll\"]}\n   */\n\n  function addAll(_x) {\n    return _addAll.apply(this, arguments);\n  }\n\n  function _addAll() {\n    _addAll = _wrapAsyncGenerator(function* (source, options = {}) {\n      const opts = mergeOptions({\n        shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n        strategy: 'balanced'\n      }, options, { ...parseChunkerString(options.chunker)\n      }); // CID v0 is for multihashes encoded with sha2-256\n\n      if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n        opts.cidVersion = 1;\n      }\n\n      if (opts.trickle) {\n        opts.strategy = 'trickle';\n      }\n\n      if (opts.strategy === 'trickle') {\n        opts.leafType = 'raw';\n        opts.reduceSingleLeafToSelf = false;\n      }\n\n      if (opts.cidVersion > 0 && opts.rawLeaves === undefined) {\n        // if the cid version is 1 or above, use raw leaves as this is\n        // what go does.\n        opts.rawLeaves = true;\n      }\n\n      if (opts.hashAlg !== undefined && opts.rawLeaves === undefined) {\n        // if a non-default hash alg has been specified, use raw leaves as this is\n        // what go does.\n        opts.rawLeaves = true;\n      }\n\n      delete opts.trickle;\n      /** @type {Record<string, number>} */\n\n      const totals = {};\n\n      if (opts.progress) {\n        const prog = opts.progress;\n        /**\n         * @param {number} bytes\n         * @param {string} path\n         */\n\n        opts.progress = (bytes, path) => {\n          if (!totals[path]) {\n            totals[path] = 0;\n          }\n\n          totals[path] += bytes;\n          prog(totals[path], path);\n        };\n      }\n\n      const iterator = pipe(normaliseInput(source),\n      /**\n       * @param {AsyncIterable<import('ipfs-unixfs-importer').ImportCandidate>} source\n       */\n      source => importer(source, repo.blocks, { ...opts,\n        pin: false\n      }), transformFile(opts), preloadFile(preload, opts), pinFile(repo, opts));\n      const releaseLock = yield _awaitAsyncGenerator(repo.gcLock.readLock());\n\n      try {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(iterator), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const added = _value;\n            // do not keep file totals around forever\n            delete totals[added.path];\n            yield added;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } finally {\n        releaseLock();\n      }\n    });\n    return _addAll.apply(this, arguments);\n  }\n\n  return withTimeoutOption(addAll);\n};\n/**\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\n\n\nfunction transformFile(opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  function transformFile(_x2) {\n    return _transformFile.apply(this, arguments);\n  }\n\n  function _transformFile() {\n    _transformFile = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const file = _value2;\n          let cid = file.cid;\n\n          if (opts.cidVersion === 1) {\n            cid = cid.toV1();\n          }\n\n          let path = file.path ? file.path : cid.toString();\n\n          if (opts.wrapWithDirectory && !file.path) {\n            path = '';\n          }\n\n          yield {\n            path,\n            cid: cid,\n            size: file.size,\n            mode: file.unixfs && file.unixfs.mode,\n            mtime: file.unixfs && file.unixfs.mtime\n          };\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n    return _transformFile.apply(this, arguments);\n  }\n\n  return transformFile;\n}\n/**\n * @param {(cid: CID) => void} preload\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\n\n\nfunction preloadFile(preload, opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  function maybePreloadFile(_x3) {\n    return _maybePreloadFile.apply(this, arguments);\n  }\n\n  function _maybePreloadFile() {\n    _maybePreloadFile = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(source), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const file = _value3;\n          const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n          const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n\n          if (shouldPreload) {\n            preload(file.cid);\n          }\n\n          yield file;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            yield _awaitAsyncGenerator(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    });\n    return _maybePreloadFile.apply(this, arguments);\n  }\n\n  return maybePreloadFile;\n}\n/**\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\n\n\nfunction pinFile(repo, opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  function maybePinFile(_x4) {\n    return _maybePinFile.apply(this, arguments);\n  }\n\n  function _maybePinFile() {\n    _maybePinFile = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n\n      var _iteratorError4;\n\n      try {\n        for (var _iterator4 = _asyncIterator(source), _step4, _value4; _step4 = yield _awaitAsyncGenerator(_iterator4.next()), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _awaitAsyncGenerator(_step4.value), !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {\n          const file = _value4;\n          // Pin a file if it is the root dir of a recursive add or the single file\n          // of a direct add.\n          const isRootDir = !(file.path && file.path.includes('/'));\n          const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;\n\n          if (shouldPin) {\n            yield _awaitAsyncGenerator(repo.pins.pinRecursively(file.cid));\n          }\n\n          yield file;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            yield _awaitAsyncGenerator(_iterator4.return());\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    });\n    return _maybePinFile.apply(this, arguments);\n  }\n\n  return maybePinFile;\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/components/add-all/index.js"],"names":["importer","require","normaliseInput","parseChunkerString","pipe","withTimeoutOption","mergeOptions","bind","ignoreUndefined","module","exports","repo","preload","options","isShardingEnabled","sharding","addAll","source","opts","shardSplitThreshold","Infinity","strategy","chunker","hashAlg","cidVersion","trickle","leafType","reduceSingleLeafToSelf","rawLeaves","undefined","totals","progress","prog","bytes","path","iterator","blocks","pin","transformFile","preloadFile","pinFile","releaseLock","gcLock","readLock","added","file","cid","toV1","toString","wrapWithDirectory","size","mode","unixfs","mtime","maybePreloadFile","isRootFile","includes","shouldPreload","onlyHash","maybePinFile","isRootDir","shouldPin","pins","pinRecursively"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { importer } = require('ipfs-unixfs-importer')\nconst { normaliseInput } = require('ipfs-core-utils/src/files/normalise-input/index')\nconst { parseChunkerString } = require('./utils')\nconst { pipe } = require('it-pipe')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-unixfs-importer').ImportResult} ImportResult\n */\n\n/**\n * @typedef {Object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../../types').Preload} preload\n * @property {import('ipfs-core-types/src/root').ShardingOptions} [options]\n *\n * @param {Context} context\n */\nmodule.exports = ({ repo, preload, options }) => {\n  const isShardingEnabled = options && options.sharding\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    const opts = mergeOptions({\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      strategy: 'balanced'\n    }, options, {\n      ...parseChunkerString(options.chunker)\n    })\n\n    // CID v0 is for multihashes encoded with sha2-256\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle'\n    }\n\n    if (opts.strategy === 'trickle') {\n      opts.leafType = 'raw'\n      opts.reduceSingleLeafToSelf = false\n    }\n\n    if (opts.cidVersion > 0 && opts.rawLeaves === undefined) {\n      // if the cid version is 1 or above, use raw leaves as this is\n      // what go does.\n      opts.rawLeaves = true\n    }\n\n    if (opts.hashAlg !== undefined && opts.rawLeaves === undefined) {\n      // if a non-default hash alg has been specified, use raw leaves as this is\n      // what go does.\n      opts.rawLeaves = true\n    }\n\n    delete opts.trickle\n\n    /** @type {Record<string, number>} */\n    const totals = {}\n\n    if (opts.progress) {\n      const prog = opts.progress\n\n      /**\n       * @param {number} bytes\n       * @param {string} path\n       */\n      opts.progress = (bytes, path) => {\n        if (!totals[path]) {\n          totals[path] = 0\n        }\n\n        totals[path] += bytes\n\n        prog(totals[path], path)\n      }\n    }\n\n    const iterator = pipe(\n      normaliseInput(source),\n      /**\n       * @param {AsyncIterable<import('ipfs-unixfs-importer').ImportCandidate>} source\n       */\n      source => importer(source, repo.blocks, {\n        ...opts,\n        pin: false\n      }),\n      transformFile(opts),\n      preloadFile(preload, opts),\n      pinFile(repo, opts)\n    )\n\n    const releaseLock = await repo.gcLock.readLock()\n\n    try {\n      for await (const added of iterator) {\n        // do not keep file totals around forever\n        delete totals[added.path]\n\n        yield added\n      }\n    } finally {\n      releaseLock()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n\n/**\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction transformFile (opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  async function * transformFile (source) {\n    for await (const file of source) {\n      let cid = file.cid\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1()\n      }\n\n      let path = file.path ? file.path : cid.toString()\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = ''\n      }\n\n      yield {\n        path,\n        cid: cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      }\n    }\n  }\n\n  return transformFile\n}\n\n/**\n * @param {(cid: CID) => void} preload\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction preloadFile (preload, opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  async function * maybePreloadFile (source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory\n        ? file.path === ''\n        : !file.path.includes('/')\n\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false\n\n      if (shouldPreload) {\n        preload(file.cid)\n      }\n\n      yield file\n    }\n  }\n\n  return maybePreloadFile\n}\n\n/**\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction pinFile (repo, opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  async function * maybePinFile (source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const isRootDir = !(file.path && file.path.includes('/'))\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash\n\n      if (shouldPin) {\n        await repo.pins.pinRecursively(file.cid)\n      }\n\n      yield file\n    }\n  }\n\n  return maybePinFile\n}\n"]},"metadata":{},"sourceType":"script"}