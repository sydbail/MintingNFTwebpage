{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport _asyncGeneratorDelegate from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\nimport DirFlat from './dir-flat.js';\nimport flatToShard from './flat-to-shard.js';\nimport Dir from './dir.js';\nimport toPathComponents from './utils/to-path-components.js';\n\nfunction addToTree(_x6, _x7, _x8) {\n  return _addToTree.apply(this, arguments);\n}\n\nfunction _addToTree() {\n  _addToTree = _asyncToGenerator(function* (elem, tree, options) {\n    const pathElems = toPathComponents(elem.path || '');\n    const lastIndex = pathElems.length - 1;\n    let parent = tree;\n    let currentPath = '';\n\n    for (let i = 0; i < pathElems.length; i++) {\n      const pathElem = pathElems[i];\n      currentPath += `${currentPath ? '/' : ''}${pathElem}`;\n      const last = i === lastIndex;\n      parent.dirty = true;\n      parent.cid = undefined;\n      parent.size = undefined;\n\n      if (last) {\n        yield parent.put(pathElem, elem);\n        tree = yield flatToShard(null, parent, options.shardSplitThreshold, options);\n      } else {\n        let dir = yield parent.get(pathElem);\n\n        if (!dir || !(dir instanceof Dir)) {\n          dir = new DirFlat({\n            root: false,\n            dir: true,\n            parent: parent,\n            parentKey: pathElem,\n            path: currentPath,\n            dirty: true,\n            flat: true,\n            mtime: dir && dir.unixfs && dir.unixfs.mtime,\n            mode: dir && dir.unixfs && dir.unixfs.mode\n          }, options);\n        }\n\n        yield parent.put(pathElem, dir);\n        parent = dir;\n      }\n    }\n\n    return tree;\n  });\n  return _addToTree.apply(this, arguments);\n}\n\nfunction flushAndYield(_x, _x2) {\n  return _flushAndYield.apply(this, arguments);\n}\n\nfunction _flushAndYield() {\n  _flushAndYield = _wrapAsyncGenerator(function* (tree, blockstore) {\n    if (!(tree instanceof Dir)) {\n      if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n        yield tree;\n      }\n\n      return;\n    }\n\n    yield* _asyncGeneratorDelegate(_asyncIterator(tree.flush(blockstore)), _awaitAsyncGenerator);\n  });\n  return _flushAndYield.apply(this, arguments);\n}\n\nfunction treeBuilder(_x3, _x4, _x5) {\n  return _treeBuilder.apply(this, arguments);\n}\n\nfunction _treeBuilder() {\n  _treeBuilder = _wrapAsyncGenerator(function* (source, block, options) {\n    let tree = new DirFlat({\n      root: true,\n      dir: true,\n      path: '',\n      dirty: true,\n      flat: true\n    }, options);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const entry = _value;\n\n        if (!entry) {\n          continue;\n        }\n\n        tree = yield _awaitAsyncGenerator(addToTree(entry, tree, options));\n\n        if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n          yield entry;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (options.wrapWithDirectory) {\n      yield* _asyncGeneratorDelegate(_asyncIterator(flushAndYield(tree, block)), _awaitAsyncGenerator);\n    } else {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(tree.eachChildSeries()), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const unwrapped = _value2;\n\n          if (!unwrapped) {\n            continue;\n          }\n\n          yield* _asyncGeneratorDelegate(_asyncIterator(flushAndYield(unwrapped.child, block)), _awaitAsyncGenerator);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  });\n  return _treeBuilder.apply(this, arguments);\n}\n\nexport default treeBuilder;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js"],"names":["DirFlat","flatToShard","Dir","toPathComponents","addToTree","elem","tree","options","pathElems","path","lastIndex","length","parent","currentPath","i","pathElem","last","dirty","cid","undefined","size","put","shardSplitThreshold","dir","get","root","parentKey","flat","mtime","unixfs","mode","flushAndYield","blockstore","isDirectory","flush","treeBuilder","source","block","entry","wrapWithDirectory","eachChildSeries","unwrapped","child"],"mappings":"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","sourcesContent":["import DirFlat from './dir-flat.js';\nimport flatToShard from './flat-to-shard.js';\nimport Dir from './dir.js';\nimport toPathComponents from './utils/to-path-components.js';\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${ currentPath ? '/' : '' }${ pathElem }`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = undefined;\n    parent.size = undefined;\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir = await parent.get(pathElem);\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options);\n      }\n      await parent.put(pathElem, dir);\n      parent = dir;\n    }\n  }\n  return tree;\n}\nasync function* flushAndYield(tree, blockstore) {\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n    return;\n  }\n  yield* tree.flush(blockstore);\n}\nasync function* treeBuilder(source, block, options) {\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n    tree = await addToTree(entry, tree, options);\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n  if (options.wrapWithDirectory) {\n    yield* flushAndYield(tree, block);\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue;\n      }\n      yield* flushAndYield(unwrapped.child, block);\n    }\n  }\n}\nexport default treeBuilder;"]},"metadata":{},"sourceType":"module"}