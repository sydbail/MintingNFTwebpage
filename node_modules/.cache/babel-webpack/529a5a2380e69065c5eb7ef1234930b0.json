{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst BufferList = require('bl/BufferList');\n\nconst Reader = require('it-reader');\n\nmodule.exports = function LteReader(source) {\n  const reader = Reader(source);\n  let overflow;\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n\n    next(bytes) {\n      return _asyncToGenerator(function* () {\n        if (overflow) {\n          let value;\n\n          if (bytes == null || overflow.length === bytes) {\n            value = overflow;\n            overflow = null;\n          } else if (overflow.length > bytes) {\n            value = overflow.shallowSlice(0, bytes);\n            overflow = overflow.shallowSlice(bytes);\n          } else if (overflow.length < bytes) {\n            const {\n              value: nextValue,\n              done\n            } = yield reader.next(bytes - overflow.length);\n\n            if (done) {\n              throw Object.assign(new Error(`stream ended before ${bytes - overflow.length} bytes became available`), {\n                code: 'ERR_UNDER_READ'\n              });\n            }\n\n            value = new BufferList([overflow, nextValue]);\n            overflow = null;\n          }\n\n          return {\n            value\n          };\n        }\n\n        return reader.next(bytes);\n      })();\n    },\n\n    nextLte(bytes) {\n      return _asyncToGenerator(function* () {\n        let {\n          done,\n          value\n        } = yield lteReader.next();\n        if (done) return {\n          done\n        };\n        if (value.length <= bytes) return {\n          value\n        };\n        value = BufferList.isBufferList(value) ? value : new BufferList(value);\n\n        if (overflow) {\n          overflow.append(value.shallowSlice(bytes));\n        } else {\n          overflow = value.shallowSlice(bytes);\n        }\n\n        return {\n          value: value.shallowSlice(0, bytes)\n        };\n      })();\n    },\n\n    return() {\n      return reader.return();\n    }\n\n  };\n  return lteReader;\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/it-tar/lte-reader.js"],"names":["BufferList","require","Reader","module","exports","LteReader","source","reader","overflow","lteReader","Symbol","asyncIterator","next","bytes","value","length","shallowSlice","nextValue","done","Object","assign","Error","code","nextLte","isBufferList","append","return"],"mappings":";;AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAoBC,MAApB,EAA4B;AAC3C,QAAMC,MAAM,GAAGL,MAAM,CAACI,MAAD,CAArB;AACA,MAAIE,QAAJ;AACA,QAAMC,SAAS,GAAG;AAChB,KAACC,MAAM,CAACC,aAAR,GAAwB,MAAMF,SADd;;AAEVG,IAAAA,IAAN,CAAYC,KAAZ,EAAmB;AAAA;AACjB,YAAIL,QAAJ,EAAc;AACZ,cAAIM,KAAJ;;AACA,cAAID,KAAK,IAAI,IAAT,IAAiBL,QAAQ,CAACO,MAAT,KAAoBF,KAAzC,EAAgD;AAC9CC,YAAAA,KAAK,GAAGN,QAAR;AACAA,YAAAA,QAAQ,GAAG,IAAX;AACD,WAHD,MAGO,IAAIA,QAAQ,CAACO,MAAT,GAAkBF,KAAtB,EAA6B;AAClCC,YAAAA,KAAK,GAAGN,QAAQ,CAACQ,YAAT,CAAsB,CAAtB,EAAyBH,KAAzB,CAAR;AACAL,YAAAA,QAAQ,GAAGA,QAAQ,CAACQ,YAAT,CAAsBH,KAAtB,CAAX;AACD,WAHM,MAGA,IAAIL,QAAQ,CAACO,MAAT,GAAkBF,KAAtB,EAA6B;AAClC,kBAAM;AAAEC,cAAAA,KAAK,EAAEG,SAAT;AAAoBC,cAAAA;AAApB,sBAAmCX,MAAM,CAACK,IAAP,CAAYC,KAAK,GAAGL,QAAQ,CAACO,MAA7B,CAAzC;;AACA,gBAAIG,IAAJ,EAAU;AACR,oBAAMC,MAAM,CAACC,MAAP,CACJ,IAAIC,KAAJ,CAAW,uBAAsBR,KAAK,GAAGL,QAAQ,CAACO,MAAO,yBAAzD,CADI,EAEJ;AAAEO,gBAAAA,IAAI,EAAE;AAAR,eAFI,CAAN;AAID;;AACDR,YAAAA,KAAK,GAAG,IAAId,UAAJ,CAAe,CAACQ,QAAD,EAAWS,SAAX,CAAf,CAAR;AACAT,YAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,iBAAO;AAAEM,YAAAA;AAAF,WAAP;AACD;;AACD,eAAOP,MAAM,CAACK,IAAP,CAAYC,KAAZ,CAAP;AAtBiB;AAuBlB,KAzBe;;AA0BVU,IAAAA,OAAN,CAAeV,KAAf,EAAsB;AAAA;AACpB,YAAI;AAAEK,UAAAA,IAAF;AAAQJ,UAAAA;AAAR,kBAAwBL,SAAS,CAACG,IAAV,EAA5B;AACA,YAAIM,IAAJ,EAAU,OAAO;AAAEA,UAAAA;AAAF,SAAP;AACV,YAAIJ,KAAK,CAACC,MAAN,IAAgBF,KAApB,EAA2B,OAAO;AAAEC,UAAAA;AAAF,SAAP;AAC3BA,QAAAA,KAAK,GAAGd,UAAU,CAACwB,YAAX,CAAwBV,KAAxB,IAAiCA,KAAjC,GAAyC,IAAId,UAAJ,CAAec,KAAf,CAAjD;;AACA,YAAIN,QAAJ,EAAc;AACZA,UAAAA,QAAQ,CAACiB,MAAT,CAAgBX,KAAK,CAACE,YAAN,CAAmBH,KAAnB,CAAhB;AACD,SAFD,MAEO;AACLL,UAAAA,QAAQ,GAAGM,KAAK,CAACE,YAAN,CAAmBH,KAAnB,CAAX;AACD;;AACD,eAAO;AAAEC,UAAAA,KAAK,EAAEA,KAAK,CAACE,YAAN,CAAmB,CAAnB,EAAsBH,KAAtB;AAAT,SAAP;AAVoB;AAWrB,KArCe;;AAsChBa,IAAAA,MAAM,GAAI;AACR,aAAOnB,MAAM,CAACmB,MAAP,EAAP;AACD;;AAxCe,GAAlB;AA0CA,SAAOjB,SAAP;AACD,CA9CD","sourcesContent":["const BufferList = require('bl/BufferList')\nconst Reader = require('it-reader')\n\nmodule.exports = function LteReader (source) {\n  const reader = Reader(source)\n  let overflow\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n    async next (bytes) {\n      if (overflow) {\n        let value\n        if (bytes == null || overflow.length === bytes) {\n          value = overflow\n          overflow = null\n        } else if (overflow.length > bytes) {\n          value = overflow.shallowSlice(0, bytes)\n          overflow = overflow.shallowSlice(bytes)\n        } else if (overflow.length < bytes) {\n          const { value: nextValue, done } = await reader.next(bytes - overflow.length)\n          if (done) {\n            throw Object.assign(\n              new Error(`stream ended before ${bytes - overflow.length} bytes became available`),\n              { code: 'ERR_UNDER_READ' }\n            )\n          }\n          value = new BufferList([overflow, nextValue])\n          overflow = null\n        }\n        return { value }\n      }\n      return reader.next(bytes)\n    },\n    async nextLte (bytes) {\n      let { done, value } = await lteReader.next()\n      if (done) return { done }\n      if (value.length <= bytes) return { value }\n      value = BufferList.isBufferList(value) ? value : new BufferList(value)\n      if (overflow) {\n        overflow.append(value.shallowSlice(bytes))\n      } else {\n        overflow = value.shallowSlice(bytes)\n      }\n      return { value: value.shallowSlice(0, bytes) }\n    },\n    return () {\n      return reader.return()\n    }\n  }\n  return lteReader\n}\n"]},"metadata":{},"sourceType":"script"}