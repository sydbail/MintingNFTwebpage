{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  PinTypes\n} = require('ipfs-repo');\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst errCode = require('err-code');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @param {string} type\n * @param {CID} cid\n * @param {Record<string, any>} [metadata]\n */\n\n\nfunction toPin(type, cid, metadata) {\n  /** @type {import('ipfs-core-types/src/pin').LsResult} */\n  const output = {\n    type,\n    cid\n  };\n\n  if (metadata) {\n    output.metadata = metadata;\n  }\n\n  return output;\n}\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\n\n\nmodule.exports = ({\n  repo,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"ls\"]}\n   */\n  function ls() {\n    return _ls.apply(this, arguments);\n  }\n\n  function _ls() {\n    _ls = _wrapAsyncGenerator(function* (options = {}) {\n      /** @type {import('ipfs-core-types/src/pin').PinQueryType} */\n      let type = PinTypes.all;\n\n      if (options.type) {\n        type = options.type;\n\n        if (!Object.keys(PinTypes).includes(type)) {\n          throw errCode(new Error('Invalid pin type'), 'ERR_INVALID_PIN_TYPE');\n        }\n      }\n\n      if (options.paths) {\n        // check the pinned state of specific hashes\n        let matched = false;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(normaliseInput(options.paths)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const {\n              path\n            } = _value;\n            const {\n              cid\n            } = yield _awaitAsyncGenerator(resolvePath(repo, codecs, path));\n            const {\n              reason,\n              pinned,\n              parent,\n              metadata\n            } = yield _awaitAsyncGenerator(repo.pins.isPinnedWithType(cid, type));\n\n            if (!pinned) {\n              throw errCode(new Error(`path '${path}' is not pinned`), 'ERR_NOT_PINNED');\n            }\n\n            switch (reason) {\n              case PinTypes.direct:\n              case PinTypes.recursive:\n                matched = true;\n                yield toPin(reason, cid, metadata);\n                break;\n\n              default:\n                matched = true;\n                yield toPin(`${PinTypes.indirect} through ${parent}`, cid, metadata);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (!matched) {\n          throw new Error('No match found');\n        }\n\n        return;\n      }\n\n      if (type === PinTypes.recursive || type === PinTypes.all) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n\n        var _iteratorError2;\n\n        try {\n          for (var _iterator2 = _asyncIterator(repo.pins.recursiveKeys()), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n            const {\n              cid,\n              metadata\n            } = _value2;\n            yield toPin(PinTypes.recursive, cid, metadata);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              yield _awaitAsyncGenerator(_iterator2.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      if (type === PinTypes.indirect || type === PinTypes.all) {\n        // @ts-ignore - LsSettings & AbortOptions have no properties in common\n        // with type { preload?: boolean }\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n\n        var _iteratorError3;\n\n        try {\n          for (var _iterator3 = _asyncIterator(repo.pins.indirectKeys(options)), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n            const cid = _value3;\n            yield toPin(PinTypes.indirect, cid);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              yield _awaitAsyncGenerator(_iterator3.return());\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      if (type === PinTypes.direct || type === PinTypes.all) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n\n        var _iteratorError4;\n\n        try {\n          for (var _iterator4 = _asyncIterator(repo.pins.directKeys()), _step4, _value4; _step4 = yield _awaitAsyncGenerator(_iterator4.next()), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _awaitAsyncGenerator(_step4.value), !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {\n            const {\n              cid,\n              metadata\n            } = _value4;\n            yield toPin(PinTypes.direct, cid, metadata);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              yield _awaitAsyncGenerator(_iterator4.return());\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n    });\n    return _ls.apply(this, arguments);\n  }\n\n  return withTimeoutOption(ls);\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-core/src/components/pin/ls.js"],"names":["PinTypes","require","normaliseInput","resolvePath","withTimeoutOption","errCode","toPin","type","cid","metadata","output","module","exports","repo","codecs","ls","options","all","Object","keys","includes","Error","paths","matched","path","reason","pinned","parent","pins","isPinnedWithType","direct","recursive","indirect","recursiveKeys","indirectKeys","directKeys"],"mappings":"AAAA;AACA;;;;;;;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAeC,OAAO,CAAC,WAAD,CAA5B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAqBD,OAAO,CAAC,0CAAD,CAAlC;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAkBF,OAAO,CAAC,aAAD,CAA/B;;AACA,MAAMG,iBAAiB,GAAGH,OAAO,CAAC,yCAAD,CAAjC;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAAvB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASK,KAAT,CAAgBC,IAAhB,EAAsBC,GAAtB,EAA2BC,QAA3B,EAAqC;AACnC;AACA,QAAMC,MAAM,GAAG;AACbH,IAAAA,IADa;AAEbC,IAAAA;AAFa,GAAf;;AAKA,MAAIC,QAAJ,EAAc;AACZC,IAAAA,MAAM,CAACD,QAAP,GAAkBA,QAAlB;AACD;;AAED,SAAOC,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAAsB;AACrC;AACF;AACA;AAHuC,WAIpBC,EAJoB;AAAA;AAAA;;AAAA;AAAA,8BAIrC,WAAqBC,OAAO,GAAG,EAA/B,EAAmC;AACjC;AACA,UAAIT,IAAI,GAAGP,QAAQ,CAACiB,GAApB;;AAEA,UAAID,OAAO,CAACT,IAAZ,EAAkB;AAChBA,QAAAA,IAAI,GAAGS,OAAO,CAACT,IAAf;;AAEA,YAAI,CAACW,MAAM,CAACC,IAAP,CAAYnB,QAAZ,EAAsBoB,QAAtB,CAA+Bb,IAA/B,CAAL,EAA2C;AACzC,gBAAMF,OAAO,CAAC,IAAIgB,KAAJ,CAAU,kBAAV,CAAD,EAAgC,sBAAhC,CAAb;AACD;AACF;;AAED,UAAIL,OAAO,CAACM,KAAZ,EAAmB;AACjB;AACA,YAAIC,OAAO,GAAG,KAAd;AAFiB;AAAA;;AAAA;;AAAA;AAIjB,8CAA6BrB,cAAc,CAACc,OAAO,CAACM,KAAT,CAA3C,gOAA4D;AAAA,kBAA3C;AAAEE,cAAAA;AAAF,aAA2C;AAC1D,kBAAM;AAAEhB,cAAAA;AAAF,2CAAgBL,WAAW,CAACU,IAAD,EAAOC,MAAP,EAAeU,IAAf,CAA3B,CAAN;AACA,kBAAM;AAAEC,cAAAA,MAAF;AAAUC,cAAAA,MAAV;AAAkBC,cAAAA,MAAlB;AAA0BlB,cAAAA;AAA1B,2CAA6CI,IAAI,CAACe,IAAL,CAAUC,gBAAV,CAA2BrB,GAA3B,EAAgCD,IAAhC,CAA7C,CAAN;;AAEA,gBAAI,CAACmB,MAAL,EAAa;AACX,oBAAMrB,OAAO,CAAC,IAAIgB,KAAJ,CAAW,SAAQG,IAAK,iBAAxB,CAAD,EAA4C,gBAA5C,CAAb;AACD;;AAED,oBAAQC,MAAR;AACE,mBAAKzB,QAAQ,CAAC8B,MAAd;AACA,mBAAK9B,QAAQ,CAAC+B,SAAd;AACER,gBAAAA,OAAO,GAAG,IAAV;AACA,sBAAMjB,KAAK,CAACmB,MAAD,EAASjB,GAAT,EAAcC,QAAd,CAAX;AACA;;AACF;AACEc,gBAAAA,OAAO,GAAG,IAAV;AACA,sBAAMjB,KAAK,CAAE,GAAEN,QAAQ,CAACgC,QAAS,YAAWL,MAAO,EAAxC,EAA2CnB,GAA3C,EAAgDC,QAAhD,CAAX;AARJ;AAUD;AAtBgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwBjB,YAAI,CAACc,OAAL,EAAc;AACZ,gBAAM,IAAIF,KAAJ,CAAU,gBAAV,CAAN;AACD;;AAED;AACD;;AAED,UAAId,IAAI,KAAKP,QAAQ,CAAC+B,SAAlB,IAA+BxB,IAAI,KAAKP,QAAQ,CAACiB,GAArD,EAA0D;AAAA;AAAA;;AAAA;;AAAA;AACxD,+CAAsCJ,IAAI,CAACe,IAAL,CAAUK,aAAV,EAAtC,0OAAiE;AAAA,kBAAhD;AAAEzB,cAAAA,GAAF;AAAOC,cAAAA;AAAP,aAAgD;AAC/D,kBAAMH,KAAK,CAACN,QAAQ,CAAC+B,SAAV,EAAqBvB,GAArB,EAA0BC,QAA1B,CAAX;AACD;AAHuD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIzD;;AAED,UAAIF,IAAI,KAAKP,QAAQ,CAACgC,QAAlB,IAA8BzB,IAAI,KAAKP,QAAQ,CAACiB,GAApD,EAAyD;AACvD;AACA;AAFuD;AAAA;;AAAA;;AAAA;AAGvD,+CAAwBJ,IAAI,CAACe,IAAL,CAAUM,YAAV,CAAuBlB,OAAvB,CAAxB,0OAAyD;AAAA,kBAAxCR,GAAwC;AACvD,kBAAMF,KAAK,CAACN,QAAQ,CAACgC,QAAV,EAAoBxB,GAApB,CAAX;AACD;AALsD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMxD;;AAED,UAAID,IAAI,KAAKP,QAAQ,CAAC8B,MAAlB,IAA4BvB,IAAI,KAAKP,QAAQ,CAACiB,GAAlD,EAAuD;AAAA;AAAA;;AAAA;;AAAA;AACrD,+CAAsCJ,IAAI,CAACe,IAAL,CAAUO,UAAV,EAAtC,0OAA8D;AAAA,kBAA7C;AAAE3B,cAAAA,GAAF;AAAOC,cAAAA;AAAP,aAA6C;AAC5D,kBAAMH,KAAK,CAACN,QAAQ,CAAC8B,MAAV,EAAkBtB,GAAlB,EAAuBC,QAAvB,CAAX;AACD;AAHoD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAItD;AACF,KAlEoC;AAAA;AAAA;;AAoErC,SAAOL,iBAAiB,CAACW,EAAD,CAAxB;AACD,CArED","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { PinTypes } = require('ipfs-repo')\nconst { normaliseInput } = require('ipfs-core-utils/src/pins/normalise-input')\nconst { resolvePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst errCode = require('err-code')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @param {string} type\n * @param {CID} cid\n * @param {Record<string, any>} [metadata]\n */\nfunction toPin (type, cid, metadata) {\n  /** @type {import('ipfs-core-types/src/pin').LsResult} */\n  const output = {\n    type,\n    cid\n  }\n\n  if (metadata) {\n    output.metadata = metadata\n  }\n\n  return output\n}\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\nmodule.exports = ({ repo, codecs }) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"ls\"]}\n   */\n  async function * ls (options = {}) {\n    /** @type {import('ipfs-core-types/src/pin').PinQueryType} */\n    let type = PinTypes.all\n\n    if (options.type) {\n      type = options.type\n\n      if (!Object.keys(PinTypes).includes(type)) {\n        throw errCode(new Error('Invalid pin type'), 'ERR_INVALID_PIN_TYPE')\n      }\n    }\n\n    if (options.paths) {\n      // check the pinned state of specific hashes\n      let matched = false\n\n      for await (const { path } of normaliseInput(options.paths)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n        const { reason, pinned, parent, metadata } = await repo.pins.isPinnedWithType(cid, type)\n\n        if (!pinned) {\n          throw errCode(new Error(`path '${path}' is not pinned`), 'ERR_NOT_PINNED')\n        }\n\n        switch (reason) {\n          case PinTypes.direct:\n          case PinTypes.recursive:\n            matched = true\n            yield toPin(reason, cid, metadata)\n            break\n          default:\n            matched = true\n            yield toPin(`${PinTypes.indirect} through ${parent}`, cid, metadata)\n        }\n      }\n\n      if (!matched) {\n        throw new Error('No match found')\n      }\n\n      return\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      for await (const { cid, metadata } of repo.pins.recursiveKeys()) {\n        yield toPin(PinTypes.recursive, cid, metadata)\n      }\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      // @ts-ignore - LsSettings & AbortOptions have no properties in common\n      // with type { preload?: boolean }\n      for await (const cid of repo.pins.indirectKeys(options)) {\n        yield toPin(PinTypes.indirect, cid)\n      }\n    }\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      for await (const { cid, metadata } of repo.pins.directKeys()) {\n        yield toPin(PinTypes.direct, cid, metadata)\n      }\n    }\n  }\n\n  return withTimeoutOption(ls)\n}\n"]},"metadata":{},"sourceType":"script"}