{"ast":null,"code":"import _asyncIterator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport _asyncGeneratorDelegate from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport dirBuilder from './dir.js';\nimport fileBuilder from './file/index.js';\nimport errCode from 'err-code';\n\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\n\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\n\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return _wrapAsyncGenerator(function* () {\n        yield content;\n      })();\n    } else if (isIterable(content)) {\n      return _wrapAsyncGenerator(function* () {\n        yield* _asyncGeneratorDelegate(_asyncIterator(content), _awaitAsyncGenerator);\n      })();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\n\nfunction dagBuilder(_x, _x2, _x3) {\n  return _dagBuilder.apply(this, arguments);\n}\n\nfunction _dagBuilder() {\n  _dagBuilder = _wrapAsyncGenerator(function* (source, blockstore, options) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const entry = _value;\n\n        if (entry.path) {\n          if (entry.path.substring(0, 2) === './') {\n            options.wrapWithDirectory = true;\n          }\n\n          entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n        }\n\n        if (entry.content) {\n          let chunker;\n\n          if (typeof options.chunker === 'function') {\n            chunker = options.chunker;\n          } else if (options.chunker === 'rabin') {\n            chunker = (yield _awaitAsyncGenerator(import('../chunker/rabin.js'))).default;\n          } else {\n            chunker = (yield _awaitAsyncGenerator(import('../chunker/fixed-size.js'))).default;\n          }\n\n          let chunkValidator;\n\n          if (typeof options.chunkValidator === 'function') {\n            chunkValidator = options.chunkValidator;\n          } else {\n            chunkValidator = (yield _awaitAsyncGenerator(import('./validate-chunks.js'))).default;\n          }\n\n          const file = {\n            path: entry.path,\n            mtime: entry.mtime,\n            mode: entry.mode,\n            content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n          };\n          yield () => fileBuilder(file, blockstore, options);\n        } else if (entry.path) {\n          const dir = {\n            path: entry.path,\n            mtime: entry.mtime,\n            mode: entry.mode\n          };\n          yield () => dirBuilder(dir, blockstore, options);\n        } else {\n          throw new Error('Import candidate must have content or path or both');\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return _dagBuilder.apply(this, arguments);\n}\n\nexport default dagBuilder;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js"],"names":["dirBuilder","fileBuilder","errCode","isIterable","thing","Symbol","iterator","isAsyncIterable","asyncIterator","contentAsAsyncIterable","content","Uint8Array","Error","dagBuilder","source","blockstore","options","entry","path","substring","wrapWithDirectory","split","filter","join","chunker","default","chunkValidator","file","mtime","mode","dir"],"mappings":"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","sourcesContent":["import dirBuilder from './dir.js';\nimport fileBuilder from './file/index.js';\nimport errCode from 'err-code';\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\nasync function* dagBuilder(source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n    if (entry.content) {\n      let chunker;\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = (await import('../chunker/rabin.js')).default;\n      } else {\n        chunker = (await import('../chunker/fixed-size.js')).default;\n      }\n      let chunkValidator;\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = (await import('./validate-chunks.js')).default;\n      }\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => fileBuilder(file, blockstore, options);\n    } else if (entry.path) {\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dirBuilder(dir, blockstore, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\nexport default dagBuilder;"]},"metadata":{},"sourceType":"module"}