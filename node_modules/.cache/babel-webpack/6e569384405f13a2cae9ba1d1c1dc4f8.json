{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport { encode, prepare } from '@ipld/dag-pb';\nimport { UnixFS } from 'ipfs-unixfs';\nimport Dir from './dir.js';\nimport persist from './utils/persist.js';\n\nclass DirFlat extends Dir {\n  constructor(props, options) {\n    super(props, options);\n    this._children = {};\n  }\n\n  put(name, value) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3.cid = undefined;\n      _this3.size = undefined;\n      _this3._children[name] = value;\n    })();\n  }\n\n  get(name) {\n    return Promise.resolve(this._children[name]);\n  }\n\n  childCount() {\n    return Object.keys(this._children).length;\n  }\n\n  directChildrenCount() {\n    return this.childCount();\n  }\n\n  onlyChild() {\n    return this._children[Object.keys(this._children)[0]];\n  }\n\n  eachChildSeries() {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const keys = Object.keys(_this._children);\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        yield {\n          key: key,\n          child: _this._children[key]\n        };\n      }\n    })();\n  }\n\n  flush(block) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const children = Object.keys(_this2._children);\n      const links = [];\n\n      for (let i = 0; i < children.length; i++) {\n        let child = _this2._children[children[i]];\n\n        if (child instanceof Dir) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n\n          var _iteratorError;\n\n          try {\n            for (var _iterator = _asyncIterator(child.flush(block)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n              const entry = _value;\n              child = entry;\n              yield child;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                yield _awaitAsyncGenerator(_iterator.return());\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        if (child.size != null && child.cid) {\n          links.push({\n            Name: children[i],\n            Tsize: child.size,\n            Hash: child.cid\n          });\n        }\n      }\n\n      const unixfs = new UnixFS({\n        type: 'directory',\n        mtime: _this2.mtime,\n        mode: _this2.mode\n      });\n      const node = {\n        Data: unixfs.marshal(),\n        Links: links\n      };\n      const buffer = encode(prepare(node));\n      const cid = yield _awaitAsyncGenerator(persist(buffer, block, _this2.options));\n      const size = buffer.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);\n      _this2.cid = cid;\n      _this2.size = size;\n      yield {\n        cid,\n        unixfs,\n        path: _this2.path,\n        size\n      };\n    })();\n  }\n\n}\n\nexport default DirFlat;","map":null,"metadata":{},"sourceType":"module"}