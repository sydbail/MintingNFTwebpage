{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst PeerId = require('peer-id');\n/** @type {{success:true, time:0, text: ''}} */\n\n\nconst basePacket = {\n  success: true,\n  time: 0,\n  text: ''\n};\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n */\n\n\nmodule.exports = ({\n  network\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"ping\"]}\n   */\n  function ping(_x) {\n    return _ping.apply(this, arguments);\n  }\n\n  function _ping() {\n    _ping = _wrapAsyncGenerator(function* (peerId, options = {}) {\n      const {\n        libp2p\n      } = yield _awaitAsyncGenerator(network.use());\n      options.count = options.count || 10;\n      const peer = PeerId.createFromB58String(peerId);\n      const storedPeer = libp2p.peerStore.get(peer);\n      let id = storedPeer && storedPeer.id;\n\n      if (!id) {\n        yield { ...basePacket,\n          text: `Looking up peer ${peerId}`\n        };\n        const remotePeer = yield _awaitAsyncGenerator(libp2p.peerRouting.findPeer(peer));\n        id = remotePeer && remotePeer.id;\n      }\n\n      if (!id) {\n        throw new Error('Peer was not found');\n      }\n\n      yield { ...basePacket,\n        text: `PING ${id.toB58String()}`\n      };\n      let packetCount = 0;\n      let totalTime = 0;\n\n      for (let i = 0; i < options.count; i++) {\n        try {\n          const time = yield _awaitAsyncGenerator(libp2p.ping(id));\n          totalTime += time;\n          packetCount++;\n          yield { ...basePacket,\n            time\n          };\n        } catch (err) {\n          yield { ...basePacket,\n            success: false,\n            text: err.toString()\n          };\n        }\n      }\n\n      if (packetCount) {\n        const average = totalTime / packetCount;\n        yield { ...basePacket,\n          text: `Average latency: ${average}ms`\n        };\n      }\n    });\n    return _ping.apply(this, arguments);\n  }\n\n  return withTimeoutOption(ping);\n};\n/**\n * @typedef {Pong|PingFailure|StatusUpdate} Packet\n * Note that not all ping response objects are \"pongs\".\n * A \"pong\" message can be identified by a truthy success property and an empty\n * text property. Other ping responses are failures or status updates.\n *\n * @typedef {Object} Pong\n * @property {true} success\n * @property {number} time\n * @property {''} text\n *\n * @typedef {Object} PingFailure\n * @property {false} success\n * @property {number} time\n * @property {string} text\n *\n * @typedef {Object} StatusUpdate\n * @property {true} success\n * @property {0} time\n * @property {string} text\n *\n * @typedef {PingSettings & AbortOptions} PingOptions\n *\n * @typedef {Object} PingSettings\n * @property {number} [count=10] - The number of ping messages to send\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/ipfs-core/src/components/ping.js"],"names":["PeerId","require","basePacket","success","time","text","withTimeoutOption","module","exports","network","ping","peerId","options","libp2p","use","count","peer","createFromB58String","storedPeer","peerStore","get","id","remotePeer","peerRouting","findPeer","Error","toB58String","packetCount","totalTime","i","err","toString","average"],"mappings":"AAAA;;;;;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;AACA;;;AACA,MAAMC,UAAU,GAAG;AAAEC,EAAAA,OAAO,EAAE,IAAX;AAAiBC,EAAAA,IAAI,EAAE,CAAvB;AAA0BC,EAAAA,IAAI,EAAE;AAAhC,CAAnB;;AACA,MAAMC,iBAAiB,GAAGL,OAAO,CAAC,yCAAD,CAAjC;AAEA;AACA;AACA;AACA;;;AACAM,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAAiB;AAChC;AACF;AACA;AAHkC,WAIfC,IAJe;AAAA;AAAA;;AAAA;AAAA,gCAIhC,WAAuBC,MAAvB,EAA+BC,OAAO,GAAG,EAAzC,EAA6C;AAC3C,YAAM;AAAEC,QAAAA;AAAF,qCAAmBJ,OAAO,CAACK,GAAR,EAAnB,CAAN;AACAF,MAAAA,OAAO,CAACG,KAAR,GAAgBH,OAAO,CAACG,KAAR,IAAiB,EAAjC;AAEA,YAAMC,IAAI,GAAGhB,MAAM,CAACiB,mBAAP,CAA2BN,MAA3B,CAAb;AAEA,YAAMO,UAAU,GAAGL,MAAM,CAACM,SAAP,CAAiBC,GAAjB,CAAqBJ,IAArB,CAAnB;AACA,UAAIK,EAAE,GAAGH,UAAU,IAAIA,UAAU,CAACG,EAAlC;;AAEA,UAAI,CAACA,EAAL,EAAS;AACP,cAAM,EAAE,GAAGnB,UAAL;AAAiBG,UAAAA,IAAI,EAAG,mBAAkBM,MAAO;AAAjD,SAAN;AACA,cAAMW,UAAU,8BAAST,MAAM,CAACU,WAAP,CAAmBC,QAAnB,CAA4BR,IAA5B,CAAT,CAAhB;AAEAK,QAAAA,EAAE,GAAGC,UAAU,IAAIA,UAAU,CAACD,EAA9B;AACD;;AAED,UAAI,CAACA,EAAL,EAAS;AACP,cAAM,IAAII,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAED,YAAM,EAAE,GAAGvB,UAAL;AAAiBG,QAAAA,IAAI,EAAG,QAAOgB,EAAE,CAACK,WAAH,EAAiB;AAAhD,OAAN;AAEA,UAAIC,WAAW,GAAG,CAAlB;AACA,UAAIC,SAAS,GAAG,CAAhB;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjB,OAAO,CAACG,KAA5B,EAAmCc,CAAC,EAApC,EAAwC;AACtC,YAAI;AACF,gBAAMzB,IAAI,8BAASS,MAAM,CAACH,IAAP,CAAYW,EAAZ,CAAT,CAAV;AACAO,UAAAA,SAAS,IAAIxB,IAAb;AACAuB,UAAAA,WAAW;AACX,gBAAM,EAAE,GAAGzB,UAAL;AAAiBE,YAAAA;AAAjB,WAAN;AACD,SALD,CAKE,OAAO0B,GAAP,EAAY;AACZ,gBAAM,EAAE,GAAG5B,UAAL;AAAiBC,YAAAA,OAAO,EAAE,KAA1B;AAAiCE,YAAAA,IAAI,EAAEyB,GAAG,CAACC,QAAJ;AAAvC,WAAN;AACD;AACF;;AAED,UAAIJ,WAAJ,EAAiB;AACf,cAAMK,OAAO,GAAGJ,SAAS,GAAGD,WAA5B;AACA,cAAM,EAAE,GAAGzB,UAAL;AAAiBG,UAAAA,IAAI,EAAG,oBAAmB2B,OAAQ;AAAnD,SAAN;AACD;AACF,KA5C+B;AAAA;AAAA;;AA8ChC,SAAO1B,iBAAiB,CAACI,IAAD,CAAxB;AACD,CA/CD;AAiDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\n/** @type {{success:true, time:0, text: ''}} */\nconst basePacket = { success: true, time: 0, text: '' }\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n */\nmodule.exports = ({ network }) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"ping\"]}\n   */\n  async function * ping (peerId, options = {}) {\n    const { libp2p } = await network.use()\n    options.count = options.count || 10\n\n    const peer = PeerId.createFromB58String(peerId)\n\n    const storedPeer = libp2p.peerStore.get(peer)\n    let id = storedPeer && storedPeer.id\n\n    if (!id) {\n      yield { ...basePacket, text: `Looking up peer ${peerId}` }\n      const remotePeer = await libp2p.peerRouting.findPeer(peer)\n\n      id = remotePeer && remotePeer.id\n    }\n\n    if (!id) {\n      throw new Error('Peer was not found')\n    }\n\n    yield { ...basePacket, text: `PING ${id.toB58String()}` }\n\n    let packetCount = 0\n    let totalTime = 0\n\n    for (let i = 0; i < options.count; i++) {\n      try {\n        const time = await libp2p.ping(id)\n        totalTime += time\n        packetCount++\n        yield { ...basePacket, time }\n      } catch (err) {\n        yield { ...basePacket, success: false, text: err.toString() }\n      }\n    }\n\n    if (packetCount) {\n      const average = totalTime / packetCount\n      yield { ...basePacket, text: `Average latency: ${average}ms` }\n    }\n  }\n\n  return withTimeoutOption(ping)\n}\n\n/**\n * @typedef {Pong|PingFailure|StatusUpdate} Packet\n * Note that not all ping response objects are \"pongs\".\n * A \"pong\" message can be identified by a truthy success property and an empty\n * text property. Other ping responses are failures or status updates.\n *\n * @typedef {Object} Pong\n * @property {true} success\n * @property {number} time\n * @property {''} text\n *\n * @typedef {Object} PingFailure\n * @property {false} success\n * @property {number} time\n * @property {string} text\n *\n * @typedef {Object} StatusUpdate\n * @property {true} success\n * @property {0} time\n * @property {string} text\n *\n * @typedef {PingSettings & AbortOptions} PingOptions\n *\n * @typedef {Object} PingSettings\n * @property {number} [count=10] - The number of ping messages to send\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n"]},"metadata":{},"sourceType":"script"}