{"ast":null,"code":"'use strict';\n/**\n * @template Key, Value\n * SortedMap is a Map whose iterator order can be defined by the user\n * @extends {Map<Key, Value>}\n */\n\nclass SortedMap extends Map {\n  /**\n   * @param {Array<[Key, Value]>} [entries]\n   * @param {(a:[Key, Value], b:[Key, Value]) => number} [cmp] - compares [k1, v1] to [k2, v2]\n   */\n  constructor(entries, cmp) {\n    super();\n    this._cmp = cmp || this._defaultSort;\n    /** @type {Key[]} */\n\n    this._keys = [];\n\n    for (const [k, v] of entries || []) {\n      this.set(k, v);\n    }\n  }\n  /**\n   * Call update to update the position of the key when it should change.\n   * For example if the compare function sorts by the priority field, and the\n   * priority changes, call update.\n   * Call indexOf() to get the index _before_ the change happens.\n   *\n   * @param {number} i - the index of entry whose position should be updated.\n   */\n\n\n  update(i) {\n    if (i < 0 || i >= this._keys.length) {\n      return;\n    }\n\n    const k = this._keys[i];\n\n    this._keys.splice(i, 1);\n\n    const newIdx = this._find(k);\n\n    this._keys.splice(newIdx, 0, k);\n  }\n  /**\n   * @param {Key} k\n   * @param {Value} v\n   */\n\n\n  set(k, v) {\n    // If the key is already in the map, remove it from the ordering and\n    // re-insert it below\n    if (this.has(k)) {\n      const i = this.indexOf(k);\n\n      this._keys.splice(i, 1);\n    } // Update / insert the k/v into the map\n\n\n    super.set(k, v); // Find the correct position of the newly inserted k/v in the order\n\n    const i = this._find(k);\n\n    this._keys.splice(i, 0, k);\n\n    return this;\n  }\n\n  clear() {\n    super.clear();\n    this._keys = [];\n  }\n  /**\n   * @param {Key} k\n   */\n\n\n  delete(k) {\n    if (!this.has(k)) {\n      return false;\n    }\n\n    const i = this.indexOf(k);\n\n    this._keys.splice(i, 1);\n\n    return super.delete(k);\n  }\n  /**\n   * @param {Key} k\n   */\n\n\n  indexOf(k) {\n    if (!this.has(k)) {\n      return -1;\n    }\n\n    const i = this._find(k);\n\n    if (this._keys[i] === k) {\n      return i;\n    } // There may be more than one key with the same ordering\n    // eg { k1: <priority 5>, k2: <priority 5> }\n    // so scan outwards until the key matches\n\n\n    for (let j = 1; j < this._keys.length; j++) {\n      if (this._keys[i + j] === k) return i + j;\n      if (this._keys[i - j] === k) return i - j;\n    }\n\n    return -1; // should never happen for existing key\n  }\n  /**\n   * @private\n   * @param {Key} k\n   * @returns {number}\n   */\n\n\n  _find(k) {\n    let lower = 0;\n    let upper = this._keys.length;\n\n    while (lower < upper) {\n      const pivot = lower + upper >>> 1; // lower + (upper - lower) / 2\n\n      const cmp = this._kCmp(this._keys[pivot], k); // console.log(`  _find ${lower}:${upper}[${pivot}] ${cmp}`)\n\n\n      if (cmp < 0) {\n        // pivot < k\n        lower = pivot + 1;\n      } else if (cmp > 0) {\n        // pivot > k\n        upper = pivot;\n      } else {\n        // pivot == k\n        return pivot;\n      }\n    }\n\n    return lower;\n  }\n\n  *keys() {\n    for (const k of this._keys) {\n      yield k;\n    }\n\n    return undefined;\n  }\n  /**\n   * @returns {IterableIterator<Value>}\n   */\n\n\n  *values() {\n    for (const k of this._keys) {\n      // @ts-ignore - return of `this.get(k)` is `Value|undefined` which is\n      // incompatible with `Value`. Typechecker can't that this contains values\n      // for all the `_keys`. ts(2322)\n      yield this.get(k);\n    }\n\n    return undefined;\n  }\n  /**\n   * @returns {IterableIterator<[Key, Value]>}\n   */\n\n\n  *entries() {\n    for (const k of this._keys) {\n      // @ts-ignore - return of `this.get(k)` is `Value|undefined` which is\n      // incompatible with `Value`. Typechecker can't that this contains values\n      // for all the `_keys`. ts(2322)\n      yield [k, this.get(k)];\n    }\n\n    return undefined;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.entries();\n  }\n  /**\n   * @template This\n   * @param {(entry:[Key, Value]) => void} cb\n   * @param {This} [thisArg]\n   */\n  // @ts-expect-error - Callback in Map forEach is (V, K, Map<K, V>) => void\n\n\n  forEach(cb, thisArg) {\n    if (!cb) {\n      return;\n    }\n\n    for (const k of this._keys) {\n      cb.apply(thisArg, [[\n        /** @type {Value} */\n      k, this.get(k)]]);\n    }\n  }\n  /**\n   * @private\n   * @param {[Key, Value]} a\n   * @param {[Key, Value]} b\n   * @returns {0|1|-1}\n   */\n\n\n  _defaultSort(a, b) {\n    if (a[0] < b[0]) return -1;\n    if (b[0] < a[0]) return 1;\n    return 0;\n  }\n  /**\n   * @private\n   * @param {Key} a\n   * @param {Key} b\n   */\n\n\n  _kCmp(a, b) {\n    return this._cmp( // @ts-ignore - get may return undefined\n    [a, this.get(a)], // @ts-ignore - get may return undefined\n    [b, this.get(b)]);\n  }\n\n}\n\nmodule.exports = SortedMap;","map":null,"metadata":{},"sourceType":"script"}