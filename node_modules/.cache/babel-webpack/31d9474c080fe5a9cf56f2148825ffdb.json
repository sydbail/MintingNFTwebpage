{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst PeerDistanceList = require('../peer-list/peer-distance-list');\n\nconst EventEmitter = require('events');\n\nconst Path = require('./path');\n\nconst WorkerQueue = require('./worker-queue');\n\nconst utils = require('../utils');\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * Manages a single run of the query.\n */\n\n\nclass Run extends EventEmitter {\n  /**\n   * Creates a Run.\n   *\n   * @param {import('./index')} query\n   */\n  constructor(query) {\n    super();\n    this.query = query;\n    this.running = false;\n    /** @type {WorkerQueue[]} */\n\n    this.workers = []; // The peers that have been queried (including error responses)\n\n    this.peersSeen = new Set(); // The errors received when querying peers\n\n    /** @type {Error[]} */\n\n    this.errors = []; // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n\n    /** @type {PeerDistanceList | null} */\n\n    this.peersQueried = null;\n  }\n  /**\n   * Stop all the workers\n   */\n\n\n  stop() {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n\n    for (const worker of this.workers) {\n      worker.stop();\n    }\n  }\n  /**\n   * Execute the run with the given initial set of peers.\n   *\n   * @param {PeerId[]} peers\n   */\n\n\n  execute(peers) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      /** @type {import('./path')[]} */\n      const paths = []; // array of states per disjoint path\n      // Create disjoint paths\n\n      const numPaths = Math.min(_this.query.dht.disjointPaths, peers.length);\n\n      for (let i = 0; i < numPaths; i++) {\n        paths.push(new Path(_this, _this.query.makePath(i, numPaths)));\n      } // Assign peers to paths round-robin style\n\n\n      peers.forEach((peer, i) => {\n        paths[i % numPaths].addInitialPeer(peer);\n      }); // Execute the query along each disjoint path\n\n      yield _this.executePaths(paths);\n      const res = {\n        // The closest K peers we were able to query successfully\n        finalSet: new Set(_this.peersQueried && _this.peersQueried.peers),\n\n        /** @type {import('./index').QueryResult[]} */\n        paths: []\n      }; // Collect the results from each completed path\n\n      for (const path of paths) {\n        if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n          path.res.success = true;\n          res.paths.push(path.res);\n        }\n      }\n\n      return res;\n    })();\n  }\n  /**\n   * Execute all paths through the DHT.\n   *\n   * @param {Array<Path>} paths\n   * @returns {Promise<void>}\n   */\n\n\n  executePaths(paths) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.running = true;\n\n      _this2.emit('start');\n\n      try {\n        yield Promise.all(paths.map(path => path.execute()));\n      } finally {\n        // Ensure all workers are stopped\n        _this2.stop(); // Completed the Run\n\n\n        _this2.emit('complete');\n      } // If all queries errored out, something is seriously wrong, so callback\n      // with an error\n\n\n      if (_this2.errors.length === _this2.peersSeen.size) {\n        throw _this2.errors[0];\n      }\n    })();\n  }\n  /**\n   * Initialize the list of queried peers, then start a worker queue for the\n   * given path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n\n\n  workerQueue(path) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.init();\n      yield _this3.startWorker(path);\n    })();\n  }\n  /**\n   * Create and start a worker queue for a particular path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n\n\n  startWorker(path) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const worker = new WorkerQueue(_this4.query.dht, _this4, path, _this4.query._log);\n\n      _this4.workers.push(worker);\n\n      yield worker.execute();\n    })();\n  }\n  /**\n   * Initialize the list of closest peers we've queried - this is shared by all\n   * paths in the run.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  init() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this5.peersQueried) {\n        return;\n      } // We only want to initialize the PeerDistanceList once for the run\n\n\n      if (_this5.peersQueriedPromise) {\n        yield _this5.peersQueriedPromise;\n        return;\n      } // This promise is temporarily stored so that others may await its completion\n\n\n      _this5.peersQueriedPromise = _asyncToGenerator(function* () {\n        const dhtKey = yield utils.convertBuffer(_this5.query.key);\n        _this5.peersQueried = new PeerDistanceList(dhtKey, _this5.query.dht.kBucketSize);\n      })(); // After PeerDistanceList is initialized, clean up\n\n      yield _this5.peersQueriedPromise;\n      delete _this5.peersQueriedPromise;\n    })();\n  }\n  /**\n   * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n   * are all further from the key than the peers we've already queried, then we should\n   * stop querying on that `worker`.\n   *\n   * @param {WorkerQueue} worker\n   * @returns {Promise<boolean>}\n   */\n\n\n  continueQuerying(worker) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // If we haven't queried K peers yet, keep going\n      if (_this6.peersQueried && _this6.peersQueried.length < _this6.peersQueried.capacity) {\n        return true;\n      } // Get all the peers that are currently being queried.\n      // Note that this function gets called right after a peer has been popped\n      // off the head of the closest peers queue so it will include that peer.\n\n\n      const running = Array.from(worker.queuedPeerIds); // Check if any of the peers that are currently being queried are closer\n      // to the key than the peers we've already queried\n\n      const someCloser = _this6.peersQueried && (yield _this6.peersQueried.anyCloser(running)); // Some are closer, the worker should keep going\n\n      if (someCloser) {\n        return true;\n      } // None are closer, the worker can stop\n\n\n      return false;\n    })();\n  }\n\n}\n\nmodule.exports = Run;","map":null,"metadata":{},"sourceType":"script"}