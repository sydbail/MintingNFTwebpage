{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst PeerId = require('peer-id');\n\nconst {\n  RPC\n} = require('./rpc');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst SignPrefix = uint8ArrayFromString('libp2p-pubsub:');\n\nconst {\n  normalizeOutRpcMessage\n} = require('../utils');\n/**\n * @typedef {import('..').InMessage}\n */\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {InMessage} message\n * @returns {Promise<InMessage>}\n */\n\n\nfunction signMessage(_x, _x2) {\n  return _signMessage.apply(this, arguments);\n}\n/**\n * Verifies the signature of the given message\n *\n * @param {InMessage} message\n * @returns {Promise<boolean>}\n */\n\n\nfunction _signMessage() {\n  _signMessage = _asyncToGenerator(function* (peerId, message) {\n    // Get the message in bytes, and prepend with the pubsub prefix\n    const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(normalizeOutRpcMessage(message)).finish()]);\n    const signature = yield peerId.privKey.sign(bytes);\n    return { ...message,\n      signature: signature,\n      key: peerId.pubKey.bytes\n    };\n  });\n  return _signMessage.apply(this, arguments);\n}\n\nfunction verifySignature(_x3) {\n  return _verifySignature.apply(this, arguments);\n}\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\n\n\nfunction _verifySignature() {\n  _verifySignature = _asyncToGenerator(function* (message) {\n    if (!message.signature) {\n      throw new Error('Message must contain a signature to be verified');\n    }\n\n    if (!message.from) {\n      throw new Error('Message must contain a from property to be verified');\n    } // Get message sans the signature\n\n\n    const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode({ ...message,\n      from: PeerId.createFromB58String(message.from).toBytes(),\n      signature: undefined,\n      key: undefined\n    }).finish()]); // Get the public key\n\n    const pubKey = yield messagePublicKey(message); // verify the base message\n\n    return pubKey.verify(bytes, message.signature);\n  });\n  return _verifySignature.apply(this, arguments);\n}\n\nfunction messagePublicKey(_x4) {\n  return _messagePublicKey.apply(this, arguments);\n}\n/**\n * @typedef {import('..').InMessage} InMessage\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n */\n\n\nfunction _messagePublicKey() {\n  _messagePublicKey = _asyncToGenerator(function* (message) {\n    // should be available in the from property of the message (peer id)\n    if (!message.from) {\n      throw new Error('Could not get the public key from the originator id');\n    }\n\n    const from = PeerId.createFromB58String(message.from);\n\n    if (message.key) {\n      const keyPeerId = yield PeerId.createFromPubKey(message.key); // the key belongs to the sender, return the key\n\n      if (keyPeerId.equals(from)) return keyPeerId.pubKey; // We couldn't validate pubkey is from the originator, error\n\n      throw new Error('Public Key does not match the originator');\n    } else if (from.pubKey) {\n      return from.pubKey;\n    } else {\n      throw new Error('Could not get the public key from the originator id');\n    }\n  });\n  return _messagePublicKey.apply(this, arguments);\n}\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-interfaces/src/pubsub/message/sign.js"],"names":["PeerId","require","RPC","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","SignPrefix","normalizeOutRpcMessage","signMessage","peerId","message","bytes","Message","encode","finish","signature","privKey","sign","key","pubKey","verifySignature","Error","from","createFromB58String","toBytes","undefined","messagePublicKey","verify","keyPeerId","createFromPubKey","equals","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { RPC } = require('./rpc')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\nconst { normalizeOutRpcMessage } = require('../utils')\n\n/**\n * @typedef {import('..').InMessage}\n */\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {InMessage} message\n * @returns {Promise<InMessage>}\n */\nasync function signMessage (peerId, message) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    RPC.Message.encode(normalizeOutRpcMessage(message)).finish()\n  ])\n\n  const signature = await peerId.privKey.sign(bytes)\n\n  return {\n    ...message,\n    signature: signature,\n    key: peerId.pubKey.bytes\n  }\n}\n\n/**\n * Verifies the signature of the given message\n *\n * @param {InMessage} message\n * @returns {Promise<boolean>}\n */\nasync function verifySignature (message) {\n  if (!message.signature) {\n    throw new Error('Message must contain a signature to be verified')\n  }\n\n  if (!message.from) {\n    throw new Error('Message must contain a from property to be verified')\n  }\n\n  // Get message sans the signature\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    RPC.Message.encode({\n      ...message,\n      from: PeerId.createFromB58String(message.from).toBytes(),\n      signature: undefined,\n      key: undefined\n    }).finish()\n  ])\n\n  // Get the public key\n  const pubKey = await messagePublicKey(message)\n\n  // verify the base message\n  return pubKey.verify(bytes, message.signature)\n}\n\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\nasync function messagePublicKey (message) {\n  // should be available in the from property of the message (peer id)\n  if (!message.from) {\n    throw new Error('Could not get the public key from the originator id')\n  }\n\n  const from = PeerId.createFromB58String(message.from)\n\n  if (message.key) {\n    const keyPeerId = await PeerId.createFromPubKey(message.key)\n\n    // the key belongs to the sender, return the key\n    if (keyPeerId.equals(from)) return keyPeerId.pubKey\n    // We couldn't validate pubkey is from the originator, error\n    throw new Error('Public Key does not match the originator')\n  } else if (from.pubKey) {\n    return from.pubKey\n  } else {\n    throw new Error('Could not get the public key from the originator id')\n  }\n}\n\n/**\n * @typedef {import('..').InMessage} InMessage\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n */\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n}\n"]},"metadata":{},"sourceType":"script"}