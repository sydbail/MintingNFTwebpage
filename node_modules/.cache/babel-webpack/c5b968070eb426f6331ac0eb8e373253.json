{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:transports'), {\n  error: debug('libp2p:transports:err')\n});\n\nconst pSettle = require('p-settle');\n\nconst {\n  codes\n} = require('./errors');\n\nconst errCode = require('err-code');\n\nconst {\n  updateSelfPeerRecord\n} = require('./record/utils');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/transport/types').Transport<any, any>} Transport\n *\n * @typedef {Object} TransportManagerProperties\n * @property {import('./')} libp2p\n * @property {import('./upgrader')} upgrader\n *\n * @typedef {Object} TransportManagerOptions\n * @property {number} [faultTolerance = FAULT_TOLERANCE.FATAL_ALL] - Address listen error tolerance.\n */\n\n\nclass TransportManager {\n  /**\n   * @class\n   * @param {TransportManagerProperties & TransportManagerOptions} options\n   */\n  constructor({\n    libp2p,\n    upgrader,\n    faultTolerance = FAULT_TOLERANCE.FATAL_ALL\n  }) {\n    this.libp2p = libp2p;\n    this.upgrader = upgrader;\n    /** @type {Map<string, Transport>} */\n\n    this._transports = new Map();\n    this._listeners = new Map();\n    this._listenerOptions = new Map();\n    this.faultTolerance = faultTolerance;\n  }\n  /**\n   * Adds a `Transport` to the manager\n   *\n   * @param {string} key\n   * @param {TransportFactory} Transport\n   * @param {*} transportOptions - Additional options to pass to the transport\n   * @returns {void}\n   */\n\n\n  add(key, Transport, transportOptions = {}) {\n    log('adding %s', key);\n\n    if (!key) {\n      throw errCode(new Error(`Transport must have a valid key, was given '${key}'`), codes.ERR_INVALID_KEY);\n    }\n\n    if (this._transports.has(key)) {\n      throw errCode(new Error('There is already a transport with this key'), codes.ERR_DUPLICATE_TRANSPORT);\n    }\n\n    const transport = new Transport({ ...transportOptions,\n      libp2p: this.libp2p,\n      upgrader: this.upgrader\n    });\n\n    this._transports.set(key, transport);\n\n    this._listenerOptions.set(key, transportOptions.listenerOptions || {});\n\n    if (!this._listeners.has(key)) {\n      this._listeners.set(key, []);\n    }\n  }\n  /**\n   * Stops all listeners\n   *\n   * @async\n   */\n\n\n  close() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const tasks = [];\n\n      for (const [key, listeners] of _this._listeners) {\n        log('closing listeners for %s', key);\n\n        while (listeners.length) {\n          const listener = listeners.pop();\n          listener.removeAllListeners('listening');\n          listener.removeAllListeners('close');\n          tasks.push(listener.close());\n        }\n      }\n\n      yield Promise.all(tasks);\n      log('all listeners closed');\n\n      for (const key of _this._listeners.keys()) {\n        _this._listeners.set(key, []);\n      }\n    })();\n  }\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   *\n   * @param {Multiaddr} ma\n   * @param {*} options\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(ma, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const transport = _this2.transportForMultiaddr(ma);\n\n      if (!transport) {\n        throw errCode(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);\n      }\n\n      try {\n        return yield transport.dial(ma, options);\n      } catch (err) {\n        if (!err.code) err.code = codes.ERR_TRANSPORT_DIAL_FAILED;\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Returns all Multiaddr's the listeners are using\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  getAddrs() {\n    /** @type {Multiaddr[]} */\n    let addrs = [];\n\n    for (const listeners of this._listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()];\n      }\n    }\n\n    return addrs;\n  }\n  /**\n   * Returns all the transports instances.\n   *\n   * @returns {IterableIterator<Transport>}\n   */\n\n\n  getTransports() {\n    return this._transports.values();\n  }\n  /**\n   * Finds a transport that matches the given Multiaddr\n   *\n   * @param {Multiaddr} ma\n   * @returns {Transport|null}\n   */\n\n\n  transportForMultiaddr(ma) {\n    for (const transport of this._transports.values()) {\n      const addrs = transport.filter([ma]);\n      if (addrs.length) return transport;\n    }\n\n    return null;\n  }\n  /**\n   * Starts listeners for each listen Multiaddr.\n   *\n   * @async\n   * @param {Multiaddr[]} addrs - addresses to attempt to listen on\n   */\n\n\n  listen(addrs) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!addrs || addrs.length === 0) {\n        log('no addresses were provided for listening, this node is dial only');\n        return;\n      }\n\n      const couldNotListen = [];\n\n      for (const [key, transport] of _this3._transports.entries()) {\n        const supportedAddrs = transport.filter(addrs);\n        const tasks = []; // For each supported multiaddr, create a listener\n\n        for (const addr of supportedAddrs) {\n          log('creating listener for %s on %s', key, addr);\n          const listener = transport.createListener(_this3._listenerOptions.get(key));\n\n          _this3._listeners.get(key).push(listener); // Track listen/close events\n\n\n          listener.on('listening', () => updateSelfPeerRecord(_this3.libp2p));\n          listener.on('close', () => updateSelfPeerRecord(_this3.libp2p)); // We need to attempt to listen on everything\n\n          tasks.push(listener.listen(addr));\n        } // Keep track of transports we had no addresses for\n\n\n        if (tasks.length === 0) {\n          couldNotListen.push(key);\n          continue;\n        }\n\n        const results = yield pSettle(tasks); // If we are listening on at least 1 address, succeed.\n        // TODO: we should look at adding a retry (`p-retry`) here to better support\n        // listening on remote addresses as they may be offline. We could then potentially\n        // just wait for any (`p-any`) listener to succeed on each transport before returning\n\n        const isListening = results.find(r => r.isFulfilled === true);\n\n        if (!isListening && _this3.faultTolerance !== FAULT_TOLERANCE.NO_FATAL) {\n          throw errCode(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);\n        }\n      } // If no transports were able to listen, throw an error. This likely\n      // means we were given addresses we do not have transports for\n\n\n      if (couldNotListen.length === _this3._transports.size) {\n        const message = `no valid addresses were provided for transports [${couldNotListen}]`;\n\n        if (_this3.faultTolerance === FAULT_TOLERANCE.FATAL_ALL) {\n          throw errCode(new Error(message), codes.ERR_NO_VALID_ADDRESSES);\n        }\n\n        log(`libp2p in dial mode only: ${message}`);\n      }\n    })();\n  }\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   *\n   * @async\n   * @param {string} key\n   */\n\n\n  remove(key) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      log('removing %s', key);\n\n      if (_this4._listeners.has(key)) {\n        // Close any running listeners\n        for (const listener of _this4._listeners.get(key)) {\n          listener.removeAllListeners('listening');\n          listener.removeAllListeners('close');\n          yield listener.close();\n        }\n      }\n\n      _this4._transports.delete(key);\n\n      _this4._listeners.delete(key);\n    })();\n  }\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n\n\n  removeAll() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const tasks = [];\n\n      for (const key of _this5._transports.keys()) {\n        tasks.push(_this5.remove(key));\n      }\n\n      yield Promise.all(tasks);\n    })();\n  }\n\n}\n/**\n * Enum Transport Manager Fault Tolerance values.\n * FATAL_ALL should be used for failing in any listen circumstance.\n * NO_FATAL should be used for not failing when not listening.\n *\n * @readonly\n * @enum {number}\n */\n\n\nconst FAULT_TOLERANCE = {\n  FATAL_ALL: 0,\n  NO_FATAL: 1\n};\nTransportManager.FaultTolerance = FAULT_TOLERANCE;\nmodule.exports = TransportManager;","map":null,"metadata":{},"sourceType":"script"}