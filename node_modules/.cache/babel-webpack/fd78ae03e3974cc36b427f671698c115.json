{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:keychain'), {\n  error: debug('libp2p:keychain:err')\n});\n\nconst sanitize = require('sanitize-filename');\n\nconst mergeOptions = require('merge-options');\n\nconst crypto = require('libp2p-crypto');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst CMS = require('./cms');\n\nconst errcode = require('err-code');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string'); // @ts-ignore node-forge sha512 types not exported\n\n\nrequire('node-forge/lib/sha512');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @typedef {Object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainOptions\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n */\n\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n\nconst keyPrefix = '/pkcs8/';\nconst infoPrefix = '/info/';\nconst privates = new WeakMap(); // NIST SP 800-132\n\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n/**\n * @param {string} name\n */\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string|Error} err - The error\n * @returns {Promise<never>}\n * @private\n */\n\n\nfunction throwDelayed(_x) {\n  return _throwDelayed.apply(this, arguments);\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\n\n\nfunction _throwDelayed() {\n  _throwDelayed = _asyncToGenerator(function* (err) {\n    const min = 200;\n    const max = 1000;\n    const delay = Math.random() * (max - min) + min;\n    yield new Promise(resolve => setTimeout(resolve, delay));\n    throw err;\n  });\n  return _throwDelayed.apply(this, arguments);\n}\n\nfunction DsName(name) {\n  return new Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new Key(infoPrefix + name);\n}\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {Datastore} store - where the key are.\n   * @param {KeychainOptions} options\n   * @class\n   */\n  constructor(store, options) {\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    this.opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (this.opts.pass && this.opts.pass.length < 20) {\n      throw new Error('pass must be least 20 characters');\n    }\n\n    if (this.opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);\n    }\n\n    if (this.opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);\n    }\n\n    if (this.opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);\n    }\n\n    const dek = this.opts.pass ? crypto.pbkdf2(this.opts.pass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : '';\n    privates.set(this, {\n      dek\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  get cms() {\n    return new CMS(this, privates.get(this).dek);\n  }\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {Object}\n   */\n\n\n  static generateOptions() {\n    const options = Object.assign({}, defaultOptions);\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n    options.dek.salt = uint8ArrayToString(crypto.randomBytes(saltLength), 'base64');\n    return options;\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {Object}\n   */\n\n\n  static get options() {\n    return defaultOptions;\n  }\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  createKey(name, type, size = 2048) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (typeof type !== 'string') {\n        return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'));\n      }\n\n      const dsname = DsName(name);\n      const exists = yield self.store.has(dsname);\n      if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n      switch (type.toLowerCase()) {\n        case 'rsa':\n          if (!Number.isSafeInteger(size) || size < 2048) {\n            return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'));\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      let keyInfo;\n\n      try {\n        // @ts-ignore Differences between several crypto return types need to be fixed in libp2p-crypto\n        const keypair = yield crypto.keys.generateKeyPair(type, size);\n        const kid = yield keypair.id();\n        /** @type {string} */\n\n        const dek = privates.get(_this).dek;\n        const pem = yield keypair.export(dek);\n        keyInfo = {\n          name: name,\n          id: kid\n        };\n        const batch = self.store.batch();\n        batch.put(dsname, uint8ArrayFromString(pem));\n        batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n        yield batch.commit();\n      } catch (err) {\n        return throwDelayed(err);\n      }\n\n      return keyInfo;\n    })();\n  }\n  /**\n   * List all the keys.\n   *\n   * @returns {Promise<KeyInfo[]>}\n   */\n\n\n  listKeys() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this2;\n      const query = {\n        prefix: infoPrefix\n      };\n      const info = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(self.store.query(query)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const value = _value;\n          info.push(JSON.parse(uint8ArrayToString(value.value)));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return info;\n    })();\n  }\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n   * @returns {Promise<KeyInfo|undefined>}\n   */\n\n\n  findKeyById(id) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const keys = yield _this3.listKeys();\n        return keys.find(k => k.id === id);\n      } catch (err) {\n        return throwDelayed(err);\n      }\n    })();\n  }\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  findKeyByName(name) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!validateKeyName(name)) {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      const dsname = DsInfoName(name);\n\n      try {\n        const res = yield _this4.store.get(dsname);\n        return JSON.parse(uint8ArrayToString(res));\n      } catch (err) {\n        return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'));\n      }\n    })();\n  }\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  removeKey(name) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this5;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      const dsname = DsName(name);\n      const keyInfo = yield self.findKeyByName(name);\n      const batch = self.store.batch();\n      batch.delete(dsname);\n      batch.delete(DsInfoName(name));\n      yield batch.commit();\n      return keyInfo;\n    })();\n  }\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  renameKey(oldName, newName) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this6;\n\n      if (!validateKeyName(oldName) || oldName === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'));\n      }\n\n      if (!validateKeyName(newName) || newName === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'));\n      }\n\n      const oldDsname = DsName(oldName);\n      const newDsname = DsName(newName);\n      const oldInfoName = DsInfoName(oldName);\n      const newInfoName = DsInfoName(newName);\n      const exists = yield self.store.has(newDsname);\n      if (exists) return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n      try {\n        const pem = yield self.store.get(oldDsname);\n        const res = yield self.store.get(oldInfoName);\n        const keyInfo = JSON.parse(uint8ArrayToString(res));\n        keyInfo.name = newName;\n        const batch = self.store.batch();\n        batch.put(newDsname, pem);\n        batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));\n        batch.delete(oldDsname);\n        batch.delete(oldInfoName);\n        yield batch.commit();\n        return keyInfo;\n      } catch (err) {\n        return throwDelayed(err);\n      }\n    })();\n  }\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n   * @returns {Promise<string>}\n   */\n\n\n  exportKey(name, password) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!validateKeyName(name)) {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!password) {\n        return throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'));\n      }\n\n      const dsname = DsName(name);\n\n      try {\n        const res = yield _this7.store.get(dsname);\n        const pem = uint8ArrayToString(res);\n        /** @type {string} */\n\n        const dek = privates.get(_this7).dek;\n        const privateKey = yield crypto.keys.import(pem, dek);\n        return privateKey.export(password);\n      } catch (err) {\n        return throwDelayed(err);\n      }\n    })();\n  }\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  importKey(name, pem, password) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this8;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!pem) {\n        return throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'));\n      }\n\n      const dsname = DsName(name);\n      const exists = yield self.store.has(dsname);\n      if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n      let privateKey;\n\n      try {\n        privateKey = yield crypto.keys.import(pem, password);\n      } catch (err) {\n        return throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'));\n      }\n\n      let kid;\n\n      try {\n        kid = yield privateKey.id();\n        /** @type {string} */\n\n        const dek = privates.get(_this8).dek;\n        pem = yield privateKey.export(dek);\n      } catch (err) {\n        return throwDelayed(err);\n      }\n\n      const keyInfo = {\n        name: name,\n        id: kid\n      };\n      const batch = self.store.batch();\n      batch.put(dsname, uint8ArrayFromString(pem));\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n      yield batch.commit();\n      return keyInfo;\n    })();\n  }\n  /**\n   * Import a peer key\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {PeerId} peer - The PEM encoded PKCS #8 string\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  importPeer(name, peer) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this9;\n\n      if (!validateKeyName(name)) {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!peer || !peer.privKey) {\n        return throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'));\n      }\n\n      const privateKey = peer.privKey;\n      const dsname = DsName(name);\n      const exists = yield self.store.has(dsname);\n      if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n      try {\n        const kid = yield privateKey.id();\n        /** @type {string} */\n\n        const dek = privates.get(_this9).dek;\n        const pem = yield privateKey.export(dek);\n        const keyInfo = {\n          name: name,\n          id: kid\n        };\n        const batch = self.store.batch();\n        batch.put(dsname, uint8ArrayFromString(pem));\n        batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n        yield batch.commit();\n        return keyInfo;\n      } catch (err) {\n        return throwDelayed(err);\n      }\n    })();\n  }\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n   * @returns {Promise<string>}\n   */\n\n\n  _getPrivateKey(name) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!validateKeyName(name)) {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      try {\n        const dsname = DsName(name);\n        const res = yield _this10.store.get(dsname);\n        return uint8ArrayToString(res);\n      } catch (err) {\n        return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'));\n      }\n    })();\n  }\n  /**\n   * Rotate keychain password and re-encrypt all assosciated keys\n   *\n   * @param {string} oldPass - The old local keychain password\n   * @param {string} newPass - The new local keychain password\n   */\n\n\n  rotateKeychainPass(oldPass, newPass) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof oldPass !== 'string') {\n        return throwDelayed(errcode(new Error(`Invalid old pass type '${typeof oldPass}'`), 'ERR_INVALID_OLD_PASS_TYPE'));\n      }\n\n      if (typeof newPass !== 'string') {\n        return throwDelayed(errcode(new Error(`Invalid new pass type '${typeof newPass}'`), 'ERR_INVALID_NEW_PASS_TYPE'));\n      }\n\n      if (newPass.length < 20) {\n        return throwDelayed(errcode(new Error(`Invalid pass length ${newPass.length}`), 'ERR_INVALID_PASS_LENGTH'));\n      }\n\n      log('recreating keychain');\n      const oldDek = privates.get(_this11).dek;\n      _this11.opts.pass = newPass;\n      const newDek = newPass ? crypto.pbkdf2(newPass, _this11.opts.dek.salt, _this11.opts.dek.iterationCount, _this11.opts.dek.keyLength, _this11.opts.dek.hash) : '';\n      privates.set(_this11, {\n        dek: newDek\n      });\n      const keys = yield _this11.listKeys();\n\n      for (const key of keys) {\n        const res = yield _this11.store.get(DsName(key.name));\n        const pem = uint8ArrayToString(res);\n        const privateKey = yield crypto.keys.import(pem, oldDek);\n        const password = newDek.toString();\n        const keyAsPEM = yield privateKey.export(password); // Update stored key\n\n        const batch = _this11.store.batch();\n\n        const keyInfo = {\n          name: key.name,\n          id: key.id\n        };\n        batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));\n        batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n        yield batch.commit();\n      }\n\n      log('keychain reconstructed');\n    })();\n  }\n\n}\n\nmodule.exports = Keychain;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/libp2p/src/keychain/index.js"],"names":["debug","require","log","Object","assign","error","sanitize","mergeOptions","crypto","Key","CMS","errcode","toString","uint8ArrayToString","fromString","uint8ArrayFromString","keyPrefix","infoPrefix","privates","WeakMap","NIST","minKeyLength","minSaltLength","minIterationCount","defaultOptions","dek","keyLength","iterationCount","salt","hash","validateKeyName","name","trim","throwDelayed","err","min","max","delay","Math","random","Promise","resolve","setTimeout","DsName","DsInfoName","Keychain","constructor","store","options","Error","opts","pass","length","pbkdf2","set","cms","get","generateOptions","saltLength","ceil","randomBytes","createKey","type","size","self","dsname","exists","has","toLowerCase","Number","isSafeInteger","keyInfo","keypair","keys","generateKeyPair","kid","id","pem","export","batch","put","JSON","stringify","commit","listKeys","query","prefix","info","value","push","parse","findKeyById","find","k","findKeyByName","res","message","removeKey","delete","renameKey","oldName","newName","oldDsname","newDsname","oldInfoName","newInfoName","exportKey","password","privateKey","import","importKey","importPeer","peer","privKey","_getPrivateKey","rotateKeychainPass","oldPass","newPass","oldDek","newDek","key","keyAsPEM","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict'\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:keychain'), {\n  error: debug('libp2p:keychain:err')\n})\nconst sanitize = require('sanitize-filename')\nconst mergeOptions = require('merge-options')\nconst crypto = require('libp2p-crypto')\nconst { Key } = require('interface-datastore')\nconst CMS = require('./cms')\nconst errcode = require('err-code')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\n// @ts-ignore node-forge sha512 types not exported\nrequire('node-forge/lib/sha512')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @typedef {Object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainOptions\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n */\n\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\nconst keyPrefix = '/pkcs8/'\nconst infoPrefix = '/info/'\nconst privates = new WeakMap()\n\n// NIST SP 800-132\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n}\n\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n}\n\n/**\n * @param {string} name\n */\nfunction validateKeyName (name) {\n  if (!name) return false\n  if (typeof name !== 'string') return false\n  return name === sanitize(name.trim())\n}\n\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string|Error} err - The error\n * @returns {Promise<never>}\n * @private\n */\nasync function throwDelayed (err) {\n  const min = 200\n  const max = 1000\n  const delay = Math.random() * (max - min) + min\n\n  await new Promise(resolve => setTimeout(resolve, delay))\n  throw err\n}\n\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\nfunction DsName (name) {\n  return new Key(keyPrefix + name)\n}\n\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\nfunction DsInfoName (name) {\n  return new Key(infoPrefix + name)\n}\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {Datastore} store - where the key are.\n   * @param {KeychainOptions} options\n   * @class\n   */\n  constructor (store, options) {\n    if (!store) {\n      throw new Error('store is required')\n    }\n    this.store = store\n\n    this.opts = mergeOptions(defaultOptions, options)\n\n    // Enforce NIST SP 800-132\n    if (this.opts.pass && this.opts.pass.length < 20) {\n      throw new Error('pass must be least 20 characters')\n    }\n    if (this.opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`)\n    }\n    if (this.opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`)\n    }\n    if (this.opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`)\n    }\n\n    const dek = this.opts.pass\n      ? crypto.pbkdf2(\n        this.opts.pass,\n        this.opts.dek.salt,\n        this.opts.dek.iterationCount,\n        this.opts.dek.keyLength,\n        this.opts.dek.hash)\n      : ''\n\n    privates.set(this, { dek })\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n  get cms () {\n    return new CMS(this, privates.get(this).dek)\n  }\n\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {Object}\n   */\n  static generateOptions () {\n    const options = Object.assign({}, defaultOptions)\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3 // no base64 padding\n    options.dek.salt = uint8ArrayToString(crypto.randomBytes(saltLength), 'base64')\n    return options\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {Object}\n   */\n  static get options () {\n    return defaultOptions\n  }\n\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only.\n   * @returns {Promise<KeyInfo>}\n   */\n  async createKey (name, type, size = 2048) {\n    const self = this\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    if (typeof type !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'))\n    }\n\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (!Number.isSafeInteger(size) || size < 2048) {\n          return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'))\n        }\n        break\n      default:\n        break\n    }\n\n    let keyInfo\n    try {\n      // @ts-ignore Differences between several crypto return types need to be fixed in libp2p-crypto\n      const keypair = await crypto.keys.generateKeyPair(type, size)\n      const kid = await keypair.id()\n      /** @type {string} */\n      const dek = privates.get(this).dek\n      const pem = await keypair.export(dek)\n      keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = self.store.batch()\n      batch.put(dsname, uint8ArrayFromString(pem))\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n\n      await batch.commit()\n    } catch (err) {\n      return throwDelayed(err)\n    }\n\n    return keyInfo\n  }\n\n  /**\n   * List all the keys.\n   *\n   * @returns {Promise<KeyInfo[]>}\n   */\n  async listKeys () {\n    const self = this\n    const query = {\n      prefix: infoPrefix\n    }\n\n    const info = []\n    for await (const value of self.store.query(query)) {\n      info.push(JSON.parse(uint8ArrayToString(value.value)))\n    }\n\n    return info\n  }\n\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n   * @returns {Promise<KeyInfo|undefined>}\n   */\n  async findKeyById (id) {\n    try {\n      const keys = await this.listKeys()\n      return keys.find((k) => k.id === id)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n   * @returns {Promise<KeyInfo>}\n   */\n  async findKeyByName (name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    const dsname = DsInfoName(name)\n    try {\n      const res = await this.store.get(dsname)\n      return JSON.parse(uint8ArrayToString(res))\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n    }\n  }\n\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n  async removeKey (name) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    const dsname = DsName(name)\n    const keyInfo = await self.findKeyByName(name)\n    const batch = self.store.batch()\n    batch.delete(dsname)\n    batch.delete(DsInfoName(name))\n    await batch.commit()\n    return keyInfo\n  }\n\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n  async renameKey (oldName, newName) {\n    const self = this\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'))\n    }\n    if (!validateKeyName(newName) || newName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'))\n    }\n    const oldDsname = DsName(oldName)\n    const newDsname = DsName(newName)\n    const oldInfoName = DsInfoName(oldName)\n    const newInfoName = DsInfoName(newName)\n\n    const exists = await self.store.has(newDsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    try {\n      const pem = await self.store.get(oldDsname)\n      const res = await self.store.get(oldInfoName)\n\n      const keyInfo = JSON.parse(uint8ArrayToString(res))\n      keyInfo.name = newName\n      const batch = self.store.batch()\n      batch.put(newDsname, pem)\n      batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)))\n      batch.delete(oldDsname)\n      batch.delete(oldInfoName)\n      await batch.commit()\n      return keyInfo\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n   * @returns {Promise<string>}\n   */\n  async exportKey (name, password) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!password) {\n      return throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'))\n    }\n\n    const dsname = DsName(name)\n    try {\n      const res = await this.store.get(dsname)\n      const pem = uint8ArrayToString(res)\n      /** @type {string} */\n      const dek = privates.get(this).dek\n      const privateKey = await crypto.keys.import(pem, dek)\n      return privateKey.export(password)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n   * @returns {Promise<KeyInfo>}\n   */\n  async importKey (name, pem, password) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!pem) {\n      return throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'))\n    }\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    let privateKey\n    try {\n      privateKey = await crypto.keys.import(pem, password)\n    } catch (err) {\n      return throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'))\n    }\n\n    let kid\n    try {\n      kid = await privateKey.id()\n      /** @type {string} */\n      const dek = privates.get(this).dek\n      pem = await privateKey.export(dek)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n\n    const keyInfo = {\n      name: name,\n      id: kid\n    }\n    const batch = self.store.batch()\n    batch.put(dsname, uint8ArrayFromString(pem))\n    batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n    await batch.commit()\n\n    return keyInfo\n  }\n\n  /**\n   * Import a peer key\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {PeerId} peer - The PEM encoded PKCS #8 string\n   * @returns {Promise<KeyInfo>}\n   */\n  async importPeer (name, peer) {\n    const self = this\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!peer || !peer.privKey) {\n      return throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'))\n    }\n\n    const privateKey = peer.privKey\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    try {\n      const kid = await privateKey.id()\n      /** @type {string} */\n      const dek = privates.get(this).dek\n      const pem = await privateKey.export(dek)\n      const keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = self.store.batch()\n      batch.put(dsname, uint8ArrayFromString(pem))\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n      await batch.commit()\n      return keyInfo\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n   * @returns {Promise<string>}\n   */\n  async _getPrivateKey (name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    try {\n      const dsname = DsName(name)\n      const res = await this.store.get(dsname)\n      return uint8ArrayToString(res)\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n    }\n  }\n\n  /**\n   * Rotate keychain password and re-encrypt all assosciated keys\n   *\n   * @param {string} oldPass - The old local keychain password\n   * @param {string} newPass - The new local keychain password\n   */\n  async rotateKeychainPass (oldPass, newPass) {\n    if (typeof oldPass !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid old pass type '${typeof oldPass}'`), 'ERR_INVALID_OLD_PASS_TYPE'))\n    }\n    if (typeof newPass !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid new pass type '${typeof newPass}'`), 'ERR_INVALID_NEW_PASS_TYPE'))\n    }\n    if (newPass.length < 20) {\n      return throwDelayed(errcode(new Error(`Invalid pass length ${newPass.length}`), 'ERR_INVALID_PASS_LENGTH'))\n    }\n    log('recreating keychain')\n    const oldDek = privates.get(this).dek\n    this.opts.pass = newPass\n    const newDek = newPass\n      ? crypto.pbkdf2(\n        newPass,\n        this.opts.dek.salt,\n        this.opts.dek.iterationCount,\n        this.opts.dek.keyLength,\n        this.opts.dek.hash)\n      : ''\n    privates.set(this, { dek: newDek })\n    const keys = await this.listKeys()\n    for (const key of keys) {\n      const res = await this.store.get(DsName(key.name))\n      const pem = uint8ArrayToString(res)\n      const privateKey = await crypto.keys.import(pem, oldDek)\n      const password = newDek.toString()\n      const keyAsPEM = await privateKey.export(password)\n\n      // Update stored key\n      const batch = this.store.batch()\n      const keyInfo = {\n        name: key.name,\n        id: key.id\n      }\n      batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM))\n      batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n      await batch.commit()\n    }\n    log('keychain reconstructed')\n  }\n}\n\nmodule.exports = Keychain\n"]},"metadata":{},"sourceType":"script"}