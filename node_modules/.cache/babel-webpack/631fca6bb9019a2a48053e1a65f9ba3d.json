{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Noise = void 0;\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst it_pb_rpc_1 = __importDefault(require(\"it-pb-rpc\"));\n\nconst duplex_1 = __importDefault(require(\"it-pair/duplex\"));\n\nconst it_buffer_1 = __importDefault(require(\"it-buffer\"));\n\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\n\nconst it_length_prefixed_1 = require(\"it-length-prefixed\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst handshake_ik_1 = require(\"./handshake-ik\");\n\nconst handshake_xx_fallback_1 = require(\"./handshake-xx-fallback\");\n\nconst utils_1 = require(\"./utils\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst crypto_1 = require(\"./crypto\");\n\nconst keycache_1 = require(\"./keycache\");\n\nconst logger_1 = require(\"./logger\");\n\nconst constants_1 = require(\"./constants\");\n\nclass Noise {\n  /**\n   *\n   * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n   * @param {bytes} earlyData\n   */\n  constructor(staticNoiseKey, earlyData) {\n    this.protocol = '/noise';\n    this.prologue = buffer_1.Buffer.alloc(0);\n    this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0); // disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),\n        publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)\n      };\n    } else {\n      this.staticKeys = utils_1.generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {any} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  secureOutbound(localPeer, connection, remotePeer) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const wrappedConnection = it_pb_rpc_1.default(connection, {\n        lengthEncoder: encoder_1.uint16BEEncode,\n        lengthDecoder: encoder_1.uint16BEDecode,\n        maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n      });\n      const handshake = yield _this.performHandshake({\n        connection: wrappedConnection,\n        isInitiator: true,\n        localPeer,\n        remotePeer\n      });\n      const conn = yield _this.createSecureConnection(wrappedConnection, handshake);\n      return {\n        conn,\n        remoteEarlyData: handshake.remoteEarlyData,\n        remotePeer: handshake.remotePeer\n      };\n    })();\n  }\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {any} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  secureInbound(localPeer, connection, remotePeer) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const wrappedConnection = it_pb_rpc_1.default(connection, {\n        lengthEncoder: encoder_1.uint16BEEncode,\n        lengthDecoder: encoder_1.uint16BEDecode,\n        maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n      });\n      const handshake = yield _this2.performHandshake({\n        connection: wrappedConnection,\n        isInitiator: false,\n        localPeer,\n        remotePeer\n      });\n      const conn = yield _this2.createSecureConnection(wrappedConnection, handshake);\n      return {\n        conn,\n        remoteEarlyData: handshake.remoteEarlyData,\n        remotePeer: handshake.remotePeer\n      };\n    })();\n  }\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   *\n   * @param {HandshakeParams} params\n   */\n\n\n  performHandshake(params) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const payload = yield utils_1.getPayload(params.localPeer, _this3.staticKeys.publicKey, _this3.earlyData);\n      let tryIK = _this3.useNoisePipes;\n\n      if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {\n        // if we are initiator and remote static key is unknown, don't try IK\n        tryIK = false;\n      } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n      if (tryIK) {\n        // Try IK first\n        const {\n          remotePeer,\n          connection,\n          isInitiator\n        } = params;\n        const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, _this3.prologue, _this3.staticKeys, connection, // safe to cast as we did checks\n        (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);\n\n        try {\n          return yield _this3.performIKHandshake(ikHandshake);\n        } catch (e) {\n          // IK failed, go to XX fallback\n          let ephemeralKeys;\n\n          if (params.isInitiator) {\n            ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n          }\n\n          return yield _this3.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n        }\n      } else {\n        // run XX handshake\n        return yield _this3.performXXHandshake(params, payload);\n      }\n    })();\n  }\n\n  performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        isInitiator,\n        remotePeer,\n        connection\n      } = params;\n      const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, _this4.prologue, _this4.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n      try {\n        yield handshake.propose();\n        yield handshake.exchange();\n        yield handshake.finish();\n      } catch (e) {\n        logger_1.logger(e);\n        const err = e;\n        throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);\n      }\n\n      return handshake;\n    })();\n  }\n\n  performXXHandshake(params, payload) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        isInitiator,\n        remotePeer,\n        connection\n      } = params;\n      const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, _this5.prologue, _this5.staticKeys, connection, remotePeer);\n\n      try {\n        yield handshake.propose();\n        yield handshake.exchange();\n        yield handshake.finish();\n\n        if (_this5.useNoisePipes && handshake.remotePeer) {\n          keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n        }\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred during XX handshake: ${err.message}`);\n      }\n\n      return handshake;\n    })();\n  }\n\n  performIKHandshake(handshake) {\n    return _asyncToGenerator(function* () {\n      yield handshake.stage0();\n      yield handshake.stage1();\n      return handshake;\n    })();\n  }\n\n  createSecureConnection(connection, handshake) {\n    return _asyncToGenerator(function* () {\n      // Create encryption box/unbox wrapper\n      const [secure, user] = duplex_1.default();\n      const network = connection.unwrap();\n      yield it_pipe_1.default(secure, // write to wrapper\n      it_buffer_1.default, // ensure any type of data is converted to buffer\n      crypto_1.encryptStream(handshake), // data is encrypted\n      it_length_prefixed_1.encode({\n        lengthEncoder: encoder_1.uint16BEEncode\n      }), // prefix with message length\n      network, // send to the remote peer\n      it_length_prefixed_1.decode({\n        lengthDecoder: encoder_1.uint16BEDecode\n      }), // read message length prefix\n      it_buffer_1.default, // ensure any type of data is converted to buffer\n      crypto_1.decryptStream(handshake), // decrypt the incoming data\n      secure // pipe to the wrapper\n      );\n      return user;\n    })();\n  }\n\n}\n\nexports.Noise = Noise;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@chainsafe/libp2p-noise/dist/src/noise.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__importDefault","exports","Noise","x25519","require","buffer_1","it_pb_rpc_1","duplex_1","it_buffer_1","it_pipe_1","it_length_prefixed_1","handshake_xx_1","handshake_ik_1","handshake_xx_fallback_1","utils_1","encoder_1","crypto_1","keycache_1","logger_1","constants_1","constructor","staticNoiseKey","earlyData","protocol","prologue","Buffer","alloc","useNoisePipes","keyPair","generateKeyPairFromSeed","staticKeys","privateKey","from","secretKey","buffer","byteOffset","length","publicKey","generateKeypair","secureOutbound","localPeer","connection","remotePeer","wrappedConnection","default","lengthEncoder","uint16BEEncode","lengthDecoder","uint16BEDecode","maxDataLength","NOISE_MSG_MAX_LENGTH_BYTES","handshake","performHandshake","isInitiator","conn","createSecureConnection","remoteEarlyData","secureInbound","params","_a","payload","getPayload","tryIK","KeyCache","load","ikHandshake","IKHandshake","performIKHandshake","e","ephemeralKeys","getLocalEphemeralKeys","performXXFallbackHandshake","initialMsg","performXXHandshake","XXFallbackHandshake","propose","exchange","finish","logger","err","Error","message","XXHandshake","store","getRemoteStaticKey","stage0","stage1","secure","user","network","unwrap","encryptStream","encode","decode","decryptStream"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Noise = void 0;\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\nconst buffer_1 = require(\"buffer\");\nconst it_pb_rpc_1 = __importDefault(require(\"it-pb-rpc\"));\nconst duplex_1 = __importDefault(require(\"it-pair/duplex\"));\nconst it_buffer_1 = __importDefault(require(\"it-buffer\"));\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\nconst it_length_prefixed_1 = require(\"it-length-prefixed\");\nconst handshake_xx_1 = require(\"./handshake-xx\");\nconst handshake_ik_1 = require(\"./handshake-ik\");\nconst handshake_xx_fallback_1 = require(\"./handshake-xx-fallback\");\nconst utils_1 = require(\"./utils\");\nconst encoder_1 = require(\"./encoder\");\nconst crypto_1 = require(\"./crypto\");\nconst keycache_1 = require(\"./keycache\");\nconst logger_1 = require(\"./logger\");\nconst constants_1 = require(\"./constants\");\nclass Noise {\n    /**\n     *\n     * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n     * @param {bytes} earlyData\n     */\n    constructor(staticNoiseKey, earlyData) {\n        this.protocol = '/noise';\n        this.prologue = buffer_1.Buffer.alloc(0);\n        this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n        // disabled until properly specked\n        this.useNoisePipes = false;\n        if (staticNoiseKey) {\n            // accepts x25519 private key of length 32\n            const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);\n            this.staticKeys = {\n                privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),\n                publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)\n            };\n        }\n        else {\n            this.staticKeys = utils_1.generateKeypair();\n        }\n    }\n    /**\n     * Encrypt outgoing data to the remote party (handshake as initiator)\n     *\n     * @param {PeerId} localPeer - PeerId of the receiving peer\n     * @param {any} connection - streaming iterable duplex that will be encrypted\n     * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n     * @returns {Promise<SecureOutbound>}\n     */\n    async secureOutbound(localPeer, connection, remotePeer) {\n        const wrappedConnection = it_pb_rpc_1.default(connection, {\n            lengthEncoder: encoder_1.uint16BEEncode,\n            lengthDecoder: encoder_1.uint16BEDecode,\n            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        const handshake = await this.performHandshake({\n            connection: wrappedConnection,\n            isInitiator: true,\n            localPeer,\n            remotePeer\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        return {\n            conn,\n            remoteEarlyData: handshake.remoteEarlyData,\n            remotePeer: handshake.remotePeer\n        };\n    }\n    /**\n     * Decrypt incoming data (handshake as responder).\n     *\n     * @param {PeerId} localPeer - PeerId of the receiving peer.\n     * @param {any} connection - streaming iterable duplex that will be encryption.\n     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n     * @returns {Promise<SecureOutbound>}\n     */\n    async secureInbound(localPeer, connection, remotePeer) {\n        const wrappedConnection = it_pb_rpc_1.default(connection, {\n            lengthEncoder: encoder_1.uint16BEEncode,\n            lengthDecoder: encoder_1.uint16BEDecode,\n            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        const handshake = await this.performHandshake({\n            connection: wrappedConnection,\n            isInitiator: false,\n            localPeer,\n            remotePeer\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        return {\n            conn,\n            remoteEarlyData: handshake.remoteEarlyData,\n            remotePeer: handshake.remotePeer\n        };\n    }\n    /**\n     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n     * If noise pipes disabled or remote peer static key is unknown, use XX.\n     *\n     * @param {HandshakeParams} params\n     */\n    async performHandshake(params) {\n        var _a;\n        const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n        let tryIK = this.useNoisePipes;\n        if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {\n            // if we are initiator and remote static key is unknown, don't try IK\n            tryIK = false;\n        }\n        // Try IK if acting as responder or initiator that has remote's static key.\n        if (tryIK) {\n            // Try IK first\n            const { remotePeer, connection, isInitiator } = params;\n            const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, \n            // safe to cast as we did checks\n            (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);\n            try {\n                return await this.performIKHandshake(ikHandshake);\n            }\n            catch (e) {\n                // IK failed, go to XX fallback\n                let ephemeralKeys;\n                if (params.isInitiator) {\n                    ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n                }\n                return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n            }\n        }\n        else {\n            // run XX handshake\n            return await this.performXXHandshake(params, payload);\n        }\n    }\n    async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n        const { isInitiator, remotePeer, connection } = params;\n        const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n        try {\n            await handshake.propose();\n            await handshake.exchange();\n            await handshake.finish();\n        }\n        catch (e) {\n            logger_1.logger(e);\n            const err = e;\n            throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);\n        }\n        return handshake;\n    }\n    async performXXHandshake(params, payload) {\n        const { isInitiator, remotePeer, connection } = params;\n        const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n        try {\n            await handshake.propose();\n            await handshake.exchange();\n            await handshake.finish();\n            if (this.useNoisePipes && handshake.remotePeer) {\n                keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n            }\n        }\n        catch (e) {\n            const err = e;\n            throw new Error(`Error occurred during XX handshake: ${err.message}`);\n        }\n        return handshake;\n    }\n    async performIKHandshake(handshake) {\n        await handshake.stage0();\n        await handshake.stage1();\n        return handshake;\n    }\n    async createSecureConnection(connection, handshake) {\n        // Create encryption box/unbox wrapper\n        const [secure, user] = duplex_1.default();\n        const network = connection.unwrap();\n        await it_pipe_1.default(secure, // write to wrapper\n        it_buffer_1.default, // ensure any type of data is converted to buffer\n        crypto_1.encryptStream(handshake), // data is encrypted\n        it_length_prefixed_1.encode({ lengthEncoder: encoder_1.uint16BEEncode }), // prefix with message length\n        network, // send to the remote peer\n        it_length_prefixed_1.decode({ lengthDecoder: encoder_1.uint16BEDecode }), // read message length prefix\n        it_buffer_1.default, // ensure any type of data is converted to buffer\n        crypto_1.decryptStream(handshake), // decrypt the incoming data\n        secure // pipe to the wrapper\n        );\n        return user;\n    }\n}\nexports.Noise = Noise;\n"]},"metadata":{},"sourceType":"script"}