{"ast":null,"code":"'use strict';\n\nconst {\n  AbortController\n} = require('native-abort-controller');\n/**\n * @typedef {import('ipfs-core-types/src/pubsub').MessageHandlerFn} MessageHandlerFn\n *\n * @typedef {Object} Subscription\n * @property {MessageHandlerFn} handler\n * @property {AbortController} controller\n */\n\n\nclass SubscriptionTracker {\n  constructor() {\n    /** @type {Map<string, Subscription[]>} */\n    this._subs = new Map();\n  }\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} handler\n   * @param {AbortSignal} [signal]\n   */\n\n\n  subscribe(topic, handler, signal) {\n    const topicSubs = this._subs.get(topic) || [];\n\n    if (topicSubs.find(s => s.handler === handler)) {\n      throw new Error(`Already subscribed to ${topic} with this handler`);\n    } // Create controller so a call to unsubscribe can cancel the request\n\n\n    const controller = new AbortController();\n\n    this._subs.set(topic, [{\n      handler,\n      controller\n    }].concat(topicSubs)); // If there is an external signal, forward the abort event\n\n\n    if (signal) {\n      signal.addEventListener('abort', () => this.unsubscribe(topic, handler));\n    }\n\n    return controller.signal;\n  }\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} [handler]\n   */\n\n\n  unsubscribe(topic, handler) {\n    const subs = this._subs.get(topic) || [];\n    let unsubs;\n\n    if (handler) {\n      this._subs.set(topic, subs.filter(s => s.handler !== handler));\n\n      unsubs = subs.filter(s => s.handler === handler);\n    } else {\n      this._subs.set(topic, []);\n\n      unsubs = subs;\n    }\n\n    if (!(this._subs.get(topic) || []).length) {\n      this._subs.delete(topic);\n    }\n\n    unsubs.forEach(s => s.controller.abort());\n  }\n\n}\n\nmodule.exports = SubscriptionTracker;","map":null,"metadata":{},"sourceType":"script"}