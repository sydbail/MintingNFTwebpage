{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst PeerDistanceList = require('../peer-list/peer-distance-list');\n\nconst EventEmitter = require('events');\n\nconst Path = require('./path');\n\nconst WorkerQueue = require('./worker-queue');\n\nconst utils = require('../utils');\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * Manages a single run of the query.\n */\n\n\nclass Run extends EventEmitter {\n  /**\n   * Creates a Run.\n   *\n   * @param {import('./index')} query\n   */\n  constructor(query) {\n    super();\n    this.query = query;\n    this.running = false;\n    /** @type {WorkerQueue[]} */\n\n    this.workers = []; // The peers that have been queried (including error responses)\n\n    this.peersSeen = new Set(); // The errors received when querying peers\n\n    /** @type {Error[]} */\n\n    this.errors = []; // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n\n    /** @type {PeerDistanceList | null} */\n\n    this.peersQueried = null;\n  }\n  /**\n   * Stop all the workers\n   */\n\n\n  stop() {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n\n    for (const worker of this.workers) {\n      worker.stop();\n    }\n  }\n  /**\n   * Execute the run with the given initial set of peers.\n   *\n   * @param {PeerId[]} peers\n   */\n\n\n  execute(peers) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      /** @type {import('./path')[]} */\n      const paths = []; // array of states per disjoint path\n      // Create disjoint paths\n\n      const numPaths = Math.min(_this.query.dht.disjointPaths, peers.length);\n\n      for (let i = 0; i < numPaths; i++) {\n        paths.push(new Path(_this, _this.query.makePath(i, numPaths)));\n      } // Assign peers to paths round-robin style\n\n\n      peers.forEach((peer, i) => {\n        paths[i % numPaths].addInitialPeer(peer);\n      }); // Execute the query along each disjoint path\n\n      yield _this.executePaths(paths);\n      const res = {\n        // The closest K peers we were able to query successfully\n        finalSet: new Set(_this.peersQueried && _this.peersQueried.peers),\n\n        /** @type {import('./index').QueryResult[]} */\n        paths: []\n      }; // Collect the results from each completed path\n\n      for (const path of paths) {\n        if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n          path.res.success = true;\n          res.paths.push(path.res);\n        }\n      }\n\n      return res;\n    })();\n  }\n  /**\n   * Execute all paths through the DHT.\n   *\n   * @param {Array<Path>} paths\n   * @returns {Promise<void>}\n   */\n\n\n  executePaths(paths) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.running = true;\n\n      _this2.emit('start');\n\n      try {\n        yield Promise.all(paths.map(path => path.execute()));\n      } finally {\n        // Ensure all workers are stopped\n        _this2.stop(); // Completed the Run\n\n\n        _this2.emit('complete');\n      } // If all queries errored out, something is seriously wrong, so callback\n      // with an error\n\n\n      if (_this2.errors.length === _this2.peersSeen.size) {\n        throw _this2.errors[0];\n      }\n    })();\n  }\n  /**\n   * Initialize the list of queried peers, then start a worker queue for the\n   * given path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n\n\n  workerQueue(path) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.init();\n      yield _this3.startWorker(path);\n    })();\n  }\n  /**\n   * Create and start a worker queue for a particular path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n\n\n  startWorker(path) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const worker = new WorkerQueue(_this4.query.dht, _this4, path, _this4.query._log);\n\n      _this4.workers.push(worker);\n\n      yield worker.execute();\n    })();\n  }\n  /**\n   * Initialize the list of closest peers we've queried - this is shared by all\n   * paths in the run.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  init() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this5.peersQueried) {\n        return;\n      } // We only want to initialize the PeerDistanceList once for the run\n\n\n      if (_this5.peersQueriedPromise) {\n        yield _this5.peersQueriedPromise;\n        return;\n      } // This promise is temporarily stored so that others may await its completion\n\n\n      _this5.peersQueriedPromise = _asyncToGenerator(function* () {\n        const dhtKey = yield utils.convertBuffer(_this5.query.key);\n        _this5.peersQueried = new PeerDistanceList(dhtKey, _this5.query.dht.kBucketSize);\n      })(); // After PeerDistanceList is initialized, clean up\n\n      yield _this5.peersQueriedPromise;\n      delete _this5.peersQueriedPromise;\n    })();\n  }\n  /**\n   * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n   * are all further from the key than the peers we've already queried, then we should\n   * stop querying on that `worker`.\n   *\n   * @param {WorkerQueue} worker\n   * @returns {Promise<boolean>}\n   */\n\n\n  continueQuerying(worker) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // If we haven't queried K peers yet, keep going\n      if (_this6.peersQueried && _this6.peersQueried.length < _this6.peersQueried.capacity) {\n        return true;\n      } // Get all the peers that are currently being queried.\n      // Note that this function gets called right after a peer has been popped\n      // off the head of the closest peers queue so it will include that peer.\n\n\n      const running = Array.from(worker.queuedPeerIds); // Check if any of the peers that are currently being queried are closer\n      // to the key than the peers we've already queried\n\n      const someCloser = _this6.peersQueried && (yield _this6.peersQueried.anyCloser(running)); // Some are closer, the worker should keep going\n\n      if (someCloser) {\n        return true;\n      } // None are closer, the worker can stop\n\n\n      return false;\n    })();\n  }\n\n}\n\nmodule.exports = Run;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p-kad-dht/src/query/run.js"],"names":["PeerDistanceList","require","EventEmitter","Path","WorkerQueue","utils","Run","constructor","query","running","workers","peersSeen","Set","errors","peersQueried","stop","worker","execute","peers","paths","numPaths","Math","min","dht","disjointPaths","length","i","push","makePath","forEach","peer","addInitialPeer","executePaths","res","finalSet","path","pathComplete","queryComplete","success","emit","Promise","all","map","size","workerQueue","init","startWorker","_log","peersQueriedPromise","dhtKey","convertBuffer","key","kBucketSize","continueQuerying","capacity","Array","from","queuedPeerIds","someCloser","anyCloser","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerDistanceList = require('../peer-list/peer-distance-list')\nconst EventEmitter = require('events')\n\nconst Path = require('./path')\nconst WorkerQueue = require('./worker-queue')\nconst utils = require('../utils')\n\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * Manages a single run of the query.\n */\nclass Run extends EventEmitter {\n  /**\n   * Creates a Run.\n   *\n   * @param {import('./index')} query\n   */\n  constructor (query) {\n    super()\n\n    this.query = query\n\n    this.running = false\n\n    /** @type {WorkerQueue[]} */\n    this.workers = []\n\n    // The peers that have been queried (including error responses)\n    this.peersSeen = new Set()\n\n    // The errors received when querying peers\n    /** @type {Error[]} */\n    this.errors = []\n\n    // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n    /** @type {PeerDistanceList | null} */\n    this.peersQueried = null\n  }\n\n  /**\n   * Stop all the workers\n   */\n  stop () {\n    if (!this.running) {\n      return\n    }\n\n    this.running = false\n    for (const worker of this.workers) {\n      worker.stop()\n    }\n  }\n\n  /**\n   * Execute the run with the given initial set of peers.\n   *\n   * @param {PeerId[]} peers\n   */\n  async execute (peers) {\n    /** @type {import('./path')[]} */\n    const paths = [] // array of states per disjoint path\n\n    // Create disjoint paths\n    const numPaths = Math.min(this.query.dht.disjointPaths, peers.length)\n    for (let i = 0; i < numPaths; i++) {\n      paths.push(new Path(this, this.query.makePath(i, numPaths)))\n    }\n\n    // Assign peers to paths round-robin style\n    peers.forEach((peer, i) => {\n      paths[i % numPaths].addInitialPeer(peer)\n    })\n\n    // Execute the query along each disjoint path\n    await this.executePaths(paths)\n\n    const res = {\n      // The closest K peers we were able to query successfully\n      finalSet: new Set(this.peersQueried && this.peersQueried.peers),\n\n      /** @type {import('./index').QueryResult[]} */\n      paths: []\n    }\n\n    // Collect the results from each completed path\n    for (const path of paths) {\n      if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n        path.res.success = true\n        res.paths.push(path.res)\n      }\n    }\n\n    return res\n  }\n\n  /**\n   * Execute all paths through the DHT.\n   *\n   * @param {Array<Path>} paths\n   * @returns {Promise<void>}\n   */\n  async executePaths (paths) {\n    this.running = true\n\n    this.emit('start')\n    try {\n      await Promise.all(paths.map(path => path.execute()))\n    } finally {\n      // Ensure all workers are stopped\n      this.stop()\n      // Completed the Run\n      this.emit('complete')\n    }\n\n    // If all queries errored out, something is seriously wrong, so callback\n    // with an error\n    if (this.errors.length === this.peersSeen.size) {\n      throw this.errors[0]\n    }\n  }\n\n  /**\n   * Initialize the list of queried peers, then start a worker queue for the\n   * given path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n  async workerQueue (path) {\n    await this.init()\n    await this.startWorker(path)\n  }\n\n  /**\n   * Create and start a worker queue for a particular path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n  async startWorker (path) {\n    const worker = new WorkerQueue(this.query.dht, this, path, this.query._log)\n    this.workers.push(worker)\n    await worker.execute()\n  }\n\n  /**\n   * Initialize the list of closest peers we've queried - this is shared by all\n   * paths in the run.\n   *\n   * @returns {Promise<void>}\n   */\n  async init () {\n    if (this.peersQueried) {\n      return\n    }\n\n    // We only want to initialize the PeerDistanceList once for the run\n    if (this.peersQueriedPromise) {\n      await this.peersQueriedPromise\n      return\n    }\n\n    // This promise is temporarily stored so that others may await its completion\n    this.peersQueriedPromise = (async () => {\n      const dhtKey = await utils.convertBuffer(this.query.key)\n      this.peersQueried = new PeerDistanceList(dhtKey, this.query.dht.kBucketSize)\n    })()\n\n    // After PeerDistanceList is initialized, clean up\n    await this.peersQueriedPromise\n    delete this.peersQueriedPromise\n  }\n\n  /**\n   * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n   * are all further from the key than the peers we've already queried, then we should\n   * stop querying on that `worker`.\n   *\n   * @param {WorkerQueue} worker\n   * @returns {Promise<boolean>}\n   */\n  async continueQuerying (worker) {\n    // If we haven't queried K peers yet, keep going\n    if (this.peersQueried && this.peersQueried.length < this.peersQueried.capacity) {\n      return true\n    }\n\n    // Get all the peers that are currently being queried.\n    // Note that this function gets called right after a peer has been popped\n    // off the head of the closest peers queue so it will include that peer.\n    const running = Array.from(worker.queuedPeerIds)\n\n    // Check if any of the peers that are currently being queried are closer\n    // to the key than the peers we've already queried\n    const someCloser = this.peersQueried && await this.peersQueried.anyCloser(running)\n\n    // Some are closer, the worker should keep going\n    if (someCloser) {\n      return true\n    }\n\n    // None are closer, the worker can stop\n    return false\n  }\n}\n\nmodule.exports = Run\n"]},"metadata":{},"sourceType":"script"}