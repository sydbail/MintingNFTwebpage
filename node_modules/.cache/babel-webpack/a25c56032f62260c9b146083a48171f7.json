{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:circuit:hop'), {\n  error: debug('libp2p:circuit:hop:err')\n});\n\nconst errCode = require('err-code');\n\nconst PeerId = require('peer-id');\n\nconst {\n  validateAddrs\n} = require('./utils');\n\nconst StreamHandler = require('./stream-handler');\n\nconst {\n  CircuitRelay: CircuitPB\n} = require('../protocol');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  codes: Errors\n} = require('../../errors');\n\nconst {\n  stop\n} = require('./stop');\n\nconst multicodec = require('./../multicodec');\n/**\n * @typedef {import('../protocol').ICircuitRelay} ICircuitRelay\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('../transport')} Transport\n */\n\n/**\n * @typedef {Object} HopRequest\n * @property {Connection} connection\n * @property {ICircuitRelay} request\n * @property {StreamHandler} streamHandler\n * @property {Transport} circuit\n */\n\n/**\n * @param {HopRequest} options\n * @returns {Promise<void>}\n */\n\n\nfunction handleHop(_x) {\n  return _handleHop.apply(this, arguments);\n}\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n *\n * @param {object} options\n * @param {Connection} options.connection - Connection to the relay\n * @param {ICircuitRelay} options.request\n * @returns {Promise<MuxedStream>}\n */\n\n\nfunction _handleHop() {\n  _handleHop = _asyncToGenerator(function* ({\n    connection,\n    request,\n    streamHandler,\n    circuit\n  }) {\n    // Ensure hop is enabled\n    if (!circuit._options.hop.enabled) {\n      log('HOP request received but we are not acting as a relay');\n      return streamHandler.end({\n        type: CircuitPB.Type.STATUS,\n        code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n      });\n    } // Validate the HOP request has the required input\n\n\n    try {\n      validateAddrs(request, streamHandler);\n    } catch (err) {\n      return log.error('invalid hop request via peer %s', connection.remotePeer.toB58String(), err);\n    }\n\n    if (!request.dstPeer) {\n      log('HOP request received but we do not receive a dstPeer');\n      return;\n    } // Get the connection to the destination (stop) peer\n\n\n    const destinationPeer = new PeerId(request.dstPeer.id);\n\n    const destinationConnection = circuit._connectionManager.get(destinationPeer);\n\n    if (!destinationConnection && !circuit._options.hop.active) {\n      log('HOP request received but we are not connected to the destination peer');\n      return streamHandler.end({\n        type: CircuitPB.Type.STATUS,\n        code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n      });\n    } // TODO: Handle being an active relay\n\n\n    if (!destinationConnection) {\n      return;\n    } // Handle the incoming HOP request by performing a STOP request\n\n\n    const stopRequest = {\n      type: CircuitPB.Type.STOP,\n      dstPeer: request.dstPeer,\n      srcPeer: request.srcPeer\n    };\n    let destinationStream;\n\n    try {\n      destinationStream = yield stop({\n        connection: destinationConnection,\n        request: stopRequest\n      });\n    } catch (err) {\n      return log.error(err);\n    }\n\n    log('hop request from %s is valid', connection.remotePeer.toB58String());\n    streamHandler.write({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.SUCCESS\n    });\n    const sourceStream = streamHandler.rest(); // Short circuit the two streams to create the relayed connection\n\n    return pipe(sourceStream, destinationStream, sourceStream);\n  });\n  return _handleHop.apply(this, arguments);\n}\n\nfunction hop(_x2) {\n  return _hop.apply(this, arguments);\n}\n/**\n * Performs a CAN_HOP request to a relay peer, in order to understand its capabilities.\n *\n * @param {object} options\n * @param {Connection} options.connection - Connection to the relay\n * @returns {Promise<boolean>}\n */\n\n\nfunction _hop() {\n  _hop = _asyncToGenerator(function* ({\n    connection,\n    request\n  }) {\n    // Create a new stream to the relay\n    const {\n      stream\n    } = yield connection.newStream([multicodec.relay]); // Send the HOP request\n\n    const streamHandler = new StreamHandler({\n      stream\n    });\n    streamHandler.write(request);\n    const response = yield streamHandler.read();\n\n    if (!response) {\n      throw errCode(new Error('HOP request had no response'), Errors.ERR_HOP_REQUEST_FAILED);\n    }\n\n    if (response.code === CircuitPB.Status.SUCCESS) {\n      log('hop request was successful');\n      return streamHandler.rest();\n    }\n\n    log('hop request failed with code %d, closing stream', response.code);\n    streamHandler.close();\n    throw errCode(new Error(`HOP request failed with code ${response.code}`), Errors.ERR_HOP_REQUEST_FAILED);\n  });\n  return _hop.apply(this, arguments);\n}\n\nfunction canHop(_x3) {\n  return _canHop.apply(this, arguments);\n}\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n *\n * @param {Object} options\n * @param {Connection} options.connection\n * @param {StreamHandler} options.streamHandler\n * @param {Transport} options.circuit\n * @private\n */\n\n\nfunction _canHop() {\n  _canHop = _asyncToGenerator(function* ({\n    connection\n  }) {\n    // Create a new stream to the relay\n    const {\n      stream\n    } = yield connection.newStream([multicodec.relay]); // Send the HOP request\n\n    const streamHandler = new StreamHandler({\n      stream\n    });\n    streamHandler.write({\n      type: CircuitPB.Type.CAN_HOP\n    });\n    const response = yield streamHandler.read();\n    yield streamHandler.close();\n\n    if (!response || response.code !== CircuitPB.Status.SUCCESS) {\n      return false;\n    }\n\n    return true;\n  });\n  return _canHop.apply(this, arguments);\n}\n\nfunction handleCanHop({\n  connection,\n  streamHandler,\n  circuit\n}) {\n  const canHop = circuit._options.hop.enabled;\n  log('can hop (%s) request from %s', canHop, connection.remotePeer.toB58String());\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  });\n}\n\nmodule.exports = {\n  handleHop,\n  hop,\n  canHop,\n  handleCanHop\n};","map":null,"metadata":{},"sourceType":"script"}