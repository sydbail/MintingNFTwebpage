{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst {\n  isTest\n} = require('ipfs-utils/src/env');\n\nconst log = require('debug')('ipfs');\n\nconst errCode = require('err-code');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst dagCbor = require('@ipld/dag-cbor');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n\nconst {\n  bases,\n  hashes,\n  codecs\n} = require('multiformats/basics');\n\nconst initAssets = require('../runtime/init-assets-nodejs');\n\nconst {\n  AlreadyInitializedError\n} = require('../errors');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst createStartAPI = require('./start');\n\nconst createStopAPI = require('./stop');\n\nconst createDNSAPI = require('./dns');\n\nconst createIsOnlineAPI = require('./is-online');\n\nconst createResolveAPI = require('./resolve');\n\nconst PinAPI = require('./pin');\n\nconst IPNSAPI = require('./ipns');\n\nconst NameAPI = require('./name');\n\nconst createRefsAPI = require('./refs');\n\nconst createRefsLocalAPI = require('./refs/local');\n\nconst BitswapAPI = require('./bitswap');\n\nconst BootstrapAPI = require('./bootstrap');\n\nconst BlockAPI = require('./block');\n\nconst RootAPI = require('./root');\n\nconst createVersionAPI = require('./version');\n\nconst createIDAPI = require('./id');\n\nconst createConfigAPI = require('./config');\n\nconst DagAPI = require('./dag');\n\nconst createPreloadAPI = require('../preload');\n\nconst createMfsPreloadAPI = require('../mfs-preload');\n\nconst createFilesAPI = require('./files');\n\nconst KeyAPI = require('./key');\n\nconst ObjectAPI = require('./object');\n\nconst RepoAPI = require('./repo');\n\nconst StatsAPI = require('./stats');\n\nconst Storage = require('./storage');\n\nconst Network = require('./network');\n\nconst Service = require('../utils/service');\n\nconst SwarmAPI = require('./swarm');\n\nconst createPingAPI = require('./ping');\n\nconst createDHTAPI = require('./dht');\n\nconst createPubSubAPI = require('./pubsub');\n\nconst Multicodecs = require('ipfs-core-utils/src/multicodecs');\n\nconst Multihashes = require('ipfs-core-utils/src/multihashes');\n\nconst Multibases = require('ipfs-core-utils/src/multibases');\n/**\n * @typedef {import('../types').Options} Options\n * @typedef {import('../types').Print} Print\n * @typedef {import('./storage')} StorageAPI\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec\n */\n\n\nclass IPFS {\n  /**\n   * @param {Object} config\n   * @param {Print} config.print\n   * @param {StorageAPI} config.storage\n   * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n   * @param {Options} config.options\n   */\n  constructor({\n    print,\n    storage,\n    codecs,\n    options\n  }) {\n    const {\n      peerId,\n      repo,\n      keychain\n    } = storage;\n    const network = Service.create(Network);\n    const preload = createPreloadAPI(options.preload);\n    const dns = createDNSAPI();\n    const isOnline = createIsOnlineAPI({\n      network\n    }); // @ts-ignore This type check fails as options.\n    // libp2p can be a function, while IPNS router config expects libp2p config\n\n    const ipns = new IPNSAPI(options);\n    /** @type {MultihashHasher[]} */\n\n    const multihashHashers = Object.values(hashes);\n    (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach(hasher => multihashHashers.push(hasher));\n    this.hashers = new Multihashes({\n      hashers: multihashHashers,\n      loadHasher: options.ipld && options.ipld.loadHasher\n    });\n    /** @type {MultibaseCodec[]} */\n\n    const multibaseCodecs = Object.values(bases);\n    (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach(base => multibaseCodecs.push(base));\n    this.bases = new Multibases({\n      bases: multibaseCodecs,\n      loadBase: options.ipld && options.ipld.loadBase\n    });\n    const pin = new PinAPI({\n      repo,\n      codecs\n    });\n    const block = new BlockAPI({\n      codecs,\n      hashers: this.hashers,\n      preload,\n      repo\n    });\n    const name = new NameAPI({\n      dns,\n      ipns,\n      repo,\n      codecs,\n      peerId,\n      isOnline,\n      keychain,\n      options\n    });\n    const resolve = createResolveAPI({\n      repo,\n      codecs,\n      bases: this.bases,\n      name\n    });\n    const dag = new DagAPI({\n      repo,\n      codecs,\n      hashers: this.hashers,\n      preload\n    });\n    const refs = Object.assign(createRefsAPI({\n      repo,\n      codecs,\n      resolve,\n      preload\n    }), {\n      local: createRefsLocalAPI({\n        repo: storage.repo\n      })\n    });\n    const {\n      add,\n      addAll,\n      cat,\n      get,\n      ls\n    } = new RootAPI({\n      preload,\n      repo,\n      options: options.EXPERIMENTAL\n    });\n    const files = createFilesAPI({\n      repo,\n      preload,\n      hashers: this.hashers,\n      options\n    });\n    const mfsPreload = createMfsPreloadAPI({\n      files,\n      preload,\n      options: options.preload\n    });\n    this.preload = preload;\n    this.name = name;\n    this.ipns = ipns;\n    this.pin = pin;\n    this.resolve = resolve;\n    this.block = block;\n    this.refs = refs;\n    this.start = createStartAPI({\n      network,\n      peerId,\n      repo,\n      preload,\n      ipns,\n      mfsPreload,\n      print,\n      keychain,\n      options\n    });\n    this.stop = createStopAPI({\n      network,\n      preload,\n      mfsPreload,\n      ipns,\n      repo\n    });\n    this.dht = createDHTAPI({\n      network,\n      repo\n    });\n    this.pubsub = createPubSubAPI({\n      network,\n      config: options.config\n    });\n    this.dns = dns;\n    this.isOnline = isOnline;\n    this.id = createIDAPI({\n      network,\n      peerId\n    });\n    this.version = createVersionAPI({\n      repo\n    });\n    this.bitswap = new BitswapAPI({\n      network\n    });\n    this.bootstrap = new BootstrapAPI({\n      repo\n    });\n    this.config = createConfigAPI({\n      repo\n    });\n    this.ping = createPingAPI({\n      network\n    });\n    this.add = add;\n    this.addAll = addAll;\n    this.cat = cat;\n    this.get = get;\n    this.ls = ls;\n    this.dag = dag;\n    this.files = files;\n    this.key = new KeyAPI({\n      keychain\n    });\n    this.object = new ObjectAPI({\n      preload,\n      codecs,\n      repo\n    });\n    this.repo = new RepoAPI({\n      repo,\n      hashers: this.hashers\n    });\n    this.stats = new StatsAPI({\n      repo,\n      network\n    });\n    this.swarm = new SwarmAPI({\n      network\n    }); // For the backwards compatibility\n\n    Object.defineProperty(this, 'libp2p', {\n      get() {\n        const net = network.try();\n        return net ? net.libp2p : undefined;\n      }\n\n    }); // unimplemented methods\n\n    const notImplemented = () => Promise.reject(errCode(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED'));\n\n    const notImplementedIter = /*#__PURE__*/function () {\n      var _ref = _wrapAsyncGenerator(function* () {\n        throw errCode(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED');\n      });\n\n      return function notImplementedIter() {\n        return _ref.apply(this, arguments);\n      };\n    }(); // eslint-disable-line require-yield\n\n\n    this.commands = notImplemented;\n    this.diag = {\n      cmds: notImplemented,\n      net: notImplemented,\n      sys: notImplemented\n    };\n    this.log = {\n      level: notImplemented,\n      ls: notImplemented,\n      tail: notImplementedIter\n    };\n    this.mount = notImplemented;\n    this.codecs = codecs;\n  }\n  /**\n   * `IPFS.create` will do the initialization. Keep this around for backwards\n   * compatibility.\n   *\n   * @deprecated\n   */\n\n\n  init() {\n    return _asyncToGenerator(function* () {\n      // eslint-disable-line require-await\n      throw new AlreadyInitializedError();\n    })();\n  }\n  /**\n   * @param {Options} options\n   */\n\n\n  static create(options = {}) {\n    return _asyncToGenerator(function* () {\n      options = mergeOptions(getDefaultOptions(), options);\n      const initOptions = options.init || {};\n      /**\n       * @type {BlockCodec}\n       */\n\n      const id = {\n        name: identity.name,\n        code: identity.code,\n        encode: id => id,\n        decode: id => id\n      };\n      /** @type {BlockCodec[]} */\n\n      const blockCodecs = Object.values(codecs);\n      [dagPb, dagCbor, id].concat(options.ipld && options.ipld.codecs || []).forEach(codec => blockCodecs.push(codec));\n      const multicodecs = new Multicodecs({\n        codecs: blockCodecs,\n        loadCodec: options.ipld && options.ipld.loadCodec\n      }); // eslint-disable-next-line no-console\n\n      const print = options.silent ? log : console.log;\n      const storage = yield Storage.start(print, multicodecs, options);\n      const config = yield storage.repo.config.getAll();\n      const ipfs = new IPFS({\n        storage,\n        print,\n        codecs: multicodecs,\n        options: { ...options,\n          config\n        }\n      });\n      yield ipfs.preload.start();\n      ipfs.ipns.startOffline(storage);\n\n      if (storage.isNew && !initOptions.emptyRepo) {\n        // add empty unixfs dir object (go-ipfs assumes this exists)\n        const cid = yield addEmptyDir(ipfs);\n        log('adding default assets');\n        yield initAssets({\n          addAll: ipfs.addAll,\n          print\n        });\n        log('initializing IPNS keyspace');\n        yield ipfs.ipns.initializeKeyspace(storage.peerId.privKey, uint8ArrayFromString(`/ipfs/${cid}`));\n      }\n\n      if (options.start !== false) {\n        yield ipfs.start();\n      }\n\n      return ipfs;\n    })();\n  }\n\n}\n\nmodule.exports = IPFS;\n/**\n * @param {IPFS} ipfs\n */\n\nconst addEmptyDir = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (ipfs) {\n    const buf = dagPb.encode({\n      Data: new UnixFS({\n        type: 'directory'\n      }).marshal(),\n      Links: []\n    });\n    const cid = yield ipfs.block.put(buf, {\n      mhtype: 'sha2-256',\n      format: 'dag-pb'\n    });\n    yield ipfs.pin.add(cid);\n    return cid;\n  });\n\n  return function addEmptyDir(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @returns {Options}\n */\n\n\nconst getDefaultOptions = () => ({\n  start: true,\n  EXPERIMENTAL: {},\n  preload: {\n    enabled: !isTest,\n    // preload by default, unless in test env\n    addresses: ['/dns4/node0.preload.ipfs.io/https', '/dns4/node1.preload.ipfs.io/https', '/dns4/node2.preload.ipfs.io/https', '/dns4/node3.preload.ipfs.io/https']\n  }\n});","map":null,"metadata":{},"sourceType":"script"}