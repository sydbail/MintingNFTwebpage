{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst errcode = require('err-code');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst exporter = require('./exporter');\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')(randomBytes);\n\n  class Secp256k1PublicKey {\n    constructor(key) {\n      crypto.validatePublicKey(key);\n      this._key = key;\n    }\n\n    verify(data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data);\n    }\n\n    marshal() {\n      return crypto.compressPublicKey(this._key);\n    }\n\n    get bytes() {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      }).finish();\n    }\n\n    equals(key) {\n      return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n\n    hash() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          bytes\n        } = yield sha256.digest(_this.bytes);\n        return bytes;\n      })();\n    }\n\n  }\n\n  class Secp256k1PrivateKey {\n    constructor(key, publicKey) {\n      this._key = key;\n      this._publicKey = publicKey || crypto.computePublicKey(key);\n      crypto.validatePrivateKey(this._key);\n      crypto.validatePublicKey(this._publicKey);\n    }\n\n    sign(message) {\n      return crypto.hashAndSign(this._key, message);\n    }\n\n    get public() {\n      return new Secp256k1PublicKey(this._publicKey);\n    }\n\n    marshal() {\n      return this._key;\n    }\n\n    get bytes() {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      }).finish();\n    }\n\n    equals(key) {\n      return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n\n    hash() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          bytes\n        } = yield sha256.digest(_this2.bytes);\n        return bytes;\n      })();\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n\n\n    id() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        const hash = yield _this3.public.hash();\n        return uint8ArrayToString(hash, 'base58btc');\n      })();\n    }\n    /**\n     * Exports the key into a password protected `format`\n     *\n     * @param {string} password - The password to encrypt the key\n     * @param {string} [format=libp2p-key] - The format in which to export as\n     * @returns {Promise<string>} The encrypted private key\n     */\n\n\n    export(password, format = 'libp2p-key') {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        // eslint-disable-line require-await\n        if (format === 'libp2p-key') {\n          return exporter.export(_this4.bytes, password);\n        } else {\n          throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n        }\n      })();\n    }\n\n  }\n\n  function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n  }\n\n  function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  function generateKeyPair() {\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  function _generateKeyPair() {\n    _generateKeyPair = _asyncToGenerator(function* () {\n      const privateKeyBytes = yield crypto.generateKey();\n      return new Secp256k1PrivateKey(privateKeyBytes);\n    });\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  };\n};","map":null,"metadata":{},"sourceType":"script"}