{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst cbor = require('cborg');\n\nconst pinset = require('./pin-set');\n\nconst {\n  cidToKey,\n  PIN_DS_KEY,\n  PinTypes\n} = require('./utils');\n\nconst length = require('it-length');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst mhd = require('multiformats/hashes/digest');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('../../src/types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\n\n\nfunction pinsToDatastore(_x, _x2, _x3, _x4) {\n  return _pinsToDatastore.apply(this, arguments);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\n\n\nfunction _pinsToDatastore() {\n  _pinsToDatastore = _asyncToGenerator(function* (blockstore, datastore, pinstore, onProgress) {\n    if (!(yield datastore.has(PIN_DS_KEY))) {\n      return;\n    }\n\n    const mh = yield datastore.get(PIN_DS_KEY);\n    const cid = CID.decode(mh);\n    const pinRootBuf = yield blockstore.get(cid);\n    const pinRoot = dagPb.decode(pinRootBuf);\n    let counter = 0;\n    const pinCount = (yield length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (yield length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)));\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const cid = _value;\n        counter++;\n        /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n\n        const pin = {\n          depth: Infinity\n        };\n\n        if (cid.version !== 0) {\n          pin.version = cid.version;\n        }\n\n        if (cid.code !== dagPb.code) {\n          pin.codec = cid.code;\n        }\n\n        yield pinstore.put(cidToKey(cid), cbor.encode(pin));\n        onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid}`);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n\n    var _iteratorError2;\n\n    try {\n      for (var _iterator2 = _asyncIterator(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)), _step2, _value2; _step2 = yield _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n        const cid = _value2;\n        counter++;\n        /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n\n        const pin = {\n          depth: 0\n        };\n\n        if (cid.version !== 0) {\n          pin.version = cid.version;\n        }\n\n        if (cid.code !== dagPb.code) {\n          pin.codec = cid.code;\n        }\n\n        yield pinstore.put(cidToKey(cid), cbor.encode(pin));\n        onProgress(counter / pinCount * 100, `Migrated direct pin ${cid}`);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          yield _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    yield blockstore.delete(cid);\n    yield datastore.delete(PIN_DS_KEY);\n  });\n  return _pinsToDatastore.apply(this, arguments);\n}\n\nfunction pinsToDAG(_x5, _x6, _x7, _x8) {\n  return _pinsToDAG.apply(this, arguments);\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\n\n\nfunction _pinsToDAG() {\n  _pinsToDAG = _asyncToGenerator(function* (blockstore, datastore, pinstore, onProgress) {\n    const recursivePins = [];\n    const directPins = [];\n    let counter = 0;\n    const pinCount = yield length(pinstore.queryKeys({}));\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n\n    var _iteratorError3;\n\n    try {\n      for (var _iterator3 = _asyncIterator(pinstore.query({})), _step3, _value3; _step3 = yield _iterator3.next(), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _step3.value, !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n        const {\n          key,\n          value\n        } = _value3;\n        counter++;\n        const pin = cbor.decode(value);\n        const cid = CID.create(pin.version || 0, pin.codec || dagPb.code, mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop())));\n\n        if (pin.depth === 0) {\n          onProgress(counter / pinCount * 100, `Reverted direct pin ${cid}`);\n          directPins.push(cid);\n        } else {\n          onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid}`);\n          recursivePins.push(cid);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          yield _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    onProgress(100, 'Updating pin root');\n    const pinRoot = {\n      Links: [yield pinset.storeSet(blockstore, PinTypes.direct, directPins), yield pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)]\n    };\n    const buf = dagPb.encode(pinRoot);\n    const digest = yield sha256.digest(buf);\n    const cid = CID.createV0(digest);\n    yield blockstore.put(cid, buf);\n    yield datastore.put(PIN_DS_KEY, cid.bytes);\n  });\n  return _pinsToDAG.apply(this, arguments);\n}\n\nfunction process(_x9, _x10, _x11) {\n  return _process.apply(this, arguments);\n}\n/** @type {Migration} */\n\n\nfunction _process() {\n  _process = _asyncToGenerator(function* (backends, onProgress, fn) {\n    const blockstore = backends.blocks;\n    const datastore = backends.datastore;\n    const pinstore = backends.pins;\n    yield blockstore.open();\n    yield datastore.open();\n    yield pinstore.open();\n\n    try {\n      yield fn(blockstore, datastore, pinstore, onProgress);\n    } finally {\n      yield pinstore.close();\n      yield datastore.close();\n      yield blockstore.close();\n    }\n  });\n  return _process.apply(this, arguments);\n}\n\nmodule.exports = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDatastore);\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDAG);\n  }\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-repo-migrations/migrations/migration-9/index.js"],"names":["CID","require","dagPb","cbor","pinset","cidToKey","PIN_DS_KEY","PinTypes","length","sha256","mhd","base32","pinsToDatastore","blockstore","datastore","pinstore","onProgress","has","mh","get","cid","decode","pinRootBuf","pinRoot","counter","pinCount","loadSet","recursive","direct","pin","depth","Infinity","version","code","codec","put","encode","delete","pinsToDAG","recursivePins","directPins","queryKeys","query","key","value","create","toString","toLowerCase","split","pop","push","Links","storeSet","buf","digest","createV0","bytes","process","backends","fn","blocks","pins","open","close","module","exports","description","migrate","revert"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst dagPb = require('@ipld/dag-pb')\nconst cbor = require('cborg')\nconst pinset = require('./pin-set')\nconst { cidToKey, PIN_DS_KEY, PinTypes } = require('./utils')\nconst length = require('it-length')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst mhd = require('multiformats/hashes/digest')\nconst { base32 } = require('multiformats/bases/base32')\n\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('../../src/types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDatastore (blockstore, datastore, pinstore, onProgress) {\n  if (!await datastore.has(PIN_DS_KEY)) {\n    return\n  }\n\n  const mh = await datastore.get(PIN_DS_KEY)\n  const cid = CID.decode(mh)\n  const pinRootBuf = await blockstore.get(cid)\n  const pinRoot = dagPb.decode(pinRootBuf)\n  let counter = 0\n  const pinCount = (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)))\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) {\n    counter++\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin))\n\n    onProgress((counter / pinCount) * 100, `Migrated recursive pin ${cid}`)\n  }\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.direct)) {\n    counter++\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin))\n\n    onProgress((counter / pinCount) * 100, `Migrated direct pin ${cid}`)\n  }\n\n  await blockstore.delete(cid)\n  await datastore.delete(PIN_DS_KEY)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDAG (blockstore, datastore, pinstore, onProgress) {\n  const recursivePins = []\n  const directPins = []\n  let counter = 0\n  const pinCount = await length(pinstore.queryKeys({}))\n\n  for await (const { key, value } of pinstore.query({})) {\n    counter++\n    const pin = cbor.decode(value)\n    const cid = CID.create(\n      pin.version || 0,\n      pin.codec || dagPb.code,\n      mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop()))\n    )\n\n    if (pin.depth === 0) {\n      onProgress((counter / pinCount) * 100, `Reverted direct pin ${cid}`)\n\n      directPins.push(cid)\n    } else {\n      onProgress((counter / pinCount) * 100, `Reverted recursive pin ${cid}`)\n\n      recursivePins.push(cid)\n    }\n  }\n\n  onProgress(100, 'Updating pin root')\n  const pinRoot = {\n    Links: [\n      await pinset.storeSet(blockstore, PinTypes.direct, directPins),\n      await pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)\n    ]\n  }\n  const buf = dagPb.encode(pinRoot)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n  await datastore.put(PIN_DS_KEY, cid.bytes)\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\nasync function process (backends, onProgress, fn) {\n  const blockstore = backends.blocks\n  const datastore = backends.datastore\n  const pinstore = backends.pins\n\n  await blockstore.open()\n  await datastore.open()\n  await pinstore.open()\n\n  try {\n    await fn(blockstore, datastore, pinstore, onProgress)\n  } finally {\n    await pinstore.close()\n    await datastore.close()\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nmodule.exports = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDatastore)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDAG)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}