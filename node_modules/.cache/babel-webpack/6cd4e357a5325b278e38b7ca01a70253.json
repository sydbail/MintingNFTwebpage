{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst getIterator = require('get-iterator');\n\nmodule.exports = writable => /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (source) {\n    source = getIterator(source);\n\n    const maybeEndSource = source => {\n      if (typeof source.return === 'function') source.return();\n    };\n\n    let error = null;\n    let errCb = null;\n\n    const errorHandler = err => {\n      error = err;\n      if (errCb) errCb(err); // When the writable errors, try to end the source to exit iteration early\n\n      maybeEndSource(source);\n    };\n\n    let closeCb = null;\n    let closed = false;\n\n    const closeHandler = () => {\n      closed = true;\n      if (closeCb) closeCb();\n    };\n\n    let finishCb = null;\n    let finished = false;\n\n    const finishHandler = () => {\n      finished = true;\n      if (finishCb) finishCb();\n    };\n\n    let drainCb = null;\n\n    const drainHandler = () => {\n      if (drainCb) drainCb();\n    };\n\n    const waitForDrainOrClose = () => {\n      return new Promise((resolve, reject) => {\n        closeCb = drainCb = resolve;\n        errCb = reject;\n        writable.once('drain', drainHandler);\n      });\n    };\n\n    const waitForDone = () => {\n      // Immediately try to end the source\n      maybeEndSource(source);\n      return new Promise((resolve, reject) => {\n        if (closed || finished || error) return resolve();\n        finishCb = closeCb = resolve;\n        errCb = reject;\n      });\n    };\n\n    const cleanup = () => {\n      writable.removeListener('error', errorHandler);\n      writable.removeListener('close', closeHandler);\n      writable.removeListener('finish', finishHandler);\n      writable.removeListener('drain', drainHandler);\n    };\n\n    writable.once('error', errorHandler);\n    writable.once('close', closeHandler);\n    writable.once('finish', finishHandler);\n\n    try {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const value = _value;\n          if (!writable.writable || writable.destroyed || error) break;\n\n          if (writable.write(value) === false) {\n            yield waitForDrainOrClose();\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } catch (err) {\n      // error is set by stream error handler so only destroy stream if source threw\n      if (!error) {\n        writable.destroy();\n      } // could we be obscuring an error here?\n\n\n      error = err;\n    }\n\n    try {\n      // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n      if (writable.writable) {\n        writable.end();\n      } // Wait until we close or finish. This supports halfClosed streams\n\n\n      yield waitForDone(); // Notify the user an error occurred\n\n      if (error) throw error;\n    } finally {\n      // Clean up listeners\n      cleanup();\n    }\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/stream-to-it/sink.js"],"names":["getIterator","require","module","exports","writable","source","maybeEndSource","return","error","errCb","errorHandler","err","closeCb","closed","closeHandler","finishCb","finished","finishHandler","drainCb","drainHandler","waitForDrainOrClose","Promise","resolve","reject","once","waitForDone","cleanup","removeListener","value","destroyed","write","destroy","end"],"mappings":";;;;AAAA,MAAMA,WAAW,GAAGC,OAAO,CAAC,cAAD,CAA3B;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,QAAQ;AAAA,+BAAI,WAAMC,MAAN,EAAgB;AAC3CA,IAAAA,MAAM,GAAGL,WAAW,CAACK,MAAD,CAApB;;AAEA,UAAMC,cAAc,GAAID,MAAD,IAAY;AACjC,UAAI,OAAOA,MAAM,CAACE,MAAd,KAAyB,UAA7B,EAAyCF,MAAM,CAACE,MAAP;AAC1C,KAFD;;AAIA,QAAIC,KAAK,GAAG,IAAZ;AACA,QAAIC,KAAK,GAAG,IAAZ;;AACA,UAAMC,YAAY,GAAIC,GAAD,IAAS;AAC5BH,MAAAA,KAAK,GAAGG,GAAR;AACA,UAAIF,KAAJ,EAAWA,KAAK,CAACE,GAAD,CAAL,CAFiB,CAG5B;;AACAL,MAAAA,cAAc,CAACD,MAAD,CAAd;AACD,KALD;;AAOA,QAAIO,OAAO,GAAG,IAAd;AACA,QAAIC,MAAM,GAAG,KAAb;;AACA,UAAMC,YAAY,GAAG,MAAM;AACzBD,MAAAA,MAAM,GAAG,IAAT;AACA,UAAID,OAAJ,EAAaA,OAAO;AACrB,KAHD;;AAKA,QAAIG,QAAQ,GAAG,IAAf;AACA,QAAIC,QAAQ,GAAG,KAAf;;AACA,UAAMC,aAAa,GAAG,MAAM;AAC1BD,MAAAA,QAAQ,GAAG,IAAX;AACA,UAAID,QAAJ,EAAcA,QAAQ;AACvB,KAHD;;AAKA,QAAIG,OAAO,GAAG,IAAd;;AACA,UAAMC,YAAY,GAAG,MAAM;AACzB,UAAID,OAAJ,EAAaA,OAAO;AACrB,KAFD;;AAIA,UAAME,mBAAmB,GAAG,MAAM;AAChC,aAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCX,QAAAA,OAAO,GAAGM,OAAO,GAAGI,OAApB;AACAb,QAAAA,KAAK,GAAGc,MAAR;AACAnB,QAAAA,QAAQ,CAACoB,IAAT,CAAc,OAAd,EAAuBL,YAAvB;AACD,OAJM,CAAP;AAKD,KAND;;AAQA,UAAMM,WAAW,GAAG,MAAM;AACxB;AACAnB,MAAAA,cAAc,CAACD,MAAD,CAAd;AACA,aAAO,IAAIgB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,YAAIV,MAAM,IAAIG,QAAV,IAAsBR,KAA1B,EAAiC,OAAOc,OAAO,EAAd;AACjCP,QAAAA,QAAQ,GAAGH,OAAO,GAAGU,OAArB;AACAb,QAAAA,KAAK,GAAGc,MAAR;AACD,OAJM,CAAP;AAKD,KARD;;AAUA,UAAMG,OAAO,GAAG,MAAM;AACpBtB,MAAAA,QAAQ,CAACuB,cAAT,CAAwB,OAAxB,EAAiCjB,YAAjC;AACAN,MAAAA,QAAQ,CAACuB,cAAT,CAAwB,OAAxB,EAAiCb,YAAjC;AACAV,MAAAA,QAAQ,CAACuB,cAAT,CAAwB,QAAxB,EAAkCV,aAAlC;AACAb,MAAAA,QAAQ,CAACuB,cAAT,CAAwB,OAAxB,EAAiCR,YAAjC;AACD,KALD;;AAOAf,IAAAA,QAAQ,CAACoB,IAAT,CAAc,OAAd,EAAuBd,YAAvB;AACAN,IAAAA,QAAQ,CAACoB,IAAT,CAAc,OAAd,EAAuBV,YAAvB;AACAV,IAAAA,QAAQ,CAACoB,IAAT,CAAc,QAAd,EAAwBP,aAAxB;;AAEA,QAAI;AAAA;AAAA;;AAAA;;AAAA;AACF,4CAA0BZ,MAA1B,oLAAkC;AAAA,gBAAjBuB,KAAiB;AAChC,cAAI,CAACxB,QAAQ,CAACA,QAAV,IAAsBA,QAAQ,CAACyB,SAA/B,IAA4CrB,KAAhD,EAAuD;;AAEvD,cAAIJ,QAAQ,CAAC0B,KAAT,CAAeF,KAAf,MAA0B,KAA9B,EAAqC;AACnC,kBAAMR,mBAAmB,EAAzB;AACD;AACF;AAPC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQH,KARD,CAQE,OAAOT,GAAP,EAAY;AACZ;AACA,UAAI,CAACH,KAAL,EAAY;AACVJ,QAAAA,QAAQ,CAAC2B,OAAT;AACD,OAJW,CAMZ;;;AACAvB,MAAAA,KAAK,GAAGG,GAAR;AACD;;AAED,QAAI;AACF;AACA,UAAIP,QAAQ,CAACA,QAAb,EAAuB;AACrBA,QAAAA,QAAQ,CAAC4B,GAAT;AACD,OAJC,CAMF;;;AACA,YAAMP,WAAW,EAAjB,CAPE,CASF;;AACA,UAAIjB,KAAJ,EAAW,MAAMA,KAAN;AACZ,KAXD,SAWU;AACR;AACAkB,MAAAA,OAAO;AACR;AACF,GAjGwB;;AAAA;AAAA;AAAA;AAAA,GAAzB","sourcesContent":["const getIterator = require('get-iterator')\n\nmodule.exports = writable => async source => {\n  source = getIterator(source)\n\n  const maybeEndSource = (source) => {\n    if (typeof source.return === 'function') source.return()\n  }\n\n  let error = null\n  let errCb = null\n  const errorHandler = (err) => {\n    error = err\n    if (errCb) errCb(err)\n    // When the writable errors, try to end the source to exit iteration early\n    maybeEndSource(source)\n  }\n\n  let closeCb = null\n  let closed = false\n  const closeHandler = () => {\n    closed = true\n    if (closeCb) closeCb()\n  }\n\n  let finishCb = null\n  let finished = false\n  const finishHandler = () => {\n    finished = true\n    if (finishCb) finishCb()\n  }\n\n  let drainCb = null\n  const drainHandler = () => {\n    if (drainCb) drainCb()\n  }\n\n  const waitForDrainOrClose = () => {\n    return new Promise((resolve, reject) => {\n      closeCb = drainCb = resolve\n      errCb = reject\n      writable.once('drain', drainHandler)\n    })\n  }\n\n  const waitForDone = () => {\n    // Immediately try to end the source\n    maybeEndSource(source)\n    return new Promise((resolve, reject) => {\n      if (closed || finished || error) return resolve()\n      finishCb = closeCb = resolve\n      errCb = reject\n    })\n  }\n\n  const cleanup = () => {\n    writable.removeListener('error', errorHandler)\n    writable.removeListener('close', closeHandler)\n    writable.removeListener('finish', finishHandler)\n    writable.removeListener('drain', drainHandler)\n  }\n\n  writable.once('error', errorHandler)\n  writable.once('close', closeHandler)\n  writable.once('finish', finishHandler)\n\n  try {\n    for await (const value of source) {\n      if (!writable.writable || writable.destroyed || error) break\n\n      if (writable.write(value) === false) {\n        await waitForDrainOrClose()\n      }\n    }\n  } catch (err) {\n    // error is set by stream error handler so only destroy stream if source threw\n    if (!error) {\n      writable.destroy()\n    }\n\n    // could we be obscuring an error here?\n    error = err\n  }\n\n  try {\n    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n    if (writable.writable) {\n      writable.end()\n    }\n\n    // Wait until we close or finish. This supports halfClosed streams\n    await waitForDone()\n\n    // Notify the user an error occurred\n    if (error) throw error\n  } finally {\n    // Clean up listeners\n    cleanup()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}