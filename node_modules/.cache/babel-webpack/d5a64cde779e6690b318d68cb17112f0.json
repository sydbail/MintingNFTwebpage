{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-peer-record\"] || ($protobuf.roots[\"libp2p-peer-record\"] = {});\n\n$root.PeerRecord = function () {\n  /**\n   * Properties of a PeerRecord.\n   * @exports IPeerRecord\n   * @interface IPeerRecord\n   * @property {Uint8Array|null} [peerId] PeerRecord peerId\n   * @property {number|null} [seq] PeerRecord seq\n   * @property {Array.<PeerRecord.IAddressInfo>|null} [addresses] PeerRecord addresses\n   */\n\n  /**\n   * Constructs a new PeerRecord.\n   * @exports PeerRecord\n   * @classdesc Represents a PeerRecord.\n   * @implements IPeerRecord\n   * @constructor\n   * @param {IPeerRecord=} [p] Properties to set\n   */\n  function PeerRecord(p) {\n    this.addresses = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * PeerRecord peerId.\n   * @member {Uint8Array} peerId\n   * @memberof PeerRecord\n   * @instance\n   */\n\n\n  PeerRecord.prototype.peerId = $util.newBuffer([]);\n  /**\n   * PeerRecord seq.\n   * @member {number} seq\n   * @memberof PeerRecord\n   * @instance\n   */\n\n  PeerRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * PeerRecord addresses.\n   * @member {Array.<PeerRecord.IAddressInfo>} addresses\n   * @memberof PeerRecord\n   * @instance\n   */\n\n  PeerRecord.prototype.addresses = $util.emptyArray;\n  /**\n   * Encodes the specified PeerRecord message. Does not implicitly {@link PeerRecord.verify|verify} messages.\n   * @function encode\n   * @memberof PeerRecord\n   * @static\n   * @param {IPeerRecord} m PeerRecord message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  PeerRecord.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.peerId != null && Object.hasOwnProperty.call(m, \"peerId\")) w.uint32(10).bytes(m.peerId);\n    if (m.seq != null && Object.hasOwnProperty.call(m, \"seq\")) w.uint32(16).uint64(m.seq);\n\n    if (m.addresses != null && m.addresses.length) {\n      for (var i = 0; i < m.addresses.length; ++i) $root.PeerRecord.AddressInfo.encode(m.addresses[i], w.uint32(26).fork()).ldelim();\n    }\n\n    return w;\n  };\n  /**\n   * Decodes a PeerRecord message from the specified reader or buffer.\n   * @function decode\n   * @memberof PeerRecord\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {PeerRecord} PeerRecord\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  PeerRecord.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.PeerRecord();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.peerId = r.bytes();\n          break;\n\n        case 2:\n          m.seq = r.uint64();\n          break;\n\n        case 3:\n          if (!(m.addresses && m.addresses.length)) m.addresses = [];\n          m.addresses.push($root.PeerRecord.AddressInfo.decode(r, r.uint32()));\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a PeerRecord message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PeerRecord\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {PeerRecord} PeerRecord\n   */\n\n\n  PeerRecord.fromObject = function fromObject(d) {\n    if (d instanceof $root.PeerRecord) return d;\n    var m = new $root.PeerRecord();\n\n    if (d.peerId != null) {\n      if (typeof d.peerId === \"string\") $util.base64.decode(d.peerId, m.peerId = $util.newBuffer($util.base64.length(d.peerId)), 0);else if (d.peerId.length) m.peerId = d.peerId;\n    }\n\n    if (d.seq != null) {\n      if ($util.Long) (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;else if (typeof d.seq === \"string\") m.seq = parseInt(d.seq, 10);else if (typeof d.seq === \"number\") m.seq = d.seq;else if (typeof d.seq === \"object\") m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);\n    }\n\n    if (d.addresses) {\n      if (!Array.isArray(d.addresses)) throw TypeError(\".PeerRecord.addresses: array expected\");\n      m.addresses = [];\n\n      for (var i = 0; i < d.addresses.length; ++i) {\n        if (typeof d.addresses[i] !== \"object\") throw TypeError(\".PeerRecord.addresses: object expected\");\n        m.addresses[i] = $root.PeerRecord.AddressInfo.fromObject(d.addresses[i]);\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a PeerRecord message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PeerRecord\n   * @static\n   * @param {PeerRecord} m PeerRecord\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  PeerRecord.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.arrays || o.defaults) {\n      d.addresses = [];\n    }\n\n    if (o.defaults) {\n      if (o.bytes === String) d.peerId = \"\";else {\n        d.peerId = [];\n        if (o.bytes !== Array) d.peerId = $util.newBuffer(d.peerId);\n      }\n\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else d.seq = o.longs === String ? \"0\" : 0;\n    }\n\n    if (m.peerId != null && m.hasOwnProperty(\"peerId\")) {\n      d.peerId = o.bytes === String ? $util.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;\n    }\n\n    if (m.seq != null && m.hasOwnProperty(\"seq\")) {\n      if (typeof m.seq === \"number\") d.seq = o.longs === String ? String(m.seq) : m.seq;else d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;\n    }\n\n    if (m.addresses && m.addresses.length) {\n      d.addresses = [];\n\n      for (var j = 0; j < m.addresses.length; ++j) {\n        d.addresses[j] = $root.PeerRecord.AddressInfo.toObject(m.addresses[j], o);\n      }\n    }\n\n    return d;\n  };\n  /**\n   * Converts this PeerRecord to JSON.\n   * @function toJSON\n   * @memberof PeerRecord\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  PeerRecord.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  PeerRecord.AddressInfo = function () {\n    /**\n     * Properties of an AddressInfo.\n     * @memberof PeerRecord\n     * @interface IAddressInfo\n     * @property {Uint8Array|null} [multiaddr] AddressInfo multiaddr\n     */\n\n    /**\n     * Constructs a new AddressInfo.\n     * @memberof PeerRecord\n     * @classdesc Represents an AddressInfo.\n     * @implements IAddressInfo\n     * @constructor\n     * @param {PeerRecord.IAddressInfo=} [p] Properties to set\n     */\n    function AddressInfo(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * AddressInfo multiaddr.\n     * @member {Uint8Array} multiaddr\n     * @memberof PeerRecord.AddressInfo\n     * @instance\n     */\n\n\n    AddressInfo.prototype.multiaddr = $util.newBuffer([]);\n    /**\n     * Encodes the specified AddressInfo message. Does not implicitly {@link PeerRecord.AddressInfo.verify|verify} messages.\n     * @function encode\n     * @memberof PeerRecord.AddressInfo\n     * @static\n     * @param {PeerRecord.IAddressInfo} m AddressInfo message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    AddressInfo.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.multiaddr != null && Object.hasOwnProperty.call(m, \"multiaddr\")) w.uint32(10).bytes(m.multiaddr);\n      return w;\n    };\n    /**\n     * Decodes an AddressInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof PeerRecord.AddressInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {PeerRecord.AddressInfo} AddressInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    AddressInfo.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.PeerRecord.AddressInfo();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.multiaddr = r.bytes();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates an AddressInfo message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PeerRecord.AddressInfo\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {PeerRecord.AddressInfo} AddressInfo\n     */\n\n\n    AddressInfo.fromObject = function fromObject(d) {\n      if (d instanceof $root.PeerRecord.AddressInfo) return d;\n      var m = new $root.PeerRecord.AddressInfo();\n\n      if (d.multiaddr != null) {\n        if (typeof d.multiaddr === \"string\") $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);else if (d.multiaddr.length) m.multiaddr = d.multiaddr;\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from an AddressInfo message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PeerRecord.AddressInfo\n     * @static\n     * @param {PeerRecord.AddressInfo} m AddressInfo\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    AddressInfo.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.defaults) {\n        if (o.bytes === String) d.multiaddr = \"\";else {\n          d.multiaddr = [];\n          if (o.bytes !== Array) d.multiaddr = $util.newBuffer(d.multiaddr);\n        }\n      }\n\n      if (m.multiaddr != null && m.hasOwnProperty(\"multiaddr\")) {\n        d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;\n      }\n\n      return d;\n    };\n    /**\n     * Converts this AddressInfo to JSON.\n     * @function toJSON\n     * @memberof PeerRecord.AddressInfo\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    AddressInfo.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return AddressInfo;\n  }();\n\n  return PeerRecord;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}