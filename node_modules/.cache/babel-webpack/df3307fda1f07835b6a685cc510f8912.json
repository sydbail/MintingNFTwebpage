{"ast":null,"code":"import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\n\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n\n}\n\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseDecode = baseDecode;\n  }\n\n  decode(text) {\n    if (typeof text === 'string') {\n      switch (text[0]) {\n        case this.prefix:\n          {\n            return this.baseDecode(text.slice(1));\n          }\n\n        default:\n          {\n            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n          }\n      }\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n\n  or(decoder) {\n    const decoders = {\n      [this.prefix]: this,\n      ...(decoder.decoders || {\n        [decoder.prefix]: decoder\n      })\n    };\n    return new ComposedDecoder(decoders);\n  }\n\n}\n\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n\n  or(decoder) {\n    const other = decoder.decoders || {\n      [decoder.prefix]: decoder\n    };\n    return new ComposedDecoder({ ...this.decoders,\n      ...other\n    });\n  }\n\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n    }\n  }\n\n}\n\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n\n}\nexport const from = ({\n  name,\n  prefix,\n  encode,\n  decode\n}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({\n  prefix,\n  name,\n  alphabet\n}) => {\n  const {\n    encode,\n    decode\n  } = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\n\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n\n  let end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end;\n  }\n\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`);\n    }\n\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n};\n\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n};\n\nexport const rfc4648 = ({\n  name,\n  prefix,\n  bitsPerChar,\n  alphabet\n}) => {\n  return from({\n    prefix,\n    name,\n\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n\n  });\n};","map":null,"metadata":{},"sourceType":"module"}