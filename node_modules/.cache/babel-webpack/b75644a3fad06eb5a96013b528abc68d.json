{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst MovingAverage = require('@vascosantos/moving-average');\n/**\n * @typedef {import('@vascosantos/moving-average').IMovingAverage} IMovingAverage\n * @typedef {[string, number, number]} Op\n */\n\n\nclass Stats extends EventEmitter {\n  /**\n   *\n   * @param {string[]} initialCounters\n   * @param {Object} options\n   * @param {boolean} options.enabled\n   * @param {number} options.computeThrottleTimeout\n   * @param {number} options.computeThrottleMaxQueueSize\n   * @param {import('.').AverageIntervals} options.movingAverageIntervals\n   */\n  constructor(initialCounters, options) {\n    super();\n    this._options = options;\n    /** @type {Op[]} */\n\n    this._queue = [];\n    /** @type {Record<string, bigint>} */\n\n    this._stats = {};\n    this._frequencyLastTime = Date.now();\n    /** @type {Record<string, number>} */\n\n    this._frequencyAccumulators = {};\n    /** @type {Record<string, Record<number, IMovingAverage>>} */\n\n    this._movingAverages = {};\n    this._update = this._update.bind(this);\n    initialCounters.forEach(key => {\n      this._stats[key] = BigInt(0);\n      this._movingAverages[key] = {};\n\n      this._options.movingAverageIntervals.forEach(interval => {\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval);\n        ma.push(this._frequencyLastTime, 0);\n      });\n    });\n    this._enabled = this._options.enabled;\n  }\n\n  enable() {\n    this._enabled = true;\n  }\n\n  disable() {\n    this._disabled = true;\n  }\n\n  stop() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n  }\n\n  get snapshot() {\n    return Object.assign({}, this._stats);\n  }\n\n  get movingAverages() {\n    return Object.assign({}, this._movingAverages);\n  }\n  /**\n   * @param {string} counter\n   * @param {number} inc\n   */\n\n\n  push(counter, inc) {\n    if (this._enabled) {\n      this._queue.push([counter, inc, Date.now()]);\n\n      this._resetComputeTimeout();\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _resetComputeTimeout() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    this._timeout = setTimeout(this._update, this._nextTimeout());\n  }\n  /**\n   * @private\n   * @returns {number}\n   */\n\n\n  _nextTimeout() {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n  }\n  /**\n   * @private\n   */\n\n\n  _update() {\n    this._timeout = null;\n\n    if (this._queue.length) {\n      let last;\n\n      while (this._queue.length) {\n        const op = last = this._queue.shift();\n\n        op && this._applyOp(op);\n      }\n\n      last && this._updateFrequency(last[2]); // contains timestamp of last op\n\n      this.emit('update', this._stats);\n    }\n  }\n  /**\n   * @private\n   * @param {number} latestTime\n   */\n\n\n  _updateFrequency(latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime;\n\n    if (timeDiff) {\n      Object.keys(this._stats).forEach(key => {\n        this._updateFrequencyFor(key, timeDiff, latestTime);\n      });\n    }\n\n    this._frequencyLastTime = latestTime;\n  }\n  /**\n   * @private\n   * @param {string} key\n   * @param {number} timeDiffMS\n   * @param {number} latestTime\n   * @returns {void}\n   */\n\n\n  _updateFrequencyFor(key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0;\n    this._frequencyAccumulators[key] = 0;\n    const hz = count / timeDiffMS * 1000;\n    let movingAverages = this._movingAverages[key];\n\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {};\n    }\n\n    this._options.movingAverageIntervals.forEach(movingAverageInterval => {\n      let movingAverage = movingAverages[movingAverageInterval];\n\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);\n      }\n\n      movingAverage.push(latestTime, hz);\n    });\n  }\n  /**\n   * @private\n   * @param {Op} op\n   */\n\n\n  _applyOp(op) {\n    const key = op[0];\n    const inc = op[1];\n\n    if (typeof inc !== 'number') {\n      throw new Error(`invalid increment number: ${inc}`);\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      this._stats[key] = BigInt(0);\n    }\n\n    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0;\n    }\n\n    this._frequencyAccumulators[key] += inc;\n  }\n\n}\n\nmodule.exports = Stats;","map":null,"metadata":{},"sourceType":"script"}