{"ast":null,"code":"\"use strict\";\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptStream = exports.encryptStream = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst constants_1 = require(\"./constants\"); // Returns generator that encrypts payload from the user\n\n\nfunction encryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const chunk = _value;\n          const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n          for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n            let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n            if (end > chunkBuffer.length) {\n              end = chunkBuffer.length;\n            }\n\n            const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n            yield data;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nexports.encryptStream = encryptStream; // Decrypt received payload to the user\n\nfunction decryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const chunk = _value2;\n          const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n          for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {\n            let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n\n            if (end > chunkBuffer.length) {\n              end = chunkBuffer.length;\n            }\n\n            const chunk = chunkBuffer.slice(i, end);\n            const {\n              plaintext: decrypted,\n              valid\n            } = yield _awaitAsyncGenerator(handshake.decrypt(chunk, handshake.session));\n\n            if (!valid) {\n              throw new Error('Failed to validate decrypted chunk');\n            }\n\n            yield decrypted;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\n\nexports.decryptStream = decryptStream;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js"],"names":["Object","defineProperty","exports","value","decryptStream","encryptStream","buffer_1","require","constants_1","handshake","source","chunk","chunkBuffer","Buffer","from","buffer","byteOffset","length","i","NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG","end","data","encrypt","slice","session","NOISE_MSG_MAX_LENGTH_BYTES","plaintext","decrypted","valid","decrypt","Error"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptStream = exports.encryptStream = void 0;\nconst buffer_1 = require(\"buffer\");\nconst constants_1 = require(\"./constants\");\n// Returns generator that encrypts payload from the user\nfunction encryptStream(handshake) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n                if (end > chunkBuffer.length) {\n                    end = chunkBuffer.length;\n                }\n                const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n                yield data;\n            }\n        }\n    };\n}\nexports.encryptStream = encryptStream;\n// Decrypt received payload to the user\nfunction decryptStream(handshake) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {\n                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n                if (end > chunkBuffer.length) {\n                    end = chunkBuffer.length;\n                }\n                const chunk = chunkBuffer.slice(i, end);\n                const { plaintext: decrypted, valid } = await handshake.decrypt(chunk, handshake.session);\n                if (!valid) {\n                    throw new Error('Failed to validate decrypted chunk');\n                }\n                yield decrypted;\n            }\n        }\n    };\n}\nexports.decryptStream = decryptStream;\n"]},"metadata":{},"sourceType":"script"}