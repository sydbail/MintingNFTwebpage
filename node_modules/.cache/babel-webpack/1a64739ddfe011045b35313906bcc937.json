{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXFallbackHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n\n    this.initialMsg = initialMsg;\n  } // stage 0\n  // eslint-disable-next-line require-await\n\n\n  propose() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.isInitiator) {\n        _this.xx.sendMessage(_this.session, buffer_1.Buffer.alloc(0), _this.ephemeralKeys);\n\n        logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n        logger_1.logLocalEphemeralKeys(_this.session.hs.e);\n      } else {\n        logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n        const receivedMessageBuffer = encoder_1.decode0(_this.initialMsg);\n\n        const {\n          valid\n        } = _this.xx.recvMessage(_this.session, {\n          ne: receivedMessageBuffer.ne,\n          ns: buffer_1.Buffer.alloc(0),\n          ciphertext: buffer_1.Buffer.alloc(0)\n        });\n\n        if (!valid) {\n          throw new Error('xx fallback stage 0 decryption validation fail');\n        }\n\n        logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');\n        logger_1.logRemoteEphemeralKey(_this.session.hs.re);\n      }\n    })();\n  } // stage 1\n\n\n  exchange() {\n    var _superprop_getExchange = () => super.exchange,\n        _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isInitiator) {\n        const receivedMessageBuffer = encoder_1.decode1(_this2.initialMsg);\n\n        const {\n          plaintext,\n          valid\n        } = _this2.xx.recvMessage(_this2.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('xx fallback stage 1 decryption validation fail');\n        }\n\n        logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n        logger_1.logRemoteEphemeralKey(_this2.session.hs.re);\n        logger_1.logRemoteStaticKey(_this2.session.hs.rs);\n        logger_1.logger(\"Initiator going to check remote's signature...\");\n\n        try {\n          const decodedPayload = yield utils_1.decodePayload(plaintext);\n          _this2.remotePeer = _this2.remotePeer || (yield utils_1.getPeerIdFromPayload(decodedPayload));\n          yield utils_1.verifySignedPayload(_this2.session.hs.rs, decodedPayload, _this2.remotePeer);\n\n          _this2.setRemoteEarlyData(decodedPayload.data);\n        } catch (e) {\n          const err = e;\n          throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);\n        }\n\n        logger_1.logger('All good with the signature!');\n      } else {\n        logger_1.logger('XX Fallback Stage 1 - Responder start');\n        yield _superprop_getExchange().call(_this2);\n        logger_1.logger('XX Fallback Stage 1 - Responder end');\n      }\n    })();\n  }\n\n}\n\nexports.XXFallbackHandshake = XXFallbackHandshake;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx-fallback.js"],"names":["Object","defineProperty","exports","value","XXFallbackHandshake","buffer_1","require","handshake_xx_1","utils_1","logger_1","encoder_1","XXHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","initialMsg","remotePeer","ephemeralKeys","handshake","propose","xx","sendMessage","session","Buffer","alloc","logger","logLocalEphemeralKeys","hs","e","receivedMessageBuffer","decode0","valid","recvMessage","ne","ns","ciphertext","Error","logRemoteEphemeralKey","re","exchange","decode1","plaintext","logRemoteStaticKey","rs","decodedPayload","decodePayload","getPeerIdFromPayload","verifySignedPayload","setRemoteEarlyData","data","err","message"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XXFallbackHandshake = void 0;\nconst buffer_1 = require(\"buffer\");\nconst handshake_xx_1 = require(\"./handshake-xx\");\nconst utils_1 = require(\"./utils\");\nconst logger_1 = require(\"./logger\");\nconst encoder_1 = require(\"./encoder\");\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n        super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n        if (ephemeralKeys) {\n            this.ephemeralKeys = ephemeralKeys;\n        }\n        this.initialMsg = initialMsg;\n    }\n    // stage 0\n    // eslint-disable-next-line require-await\n    async propose() {\n        if (this.isInitiator) {\n            this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);\n            logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n            const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);\n            const { valid } = this.xx.recvMessage(this.session, {\n                ne: receivedMessageBuffer.ne,\n                ns: buffer_1.Buffer.alloc(0),\n                ciphertext: buffer_1.Buffer.alloc(0)\n            });\n            if (!valid) {\n                throw new Error('xx fallback stage 0 decryption validation fail');\n            }\n            logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n        }\n    }\n    // stage 1\n    async exchange() {\n        if (this.isInitiator) {\n            const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx fallback stage 1 decryption validation fail');\n            }\n            logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            logger_1.logRemoteStaticKey(this.session.hs.rs);\n            logger_1.logger(\"Initiator going to check remote's signature...\");\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                const err = e;\n                throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);\n            }\n            logger_1.logger('All good with the signature!');\n        }\n        else {\n            logger_1.logger('XX Fallback Stage 1 - Responder start');\n            await super.exchange();\n            logger_1.logger('XX Fallback Stage 1 - Responder end');\n        }\n    }\n}\nexports.XXFallbackHandshake = XXFallbackHandshake;\n"]},"metadata":{},"sourceType":"script"}