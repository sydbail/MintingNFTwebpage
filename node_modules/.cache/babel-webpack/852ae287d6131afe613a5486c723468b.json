{"ast":null,"code":"'use strict';\n\nconst AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN;\n\nconst inherits = require('inherits');\n\nconst DeferredIterator = require('./deferred-iterator');\n\nconst deferrables = 'put get del batch clear'.split(' ');\nconst optionalDeferrables = 'approximateSize compactRange'.split(' ');\n\nfunction DeferredLevelDOWN(db) {\n  AbstractLevelDOWN.call(this, db.supports || {}); // TODO (future major): remove this fallback; db must have manifest that\n  // declares approximateSize and compactRange in additionalMethods.\n\n  for (const m of optionalDeferrables) {\n    if (typeof db[m] === 'function' && !this.supports.additionalMethods[m]) {\n      this.supports.additionalMethods[m] = true;\n    }\n  }\n\n  this._db = db;\n  this._operations = [];\n  closed(this);\n}\n\ninherits(DeferredLevelDOWN, AbstractLevelDOWN);\nDeferredLevelDOWN.prototype.type = 'deferred-leveldown';\n\nDeferredLevelDOWN.prototype._open = function (options, callback) {\n  this._db.open(options, err => {\n    if (err) return callback(err);\n\n    for (const op of this._operations) {\n      if (op.iterator) {\n        op.iterator.setDb(this._db);\n      } else {\n        this._db[op.method](...op.args);\n      }\n    }\n\n    this._operations = [];\n    open(this);\n    callback();\n  });\n};\n\nDeferredLevelDOWN.prototype._close = function (callback) {\n  this._db.close(err => {\n    if (err) return callback(err);\n    closed(this);\n    callback();\n  });\n};\n\nfunction open(self) {\n  for (const m of deferrables.concat('iterator')) {\n    self['_' + m] = function (...args) {\n      return this._db[m](...args);\n    };\n  }\n\n  for (const m of Object.keys(self.supports.additionalMethods)) {\n    self[m] = function (...args) {\n      return this._db[m](...args);\n    };\n  }\n}\n\nfunction closed(self) {\n  for (const m of deferrables) {\n    self['_' + m] = function (...args) {\n      this._operations.push({\n        method: m,\n        args\n      });\n    };\n  }\n\n  for (const m of Object.keys(self.supports.additionalMethods)) {\n    self[m] = function (...args) {\n      this._operations.push({\n        method: m,\n        args\n      });\n    };\n  }\n\n  self._iterator = function (options) {\n    const it = new DeferredIterator(self, options);\n\n    this._operations.push({\n      iterator: it\n    });\n\n    return it;\n  };\n}\n\nDeferredLevelDOWN.prototype._serializeKey = function (key) {\n  return key;\n};\n\nDeferredLevelDOWN.prototype._serializeValue = function (value) {\n  return value;\n};\n\nmodule.exports = DeferredLevelDOWN;\nmodule.exports.DeferredIterator = DeferredIterator;","map":null,"metadata":{},"sourceType":"script"}