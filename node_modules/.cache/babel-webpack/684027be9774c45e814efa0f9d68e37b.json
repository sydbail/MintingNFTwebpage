{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst NanoDate = require('timestamp-nano');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n\nconst errCode = require('err-code');\n\nconst {\n  base32upper\n} = require('multiformats/bases/base32');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst cborg = require('cborg');\n\nconst Long = require('long');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('jsipns'), {\n  error: debug('jsipns:error')\n});\n\nconst {\n  IpnsEntry: ipnsEntryProto\n} = require('./pb/ipns.js');\n\nconst {\n  parseRFC3339\n} = require('./utils');\n\nconst ERRORS = require('./errors');\n\nconst ID_MULTIHASH_CODE = identity.code;\nconst namespace = '/ipns/';\nconst IPNS_PREFIX = uint8ArrayFromString('/ipns/');\n/**\n * @typedef {import('./types').IPNSEntry} IPNSEntry\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\n\nconst create = (privateKey, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const expirationDate = new NanoDate(Date.now() + Number(lifetime));\n  const validityType = ipnsEntryProto.ValidityType.EOL;\n  const [ms, ns] = lifetime.toString().split('.');\n  const lifetimeNs = BigInt(ms) * 100000n + BigInt(ns || 0);\n  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\n\n\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const expirationDate = NanoDate.fromString(expiration);\n  const validityType = ipnsEntryProto.ValidityType.EOL;\n  const ttlMs = expirationDate.toDate().getTime() - Date.now();\n  const ttlNs = BigInt(ttlMs) * 100000n + BigInt(expirationDate.getNano());\n  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs);\n};\n/**\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number | bigint} seq\n * @param {number} validityType\n * @param {NanoDate} expirationDate\n * @param {bigint} ttl\n */\n\n\nconst _create = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (privateKey, value, seq, validityType, expirationDate, ttl) {\n    seq = BigInt(seq);\n    const isoValidity = uint8ArrayFromString(expirationDate.toString());\n    const signatureV1 = yield sign(privateKey, value, validityType, isoValidity);\n    const data = createCborData(value, isoValidity, validityType, seq, ttl);\n    const sigData = ipnsEntryDataForV2Sig(data);\n    const signatureV2 = yield privateKey.sign(sigData);\n    const entry = {\n      value,\n      signature: signatureV1,\n      validityType: validityType,\n      validity: isoValidity,\n      sequence: seq,\n      ttl,\n      signatureV2,\n      data\n    };\n    log(`ipns entry for ${value} created`);\n    return entry;\n  });\n\n  return function _create(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {Uint8Array} value\n * @param {Uint8Array} validity\n * @param {number} validityType\n * @param {bigint} sequence\n * @param {bigint} ttl\n */\n\n\nconst createCborData = (value, validity, validityType, sequence, ttl) => {\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType: validityType,\n    Sequence: sequence,\n    TTL: ttl\n  };\n  return cborg.encode(data);\n};\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {PublicKey} publicKey - public key for validating the record.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nconst validate = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (publicKey, entry) {\n    const {\n      value,\n      validityType,\n      validity\n    } = entry;\n    /** @type {Uint8Array} */\n\n    let dataForSignature;\n    let signature; // Check v2 signature if it's available, otherwise use the v1 signature\n\n    if (entry.signatureV2 && entry.data) {\n      signature = entry.signatureV2;\n      dataForSignature = ipnsEntryDataForV2Sig(entry.data);\n      validateCborDataMatchesPbData(entry);\n    } else {\n      signature = entry.signature;\n      dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n    } // Validate Signature\n\n\n    let isValid;\n\n    try {\n      isValid = yield publicKey.verify(dataForSignature, signature);\n    } catch (err) {\n      isValid = false;\n    }\n\n    if (!isValid) {\n      log.error('record signature verification failed');\n      throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n    } // Validate according to the validity type\n\n\n    if (validityType === ipnsEntryProto.ValidityType.EOL) {\n      let validityDate;\n\n      try {\n        validityDate = parseRFC3339(uint8ArrayToString(validity));\n      } catch (e) {\n        log.error('unrecognized validity format (not an rfc3339 format)');\n        throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n      }\n\n      if (validityDate.getTime() < Date.now()) {\n        log.error('record has expired');\n        throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n      }\n    } else if (validityType) {\n      log.error('unrecognized validity type');\n      throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n    }\n\n    log(`ipns entry for ${value} is valid`);\n  });\n\n  return function validate(_x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @param {IPNSEntry} entry\n */\n\n\nconst validateCborDataMatchesPbData = entry => {\n  if (!entry.data) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA);\n  }\n\n  const data = cborg.decode(entry.data);\n\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence);\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL);\n  }\n\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n};\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validate a record upon receipt, they need\n * the public key associated with it. For old RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {PublicKey} publicKey - public key to embed.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nconst embedPublicKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (publicKey, entry) {\n    if (!publicKey || !publicKey.bytes || !entry) {\n      const error = new Error('one or more of the provided parameters are not defined');\n      log.error(error);\n      throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n    } // Create a peer id from the public key.\n\n\n    let peerId;\n\n    try {\n      peerId = yield PeerId.createFromPubKey(publicKey.bytes);\n    } catch (err) {\n      throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);\n    } // Try to extract the public key from the ID. If we can, no need to embed it\n\n\n    let extractedPublicKey;\n\n    try {\n      extractedPublicKey = extractPublicKeyFromId(peerId);\n    } catch (err) {\n      log.error(err);\n      throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID);\n    }\n\n    if (extractedPublicKey) {\n      return null;\n    } // If we failed to extract the public key from the peer ID, embed it in the record.\n\n\n    try {\n      entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return entry;\n  });\n\n  return function embedPublicKey(_x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {PeerId} peerId - peer identifier object.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nconst extractPublicKey = (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  }\n\n  if (entry.pubKey) {\n    let pubKey;\n\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return pubKey;\n  }\n\n  if (peerId.pubKey) {\n    return peerId.pubKey;\n  }\n\n  throw Object.assign(new Error('no public key is available'), {\n    code: ERRORS.ERR_UNDEFINED_PARAMETER\n  });\n};\n/**\n * rawStdEncoding with RFC4648\n *\n * @param {Uint8Array} key\n */\n\n\nconst rawStdEncoding = key => base32upper.encode(key).slice(1);\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\n\n\nconst getLocalKey = key => new Key(`/ipns/${rawStdEncoding(key)}`);\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Uint8Array} pid - peer identifier represented by the multihash of the public key as Uint8Array.\n */\n\n\nconst getIdKeys = pid => {\n  const pkBuffer = uint8ArrayFromString('/pk/');\n  const ipnsBuffer = uint8ArrayFromString('/ipns/');\n  return {\n    routingPubKey: new Key(uint8ArrayConcat([pkBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(uint8ArrayConcat([pkBuffer, pid]))),\n    routingKey: new Key(uint8ArrayConcat([ipnsBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(uint8ArrayConcat([ipnsBuffer, pid])))\n  };\n};\n/**\n * Sign ipns record data\n *\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\n\n\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n};\n/**\n * Utility for getting the validity type code name of a validity\n *\n * @param {number} validityType\n */\n\n\nconst getValidityType = validityType => {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`);\n  log.error(error);\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n};\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\n\n\nconst ipnsEntryDataForV1Sig = (value, validityType, validity) => {\n  const validityTypeBuffer = uint8ArrayFromString(getValidityType(validityType));\n  return uint8ArrayConcat([value, validity, validityTypeBuffer]);\n};\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} data\n */\n\n\nconst ipnsEntryDataForV2Sig = data => {\n  const entryData = uint8ArrayFromString('ipns-signature:');\n  return uint8ArrayConcat([entryData, data]);\n};\n/**\n * Utility for extracting the public key from a peer-id\n *\n * @param {PeerId} peerId\n */\n\n\nconst extractPublicKeyFromId = peerId => {\n  const digest = Digest.decode(peerId.id);\n\n  if (digest.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(digest.digest);\n};\n/**\n * @param {IPNSEntry} obj\n */\n\n\nconst marshal = obj => {\n  return ipnsEntryProto.encode({ ...obj,\n    sequence: Long.fromString(obj.sequence.toString()),\n    ttl: obj.ttl == null ? undefined : Long.fromString(obj.ttl.toString())\n  }).finish();\n};\n/**\n * @param {Uint8Array} buf\n * @returns {IPNSEntry}\n */\n\n\nconst unmarshal = buf => {\n  const message = ipnsEntryProto.decode(buf);\n  const object = ipnsEntryProto.toObject(message, {\n    defaults: false,\n    arrays: true,\n    objects: false\n  });\n  return {\n    value: object.value,\n    signature: object.signature,\n    validityType: object.validityType,\n    validity: object.validity,\n    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(`${object.sequence}`) : 0n,\n    pubKey: object.pubKey,\n    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(`${object.ttl}`) : undefined\n  };\n};\n\nconst validator = {\n  /**\n   * @param {Uint8Array} marshalledData\n   * @param {Uint8Array} key\n   */\n  validate: function () {\n    var _ref4 = _asyncToGenerator(function* (marshalledData, key) {\n      const receivedEntry = unmarshal(marshalledData);\n      const bufferId = key.slice(IPNS_PREFIX.length);\n      const peerId = PeerId.createFromBytes(bufferId); // extract public key\n\n      const pubKey = extractPublicKey(peerId, receivedEntry); // Record validation\n\n      yield validate(pubKey, receivedEntry);\n    });\n\n    return function validate(_x11, _x12) {\n      return _ref4.apply(this, arguments);\n    };\n  }(),\n\n  /**\n   * @param {Uint8Array} dataA\n   * @param {Uint8Array} dataB\n   */\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA);\n    const entryB = unmarshal(dataB);\n    return entryA.sequence > entryB.sequence ? 0 : 1;\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n};","map":null,"metadata":{},"sourceType":"script"}