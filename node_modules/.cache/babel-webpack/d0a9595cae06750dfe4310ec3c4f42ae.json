{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:circuit'), {\n  error: debug('libp2p:circuit:err')\n});\n\nconst errCode = require('err-code');\n\nconst mafmt = require('mafmt');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst {\n  CircuitRelay: CircuitPB\n} = require('./protocol');\n\nconst {\n  codes\n} = require('../errors');\n\nconst toConnection = require('libp2p-utils/src/stream-to-ma-conn');\n\nconst {\n  relay: multicodec\n} = require('./multicodec');\n\nconst createListener = require('./listener');\n\nconst {\n  handleCanHop,\n  handleHop,\n  hop\n} = require('./circuit/hop');\n\nconst {\n  handleStop\n} = require('./circuit/stop');\n\nconst StreamHandler = require('./circuit/stream-handler');\n\nconst transportSymbol = Symbol.for('@libp2p/js-libp2p-circuit/circuit');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\nclass Circuit {\n  /**\n   * Creates an instance of the Circuit Transport.\n   *\n   * @class\n   * @param {object} options\n   * @param {import('../')} options.libp2p\n   * @param {import('../upgrader')} options.upgrader\n   */\n  constructor({\n    libp2p,\n    upgrader\n  }) {\n    this._dialer = libp2p.dialer;\n    this._registrar = libp2p.registrar;\n    this._connectionManager = libp2p.connectionManager;\n    this._upgrader = upgrader;\n    this._options = libp2p._config.relay;\n    this._libp2p = libp2p;\n    this.peerId = libp2p.peerId;\n\n    this._registrar.handle(multicodec, this._onProtocol.bind(this));\n  }\n  /**\n   * @param {Object} props\n   * @param {Connection} props.connection\n   * @param {MuxedStream} props.stream\n   */\n\n\n  _onProtocol({\n    connection,\n    stream\n  }) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      /** @type {import('./circuit/stream-handler')} */\n      const streamHandler = new StreamHandler({\n        stream\n      });\n      const request = yield streamHandler.read();\n\n      if (!request) {\n        return;\n      }\n\n      const circuit = _this;\n      let virtualConnection;\n\n      switch (request.type) {\n        case CircuitPB.Type.CAN_HOP:\n          {\n            log('received CAN_HOP request from %s', connection.remotePeer.toB58String());\n            yield handleCanHop({\n              circuit,\n              connection,\n              streamHandler\n            });\n            break;\n          }\n\n        case CircuitPB.Type.HOP:\n          {\n            log('received HOP request from %s', connection.remotePeer.toB58String());\n            virtualConnection = yield handleHop({\n              connection,\n              request,\n              streamHandler,\n              circuit\n            });\n            break;\n          }\n\n        case CircuitPB.Type.STOP:\n          {\n            log('received STOP request from %s', connection.remotePeer.toB58String());\n            virtualConnection = yield handleStop({\n              connection,\n              request,\n              streamHandler\n            });\n            break;\n          }\n\n        default:\n          {\n            log('Request of type %s not supported', request.type);\n          }\n      }\n\n      if (virtualConnection) {\n        // @ts-ignore dst peer will not be undefined\n        const remoteAddr = new Multiaddr(request.dstPeer.addrs[0]); // @ts-ignore src peer will not be undefined\n\n        const localAddr = new Multiaddr(request.srcPeer.addrs[0]);\n        const maConn = toConnection({\n          stream: virtualConnection,\n          remoteAddr,\n          localAddr\n        });\n        const type = request.type === CircuitPB.Type.HOP ? 'relay' : 'inbound';\n        log('new %s connection %s', type, maConn.remoteAddr);\n        const conn = yield _this._upgrader.upgradeInbound(maConn);\n        log('%s connection %s upgraded', type, maConn.remoteAddr);\n        _this.handler && _this.handler(conn);\n      }\n    })();\n  }\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {Multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Object} options - dial options\n   * @param {AbortSignal} [options.signal] - An optional abort signal\n   * @returns {Promise<Connection>} - the connection\n   */\n\n\n  dial(ma, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Check the multiaddr to see if it contains a relay and a destination peer\n      const addrs = ma.toString().split('/p2p-circuit');\n      const relayAddr = new Multiaddr(addrs[0]);\n      const destinationAddr = new Multiaddr(addrs[addrs.length - 1]);\n      const relayId = relayAddr.getPeerId();\n      const destinationId = destinationAddr.getPeerId();\n\n      if (!relayId || !destinationId) {\n        const errMsg = 'Circuit relay dial failed as addresses did not have peer id';\n        log.error(errMsg);\n        throw errCode(new Error(errMsg), codes.ERR_RELAYED_DIAL);\n      }\n\n      const relayPeer = PeerId.createFromB58String(relayId);\n      const destinationPeer = PeerId.createFromB58String(destinationId);\n      let disconnectOnFailure = false;\n\n      let relayConnection = _this2._connectionManager.get(relayPeer);\n\n      if (!relayConnection) {\n        relayConnection = yield _this2._dialer.connectToPeer(relayAddr, options);\n        disconnectOnFailure = true;\n      }\n\n      try {\n        const virtualConnection = yield hop({\n          connection: relayConnection,\n          request: {\n            type: CircuitPB.Type.HOP,\n            srcPeer: {\n              id: _this2.peerId.toBytes(),\n              addrs: _this2._libp2p.multiaddrs.map(addr => addr.bytes)\n            },\n            dstPeer: {\n              id: destinationPeer.toBytes(),\n              addrs: [new Multiaddr(destinationAddr).bytes]\n            }\n          }\n        });\n        const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${_this2.peerId.toB58String()}`);\n        const maConn = toConnection({\n          stream: virtualConnection,\n          remoteAddr: ma,\n          localAddr\n        });\n        log('new outbound connection %s', maConn.remoteAddr);\n        return _this2._upgrader.upgradeOutbound(maConn);\n      } catch (err) {\n        log.error('Circuit relay dial failed', err);\n        disconnectOnFailure && (yield relayConnection.close());\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Create a listener\n   *\n   * @param {any} options\n   * @param {Function} handler\n   * @returns {import('libp2p-interfaces/src/transport/types').Listener}\n   */\n\n\n  createListener(options, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    } // Called on successful HOP and STOP requests\n\n\n    this.handler = handler;\n    return createListener(this._libp2p);\n  }\n  /**\n   * Filter check for all Multiaddrs that this transport can dial on\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]}\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    return multiaddrs.filter(ma => {\n      return mafmt.Circuit.matches(ma);\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Circuit';\n  }\n  /**\n   * Checks if the given value is a Transport instance.\n   *\n   * @param {any} other\n   * @returns {other is Transport}\n   */\n\n\n  static isTransport(other) {\n    return Boolean(other && other[transportSymbol]);\n  }\n\n}\n\nmodule.exports = Circuit;","map":null,"metadata":{},"sourceType":"script"}