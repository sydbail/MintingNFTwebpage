{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n\nconst debug = require('debug');\n\nconst first = require('it-first');\n\nconst Block = require('multiformats/block');\n\nconst cborg = require('cborg');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  cidToKey,\n  keyToMultihash\n} = require('./utils/blockstore');\n\nconst walkDag = require('./utils/walk-dag');\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').CIDVersion} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @param {string} type\n */\n\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nconst PinTypes = {\n  /** @type {'direct'} */\n  direct: 'direct',\n\n  /** @type {'recursive'} */\n  recursive: 'recursive',\n\n  /** @type {'indirect'} */\n  indirect: 'indirect',\n\n  /** @type {'all'} */\n  all: 'all'\n};\n/**\n * @implements {Pins}\n */\n\nclass PinManager {\n  /**\n   * @param {Object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor({\n    pinstore,\n    blockstore,\n    loadCodec\n  }) {\n    this.pinstore = pinstore;\n    this.blockstore = blockstore;\n    this.loadCodec = loadCodec;\n    this.log = debug('ipfs:repo:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  pinDirectly(cid, options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.blockstore.get(cid, options);\n      /** @type {PinInternal} */\n\n      const pin = {\n        depth: 0\n      };\n\n      if (cid.version !== 0) {\n        pin.version = cid.version;\n      }\n\n      if (cid.code !== dagPb.code) {\n        pin.codec = cid.code;\n      }\n\n      if (options.metadata) {\n        pin.metadata = options.metadata;\n      }\n\n      return _this4.pinstore.put(cidToKey(cid), cborg.encode(pin));\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n\n\n  unpin(cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options);\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  pinRecursively(cid, options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.fetchCompleteDag(cid, options);\n      /** @type {PinInternal} */\n\n      const pin = {\n        depth: Infinity\n      };\n\n      if (cid.version !== 0) {\n        pin.version = cid.version;\n      }\n\n      if (cid.code !== dagPb.code) {\n        pin.codec = cid.code;\n      }\n\n      if (options.metadata) {\n        pin.metadata = options.metadata;\n      }\n\n      yield _this5.pinstore.put(cidToKey(cid), cborg.encode(pin));\n    })();\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  directKeys(options) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(_this.pinstore.query({\n          filters: [entry => {\n            const pin = cborg.decode(entry.value);\n            return pin.depth === 0;\n          }]\n        })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const entry = _value;\n          const pin = cborg.decode(entry.value);\n          const version = pin.version || 0;\n          const codec = pin.codec != null ? pin.codec : dagPb.code;\n          const multihash = keyToMultihash(entry.key);\n          yield {\n            cid: CID.create(version, codec, multihash),\n            metadata: pin.metadata\n          };\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  recursiveKeys(options) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this2.pinstore.query({\n          filters: [entry => {\n            const pin = cborg.decode(entry.value);\n            return pin.depth === Infinity;\n          }]\n        })), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const entry = _value2;\n          const pin = cborg.decode(entry.value);\n          const version = pin.version || 0;\n          const codec = pin.codec != null ? pin.codec : dagPb.code;\n          const multihash = keyToMultihash(entry.key);\n          yield {\n            cid: CID.create(version, codec, multihash),\n            metadata: pin.metadata\n          };\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  indirectKeys(options) {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(_this3.recursiveKeys()), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const {\n            cid\n          } = _value3;\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n\n          var _iteratorError4;\n\n          try {\n            for (var _iterator4 = _asyncIterator(walkDag(cid, _this3.blockstore, _this3.loadCodec, options)), _step4, _value4; _step4 = yield _awaitAsyncGenerator(_iterator4.next()), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _awaitAsyncGenerator(_step4.value), !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {\n              const childCid = _value4;\n              // recursive pins override indirect pins\n              const types = [PinTypes.recursive];\n              const result = yield _awaitAsyncGenerator(_this3.isPinnedWithType(childCid, types));\n\n              if (result.pinned) {\n                continue;\n              }\n\n              yield childCid;\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                yield _awaitAsyncGenerator(_iterator4.return());\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            yield _awaitAsyncGenerator(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n\n\n  isPinnedWithType(cid, types, options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!Array.isArray(types)) {\n        types = [types];\n      }\n\n      const all = types.includes(PinTypes.all);\n      const direct = types.includes(PinTypes.direct);\n      const recursive = types.includes(PinTypes.recursive);\n      const indirect = types.includes(PinTypes.indirect);\n\n      if (recursive || direct || all) {\n        const result = yield first(_this6.pinstore.query({\n          prefix: cidToKey(cid).toString(),\n          filters: [entry => {\n            if (all) {\n              return true;\n            }\n\n            const pin = cborg.decode(entry.value);\n            return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);\n          }],\n          limit: 1\n        }));\n\n        if (result) {\n          const pin = cborg.decode(result.value);\n          return {\n            cid,\n            pinned: true,\n            reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n            metadata: pin.metadata\n          };\n        }\n      }\n\n      const self = _this6;\n      /**\n       * @param {CID} key\n       * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n       */\n\n      function findChild(_x, _x2) {\n        return _findChild.apply(this, arguments);\n      }\n\n      function _findChild() {\n        _findChild = _wrapAsyncGenerator(function* (key, source) {\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n\n          var _iteratorError5;\n\n          try {\n            for (var _iterator5 = _asyncIterator(source), _step5, _value5; _step5 = yield _awaitAsyncGenerator(_iterator5.next()), _iteratorNormalCompletion5 = _step5.done, _value5 = yield _awaitAsyncGenerator(_step5.value), !_iteratorNormalCompletion5; _iteratorNormalCompletion5 = true) {\n              const {\n                cid: parentCid\n              } = _value5;\n              var _iteratorNormalCompletion6 = true;\n              var _didIteratorError6 = false;\n\n              var _iteratorError6;\n\n              try {\n                for (var _iterator6 = _asyncIterator(walkDag(parentCid, self.blockstore, self.loadCodec)), _step6, _value6; _step6 = yield _awaitAsyncGenerator(_iterator6.next()), _iteratorNormalCompletion6 = _step6.done, _value6 = yield _awaitAsyncGenerator(_step6.value), !_iteratorNormalCompletion6; _iteratorNormalCompletion6 = true) {\n                  const childCid = _value6;\n\n                  if (childCid.equals(key)) {\n                    yield parentCid;\n                    return;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                    yield _awaitAsyncGenerator(_iterator6.return());\n                  }\n                } finally {\n                  if (_didIteratorError6) {\n                    throw _iteratorError6;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                yield _awaitAsyncGenerator(_iterator5.return());\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        });\n        return _findChild.apply(this, arguments);\n      }\n\n      if (all || indirect) {\n        // indirect (default)\n        // check each recursive key to see if multihash is under it\n        const parentCid = yield first(findChild(cid, _this6.recursiveKeys()));\n\n        if (parentCid) {\n          return {\n            cid,\n            pinned: true,\n            reason: PinTypes.indirect,\n            parent: parentCid\n          };\n        }\n      }\n\n      return {\n        cid,\n        pinned: false\n      };\n    })();\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n\n\n  fetchCompleteDag(cid, options) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const seen = new Set();\n      /**\n       * @param {CID} cid\n       * @param {AbortOptions} options\n       */\n\n      const walkDag = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (cid, options) {\n          if (seen.has(cid.toString())) {\n            return;\n          }\n\n          seen.add(cid.toString());\n          const bytes = yield _this7.blockstore.get(cid, options);\n          const codec = yield _this7.loadCodec(cid.code);\n          const block = Block.createUnsafe({\n            bytes,\n            cid,\n            codec\n          });\n          yield Promise.all([...block.links()].map(([, childCid]) => walkDag(childCid, options)));\n        });\n\n        return function walkDag(_x3, _x4) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      yield walkDag(cid, options);\n    })();\n  }\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = {\n  PinManager,\n  PinTypes\n};","map":null,"metadata":{},"sourceType":"script"}