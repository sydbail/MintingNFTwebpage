{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst {\n  PinTypes\n} = require('ipfs-repo');\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = ({\n  repo,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  function addAll(_x) {\n    return _addAll.apply(this, arguments);\n  }\n\n  function _addAll() {\n    _addAll = _wrapAsyncGenerator(function* (source, options = {}) {\n      /**\n       * @returns {AsyncIterable<CID>}\n       */\n      const pinAdd = /*#__PURE__*/function () {\n        var _ref = _wrapAsyncGenerator(function* () {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n\n          var _iteratorError;\n\n          try {\n            for (var _iterator = _asyncIterator(normaliseInput(source)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n              const {\n                path,\n                recursive,\n                metadata\n              } = _value;\n              const {\n                cid\n              } = yield _awaitAsyncGenerator(resolvePath(repo, codecs, path)); // verify that each hash can be pinned\n\n              const {\n                reason\n              } = yield _awaitAsyncGenerator(repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]));\n\n              if (reason === 'recursive' && !recursive) {\n                // only disallow trying to override recursive pins\n                throw new Error(`${cid} already pinned recursively`);\n              }\n\n              if (recursive) {\n                yield _awaitAsyncGenerator(repo.pins.pinRecursively(cid, {\n                  metadata\n                }));\n              } else {\n                yield _awaitAsyncGenerator(repo.pins.pinDirectly(cid, {\n                  metadata\n                }));\n              }\n\n              yield cid;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                yield _awaitAsyncGenerator(_iterator.return());\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        });\n\n        return function pinAdd() {\n          return _ref.apply(this, arguments);\n        };\n      }(); // When adding a file, we take a lock that gets released after pinning\n      // is complete, so don't take a second lock here\n\n\n      const lock = Boolean(options.lock);\n\n      if (!lock) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(pinAdd()), _awaitAsyncGenerator);\n        return;\n      }\n\n      const release = yield _awaitAsyncGenerator(repo.gcLock.readLock());\n\n      try {\n        yield* _asyncGeneratorDelegate(_asyncIterator(pinAdd()), _awaitAsyncGenerator);\n      } finally {\n        release();\n      }\n    });\n    return _addAll.apply(this, arguments);\n  }\n\n  return withTimeoutOption(addAll);\n};","map":null,"metadata":{},"sourceType":"script"}