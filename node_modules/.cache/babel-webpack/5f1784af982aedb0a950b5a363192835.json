{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst PeerId = require('peer-id');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst defer = require('p-defer');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p-delegated-peer-routing');\nlog.error = debug('libp2p-delegated-peer-routing:error');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor(client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    });\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);\n  }\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  findPeer(id, options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let idStr = id;\n\n      if (PeerId.isPeerId(idStr)) {\n        idStr = id.toB58String();\n      }\n\n      log('findPeer starts: ' + id);\n      options.timeout = options.timeout || DEFAULT_TIMEOUT;\n\n      try {\n        return yield _this2._httpQueue.add( /*#__PURE__*/_asyncToGenerator(function* () {\n          const {\n            addrs\n          } = yield _this2._client.dht.findPeer(idStr, {\n            timeout: options.timeout\n          });\n          return {\n            id,\n            multiaddrs: addrs\n          };\n        }));\n      } catch (err) {\n        if (err.message.includes('not found')) {\n          return undefined;\n        }\n\n        throw err;\n      } finally {\n        log('findPeer finished: ' + id);\n      }\n    })();\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  getClosestPeers(key, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const keyStr = base58btc.encode(key).substring(1);\n      log('getClosestPeers starts:', keyStr);\n      options.timeout = options.timeout || DEFAULT_TIMEOUT;\n      const onStart = defer();\n      const onFinish = defer();\n\n      _this._httpQueue.add(() => {\n        onStart.resolve();\n        return onFinish.promise;\n      });\n\n      try {\n        yield _awaitAsyncGenerator(onStart.promise);\n        const peers = new Map();\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(_this._client.dht.query(keyStr, {\n            timeout: options.timeout\n          })), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const result = _value;\n\n            switch (result.type) {\n              case 1:\n                // Found Closer\n                // Track the addresses, so we can yield them when done\n                result.responses.forEach(response => {\n                  peers.set(response.id, {\n                    id: PeerId.parse(response.id),\n                    multiaddrs: response.addrs\n                  });\n                });\n                break;\n\n              case 2:\n                // Final Peer\n                yield peers.get(result.id.string) || {\n                  id: PeerId.createFromCID(result.id),\n                  multiaddrs: []\n                };\n                break;\n\n              default:\n                log('getClosestPeers unhandled response', result);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } catch (err) {\n        log.error('getClosestPeers errored:', err);\n        throw err;\n      } finally {\n        onFinish.resolve();\n        log('getClosestPeers finished:', keyStr);\n      }\n    })();\n  }\n\n}\n\nmodule.exports = DelegatedPeerRouting;","map":null,"metadata":{},"sourceType":"script"}