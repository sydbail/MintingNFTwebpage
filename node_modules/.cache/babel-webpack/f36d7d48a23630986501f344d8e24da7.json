{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst BufferList = require('bl/BufferList');\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nconst errCode = require('err-code');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst first = require('it-first');\n\nconst NewLine = uint8ArrayFromString('\\n');\n\nexports.encode = buffer => lp.encode.single(new BufferList([buffer, NewLine])); // `write` encodes and writes a single buffer\n\n\nexports.write = (writer, buffer) => writer.push(exports.encode(buffer)); // `writeAll` behaves like `write`, except it encodes an array of items as a single write\n\n\nexports.writeAll = (writer, buffers) => {\n  writer.push(buffers.reduce((bl, buffer) => bl.append(exports.encode(buffer)), new BufferList()));\n};\n\nexports.read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (reader) {\n    let byteLength = 1; // Read single byte chunks until the length is known\n\n    const varByteSource = {\n      // No return impl - we want the reader to remain readable\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      next: () => reader.next(byteLength)\n    }; // Once the length has been parsed, read chunk for that length\n\n    const onLength = l => {\n      byteLength = l;\n    };\n\n    const buf = yield pipe(varByteSource, lp.decode({\n      onLength\n    }), first);\n\n    if (buf.get(buf.length - 1) !== NewLine[0]) {\n      throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n    }\n\n    return buf.shallowSlice(0, -1); // Remove newline\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}