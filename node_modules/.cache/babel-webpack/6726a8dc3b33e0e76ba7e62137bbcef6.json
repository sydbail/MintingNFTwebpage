{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { asyncIterableReader, bytesReader, createDecoder } from './decoder.js';\nexport class CarIteratorBase {\n  constructor(version, roots, iterable) {\n    this._version = version;\n    this._roots = roots;\n    this._iterable = iterable;\n    this._decoded = false;\n  }\n\n  get version() {\n    return this._version;\n  }\n\n  getRoots() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this._roots;\n    })();\n  }\n\n}\nexport class CarBlockIterator extends CarIteratorBase {\n  [Symbol.asyncIterator]() {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once');\n    }\n\n    if (!this._iterable) {\n      throw new Error('Block iterable not found');\n    }\n\n    this._decoded = true;\n    return this._iterable[Symbol.asyncIterator]();\n  }\n\n  static fromBytes(bytes) {\n    return _asyncToGenerator(function* () {\n      const {\n        version,\n        roots,\n        iterator\n      } = yield fromBytes(bytes);\n      return new CarBlockIterator(version, roots, iterator);\n    })();\n  }\n\n  static fromIterable(asyncIterable) {\n    return _asyncToGenerator(function* () {\n      const {\n        version,\n        roots,\n        iterator\n      } = yield fromIterable(asyncIterable);\n      return new CarBlockIterator(version, roots, iterator);\n    })();\n  }\n\n}\nexport class CarCIDIterator extends CarIteratorBase {\n  [Symbol.asyncIterator]() {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once');\n    }\n\n    if (!this._iterable) {\n      throw new Error('Block iterable not found');\n    }\n\n    this._decoded = true;\n\n    const iterable = this._iterable[Symbol.asyncIterator]();\n\n    return {\n      next() {\n        return _asyncToGenerator(function* () {\n          const next = yield iterable.next();\n\n          if (next.done) {\n            return next;\n          }\n\n          return {\n            done: false,\n            value: next.value.cid\n          };\n        })();\n      }\n\n    };\n  }\n\n  static fromBytes(bytes) {\n    return _asyncToGenerator(function* () {\n      const {\n        version,\n        roots,\n        iterator\n      } = yield fromBytes(bytes);\n      return new CarCIDIterator(version, roots, iterator);\n    })();\n  }\n\n  static fromIterable(asyncIterable) {\n    return _asyncToGenerator(function* () {\n      const {\n        version,\n        roots,\n        iterator\n      } = yield fromIterable(asyncIterable);\n      return new CarCIDIterator(version, roots, iterator);\n    })();\n  }\n\n}\n\nfunction fromBytes(_x) {\n  return _fromBytes.apply(this, arguments);\n}\n\nfunction _fromBytes() {\n  _fromBytes = _asyncToGenerator(function* (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n\n    return decodeIterator(bytesReader(bytes));\n  });\n  return _fromBytes.apply(this, arguments);\n}\n\nfunction fromIterable(_x2) {\n  return _fromIterable.apply(this, arguments);\n}\n\nfunction _fromIterable() {\n  _fromIterable = _asyncToGenerator(function* (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n\n    return decodeIterator(asyncIterableReader(asyncIterable));\n  });\n  return _fromIterable.apply(this, arguments);\n}\n\nfunction decodeIterator(_x3) {\n  return _decodeIterator.apply(this, arguments);\n}\n\nfunction _decodeIterator() {\n  _decodeIterator = _asyncToGenerator(function* (reader) {\n    const decoder = createDecoder(reader);\n    const {\n      version,\n      roots\n    } = yield decoder.header();\n    return {\n      version,\n      roots,\n      iterator: decoder.blocks()\n    };\n  });\n  return _decodeIterator.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/@ipld/car/esm/lib/iterator.js"],"names":["asyncIterableReader","bytesReader","createDecoder","CarIteratorBase","constructor","version","roots","iterable","_version","_roots","_iterable","_decoded","getRoots","CarBlockIterator","Symbol","asyncIterator","Error","fromBytes","bytes","iterator","fromIterable","asyncIterable","CarCIDIterator","next","done","value","cid","Uint8Array","TypeError","decodeIterator","reader","decoder","header","blocks"],"mappings":"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","sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js';\nexport class CarIteratorBase {\n  constructor(version, roots, iterable) {\n    this._version = version;\n    this._roots = roots;\n    this._iterable = iterable;\n    this._decoded = false;\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n}\nexport class CarBlockIterator extends CarIteratorBase {\n  [Symbol.asyncIterator]() {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once');\n    }\n    if (!this._iterable) {\n      throw new Error('Block iterable not found');\n    }\n    this._decoded = true;\n    return this._iterable[Symbol.asyncIterator]();\n  }\n  static async fromBytes(bytes) {\n    const {version, roots, iterator} = await fromBytes(bytes);\n    return new CarBlockIterator(version, roots, iterator);\n  }\n  static async fromIterable(asyncIterable) {\n    const {version, roots, iterator} = await fromIterable(asyncIterable);\n    return new CarBlockIterator(version, roots, iterator);\n  }\n}\nexport class CarCIDIterator extends CarIteratorBase {\n  [Symbol.asyncIterator]() {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once');\n    }\n    if (!this._iterable) {\n      throw new Error('Block iterable not found');\n    }\n    this._decoded = true;\n    const iterable = this._iterable[Symbol.asyncIterator]();\n    return {\n      async next() {\n        const next = await iterable.next();\n        if (next.done) {\n          return next;\n        }\n        return {\n          done: false,\n          value: next.value.cid\n        };\n      }\n    };\n  }\n  static async fromBytes(bytes) {\n    const {version, roots, iterator} = await fromBytes(bytes);\n    return new CarCIDIterator(version, roots, iterator);\n  }\n  static async fromIterable(asyncIterable) {\n    const {version, roots, iterator} = await fromIterable(asyncIterable);\n    return new CarCIDIterator(version, roots, iterator);\n  }\n}\nasync function fromBytes(bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError('fromBytes() requires a Uint8Array');\n  }\n  return decodeIterator(bytesReader(bytes));\n}\nasync function fromIterable(asyncIterable) {\n  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n    throw new TypeError('fromIterable() requires an async iterable');\n  }\n  return decodeIterator(asyncIterableReader(asyncIterable));\n}\nasync function decodeIterator(reader) {\n  const decoder = createDecoder(reader);\n  const {version, roots} = await decoder.header();\n  return {\n    version,\n    roots,\n    iterator: decoder.blocks()\n  };\n}"]},"metadata":{},"sourceType":"module"}