{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Dapp/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  Multiaddr\n} = require('multiaddr'); // @ts-ignore timeout-abourt-controles does not export types\n\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst DialRequest = require('./dial-request');\n\nconst {\n  publicAddressesFirst\n} = require('libp2p-utils/src/address-sort');\n\nconst getPeer = require('../get-peer');\n\nconst {\n  codes\n} = require('../errors');\n\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store')} PeerStore\n * @typedef {import('../peer-store/address-book').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {DialRequest} dialRequest\n * @property {TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor({\n    transportManager,\n    peerStore,\n    addressSorter = publicAddressesFirst,\n    maxParallelDials = MAX_PARALLEL_DIALS,\n    maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n    dialTimeout = DIAL_TIMEOUT,\n    maxDialsPerPeer = MAX_PER_PEER_DIALS,\n    resolvers = {}\n  }) {\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.addressSorter = addressSorter;\n    this.maxParallelDials = maxParallelDials;\n    this.maxAddrsToDial = maxAddrsToDial;\n    this.timeout = dialTimeout;\n    this.maxDialsPerPeer = maxDialsPerPeer;\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index);\n    this._pendingDials = new Map();\n    this._pendingDialTargets = new Map();\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value);\n    }\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  destroy() {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (err) {\n        log.error(err);\n      }\n    }\n\n    this._pendingDials.clear();\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'));\n    }\n\n    this._pendingDialTargets.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n\n\n  connectToPeer(peer, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const dialTarget = yield _this._createCancellableDialTarget(peer);\n\n      if (!dialTarget.addrs.length) {\n        throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n      }\n\n      const pendingDial = _this._pendingDials.get(dialTarget.id) || _this._createPendingDial(dialTarget, options);\n\n      try {\n        const connection = yield pendingDial.promise;\n        log('dial succeeded to %s', dialTarget.id);\n        return connection;\n      } catch (err) {\n        // Error is a timeout\n        if (pendingDial.controller.signal.aborted) {\n          err.code = codes.ERR_TIMEOUT;\n        }\n\n        log.error(err);\n        throw err;\n      } finally {\n        pendingDial.destroy();\n      }\n    })();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  _createCancellableDialTarget(peer) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Make dial target promise cancellable\n      const id = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;\n      const cancellablePromise = new Promise((resolve, reject) => {\n        _this2._pendingDialTargets.set(id, {\n          resolve,\n          reject\n        });\n      });\n      const dialTarget = yield Promise.race([_this2._createDialTarget(peer), cancellablePromise]);\n\n      _this2._pendingDialTargets.delete(id);\n\n      return dialTarget;\n    })();\n  }\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  _createDialTarget(peer) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        id,\n        multiaddrs\n      } = getPeer(peer);\n\n      if (multiaddrs) {\n        _this3.peerStore.addressBook.add(id, multiaddrs);\n      }\n\n      let knownAddrs = _this3.peerStore.addressBook.getMultiaddrsForPeer(id, _this3.addressSorter) || []; // If received a multiaddr to dial, it should be the first to use\n      // But, if we know other multiaddrs for the peer, we should try them too.\n\n      if (Multiaddr.isMultiaddr(peer)) {\n        knownAddrs = knownAddrs.filter(addr => !peer.equals(addr));\n        knownAddrs.unshift(peer);\n      }\n      /** @type {Multiaddr[]} */\n\n\n      const addrs = [];\n\n      for (const a of knownAddrs) {\n        const resolvedAddrs = yield _this3._resolve(a);\n        resolvedAddrs.forEach(ra => addrs.push(ra));\n      } // Multiaddrs not supported by the available transports will be filtered out.\n\n\n      const supportedAddrs = addrs.filter(a => _this3.transportManager.transportForMultiaddr(a));\n\n      if (supportedAddrs.length > _this3.maxAddrsToDial) {\n        _this3.peerStore.delete(id);\n\n        throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n      }\n\n      return {\n        id: id.toB58String(),\n        addrs: supportedAddrs\n      };\n    })();\n  }\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n\n\n  _createPendingDial(dialTarget, options = {}) {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      return this.transportManager.dial(addr, options);\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals);\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n\n        this._pendingDials.delete(dialTarget.id);\n      }\n    };\n\n    this._pendingDials.set(dialTarget.id, pendingDial);\n\n    return pendingDial;\n  }\n  /**\n   * @param {number} num\n   */\n\n\n  getTokens(num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n  /**\n   * @param {number} token\n   */\n\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return;\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  _resolve(ma) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n      // Now only supporting resolve for dnsaddr\n      const resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n\n      if (!resolvableProto) {\n        return [ma];\n      }\n\n      const resolvedMultiaddrs = yield _this4._resolveRecord(ma);\n      const recursiveMultiaddrs = yield Promise.all(resolvedMultiaddrs.map(nm => {\n        return _this4._resolve(nm);\n      }));\n      const addrs = recursiveMultiaddrs.flat();\n      return addrs.reduce((array, newM) => {\n        if (!array.find(m => m.equals(newM))) {\n          array.push(newM);\n        }\n\n        return array;\n      }, []);\n    })();\n  }\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  _resolveRecord(ma) {\n    return _asyncToGenerator(function* () {\n      try {\n        ma = new Multiaddr(ma.toString()); // Use current multiaddr module\n\n        const multiaddrs = yield ma.resolve();\n        return multiaddrs;\n      } catch (_) {\n        log.error(`multiaddr ${ma} could not be resolved`);\n        return [];\n      }\n    })();\n  }\n\n}\n\nmodule.exports = Dialer;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Dapp/node_modules/libp2p/src/dialer/index.js"],"names":["debug","require","log","Object","assign","error","errCode","Multiaddr","TimeoutController","AbortError","anySignal","DialRequest","publicAddressesFirst","getPeer","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","MAX_ADDRS_TO_DIAL","Dialer","constructor","transportManager","peerStore","addressSorter","maxParallelDials","maxAddrsToDial","dialTimeout","maxDialsPerPeer","resolvers","timeout","tokens","Array","map","_","index","_pendingDials","Map","_pendingDialTargets","key","value","entries","set","destroy","dial","values","controller","abort","err","clear","pendingTarget","reject","connectToPeer","peer","options","dialTarget","_createCancellableDialTarget","addrs","length","Error","ERR_NO_VALID_ADDRESSES","pendingDial","get","id","_createPendingDial","connection","promise","signal","aborted","code","ERR_TIMEOUT","parseInt","String","Math","random","toString","Date","now","cancellablePromise","Promise","resolve","race","_createDialTarget","delete","multiaddrs","addressBook","add","knownAddrs","getMultiaddrsForPeer","isMultiaddr","filter","addr","equals","unshift","a","resolvedAddrs","_resolve","forEach","ra","push","supportedAddrs","transportForMultiaddr","ERR_TOO_MANY_ADDRESSES","toB58String","dialAction","ERR_ALREADY_ABORTED","dialRequest","dialer","timeoutController","signals","run","getTokens","num","total","min","splice","releaseToken","token","indexOf","ma","resolvableProto","protoNames","includes","resolvedMultiaddrs","_resolveRecord","recursiveMultiaddrs","all","nm","flat","reduce","array","newM","find","m","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n})\nconst errCode = require('err-code')\nconst { Multiaddr } = require('multiaddr')\n// @ts-ignore timeout-abourt-controles does not export types\nconst TimeoutController = require('timeout-abort-controller')\nconst { AbortError } = require('abortable-iterator')\nconst { anySignal } = require('any-signal')\n\nconst DialRequest = require('./dial-request')\nconst { publicAddressesFirst } = require('libp2p-utils/src/address-sort')\nconst getPeer = require('../get-peer')\n\nconst { codes } = require('../errors')\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store')} PeerStore\n * @typedef {import('../peer-store/address-book').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {DialRequest} dialRequest\n * @property {TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor ({\n    transportManager,\n    peerStore,\n    addressSorter = publicAddressesFirst,\n    maxParallelDials = MAX_PARALLEL_DIALS,\n    maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n    dialTimeout = DIAL_TIMEOUT,\n    maxDialsPerPeer = MAX_PER_PEER_DIALS,\n    resolvers = {}\n  }) {\n    this.transportManager = transportManager\n    this.peerStore = peerStore\n    this.addressSorter = addressSorter\n    this.maxParallelDials = maxParallelDials\n    this.maxAddrsToDial = maxAddrsToDial\n    this.timeout = dialTimeout\n    this.maxDialsPerPeer = maxDialsPerPeer\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index)\n    this._pendingDials = new Map()\n    this._pendingDialTargets = new Map()\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value)\n    }\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  destroy () {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (err) {\n        log.error(err)\n      }\n    }\n    this._pendingDials.clear()\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'))\n    }\n    this._pendingDialTargets.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n  async connectToPeer (peer, options = {}) {\n    const dialTarget = await this._createCancellableDialTarget(peer)\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n  async _createCancellableDialTarget (peer) {\n    // Make dial target promise cancellable\n    const id = `${(parseInt(String(Math.random() * 1e9), 10)).toString() + Date.now()}`\n    const cancellablePromise = new Promise((resolve, reject) => {\n      this._pendingDialTargets.set(id, { resolve, reject })\n    })\n\n    const dialTarget = await Promise.race([\n      this._createDialTarget(peer),\n      cancellablePromise\n    ])\n\n    this._pendingDialTargets.delete(id)\n\n    return dialTarget\n  }\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n  async _createDialTarget (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    let knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || []\n\n    // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n    if (Multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr))\n      knownAddrs.unshift(peer)\n    }\n\n    /** @type {Multiaddr[]} */\n    const addrs = []\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a)\n      resolvedAddrs.forEach(ra => addrs.push(ra))\n    }\n\n    // Multiaddrs not supported by the available transports will be filtered out.\n    const supportedAddrs = addrs.filter(a => this.transportManager.transportForMultiaddr(a))\n\n    if (supportedAddrs.length > this.maxAddrsToDial) {\n      this.peerStore.delete(id)\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES)\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs: supportedAddrs\n    }\n  }\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n  _createPendingDial (dialTarget, options = {}) {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      return this.transportManager.dial(addr, options)\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n    const signals = [timeoutController.signal]\n    options.signal && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this._pendingDials.delete(dialTarget.id)\n      }\n    }\n    this._pendingDials.set(dialTarget.id, pendingDial)\n    return pendingDial\n  }\n\n  /**\n   * @param {number} num\n   */\n  getTokens (num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  /**\n   * @param {number} token\n   */\n  releaseToken (token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolve (ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr')\n\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n      return [ma]\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma)\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {\n      return this._resolve(nm)\n    }))\n\n    const addrs = recursiveMultiaddrs.flat()\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM)\n      }\n      return array\n    }, /** @type  {Multiaddr[]} */([]))\n  }\n\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolveRecord (ma) {\n    try {\n      ma = new Multiaddr(ma.toString()) // Use current multiaddr module\n      const multiaddrs = await ma.resolve()\n      return multiaddrs\n    } catch (_) {\n      log.error(`multiaddr ${ma} could not be resolved`)\n      return []\n    }\n  }\n}\n\nmodule.exports = Dialer\n"]},"metadata":{},"sourceType":"script"}