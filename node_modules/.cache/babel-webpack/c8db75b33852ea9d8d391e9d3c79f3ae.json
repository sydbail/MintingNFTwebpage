{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\n\nfunction readVarint(_x) {\n  return _readVarint.apply(this, arguments);\n}\n\nfunction _readVarint() {\n  _readVarint = _asyncToGenerator(function* (reader) {\n    const bytes = yield reader.upTo(8);\n    const i = varint.decode(bytes);\n    reader.seek(varint.decode.bytes);\n    return i;\n  });\n  return _readVarint.apply(this, arguments);\n}\n\nexport function readHeader(_x2) {\n  return _readHeader.apply(this, arguments);\n}\n\nfunction _readHeader() {\n  _readHeader = _asyncToGenerator(function* (reader) {\n    const length = yield readVarint(reader);\n\n    if (length === 0) {\n      throw new Error('Invalid CAR header (zero length)');\n    }\n\n    const header = yield reader.exactly(length);\n    reader.seek(length);\n    const block = decodeDagCbor(header);\n\n    if (block == null || Array.isArray(block) || typeof block !== 'object') {\n      throw new Error('Invalid CAR header format');\n    }\n\n    if (block.version !== 1) {\n      if (typeof block.version === 'string') {\n        throw new Error(`Invalid CAR version: \"${block.version}\"`);\n      }\n\n      throw new Error(`Invalid CAR version: ${block.version}`);\n    }\n\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format');\n    }\n\n    if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n      throw new Error('Invalid CAR header format');\n    }\n\n    return block;\n  });\n  return _readHeader.apply(this, arguments);\n}\n\nfunction readMultihash(_x3) {\n  return _readMultihash.apply(this, arguments);\n}\n\nfunction _readMultihash() {\n  _readMultihash = _asyncToGenerator(function* (reader) {\n    const bytes = yield reader.upTo(8);\n    varint.decode(bytes);\n    const codeLength = varint.decode.bytes;\n    const length = varint.decode(bytes.subarray(varint.decode.bytes));\n    const lengthLength = varint.decode.bytes;\n    const mhLength = codeLength + lengthLength + length;\n    const multihash = yield reader.exactly(mhLength);\n    reader.seek(mhLength);\n    return multihash;\n  });\n  return _readMultihash.apply(this, arguments);\n}\n\nfunction readCid(_x4) {\n  return _readCid.apply(this, arguments);\n}\n\nfunction _readCid() {\n  _readCid = _asyncToGenerator(function* (reader) {\n    const first = yield reader.exactly(2);\n\n    if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n      const bytes = yield reader.exactly(34);\n      reader.seek(34);\n      const multihash = Digest.decode(bytes);\n      return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n    }\n\n    const version = yield readVarint(reader);\n\n    if (version !== 1) {\n      throw new Error(`Unexpected CID version (${version})`);\n    }\n\n    const codec = yield readVarint(reader);\n    const bytes = yield readMultihash(reader);\n    const multihash = Digest.decode(bytes);\n    return CID.create(version, codec, multihash);\n  });\n  return _readCid.apply(this, arguments);\n}\n\nfunction readBlockHead(_x5) {\n  return _readBlockHead.apply(this, arguments);\n}\n\nfunction _readBlockHead() {\n  _readBlockHead = _asyncToGenerator(function* (reader) {\n    const start = reader.pos;\n    let length = yield readVarint(reader);\n\n    if (length === 0) {\n      throw new Error('Invalid CAR section (zero length)');\n    }\n\n    length += reader.pos - start;\n    const cid = yield readCid(reader);\n    const blockLength = length - (reader.pos - start);\n    return {\n      cid,\n      length,\n      blockLength\n    };\n  });\n  return _readBlockHead.apply(this, arguments);\n}\n\nfunction readBlock(_x6) {\n  return _readBlock.apply(this, arguments);\n}\n\nfunction _readBlock() {\n  _readBlock = _asyncToGenerator(function* (reader) {\n    const {\n      cid,\n      blockLength\n    } = yield readBlockHead(reader);\n    const bytes = yield reader.exactly(blockLength);\n    reader.seek(blockLength);\n    return {\n      bytes,\n      cid\n    };\n  });\n  return _readBlock.apply(this, arguments);\n}\n\nfunction readBlockIndex(_x7) {\n  return _readBlockIndex.apply(this, arguments);\n}\n\nfunction _readBlockIndex() {\n  _readBlockIndex = _asyncToGenerator(function* (reader) {\n    const offset = reader.pos;\n    const {\n      cid,\n      length,\n      blockLength\n    } = yield readBlockHead(reader);\n    const index = {\n      cid,\n      length,\n      blockLength,\n      offset,\n      blockOffset: reader.pos\n    };\n    reader.seek(index.blockLength);\n    return index;\n  });\n  return _readBlockIndex.apply(this, arguments);\n}\n\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n\n    blocks() {\n      return _wrapAsyncGenerator(function* () {\n        yield _awaitAsyncGenerator(headerPromise);\n\n        while ((yield _awaitAsyncGenerator(reader.upTo(8))).length > 0) {\n          yield readBlock(reader);\n        }\n      })();\n    },\n\n    blocksIndex() {\n      return _wrapAsyncGenerator(function* () {\n        yield _awaitAsyncGenerator(headerPromise);\n\n        while ((yield _awaitAsyncGenerator(reader.upTo(8))).length > 0) {\n          yield readBlockIndex(reader);\n        }\n      })();\n    }\n\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    upTo(length) {\n      return _asyncToGenerator(function* () {\n        return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n      })();\n    },\n\n    exactly(length) {\n      return _asyncToGenerator(function* () {\n        if (length > bytes.length - pos) {\n          throw new Error('Unexpected end of data');\n        }\n\n        return bytes.subarray(pos, pos + length);\n      })();\n    },\n\n    seek(length) {\n      pos += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n\n  const read = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (length) {\n      have = currentChunk.length - offset;\n      const bufa = [currentChunk.subarray(offset)];\n\n      while (have < length) {\n        const chunk = yield readChunk();\n\n        if (chunk == null) {\n          break;\n        }\n\n        if (have < 0) {\n          if (chunk.length > have) {\n            bufa.push(chunk.subarray(-have));\n          }\n        } else {\n          bufa.push(chunk);\n        }\n\n        have += chunk.length;\n      }\n\n      currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n      let off = 0;\n\n      for (const b of bufa) {\n        currentChunk.set(b, off);\n        off += b.length;\n      }\n\n      offset = 0;\n    });\n\n    return function read(_x8) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return {\n    upTo(length) {\n      return _asyncToGenerator(function* () {\n        if (currentChunk.length - offset < length) {\n          yield read(length);\n        }\n\n        return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n      })();\n    },\n\n    exactly(length) {\n      return _asyncToGenerator(function* () {\n        if (currentChunk.length - offset < length) {\n          yield read(length);\n        }\n\n        if (currentChunk.length - offset < length) {\n          throw new Error('Unexpected end of data');\n        }\n\n        return currentChunk.subarray(offset, offset + length);\n      })();\n    },\n\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n\n  function readChunk() {\n    return _readChunk.apply(this, arguments);\n  }\n\n  function _readChunk() {\n    _readChunk = _asyncToGenerator(function* () {\n      const next = yield iterator.next();\n\n      if (next.done) {\n        return null;\n      }\n\n      return next.value;\n    });\n    return _readChunk.apply(this, arguments);\n  }\n\n  return chunkReader(readChunk);\n}","map":null,"metadata":{},"sourceType":"module"}