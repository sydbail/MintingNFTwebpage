{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst Reason = require(\"./reason\");\n\nconst handlers = require(\"./handlers\");\n\nconst override = {\n  timeoutMessage: \"not mined within\",\n  // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: function () {\n    var _ref = _asyncToGenerator(function* (context, web3Error) {\n      const constructor = this;\n      let currentBlock = override.defaultMaxBlocks; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n      if (!handlers.ignoreTimeoutError(context, web3Error)) {\n        // We might have been routed here in web3 >= beta.34 by their own status check\n        // error. We want to extract the receipt, emit a receipt event\n        // and reject it ourselves.\n        const receipt = override.extractReceipt(web3Error.message);\n\n        if (receipt) {\n          yield handlers.receipt(context, receipt);\n          return;\n        } // This will run if there's a reason and no status field\n        // e.g: revert with reason ganache-cli --vmErrorsOnRPCResponse=true\n\n\n        const reason = yield Reason.get(context.params, constructor.web3, constructor.interfaceAdapter);\n\n        if (reason) {\n          web3Error.reason = reason;\n          web3Error.message += ` -- Reason given: ${reason}.`;\n        }\n\n        return context.promiEvent.reject(web3Error);\n      } // This will run every block from now until contract.timeoutBlocks\n\n\n      const listener = function (pollID) {\n        currentBlock++;\n\n        if (currentBlock > constructor.timeoutBlocks) {\n          clearInterval(pollID);\n          return;\n        }\n\n        constructor.interfaceAdapter.getTransactionReceipt(context.transactionHash).then(result => {\n          if (!result) return; // make sure reporter receives tx receipt promievent\n\n          handlers.receipt(context, result);\n          result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n        }).catch(err => {\n          clearInterval(pollID);\n          context.promiEvent.reject(err);\n        });\n      }; // Start polling\n\n\n      let currentPollingBlock = yield constructor.interfaceAdapter.getBlockNumber();\n      const pollID = setInterval( /*#__PURE__*/_asyncToGenerator(function* () {\n        const newBlock = yield constructor.interfaceAdapter.getBlockNumber();\n\n        if (newBlock > currentPollingBlock) {\n          currentPollingBlock = newBlock;\n          listener(pollID);\n        }\n      }), override.pollingInterval);\n    });\n\n    return function start(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }()\n};\nmodule.exports = override;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/@truffle/contract/lib/override.js"],"names":["Reason","require","handlers","override","timeoutMessage","defaultWeb3Error","defaultMaxBlocks","pollingInterval","extractReceipt","message","hasReceipt","includes","receiptString","split","trim","JSON","parse","err","start","context","web3Error","constructor","currentBlock","ignoreTimeoutError","receipt","reason","get","params","web3","interfaceAdapter","promiEvent","reject","listener","pollID","timeoutBlocks","clearInterval","getTransactionReceipt","transactionHash","then","result","contractAddress","at","resolve","catch","currentPollingBlock","getBlockNumber","setInterval","newBlock","module","exports"],"mappings":"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","sourcesContent":["const Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\n\nconst override = {\n  timeoutMessage: \"not mined within\", // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\", // Substring of default Web3 error\n  defaultMaxBlocks: 50, // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {\n        // ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function(context, web3Error) {\n    const constructor = this;\n    let currentBlock = override.defaultMaxBlocks;\n\n    // Reject after attempting to get reason string if we shouldn't be waiting.\n    if (!handlers.ignoreTimeoutError(context, web3Error)) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      const receipt = override.extractReceipt(web3Error.message);\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      }\n\n      // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache-cli --vmErrorsOnRPCResponse=true\n      const reason = await Reason.get(\n        context.params,\n        constructor.web3,\n        constructor.interfaceAdapter\n      );\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += ` -- Reason given: ${reason}.`;\n      }\n\n      return context.promiEvent.reject(web3Error);\n    }\n\n    // This will run every block from now until contract.timeoutBlocks\n    const listener = function(pollID) {\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.interfaceAdapter\n        .getTransactionReceipt(context.transactionHash)\n        .then(result => {\n          if (!result) return;\n\n          // make sure reporter receives tx receipt promievent\n          handlers.receipt(context, result);\n          result.contractAddress\n            ? constructor\n                .at(result.contractAddress)\n                .then(context.promiEvent.resolve)\n                .catch(context.promiEvent.reject)\n            : constructor.promiEvent.resolve(result);\n        })\n        .catch(err => {\n          clearInterval(pollID);\n          context.promiEvent.reject(err);\n        });\n    };\n\n    // Start polling\n    let currentPollingBlock = await constructor.interfaceAdapter.getBlockNumber();\n\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.interfaceAdapter.getBlockNumber();\n\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\n\nmodule.exports = override;\n"]},"metadata":{},"sourceType":"script"}