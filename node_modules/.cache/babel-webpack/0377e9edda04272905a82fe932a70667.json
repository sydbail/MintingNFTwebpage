{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  CarBlockIterator\n} = require('@ipld/car/iterator');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst itPeekable = require('it-peekable');\n\nconst drain = require('it-drain');\n\nconst map = require('it-map');\n\nconst log = require('debug')('ipfs:components:dag:import');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {Object} config\n * @param {IPFSRepo} config.repo\n */\n\n\nmodule.exports = ({\n  repo\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API[\"import\"]}\n   */\n  function dagImport(_x) {\n    return _dagImport.apply(this, arguments);\n  }\n\n  function _dagImport() {\n    _dagImport = _wrapAsyncGenerator(function* (sources, options = {}) {\n      const release = yield _awaitAsyncGenerator(repo.gcLock.readLock());\n\n      try {\n        const abortOptions = {\n          signal: options.signal,\n          timeout: options.timeout\n        };\n        const peekable = itPeekable(sources);\n        const {\n          value,\n          done\n        } = yield _awaitAsyncGenerator(peekable.peek());\n\n        if (done) {\n          return;\n        }\n\n        if (value) {\n          // @ts-ignore\n          peekable.push(value);\n        }\n        /**\n         * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n         */\n\n\n        let cars;\n\n        if (value instanceof Uint8Array) {\n          // @ts-ignore\n          cars = [peekable];\n        } else {\n          // @ts-ignore\n          cars = peekable;\n        }\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(cars), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const car = _value;\n            const roots = yield _awaitAsyncGenerator(importCar(repo, abortOptions, car));\n\n            if (options.pinRoots !== false) {\n              // default=true\n              for (const cid of roots) {\n                let pinErrorMsg = '';\n\n                try {\n                  // eslint-disable-line max-depth\n                  if (yield _awaitAsyncGenerator(repo.blocks.has(cid))) {\n                    // eslint-disable-line max-depth\n                    log(`Pinning root ${cid}`);\n                    yield _awaitAsyncGenerator(repo.pins.pinRecursively(cid));\n                  } else {\n                    pinErrorMsg = 'blockstore: block not found';\n                  }\n                } catch (err) {\n                  pinErrorMsg = err.message;\n                }\n\n                yield {\n                  root: {\n                    cid,\n                    pinErrorMsg\n                  }\n                };\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } finally {\n        release();\n      }\n    });\n    return _dagImport.apply(this, arguments);\n  }\n\n  return withTimeoutOption(dagImport);\n};\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\n\n\nfunction importCar(_x2, _x3, _x4) {\n  return _importCar.apply(this, arguments);\n}\n\nfunction _importCar() {\n  _importCar = _asyncToGenerator(function* (repo, options, source) {\n    const reader = yield CarBlockIterator.fromIterable(source);\n    const roots = yield reader.getRoots();\n    yield drain(repo.blocks.putMany(map(reader, ({\n      cid: key,\n      bytes: value\n    }) => {\n      log(`Import block ${key}`);\n      return {\n        key,\n        value\n      };\n    }), {\n      signal: options.signal\n    }));\n    return roots;\n  });\n  return _importCar.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}