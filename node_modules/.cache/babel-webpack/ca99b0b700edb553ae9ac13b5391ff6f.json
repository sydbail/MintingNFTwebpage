{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:keychain'), {\n  error: debug('libp2p:keychain:err')\n});\n\nconst sanitize = require('sanitize-filename');\n\nconst mergeOptions = require('merge-options');\n\nconst crypto = require('libp2p-crypto');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst CMS = require('./cms');\n\nconst errcode = require('err-code');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string'); // @ts-ignore node-forge sha512 types not exported\n\n\nrequire('node-forge/lib/sha512');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @typedef {Object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainOptions\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n */\n\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n\nconst keyPrefix = '/pkcs8/';\nconst infoPrefix = '/info/';\nconst privates = new WeakMap(); // NIST SP 800-132\n\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n/**\n * @param {string} name\n */\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string|Error} err - The error\n * @returns {Promise<never>}\n * @private\n */\n\n\nfunction throwDelayed(_x) {\n  return _throwDelayed.apply(this, arguments);\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\n\n\nfunction _throwDelayed() {\n  _throwDelayed = _asyncToGenerator(function* (err) {\n    const min = 200;\n    const max = 1000;\n    const delay = Math.random() * (max - min) + min;\n    yield new Promise(resolve => setTimeout(resolve, delay));\n    throw err;\n  });\n  return _throwDelayed.apply(this, arguments);\n}\n\nfunction DsName(name) {\n  return new Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new Key(infoPrefix + name);\n}\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {Datastore} store - where the key are.\n   * @param {KeychainOptions} options\n   * @class\n   */\n  constructor(store, options) {\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    this.opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (this.opts.pass && this.opts.pass.length < 20) {\n      throw new Error('pass must be least 20 characters');\n    }\n\n    if (this.opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);\n    }\n\n    if (this.opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);\n    }\n\n    if (this.opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);\n    }\n\n    const dek = this.opts.pass ? crypto.pbkdf2(this.opts.pass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : '';\n    privates.set(this, {\n      dek\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  get cms() {\n    return new CMS(this, privates.get(this).dek);\n  }\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {Object}\n   */\n\n\n  static generateOptions() {\n    const options = Object.assign({}, defaultOptions);\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n    options.dek.salt = uint8ArrayToString(crypto.randomBytes(saltLength), 'base64');\n    return options;\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {Object}\n   */\n\n\n  static get options() {\n    return defaultOptions;\n  }\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  createKey(name, type, size = 2048) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (typeof type !== 'string') {\n        return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'));\n      }\n\n      const dsname = DsName(name);\n      const exists = yield self.store.has(dsname);\n      if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n      switch (type.toLowerCase()) {\n        case 'rsa':\n          if (!Number.isSafeInteger(size) || size < 2048) {\n            return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'));\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      let keyInfo;\n\n      try {\n        // @ts-ignore Differences between several crypto return types need to be fixed in libp2p-crypto\n        const keypair = yield crypto.keys.generateKeyPair(type, size);\n        const kid = yield keypair.id();\n        /** @type {string} */\n\n        const dek = privates.get(_this).dek;\n        const pem = yield keypair.export(dek);\n        keyInfo = {\n          name: name,\n          id: kid\n        };\n        const batch = self.store.batch();\n        batch.put(dsname, uint8ArrayFromString(pem));\n        batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n        yield batch.commit();\n      } catch (err) {\n        return throwDelayed(err);\n      }\n\n      return keyInfo;\n    })();\n  }\n  /**\n   * List all the keys.\n   *\n   * @returns {Promise<KeyInfo[]>}\n   */\n\n\n  listKeys() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this2;\n      const query = {\n        prefix: infoPrefix\n      };\n      const info = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(self.store.query(query)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const value = _value;\n          info.push(JSON.parse(uint8ArrayToString(value.value)));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return info;\n    })();\n  }\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n   * @returns {Promise<KeyInfo|undefined>}\n   */\n\n\n  findKeyById(id) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const keys = yield _this3.listKeys();\n        return keys.find(k => k.id === id);\n      } catch (err) {\n        return throwDelayed(err);\n      }\n    })();\n  }\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  findKeyByName(name) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!validateKeyName(name)) {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      const dsname = DsInfoName(name);\n\n      try {\n        const res = yield _this4.store.get(dsname);\n        return JSON.parse(uint8ArrayToString(res));\n      } catch (err) {\n        return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'));\n      }\n    })();\n  }\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  removeKey(name) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this5;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      const dsname = DsName(name);\n      const keyInfo = yield self.findKeyByName(name);\n      const batch = self.store.batch();\n      batch.delete(dsname);\n      batch.delete(DsInfoName(name));\n      yield batch.commit();\n      return keyInfo;\n    })();\n  }\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  renameKey(oldName, newName) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this6;\n\n      if (!validateKeyName(oldName) || oldName === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'));\n      }\n\n      if (!validateKeyName(newName) || newName === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'));\n      }\n\n      const oldDsname = DsName(oldName);\n      const newDsname = DsName(newName);\n      const oldInfoName = DsInfoName(oldName);\n      const newInfoName = DsInfoName(newName);\n      const exists = yield self.store.has(newDsname);\n      if (exists) return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n      try {\n        const pem = yield self.store.get(oldDsname);\n        const res = yield self.store.get(oldInfoName);\n        const keyInfo = JSON.parse(uint8ArrayToString(res));\n        keyInfo.name = newName;\n        const batch = self.store.batch();\n        batch.put(newDsname, pem);\n        batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));\n        batch.delete(oldDsname);\n        batch.delete(oldInfoName);\n        yield batch.commit();\n        return keyInfo;\n      } catch (err) {\n        return throwDelayed(err);\n      }\n    })();\n  }\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n   * @returns {Promise<string>}\n   */\n\n\n  exportKey(name, password) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!validateKeyName(name)) {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!password) {\n        return throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'));\n      }\n\n      const dsname = DsName(name);\n\n      try {\n        const res = yield _this7.store.get(dsname);\n        const pem = uint8ArrayToString(res);\n        /** @type {string} */\n\n        const dek = privates.get(_this7).dek;\n        const privateKey = yield crypto.keys.import(pem, dek);\n        return privateKey.export(password);\n      } catch (err) {\n        return throwDelayed(err);\n      }\n    })();\n  }\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  importKey(name, pem, password) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this8;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!pem) {\n        return throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'));\n      }\n\n      const dsname = DsName(name);\n      const exists = yield self.store.has(dsname);\n      if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n      let privateKey;\n\n      try {\n        privateKey = yield crypto.keys.import(pem, password);\n      } catch (err) {\n        return throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'));\n      }\n\n      let kid;\n\n      try {\n        kid = yield privateKey.id();\n        /** @type {string} */\n\n        const dek = privates.get(_this8).dek;\n        pem = yield privateKey.export(dek);\n      } catch (err) {\n        return throwDelayed(err);\n      }\n\n      const keyInfo = {\n        name: name,\n        id: kid\n      };\n      const batch = self.store.batch();\n      batch.put(dsname, uint8ArrayFromString(pem));\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n      yield batch.commit();\n      return keyInfo;\n    })();\n  }\n  /**\n   * Import a peer key\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {PeerId} peer - The PEM encoded PKCS #8 string\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  importPeer(name, peer) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this9;\n\n      if (!validateKeyName(name)) {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!peer || !peer.privKey) {\n        return throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'));\n      }\n\n      const privateKey = peer.privKey;\n      const dsname = DsName(name);\n      const exists = yield self.store.has(dsname);\n      if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n      try {\n        const kid = yield privateKey.id();\n        /** @type {string} */\n\n        const dek = privates.get(_this9).dek;\n        const pem = yield privateKey.export(dek);\n        const keyInfo = {\n          name: name,\n          id: kid\n        };\n        const batch = self.store.batch();\n        batch.put(dsname, uint8ArrayFromString(pem));\n        batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n        yield batch.commit();\n        return keyInfo;\n      } catch (err) {\n        return throwDelayed(err);\n      }\n    })();\n  }\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n   * @returns {Promise<string>}\n   */\n\n\n  _getPrivateKey(name) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!validateKeyName(name)) {\n        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      try {\n        const dsname = DsName(name);\n        const res = yield _this10.store.get(dsname);\n        return uint8ArrayToString(res);\n      } catch (err) {\n        return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'));\n      }\n    })();\n  }\n  /**\n   * Rotate keychain password and re-encrypt all assosciated keys\n   *\n   * @param {string} oldPass - The old local keychain password\n   * @param {string} newPass - The new local keychain password\n   */\n\n\n  rotateKeychainPass(oldPass, newPass) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof oldPass !== 'string') {\n        return throwDelayed(errcode(new Error(`Invalid old pass type '${typeof oldPass}'`), 'ERR_INVALID_OLD_PASS_TYPE'));\n      }\n\n      if (typeof newPass !== 'string') {\n        return throwDelayed(errcode(new Error(`Invalid new pass type '${typeof newPass}'`), 'ERR_INVALID_NEW_PASS_TYPE'));\n      }\n\n      if (newPass.length < 20) {\n        return throwDelayed(errcode(new Error(`Invalid pass length ${newPass.length}`), 'ERR_INVALID_PASS_LENGTH'));\n      }\n\n      log('recreating keychain');\n      const oldDek = privates.get(_this11).dek;\n      _this11.opts.pass = newPass;\n      const newDek = newPass ? crypto.pbkdf2(newPass, _this11.opts.dek.salt, _this11.opts.dek.iterationCount, _this11.opts.dek.keyLength, _this11.opts.dek.hash) : '';\n      privates.set(_this11, {\n        dek: newDek\n      });\n      const keys = yield _this11.listKeys();\n\n      for (const key of keys) {\n        const res = yield _this11.store.get(DsName(key.name));\n        const pem = uint8ArrayToString(res);\n        const privateKey = yield crypto.keys.import(pem, oldDek);\n        const password = newDek.toString();\n        const keyAsPEM = yield privateKey.export(password); // Update stored key\n\n        const batch = _this11.store.batch();\n\n        const keyInfo = {\n          name: key.name,\n          id: key.id\n        };\n        batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));\n        batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n        yield batch.commit();\n      }\n\n      log('keychain reconstructed');\n    })();\n  }\n\n}\n\nmodule.exports = Keychain;","map":null,"metadata":{},"sourceType":"script"}