{"ast":null,"code":"'use strict';\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst mafmt = require('mafmt');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  URL\n} = require('iso-url');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/;\nconst pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/;\nconst defaultProtocolMatch = 1;\nconst defaultHashMath = 2; // CID, libp2p-key or DNSLink\n\nconst subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/;\nconst subdomainIdMatch = 1;\nconst subdomainProtocolMatch = 2; // Fully qualified domain name (FQDN) that has an explicit .tld suffix\n\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;\n/**\n * @param {*} hash\n */\n\nfunction isMultihash(hash) {\n  const formatted = convertToString(hash);\n\n  try {\n    Digest.decode(base58btc.decode('z' + formatted));\n  } catch {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {*} hash\n */\n\n\nfunction isBase32EncodedMultibase(hash) {\n  try {\n    base32.decode(hash);\n  } catch {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {*} hash\n */\n\n\nfunction isCID(hash) {\n  try {\n    if (typeof hash === 'string') {\n      return Boolean(CID.parse(hash));\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash));\n    }\n\n    return Boolean(CID.asCID(hash)); // eslint-disable-line no-new\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @param {*} input\n */\n\n\nfunction isMultiaddr(input) {\n  if (!input) return false;\n  if (Multiaddr.isMultiaddr(input)) return true;\n\n  try {\n    new Multiaddr(input); // eslint-disable-line no-new\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\n\n\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.P2P.matches(input);\n}\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\n\n\nfunction isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n\n  let hash = match[hashMatch];\n\n  if (hash && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase();\n  }\n\n  return isCID(hash);\n}\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\n\n\nfunction isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n\n  let ipnsId = match[hashMatch];\n\n  if (ipnsId && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase(); // Check if it is cidv1\n\n    if (isCID(ipnsId)) return true; // Check if it looks like FQDN\n\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org â†’ en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-');\n      } // URL implementation in web browsers forces lowercase of the hostname\n\n\n      const {\n        hostname\n      } = new URL(`http://${ipnsId}`); // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n\n      return fqdnWithTld.test(hostname);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @param {any} input\n */\n\n\nfunction isString(input) {\n  return typeof input === 'string';\n}\n/**\n * @param {Uint8Array | string} input\n */\n\n\nfunction convertToString(input) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc');\n  }\n\n  if (isString(input)) {\n    return input;\n  }\n\n  return false;\n}\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst ipfsSubdomain = url => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst ipnsSubdomain = url => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst subdomain = url => ipfsSubdomain(url) || ipnsSubdomain(url);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst ipfsUrl = url => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst ipnsUrl = url => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst url = url => ipfsUrl(url) || ipnsUrl(url) || subdomain(url);\n/**\n * @param {string | Uint8Array} path\n */\n\n\nconst path = path => isIpfs(path, pathPattern) || isIpns(path, pathPattern);\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n\n  /**\n   * @param {CID | string | Uint8Array} cid\n   */\n  base32cid: cid => isBase32EncodedMultibase(cid) && isCID(cid),\n  ipfsSubdomain,\n  ipnsSubdomain,\n  subdomain,\n  subdomainGatewayPattern,\n  ipfsUrl,\n  ipnsUrl,\n  url,\n  pathGatewayPattern: pathGatewayPattern,\n\n  /**\n   * @param {string | Uint8Array} path\n   */\n  ipfsPath: path => isIpfs(path, pathPattern),\n\n  /**\n   * @param {string | Uint8Array} path\n   */\n  ipnsPath: path => isIpns(path, pathPattern),\n  path,\n  pathPattern,\n\n  /**\n   * @param {string | Uint8Array} x\n   */\n  urlOrPath: x => url(x) || path(x),\n\n  /**\n   * @param {string | Uint8Array | CID} path\n   */\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n};","map":null,"metadata":{},"sourceType":"script"}