{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst CONSTANTS = require('./constants');\n\nconst logger = require('./utils').logger;\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * @param {CID} cid\n */\n\n\nconst unwantEvent = cid => `unwant:${uint8ArrayToString(cid.multihash.bytes, 'base64')}`;\n/**\n * @param {CID} cid\n */\n\n\nconst blockEvent = cid => `block:${uint8ArrayToString(cid.multihash.bytes, 'base64')}`;\n\nclass Notifications extends EventEmitter {\n  /**\n   * Internal module used to track events about incoming blocks,\n   * wants and unwants.\n   *\n   * @param {PeerId} peerId\n   */\n  constructor(peerId) {\n    super();\n    this.setMaxListeners(CONSTANTS.maxListeners);\n    this._log = logger(peerId, 'notif');\n  }\n  /**\n   * Signal the system that we received `block`.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n\n\n  hasBlock(cid, block) {\n    const event = blockEvent(cid);\n\n    this._log(event);\n\n    this.emit(event, block);\n  }\n  /**\n   * Signal the system that we are waiting to receive the\n   * block associated with the given `cid`.\n   * Returns a Promise that resolves to the block when it is received,\n   * or undefined when the block is unwanted.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  wantBlock(cid, options = {}) {\n    if (!cid) {\n      throw new Error('Not a valid cid');\n    }\n\n    const blockEvt = blockEvent(cid);\n    const unwantEvt = unwantEvent(cid);\n\n    this._log(`wantBlock:${cid}`);\n\n    return new Promise((resolve, reject) => {\n      const onUnwant = () => {\n        this.removeListener(blockEvt, onBlock);\n        reject(new Error(`Block for ${cid} unwanted`));\n      };\n      /**\n       * @param {Uint8Array} data\n       */\n\n\n      const onBlock = data => {\n        this.removeListener(unwantEvt, onUnwant);\n        resolve(data);\n      };\n\n      this.once(unwantEvt, onUnwant);\n      this.once(blockEvt, onBlock);\n\n      if (options && options.signal) {\n        options.signal.addEventListener('abort', () => {\n          this.removeListener(blockEvt, onBlock);\n          this.removeListener(unwantEvt, onUnwant);\n          reject(new Error(`Want for ${cid} aborted`));\n        });\n      }\n    });\n  }\n  /**\n   * Signal that the block is not wanted anymore.\n   *\n   * @param {CID} cid - the CID of the block that is not wanted anymore.\n   * @returns {void}\n   */\n\n\n  unwantBlock(cid) {\n    const event = unwantEvent(cid);\n\n    this._log(event);\n\n    this.emit(event);\n  }\n\n}\n\nmodule.exports = Notifications;","map":null,"metadata":{},"sourceType":"script"}