{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst xx_1 = require(\"./handshakes/xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n  } // stage 0\n\n\n  propose() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      logger_1.logLocalStaticKeys(_this.session.hs.s);\n\n      if (_this.isInitiator) {\n        logger_1.logger('Stage 0 - Initiator starting to send first message.');\n\n        const messageBuffer = _this.xx.sendMessage(_this.session, buffer_1.Buffer.alloc(0));\n\n        _this.connection.writeLP(encoder_1.encode0(messageBuffer));\n\n        logger_1.logger('Stage 0 - Initiator finished sending first message.');\n        logger_1.logLocalEphemeralKeys(_this.session.hs.e);\n      } else {\n        logger_1.logger('Stage 0 - Responder waiting to receive first message...');\n        const receivedMessageBuffer = encoder_1.decode0((yield _this.connection.readLP()).slice());\n\n        const {\n          valid\n        } = _this.xx.recvMessage(_this.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('xx handshake stage 0 validation fail');\n        }\n\n        logger_1.logger('Stage 0 - Responder received first message.');\n        logger_1.logRemoteEphemeralKey(_this.session.hs.re);\n      }\n    })();\n  } // stage 1\n\n\n  exchange() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isInitiator) {\n        logger_1.logger('Stage 1 - Initiator waiting to receive first message from responder...');\n        const receivedMessageBuffer = encoder_1.decode1((yield _this2.connection.readLP()).slice());\n\n        const {\n          plaintext,\n          valid\n        } = _this2.xx.recvMessage(_this2.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('xx handshake stage 1 validation fail');\n        }\n\n        logger_1.logger('Stage 1 - Initiator received the message.');\n        logger_1.logRemoteEphemeralKey(_this2.session.hs.re);\n        logger_1.logRemoteStaticKey(_this2.session.hs.rs);\n        logger_1.logger(\"Initiator going to check remote's signature...\");\n\n        try {\n          const decodedPayload = yield utils_1.decodePayload(plaintext);\n          _this2.remotePeer = _this2.remotePeer || (yield utils_1.getPeerIdFromPayload(decodedPayload));\n          _this2.remotePeer = yield utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, _this2.remotePeer);\n\n          _this2.setRemoteEarlyData(decodedPayload.data);\n        } catch (e) {\n          const err = e;\n          throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n        }\n\n        logger_1.logger('All good with the signature!');\n      } else {\n        logger_1.logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n\n        const messageBuffer = _this2.xx.sendMessage(_this2.session, _this2.payload);\n\n        _this2.connection.writeLP(encoder_1.encode1(messageBuffer));\n\n        logger_1.logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n        logger_1.logLocalEphemeralKeys(_this2.session.hs.e);\n      }\n    })();\n  } // stage 2\n\n\n  finish() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3.isInitiator) {\n        logger_1.logger('Stage 2 - Initiator sending third handshake message.');\n\n        const messageBuffer = _this3.xx.sendMessage(_this3.session, _this3.payload);\n\n        _this3.connection.writeLP(encoder_1.encode2(messageBuffer));\n\n        logger_1.logger('Stage 2 - Initiator sent message with signed payload.');\n      } else {\n        logger_1.logger('Stage 2 - Responder waiting for third handshake message...');\n        const receivedMessageBuffer = encoder_1.decode2((yield _this3.connection.readLP()).slice());\n\n        const {\n          plaintext,\n          valid\n        } = _this3.xx.recvMessage(_this3.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('xx handshake stage 2 validation fail');\n        }\n\n        logger_1.logger('Stage 2 - Responder received the message, finished handshake.');\n\n        try {\n          const decodedPayload = yield utils_1.decodePayload(plaintext);\n          _this3.remotePeer = _this3.remotePeer || (yield utils_1.getPeerIdFromPayload(decodedPayload));\n          yield utils_1.verifySignedPayload(_this3.session.hs.rs, decodedPayload, _this3.remotePeer);\n\n          _this3.setRemoteEarlyData(decodedPayload.data);\n        } catch (e) {\n          const err = e;\n          throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n        }\n      }\n\n      logger_1.logCipherState(_this3.session);\n    })();\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n  }\n\n  getRemoteStaticKey() {\n    return this.session.hs.rs;\n  }\n\n  getCS(session, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}\n\nexports.XXHandshake = XXHandshake;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/js-ipfs-examples/examples/browser-angular/node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js"],"names":["Object","defineProperty","exports","value","XXHandshake","buffer_1","require","xx_1","utils_1","logger_1","encoder_1","constructor","isInitiator","payload","prologue","staticKeypair","connection","remotePeer","handshake","xx","XX","session","initSession","remoteEarlyData","Buffer","alloc","propose","logLocalStaticKeys","hs","s","logger","messageBuffer","sendMessage","writeLP","encode0","logLocalEphemeralKeys","e","receivedMessageBuffer","decode0","readLP","slice","valid","recvMessage","Error","logRemoteEphemeralKey","re","exchange","decode1","plaintext","logRemoteStaticKey","rs","decodedPayload","decodePayload","getPeerIdFromPayload","verifySignedPayload","ns","setRemoteEarlyData","data","err","message","encode1","finish","encode2","decode2","logCipherState","encrypt","cs","getCS","encryptWithAd","decrypt","ciphertext","decryptWithAd","getRemoteStaticKey","encryption","cs1","cs2","from","buffer","byteOffset","length"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XXHandshake = void 0;\nconst buffer_1 = require(\"buffer\");\nconst xx_1 = require(\"./handshakes/xx\");\nconst utils_1 = require(\"./utils\");\nconst logger_1 = require(\"./logger\");\nconst encoder_1 = require(\"./encoder\");\nclass XXHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n        this.isInitiator = isInitiator;\n        this.payload = payload;\n        this.prologue = prologue;\n        this.staticKeypair = staticKeypair;\n        this.connection = connection;\n        if (remotePeer) {\n            this.remotePeer = remotePeer;\n        }\n        this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();\n        this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n        this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n    }\n    // stage 0\n    async propose() {\n        logger_1.logLocalStaticKeys(this.session.hs.s);\n        if (this.isInitiator) {\n            logger_1.logger('Stage 0 - Initiator starting to send first message.');\n            const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));\n            this.connection.writeLP(encoder_1.encode0(messageBuffer));\n            logger_1.logger('Stage 0 - Initiator finished sending first message.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('Stage 0 - Responder waiting to receive first message...');\n            const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());\n            const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 0 validation fail');\n            }\n            logger_1.logger('Stage 0 - Responder received first message.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n        }\n    }\n    // stage 1\n    async exchange() {\n        if (this.isInitiator) {\n            logger_1.logger('Stage 1 - Initiator waiting to receive first message from responder...');\n            const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 1 validation fail');\n            }\n            logger_1.logger('Stage 1 - Initiator received the message.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            logger_1.logRemoteStaticKey(this.session.hs.rs);\n            logger_1.logger(\"Initiator going to check remote's signature...\");\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                this.remotePeer = await utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                const err = e;\n                throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n            }\n            logger_1.logger('All good with the signature!');\n        }\n        else {\n            logger_1.logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n            const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode1(messageBuffer));\n            logger_1.logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n    }\n    // stage 2\n    async finish() {\n        if (this.isInitiator) {\n            logger_1.logger('Stage 2 - Initiator sending third handshake message.');\n            const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode2(messageBuffer));\n            logger_1.logger('Stage 2 - Initiator sent message with signed payload.');\n        }\n        else {\n            logger_1.logger('Stage 2 - Responder waiting for third handshake message...');\n            const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 2 validation fail');\n            }\n            logger_1.logger('Stage 2 - Responder received the message, finished handshake.');\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                const err = e;\n                throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n            }\n        }\n        logger_1.logCipherState(this.session);\n    }\n    encrypt(plaintext, session) {\n        const cs = this.getCS(session);\n        return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n    }\n    decrypt(ciphertext, session) {\n        const cs = this.getCS(session, false);\n        return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n    }\n    getRemoteStaticKey() {\n        return this.session.hs.rs;\n    }\n    getCS(session, encryption = true) {\n        if (!session.cs1 || !session.cs2) {\n            throw new Error('Handshake not completed properly, cipher state does not exist.');\n        }\n        if (this.isInitiator) {\n            return encryption ? session.cs1 : session.cs2;\n        }\n        else {\n            return encryption ? session.cs2 : session.cs1;\n        }\n    }\n    setRemoteEarlyData(data) {\n        if (data) {\n            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n        }\n    }\n}\nexports.XXHandshake = XXHandshake;\n"]},"metadata":{},"sourceType":"script"}