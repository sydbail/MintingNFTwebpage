{"ast":null,"code":"import _awaitAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _asyncIterator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport { decode } from '@ipld/dag-pb';\n\nconst hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldHamtDirectoryContent(options = {}) {\n    return listDirectory(node, path, resolve, depth, blockstore, options);\n  }\n\n  return yieldHamtDirectoryContent;\n};\n\nfunction listDirectory(_x, _x2, _x3, _x4, _x5, _x6) {\n  return _listDirectory.apply(this, arguments);\n}\n\nfunction _listDirectory() {\n  _listDirectory = _wrapAsyncGenerator(function* (node, path, resolve, depth, blockstore, options) {\n    const links = node.Links;\n\n    for (const link of links) {\n      const name = link.Name != null ? link.Name.substring(2) : null;\n\n      if (name) {\n        const result = yield _awaitAsyncGenerator(resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, blockstore, options));\n        yield result.entry;\n      } else {\n        const block = yield _awaitAsyncGenerator(blockstore.get(link.Hash));\n        node = decode(block);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(listDirectory(node, path, resolve, depth, blockstore, options)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const file = _value;\n            yield file;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n  });\n  return _listDirectory.apply(this, arguments);\n}\n\nexport default hamtShardedDirectoryContent;","map":null,"metadata":{},"sourceType":"module"}