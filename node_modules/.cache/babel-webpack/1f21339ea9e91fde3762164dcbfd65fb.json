{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst webcrypto = require('../webcrypto');\n\nconst randomBytes = require('../random-bytes');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nexports.utils = require('./rsa-utils');\n\nexports.generateKey = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (bits) {\n    const pair = yield webcrypto.get().subtle.generateKey({\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: {\n        name: 'SHA-256'\n      }\n    }, true, ['sign', 'verify']);\n    const keys = yield exportKey(pair);\n    return {\n      privateKey: keys[0],\n      publicKey: keys[1]\n    };\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}(); // Takes a jwk key\n\n\nexports.unmarshalPrivateKey = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (key) {\n    const privateKey = yield webcrypto.get().subtle.importKey('jwk', key, {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, true, ['sign']);\n    const pair = [privateKey, yield derivePublicFromPrivate(key)];\n    const keys = yield exportKey({\n      privateKey: pair[0],\n      publicKey: pair[1]\n    });\n    return {\n      privateKey: keys[0],\n      publicKey: keys[1]\n    };\n  });\n\n  return function (_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.getRandomValues = randomBytes;\n\nexports.hashAndSign = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (key, msg) {\n    const privateKey = yield webcrypto.get().subtle.importKey('jwk', key, {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, false, ['sign']);\n    const sig = yield webcrypto.get().subtle.sign({\n      name: 'RSASSA-PKCS1-v1_5'\n    }, privateKey, Uint8Array.from(msg));\n    return new Uint8Array(sig, sig.byteOffset, sig.byteLength);\n  });\n\n  return function (_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.hashAndVerify = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (key, sig, msg) {\n    const publicKey = yield webcrypto.get().subtle.importKey('jwk', key, {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, false, ['verify']);\n    return webcrypto.get().subtle.verify({\n      name: 'RSASSA-PKCS1-v1_5'\n    }, publicKey, sig, msg);\n  });\n\n  return function (_x5, _x6, _x7) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nfunction exportKey(pair) {\n  return Promise.all([webcrypto.get().subtle.exportKey('jwk', pair.privateKey), webcrypto.get().subtle.exportKey('jwk', pair.publicKey)]);\n}\n\nfunction derivePublicFromPrivate(jwKey) {\n  return webcrypto.get().subtle.importKey('jwk', {\n    kty: jwKey.kty,\n    n: jwKey.n,\n    e: jwKey.e\n  }, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['verify']);\n}\n/*\n\nRSA encryption/decryption for the browser with webcrypto workarround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg Uint8Array to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our Uint8Array a binary string\n  - Convert resulting nodeForge buffer to Uint8Array: it returns a binary string, turn that into a Uint8Array\n\n*/\n\n\nconst {\n  jwk2pub,\n  jwk2priv\n} = require('./jwk2pem');\n\nfunction convertKey(key, pub, msg, handle) {\n  const fkey = pub ? jwk2pub(key) : jwk2priv(key);\n  const fmsg = uint8ArrayToString(Uint8Array.from(msg), 'ascii');\n  const fomsg = handle(fmsg, fkey);\n  return uint8ArrayFromString(fomsg, 'ascii');\n}\n\nexports.encrypt = function (key, msg) {\n  return convertKey(key, true, msg, (msg, key) => key.encrypt(msg));\n};\n\nexports.decrypt = function (key, msg) {\n  return convertKey(key, false, msg, (msg, key) => key.decrypt(msg));\n};","map":null,"metadata":{},"sourceType":"script"}