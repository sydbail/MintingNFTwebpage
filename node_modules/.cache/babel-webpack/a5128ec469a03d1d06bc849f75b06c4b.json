{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst log = require('debug')('ipfs:repo:gc');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst parallelBatch = require('it-parallel-batch');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst merge = require('it-merge');\n\nconst map = require('it-map');\n\nconst filter = require('it-filter');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst walkDag = require('./utils/walk-dag'); // Limit on the number of parallel block remove operations\n\n\nconst BLOCK_RM_CONCURRENCY = 256;\nconst MFS_ROOT_KEY = new Key('/local/filesroot');\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\nmodule.exports = ({\n  gcLock,\n  pins,\n  blockstore,\n  root,\n  loadCodec\n}) => {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  function gc() {\n    return _gc.apply(this, arguments);\n  }\n\n  function _gc() {\n    _gc = _wrapAsyncGenerator(function* () {\n      const start = Date.now();\n      log('Creating set of marked blocks');\n      const release = yield _awaitAsyncGenerator(gcLock.writeLock());\n\n      try {\n        // Mark all blocks that are being used\n        const markedSet = yield _awaitAsyncGenerator(createMarkedSet({\n          pins,\n          blockstore,\n          root,\n          loadCodec\n        })); // Get all blocks keys from the blockstore\n\n        const blockKeys = blockstore.queryKeys({}); // Delete blocks that are not being used\n        // @ts-ignore ts cannot tell that we filter out null results\n\n        yield* _asyncGeneratorDelegate(_asyncIterator(deleteUnmarkedBlocks({\n          blockstore\n        }, markedSet, blockKeys)), _awaitAsyncGenerator);\n        log(`Complete (${Date.now() - start}ms)`);\n      } finally {\n        release();\n      }\n    });\n    return _gc.apply(this, arguments);\n  }\n\n  return gc;\n};\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\n\nfunction createMarkedSet(_x4) {\n  return _createMarkedSet.apply(this, arguments);\n}\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\n\n\nfunction _createMarkedSet() {\n  _createMarkedSet = _asyncToGenerator(function* ({\n    pins,\n    blockstore,\n    loadCodec,\n    root\n  }) {\n    const mfsSource = _wrapAsyncGenerator(function* () {\n      let mh;\n\n      try {\n        mh = yield _awaitAsyncGenerator(root.get(MFS_ROOT_KEY));\n      } catch (err) {\n        if (err.code === ERR_NOT_FOUND) {\n          log('No blocks in MFS');\n          return;\n        }\n\n        throw err;\n      }\n\n      const rootCid = CID.decode(mh);\n      yield rootCid;\n      yield* _asyncGeneratorDelegate(_asyncIterator(walkDag(rootCid, blockstore, loadCodec)), _awaitAsyncGenerator);\n    })();\n\n    const pinsSource = merge(map(pins.recursiveKeys(), ({\n      cid\n    }) => cid), pins.indirectKeys(), map(pins.directKeys(), ({\n      cid\n    }) => cid), mfsSource);\n    const output = new Set();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(merge(pinsSource, mfsSource)), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const cid = _value;\n        output.add(base32.encode(cid.multihash.bytes));\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return output;\n  });\n  return _createMarkedSet.apply(this, arguments);\n}\n\nfunction deleteUnmarkedBlocks(_x, _x2, _x3) {\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}\n\nfunction _deleteUnmarkedBlocks() {\n  _deleteUnmarkedBlocks = _wrapAsyncGenerator(function* ({\n    blockstore\n  }, markedSet, blockKeys) {\n    // Iterate through all blocks and find those that are not in the marked set\n    // blockKeys yields { key: Key() }\n    let blocksCount = 0;\n    let removedBlocksCount = 0;\n    /**\n     * @param {CID} cid\n     */\n\n    const removeBlock = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (cid) {\n        return /*#__PURE__*/function () {\n          var _remove = _asyncToGenerator(function* () {\n            blocksCount++;\n\n            try {\n              const b32 = base32.encode(cid.multihash.bytes);\n\n              if (markedSet.has(b32)) {\n                return null;\n              }\n\n              try {\n                yield blockstore.delete(cid);\n                removedBlocksCount++;\n              } catch (err) {\n                return {\n                  err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n                };\n              }\n\n              return {\n                cid\n              };\n            } catch (err) {\n              const msg = `Could delete block with CID ${cid}`;\n              log(msg, err);\n              return {\n                err: new Error(msg + `: ${err.message}`)\n              };\n            }\n          });\n\n          function remove() {\n            return _remove.apply(this, arguments);\n          }\n\n          return remove;\n        }();\n      });\n\n      return function removeBlock(_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    yield* _asyncGeneratorDelegate(_asyncIterator(pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), // filter nulls (blocks that were retained)\n    source => filter(source, Boolean))), _awaitAsyncGenerator);\n    log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n  });\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}