{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst {\n  exporter\n} = require('ipfs-unixfs-exporter');\n\nconst log = require('debug')('ipfs:mfs:stat');\n\nconst errCode = require('err-code');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst dagPb = require('@ipld/dag-pb');\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} withLocal\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  withLocal: false\n};\n/**\n * @typedef {import('ipfs-core-types/src/files').StatResult} StatResult\n */\n\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"stat\"]}\n   */\n  function mfsStat(_x) {\n    return _mfsStat.apply(this, arguments);\n  }\n\n  function _mfsStat() {\n    _mfsStat = _asyncToGenerator(function* (path, options = {}) {\n      /** @type {DefaultOptions} */\n      options = mergeOptions(defaultOptions, options);\n      log(`Fetching stats for ${path}`);\n      const {\n        type,\n        cid,\n        mfsPath\n      } = yield toMfsPath(context, path, options);\n      const exportPath = type === 'ipfs' && cid ? cid : mfsPath;\n      let file;\n\n      try {\n        file = yield exporter(exportPath, context.repo.blocks);\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n        }\n\n        throw err;\n      }\n\n      if (!statters[file.type]) {\n        throw new Error(`Cannot stat codec ${file.cid.code}`);\n      }\n\n      return statters[file.type](file);\n    });\n    return _mfsStat.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsStat);\n};\n/** @type {Record<string, (file:any) => StatResult>} */\n\n\nconst statters = {\n  /**\n   * @param {import('ipfs-unixfs-exporter').RawNode} file\n   */\n  raw: file => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n\n  /**\n   * @param {import('ipfs-unixfs-exporter').UnixFSFile} file\n   */\n  file: file => {\n    /** @type {StatResult} */\n    const stat = {\n      cid: file.cid,\n      type: 'file',\n      size: file.unixfs.fileSize(),\n      cumulativeSize: dagPb.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),\n      blocks: file.unixfs.blockSizes.length,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false,\n      mode: file.unixfs.mode\n    };\n\n    if (file.unixfs.mtime) {\n      stat.mtime = file.unixfs.mtime;\n    }\n\n    return stat;\n  },\n\n  /**\n   * @param {import('ipfs-unixfs-exporter').UnixFSDirectory} file\n   */\n  directory: file => {\n    /** @type {StatResult} */\n    const stat = {\n      cid: file.cid,\n      type: 'directory',\n      size: 0,\n      cumulativeSize: dagPb.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),\n      blocks: file.node.Links.length,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false,\n      mode: file.unixfs.mode\n    };\n\n    if (file.unixfs.mtime) {\n      stat.mtime = file.unixfs.mtime;\n    }\n\n    return stat;\n  },\n\n  /**\n   * @param {import('ipfs-unixfs-exporter').ObjectNode} file\n   */\n  object: file => {\n    /** @type {StatResult} */\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      type: 'file',\n      // for go compatibility\n      blocks: 0,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n\n  /**\n   * @param {import('ipfs-unixfs-exporter').IdentityNode} file\n   */\n  identity: file => {\n    /** @type {StatResult} */\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  }\n};","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/ipfs-core/src/components/files/stat.js"],"names":["mergeOptions","require","bind","ignoreUndefined","toMfsPath","exporter","log","errCode","withTimeoutOption","dagPb","defaultOptions","withLocal","module","exports","context","mfsStat","path","options","type","cid","mfsPath","exportPath","file","repo","blocks","err","code","Error","statters","raw","size","node","length","cumulativeSize","local","undefined","sizeLocal","withLocality","stat","unixfs","fileSize","encode","Links","reduce","acc","curr","Tsize","blockSizes","mode","mtime","directory","object","identity"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst toMfsPath = require('./utils/to-mfs-path')\nconst { exporter } = require('ipfs-unixfs-exporter')\nconst log = require('debug')('ipfs:mfs:stat')\nconst errCode = require('err-code')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst dagPb = require('@ipld/dag-pb')\n\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} withLocal\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  withLocal: false\n}\n\n/**\n * @typedef {import('ipfs-core-types/src/files').StatResult} StatResult\n */\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"stat\"]}\n   */\n  async function mfsStat (path, options = {}) {\n    /** @type {DefaultOptions} */\n    options = mergeOptions(defaultOptions, options)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      type,\n      cid,\n      mfsPath\n    } = await toMfsPath(context, path, options)\n\n    const exportPath = type === 'ipfs' && cid ? cid : mfsPath\n    let file\n\n    try {\n      file = await exporter(exportPath, context.repo.blocks)\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n      }\n\n      throw err\n    }\n\n    if (!statters[file.type]) {\n      throw new Error(`Cannot stat codec ${file.cid.code}`)\n    }\n\n    return statters[file.type](file)\n  }\n\n  return withTimeoutOption(mfsStat)\n}\n\n/** @type {Record<string, (file:any) => StatResult>} */\nconst statters = {\n  /**\n   * @param {import('ipfs-unixfs-exporter').RawNode} file\n   */\n  raw: (file) => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file', // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  },\n  /**\n   * @param {import('ipfs-unixfs-exporter').UnixFSFile} file\n   */\n  file: (file) => {\n    /** @type {StatResult} */\n    const stat = {\n      cid: file.cid,\n      type: 'file',\n      size: file.unixfs.fileSize(),\n      cumulativeSize: dagPb.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),\n      blocks: file.unixfs.blockSizes.length,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false,\n      mode: file.unixfs.mode\n    }\n\n    if (file.unixfs.mtime) {\n      stat.mtime = file.unixfs.mtime\n    }\n\n    return stat\n  },\n  /**\n   * @param {import('ipfs-unixfs-exporter').UnixFSDirectory} file\n   */\n  directory: (file) => {\n    /** @type {StatResult} */\n    const stat = {\n      cid: file.cid,\n      type: 'directory',\n      size: 0,\n      cumulativeSize: dagPb.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),\n      blocks: file.node.Links.length,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false,\n      mode: file.unixfs.mode\n    }\n\n    if (file.unixfs.mtime) {\n      stat.mtime = file.unixfs.mtime\n    }\n\n    return stat\n  },\n  /**\n   * @param {import('ipfs-unixfs-exporter').ObjectNode} file\n   */\n  object: (file) => {\n    /** @type {StatResult} */\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      type: 'file', // for go compatibility\n      blocks: 0,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  },\n  /**\n   * @param {import('ipfs-unixfs-exporter').IdentityNode} file\n   */\n  identity: (file) => {\n    /** @type {StatResult} */\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file', // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}