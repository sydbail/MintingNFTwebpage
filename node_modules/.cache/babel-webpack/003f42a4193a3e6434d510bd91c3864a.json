{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Noise = void 0;\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst it_pb_rpc_1 = __importDefault(require(\"it-pb-rpc\"));\n\nconst duplex_1 = __importDefault(require(\"it-pair/duplex\"));\n\nconst it_buffer_1 = __importDefault(require(\"it-buffer\"));\n\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\n\nconst it_length_prefixed_1 = require(\"it-length-prefixed\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst handshake_ik_1 = require(\"./handshake-ik\");\n\nconst handshake_xx_fallback_1 = require(\"./handshake-xx-fallback\");\n\nconst utils_1 = require(\"./utils\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst crypto_1 = require(\"./crypto\");\n\nconst keycache_1 = require(\"./keycache\");\n\nconst logger_1 = require(\"./logger\");\n\nconst constants_1 = require(\"./constants\");\n\nclass Noise {\n  /**\n   *\n   * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n   * @param {bytes} earlyData\n   */\n  constructor(staticNoiseKey, earlyData) {\n    this.protocol = '/noise';\n    this.prologue = buffer_1.Buffer.alloc(0);\n    this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0); // disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),\n        publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)\n      };\n    } else {\n      this.staticKeys = utils_1.generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {any} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  secureOutbound(localPeer, connection, remotePeer) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const wrappedConnection = it_pb_rpc_1.default(connection, {\n        lengthEncoder: encoder_1.uint16BEEncode,\n        lengthDecoder: encoder_1.uint16BEDecode,\n        maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n      });\n      const handshake = yield _this.performHandshake({\n        connection: wrappedConnection,\n        isInitiator: true,\n        localPeer,\n        remotePeer\n      });\n      const conn = yield _this.createSecureConnection(wrappedConnection, handshake);\n      return {\n        conn,\n        remoteEarlyData: handshake.remoteEarlyData,\n        remotePeer: handshake.remotePeer\n      };\n    })();\n  }\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {any} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  secureInbound(localPeer, connection, remotePeer) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const wrappedConnection = it_pb_rpc_1.default(connection, {\n        lengthEncoder: encoder_1.uint16BEEncode,\n        lengthDecoder: encoder_1.uint16BEDecode,\n        maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n      });\n      const handshake = yield _this2.performHandshake({\n        connection: wrappedConnection,\n        isInitiator: false,\n        localPeer,\n        remotePeer\n      });\n      const conn = yield _this2.createSecureConnection(wrappedConnection, handshake);\n      return {\n        conn,\n        remoteEarlyData: handshake.remoteEarlyData,\n        remotePeer: handshake.remotePeer\n      };\n    })();\n  }\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   *\n   * @param {HandshakeParams} params\n   */\n\n\n  performHandshake(params) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const payload = yield utils_1.getPayload(params.localPeer, _this3.staticKeys.publicKey, _this3.earlyData);\n      let tryIK = _this3.useNoisePipes;\n\n      if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {\n        // if we are initiator and remote static key is unknown, don't try IK\n        tryIK = false;\n      } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n      if (tryIK) {\n        // Try IK first\n        const {\n          remotePeer,\n          connection,\n          isInitiator\n        } = params;\n        const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, _this3.prologue, _this3.staticKeys, connection, // safe to cast as we did checks\n        (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);\n\n        try {\n          return yield _this3.performIKHandshake(ikHandshake);\n        } catch (e) {\n          // IK failed, go to XX fallback\n          let ephemeralKeys;\n\n          if (params.isInitiator) {\n            ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n          }\n\n          return yield _this3.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n        }\n      } else {\n        // run XX handshake\n        return yield _this3.performXXHandshake(params, payload);\n      }\n    })();\n  }\n\n  performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        isInitiator,\n        remotePeer,\n        connection\n      } = params;\n      const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, _this4.prologue, _this4.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n      try {\n        yield handshake.propose();\n        yield handshake.exchange();\n        yield handshake.finish();\n      } catch (e) {\n        logger_1.logger(e);\n        const err = e;\n        throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);\n      }\n\n      return handshake;\n    })();\n  }\n\n  performXXHandshake(params, payload) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        isInitiator,\n        remotePeer,\n        connection\n      } = params;\n      const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, _this5.prologue, _this5.staticKeys, connection, remotePeer);\n\n      try {\n        yield handshake.propose();\n        yield handshake.exchange();\n        yield handshake.finish();\n\n        if (_this5.useNoisePipes && handshake.remotePeer) {\n          keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n        }\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred during XX handshake: ${err.message}`);\n      }\n\n      return handshake;\n    })();\n  }\n\n  performIKHandshake(handshake) {\n    return _asyncToGenerator(function* () {\n      yield handshake.stage0();\n      yield handshake.stage1();\n      return handshake;\n    })();\n  }\n\n  createSecureConnection(connection, handshake) {\n    return _asyncToGenerator(function* () {\n      // Create encryption box/unbox wrapper\n      const [secure, user] = duplex_1.default();\n      const network = connection.unwrap();\n      yield it_pipe_1.default(secure, // write to wrapper\n      it_buffer_1.default, // ensure any type of data is converted to buffer\n      crypto_1.encryptStream(handshake), // data is encrypted\n      it_length_prefixed_1.encode({\n        lengthEncoder: encoder_1.uint16BEEncode\n      }), // prefix with message length\n      network, // send to the remote peer\n      it_length_prefixed_1.decode({\n        lengthDecoder: encoder_1.uint16BEDecode\n      }), // read message length prefix\n      it_buffer_1.default, // ensure any type of data is converted to buffer\n      crypto_1.decryptStream(handshake), // decrypt the incoming data\n      secure // pipe to the wrapper\n      );\n      return user;\n    })();\n  }\n\n}\n\nexports.Noise = Noise; //# sourceMappingURL=noise.js.map","map":null,"metadata":{},"sourceType":"script"}