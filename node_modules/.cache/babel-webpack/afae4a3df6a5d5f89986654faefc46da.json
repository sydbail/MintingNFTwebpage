{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst WantManager = require('./want-manager');\n\nconst Network = require('./network');\n\nconst DecisionEngine = require('./decision-engine');\n\nconst Notifications = require('./notifications');\n\nconst logger = require('./utils').logger;\n\nconst Stats = require('./stats');\n\nconst {\n  AbortController\n} = require('native-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst {\n  BlockstoreAdapter\n} = require('interface-blockstore');\n\nconst {\n  CID\n} = require('multiformats');\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types/message')} BitswapMessage\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\n\nclass Bitswap extends BlockstoreAdapter {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {Blockstore} blockstore\n   * @param {Object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor(libp2p, blockstore, options = {}) {\n    super();\n    this._libp2p = libp2p;\n    this._log = logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, this._stats, {\n      hashers: options.hashers\n    }); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerId, this.network, this._stats);\n    this.notifications = new Notifications(this.peerId);\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * @type {PeerId}\n   */\n\n\n  get peerId() {\n    return this._libp2p.peerId;\n  }\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n\n\n  _receiveMessage(peerId, incoming) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // Note: this allows the engine to respond to any wants in the message.\n        // Processing of the blocks in the message happens below, after the\n        // blocks have been added to the blockstore.\n        yield _this3.engine.messageReceived(peerId, incoming);\n      } catch (err) {\n        // Log instead of throwing an error so as to process as much as\n        // possible of the message. Currently `messageReceived` does not\n        // throw any errors, but this could change in the future.\n        _this3._log('failed to receive message', incoming);\n      }\n\n      if (incoming.blocks.size === 0) {\n        return;\n      }\n      /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n\n\n      const received = [];\n\n      for (const [cidStr, data] of incoming.blocks.entries()) {\n        const cid = CID.parse(cidStr);\n        received.push({\n          wasWanted: _this3.wm.wantlist.contains(cid),\n          cid,\n          data\n        });\n      } // quickly send out cancels, reduces chances of duplicate block receives\n\n\n      _this3.wm.cancelWants(received.filter(({\n        wasWanted\n      }) => wasWanted).map(({\n        cid\n      }) => cid));\n\n      yield Promise.all(received.map(({\n        cid,\n        wasWanted,\n        data\n      }) => _this3._handleReceivedBlock(peerId, cid, data, wasWanted)));\n    })();\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n\n\n  _handleReceivedBlock(peerId, cid, data, wasWanted) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4._log('received block');\n\n      const has = yield _this4.blockstore.has(cid);\n\n      _this4._updateReceiveCounters(peerId.toB58String(), cid, data, has);\n\n      if (!wasWanted) {\n        return;\n      }\n\n      yield _this4.put(cid, data);\n    })();\n  }\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n\n\n  _updateReceiveCounters(peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1);\n\n    this._stats.push(peerIdStr, 'dataReceived', data.length);\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n    }\n  }\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n\n\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  }\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  }\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n\n    this._stats.disconnected(peerId);\n  }\n\n  enableStats() {\n    this._stats.enable();\n  }\n\n  disableStats() {\n    this._stats.disable();\n  }\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n\n\n  wantlistForPeer(peerId, _options) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  get(cid, options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      /**\n       * @param {CID} cid\n       * @param {Object} options\n       * @param {AbortSignal} options.signal\n       */\n      const fetchFromNetwork = (cid, options) => {\n        // add it to the want list - n.b. later we will abort the AbortSignal\n        // so no need to remove the blocks from the wantlist after we have it\n        _this5.wm.wantBlocks([cid], options);\n\n        return _this5.notifications.wantBlock(cid, options);\n      };\n\n      let promptedNetwork = false;\n      /**\n       *\n       * @param {CID} cid\n       * @param {Object} options\n       * @param {AbortSignal} options.signal\n       */\n\n      const loadOrFetchFromNetwork = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (cid, options) {\n          try {\n            // have to await here as we want to handle ERR_NOT_FOUND\n            const block = yield _this5.blockstore.get(cid, options);\n            return block;\n          } catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n              throw err;\n            }\n\n            if (!promptedNetwork) {\n              promptedNetwork = true;\n\n              _this5.network.findAndConnect(cid).catch(err => _this5._log.error(err));\n            } // we don't have the block locally so fetch it from the network\n\n\n            return fetchFromNetwork(cid, options);\n          }\n        });\n\n        return function loadOrFetchFromNetwork(_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }(); // depending on implementation it's possible for blocks to come in while\n      // we do the async operations to get them from the blockstore leading to\n      // a race condition, so register for incoming block notifications as well\n      // as trying to get it from the datastore\n\n\n      const controller = new AbortController();\n      const signal = options.signal ? anySignal([options.signal, controller.signal]) : controller.signal;\n      const block = yield Promise.race([_this5.notifications.wantBlock(cid, {\n        signal\n      }), loadOrFetchFromNetwork(cid, {\n        signal\n      })]); // since we have the block we can now remove our listener\n\n      controller.abort();\n      return block;\n    })();\n  }\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  getMany(cids, options = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(cids), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const cid = _value;\n          yield _this.get(cid, options);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n\n\n  unwant(cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids];\n    this.wm.unwantBlocks(cidsArray);\n    cidsArray.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n\n\n  cancelWants(cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n  }\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n\n\n  put(cid, block, _options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6.blockstore.put(cid, block);\n\n      _this6._sendHaveBlockNotifications(cid, block);\n    })();\n  }\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n\n\n  putMany(source, options) {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this2.blockstore.putMany(source, options)), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const {\n            key,\n            value\n          } = _value2;\n\n          _this2._sendHaveBlockNotifications(key, value);\n\n          yield {\n            key,\n            value\n          };\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n\n\n  _sendHaveBlockNotifications(cid, data) {\n    this.notifications.hasBlock(cid, data);\n    this.engine.receivedBlocks([{\n      cid,\n      data\n    }]); // Note: Don't wait for provide to finish before returning\n\n    this.network.provide(cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n  /**\n   * Get the current list of wants\n   */\n\n\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n  /**\n   * Get the current list of partners\n   */\n\n\n  peers() {\n    return this.engine.peers();\n  }\n  /**\n   * Get stats about the bitswap node\n   */\n\n\n  stat() {\n    return this._stats;\n  }\n  /**\n   * Start the bitswap node\n   */\n\n\n  start() {\n    this.wm.start();\n    this.network.start();\n    this.engine.start();\n    this.started = true;\n  }\n  /**\n   * Stop the bitswap node\n   */\n\n\n  stop() {\n    this._stats.stop();\n\n    this.wm.stop();\n    this.network.stop();\n    this.engine.stop();\n    this.started = false;\n  }\n\n  unwrap() {\n    return this.blockstore;\n  }\n\n}\n\nmodule.exports = Bitswap;","map":null,"metadata":{},"sourceType":"script"}