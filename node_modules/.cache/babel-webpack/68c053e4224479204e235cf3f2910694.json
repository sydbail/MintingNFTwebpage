{"ast":null,"code":"import _asyncToGenerator from \"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Bucket, createHAMT } from 'hamt-sharding';\nimport { decode } from '@ipld/dag-pb';\nimport { murmur3128 } from '@multiformats/murmur3';\n\nconst hashFn = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (buf) {\n    return (yield murmur3128.encode(buf)).slice(0, 8).reverse();\n  });\n\n  return function hashFn(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      throw new Error('Unexpected Link without a Name');\n    }\n\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nconst findShardCid = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (node, name, blockstore, context, options) {\n    if (!context) {\n      const rootBucket = createHAMT({\n        hashFn\n      });\n      context = {\n        rootBucket,\n        hamtDepth: 1,\n        lastBucket: rootBucket\n      };\n    }\n\n    yield addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n    const position = yield context.rootBucket._findNewBucketAndPos(name);\n    let prefix = toPrefix(position.pos);\n    const bucketPath = toBucketPath(position);\n\n    if (bucketPath.length > context.hamtDepth) {\n      context.lastBucket = bucketPath[context.hamtDepth];\n      prefix = toPrefix(context.lastBucket._posAtParent);\n    }\n\n    const link = node.Links.find(link => {\n      if (link.Name == null) {\n        return false;\n      }\n\n      const entryPrefix = link.Name.substring(0, 2);\n      const entryName = link.Name.substring(2);\n\n      if (entryPrefix !== prefix) {\n        return false;\n      }\n\n      if (entryName && entryName !== name) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!link) {\n      return null;\n    }\n\n    if (link.Name != null && link.Name.substring(2) === name) {\n      return link.Hash;\n    }\n\n    context.hamtDepth++;\n    const block = yield blockstore.get(link.Hash, options);\n    node = decode(block);\n    return findShardCid(node, name, blockstore, context, options);\n  });\n\n  return function findShardCid(_x2, _x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexport default findShardCid;","map":null,"metadata":{},"sourceType":"module"}