{"ast":null,"code":"'use strict';\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nvar _asyncGeneratorDelegate = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\").default;\n\nconst {\n  exporter\n} = require('ipfs-unixfs-exporter');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst map = require('it-map');\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('ipfs-core-types/src/files').MFSEntry} MFSEntry\n */\n\n/**\n * @param {import('ipfs-unixfs-exporter').UnixFSEntry} fsEntry\n */\n\n\nconst toOutput = fsEntry => {\n  /** @type {MFSEntry} */\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: fsEntry.type === 'directory' ? 'directory' : 'file',\n    size: fsEntry.size\n  };\n\n  if (fsEntry.type === 'file' || fsEntry.type === 'directory') {\n    output.mode = fsEntry.unixfs.mode;\n    output.mtime = fsEntry.unixfs.mtime;\n  }\n\n  return output;\n};\n/**\n * @param {MfsContext} context\n */\n\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"ls\"]}\n   */\n  function mfsLs(_x) {\n    return _mfsLs.apply(this, arguments);\n  }\n\n  function _mfsLs() {\n    _mfsLs = _wrapAsyncGenerator(function* (path, options = {}) {\n      const mfsPath = yield _awaitAsyncGenerator(toMfsPath(context, path, options));\n      const fsEntry = yield _awaitAsyncGenerator(exporter(mfsPath.mfsPath, context.repo.blocks)); // directory, perhaps sharded\n\n      if (fsEntry.type === 'directory') {\n        yield* _asyncGeneratorDelegate(_asyncIterator(map(fsEntry.content(options), toOutput)), _awaitAsyncGenerator);\n        return;\n      } // single file/node\n\n\n      yield toOutput(fsEntry);\n    });\n    return _mfsLs.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsLs);\n};","map":null,"metadata":{},"sourceType":"script"}