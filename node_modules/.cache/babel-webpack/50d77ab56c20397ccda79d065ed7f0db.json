{"ast":null,"code":"'use strict';\n\nvar _awaitAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\").default;\n\nvar _wrapAsyncGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\").default;\n\nvar _asyncIterator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncIterator\").default;\n\nconst {\n  importer\n} = require('ipfs-unixfs-importer');\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/files/normalise-input/index');\n\nconst {\n  parseChunkerString\n} = require('./utils');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-unixfs-importer').ImportResult} ImportResult\n */\n\n/**\n * @typedef {Object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../../types').Preload} preload\n * @property {import('ipfs-core-types/src/root').ShardingOptions} [options]\n *\n * @param {Context} context\n */\n\n\nmodule.exports = ({\n  repo,\n  preload,\n  options\n}) => {\n  const isShardingEnabled = options && options.sharding;\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"addAll\"]}\n   */\n\n  function addAll(_x) {\n    return _addAll.apply(this, arguments);\n  }\n\n  function _addAll() {\n    _addAll = _wrapAsyncGenerator(function* (source, options = {}) {\n      const opts = mergeOptions({\n        shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n        strategy: 'balanced'\n      }, options, { ...parseChunkerString(options.chunker)\n      }); // CID v0 is for multihashes encoded with sha2-256\n\n      if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n        opts.cidVersion = 1;\n      }\n\n      if (opts.trickle) {\n        opts.strategy = 'trickle';\n      }\n\n      if (opts.strategy === 'trickle') {\n        opts.leafType = 'raw';\n        opts.reduceSingleLeafToSelf = false;\n      }\n\n      if (opts.cidVersion > 0 && opts.rawLeaves === undefined) {\n        // if the cid version is 1 or above, use raw leaves as this is\n        // what go does.\n        opts.rawLeaves = true;\n      }\n\n      if (opts.hashAlg !== undefined && opts.rawLeaves === undefined) {\n        // if a non-default hash alg has been specified, use raw leaves as this is\n        // what go does.\n        opts.rawLeaves = true;\n      }\n\n      delete opts.trickle;\n      /** @type {Record<string, number>} */\n\n      const totals = {};\n\n      if (opts.progress) {\n        const prog = opts.progress;\n        /**\n         * @param {number} bytes\n         * @param {string} path\n         */\n\n        opts.progress = (bytes, path) => {\n          if (!totals[path]) {\n            totals[path] = 0;\n          }\n\n          totals[path] += bytes;\n          prog(totals[path], path);\n        };\n      }\n\n      const iterator = pipe(normaliseInput(source),\n      /**\n       * @param {AsyncIterable<import('ipfs-unixfs-importer').ImportCandidate>} source\n       */\n      source => importer(source, repo.blocks, { ...opts,\n        pin: false\n      }), transformFile(opts), preloadFile(preload, opts), pinFile(repo, opts));\n      const releaseLock = yield _awaitAsyncGenerator(repo.gcLock.readLock());\n\n      try {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(iterator), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const added = _value;\n            // do not keep file totals around forever\n            delete totals[added.path];\n            yield added;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } finally {\n        releaseLock();\n      }\n    });\n    return _addAll.apply(this, arguments);\n  }\n\n  return withTimeoutOption(addAll);\n};\n/**\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\n\n\nfunction transformFile(opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  function transformFile(_x2) {\n    return _transformFile.apply(this, arguments);\n  }\n\n  function _transformFile() {\n    _transformFile = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const file = _value2;\n          let cid = file.cid;\n\n          if (opts.cidVersion === 1) {\n            cid = cid.toV1();\n          }\n\n          let path = file.path ? file.path : cid.toString();\n\n          if (opts.wrapWithDirectory && !file.path) {\n            path = '';\n          }\n\n          yield {\n            path,\n            cid: cid,\n            size: file.size,\n            mode: file.unixfs && file.unixfs.mode,\n            mtime: file.unixfs && file.unixfs.mtime\n          };\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n    return _transformFile.apply(this, arguments);\n  }\n\n  return transformFile;\n}\n/**\n * @param {(cid: CID) => void} preload\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\n\n\nfunction preloadFile(preload, opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  function maybePreloadFile(_x3) {\n    return _maybePreloadFile.apply(this, arguments);\n  }\n\n  function _maybePreloadFile() {\n    _maybePreloadFile = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(source), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const file = _value3;\n          const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n          const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n\n          if (shouldPreload) {\n            preload(file.cid);\n          }\n\n          yield file;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            yield _awaitAsyncGenerator(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    });\n    return _maybePreloadFile.apply(this, arguments);\n  }\n\n  return maybePreloadFile;\n}\n/**\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\n\n\nfunction pinFile(repo, opts) {\n  /**\n   * @param {AsyncGenerator<ImportResult, void, undefined>} source\n   */\n  function maybePinFile(_x4) {\n    return _maybePinFile.apply(this, arguments);\n  }\n\n  function _maybePinFile() {\n    _maybePinFile = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n\n      var _iteratorError4;\n\n      try {\n        for (var _iterator4 = _asyncIterator(source), _step4, _value4; _step4 = yield _awaitAsyncGenerator(_iterator4.next()), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _awaitAsyncGenerator(_step4.value), !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {\n          const file = _value4;\n          // Pin a file if it is the root dir of a recursive add or the single file\n          // of a direct add.\n          const isRootDir = !(file.path && file.path.includes('/'));\n          const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;\n\n          if (shouldPin) {\n            yield _awaitAsyncGenerator(repo.pins.pinRecursively(file.cid));\n          }\n\n          yield file;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            yield _awaitAsyncGenerator(_iterator4.return());\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    });\n    return _maybePinFile.apply(this, arguments);\n  }\n\n  return maybePinFile;\n}","map":null,"metadata":{},"sourceType":"script"}