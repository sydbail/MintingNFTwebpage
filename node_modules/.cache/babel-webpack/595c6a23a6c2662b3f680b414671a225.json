{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst BufferList = require('bl/BufferList');\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nconst errCode = require('err-code');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst first = require('it-first');\n\nconst NewLine = uint8ArrayFromString('\\n');\n\nexports.encode = buffer => lp.encode.single(new BufferList([buffer, NewLine])); // `write` encodes and writes a single buffer\n\n\nexports.write = (writer, buffer) => writer.push(exports.encode(buffer)); // `writeAll` behaves like `write`, except it encodes an array of items as a single write\n\n\nexports.writeAll = (writer, buffers) => {\n  writer.push(buffers.reduce((bl, buffer) => bl.append(exports.encode(buffer)), new BufferList()));\n};\n\nexports.read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (reader) {\n    let byteLength = 1; // Read single byte chunks until the length is known\n\n    const varByteSource = {\n      // No return impl - we want the reader to remain readable\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      next: () => reader.next(byteLength)\n    }; // Once the length has been parsed, read chunk for that length\n\n    const onLength = l => {\n      byteLength = l;\n    };\n\n    const buf = yield pipe(varByteSource, lp.decode({\n      onLength\n    }), first);\n\n    if (buf.get(buf.length - 1) !== NewLine[0]) {\n      throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n    }\n\n    return buf.shallowSlice(0, -1); // Remove newline\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/sydneybailey/Internship/contract-testing/node_modules/multistream-select/src/multistream.js"],"names":["BufferList","require","lp","pipe","errCode","fromString","uint8ArrayFromString","first","NewLine","exports","encode","buffer","single","write","writer","push","writeAll","buffers","reduce","bl","append","read","reader","byteLength","varByteSource","Symbol","asyncIterator","next","onLength","l","buf","decode","get","length","Error","shallowSlice"],"mappings":"AAAA;;;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,oBAAD,CAAlB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,SAAD,CAApB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEI,EAAAA,UAAU,EAAEC;AAAd,IAAuCL,OAAO,CAAC,yBAAD,CAApD;;AACA,MAAMM,KAAK,GAAGN,OAAO,CAAC,UAAD,CAArB;;AAEA,MAAMO,OAAO,GAAGF,oBAAoB,CAAC,IAAD,CAApC;;AAEAG,OAAO,CAACC,MAAR,GAAiBC,MAAM,IAAIT,EAAE,CAACQ,MAAH,CAAUE,MAAV,CAAiB,IAAIZ,UAAJ,CAAe,CAACW,MAAD,EAASH,OAAT,CAAf,CAAjB,CAA3B,C,CAEA;;;AACAC,OAAO,CAACI,KAAR,GAAgB,CAACC,MAAD,EAASH,MAAT,KAAoBG,MAAM,CAACC,IAAP,CAAYN,OAAO,CAACC,MAAR,CAAeC,MAAf,CAAZ,CAApC,C,CAEA;;;AACAF,OAAO,CAACO,QAAR,GAAmB,CAACF,MAAD,EAASG,OAAT,KAAqB;AACtCH,EAAAA,MAAM,CAACC,IAAP,CAAYE,OAAO,CAACC,MAAR,CAAe,CAACC,EAAD,EAAKR,MAAL,KAAgBQ,EAAE,CAACC,MAAH,CAAUX,OAAO,CAACC,MAAR,CAAeC,MAAf,CAAV,CAA/B,EAAkE,IAAIX,UAAJ,EAAlE,CAAZ;AACD,CAFD;;AAIAS,OAAO,CAACY,IAAR;AAAA,+BAAe,WAAMC,MAAN,EAAgB;AAC7B,QAAIC,UAAU,GAAG,CAAjB,CAD6B,CACV;;AACnB,UAAMC,aAAa,GAAG;AAAE;AACtB,OAACC,MAAM,CAACC,aAAR,IAA0B;AAAE,eAAO,IAAP;AAAa,OADrB;;AAEpBC,MAAAA,IAAI,EAAE,MAAML,MAAM,CAACK,IAAP,CAAYJ,UAAZ;AAFQ,KAAtB,CAF6B,CAO7B;;AACA,UAAMK,QAAQ,GAAGC,CAAC,IAAI;AAAEN,MAAAA,UAAU,GAAGM,CAAb;AAAgB,KAAxC;;AACA,UAAMC,GAAG,SAAS3B,IAAI,CAACqB,aAAD,EAAgBtB,EAAE,CAAC6B,MAAH,CAAU;AAAEH,MAAAA;AAAF,KAAV,CAAhB,EAAyCrB,KAAzC,CAAtB;;AAEA,QAAIuB,GAAG,CAACE,GAAJ,CAAQF,GAAG,CAACG,MAAJ,GAAa,CAArB,MAA4BzB,OAAO,CAAC,CAAD,CAAvC,EAA4C;AAC1C,YAAMJ,OAAO,CAAC,IAAI8B,KAAJ,CAAU,iBAAV,CAAD,EAA+B,wCAA/B,CAAb;AACD;;AAED,WAAOJ,GAAG,CAACK,YAAJ,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAP,CAf6B,CAeE;AAChC,GAhBD;;AAAA;AAAA;AAAA;AAAA","sourcesContent":["'use strict'\n\nconst BufferList = require('bl/BufferList')\nconst lp = require('it-length-prefixed')\nconst pipe = require('it-pipe')\nconst errCode = require('err-code')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst first = require('it-first')\n\nconst NewLine = uint8ArrayFromString('\\n')\n\nexports.encode = buffer => lp.encode.single(new BufferList([buffer, NewLine]))\n\n// `write` encodes and writes a single buffer\nexports.write = (writer, buffer) => writer.push(exports.encode(buffer))\n\n// `writeAll` behaves like `write`, except it encodes an array of items as a single write\nexports.writeAll = (writer, buffers) => {\n  writer.push(buffers.reduce((bl, buffer) => bl.append(exports.encode(buffer)), new BufferList()))\n}\n\nexports.read = async reader => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n  const varByteSource = { // No return impl - we want the reader to remain readable\n    [Symbol.asyncIterator] () { return this },\n    next: () => reader.next(byteLength)\n  }\n\n  // Once the length has been parsed, read chunk for that length\n  const onLength = l => { byteLength = l }\n  const buf = await pipe(varByteSource, lp.decode({ onLength }), first)\n\n  if (buf.get(buf.length - 1) !== NewLine[0]) {\n    throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  return buf.shallowSlice(0, -1) // Remove newline\n}\n"]},"metadata":{},"sourceType":"script"}