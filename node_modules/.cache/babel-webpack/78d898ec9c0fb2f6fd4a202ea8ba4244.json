{"ast":null,"code":"'use strict'; // @ts-ignore - TODO vmx 2021-03-31\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/contract-testing/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils');\n\nconst errCode = require('err-code');\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\n\n\nconst removeLink = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (context, options) {\n    let parent = options.parent;\n\n    if (options.parentCid) {\n      const parentCid = CID.asCID(options.parentCid);\n\n      if (parentCid === null) {\n        throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n      }\n\n      log(`Loading parent node ${parentCid}`);\n      const block = yield context.repo.blocks.get(parentCid);\n      parent = dagPb.decode(block);\n    }\n\n    if (!parent) {\n      throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n    }\n\n    if (!options.name) {\n      throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n    }\n\n    if (!parent.Data) {\n      throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n    }\n\n    const meta = UnixFS.unmarshal(parent.Data);\n\n    if (meta.type === 'hamt-sharded-directory') {\n      log(`Removing ${options.name} from sharded directory`);\n      return removeFromShardedDirectory(context, { ...options,\n        parent\n      });\n    }\n\n    log(`Removing link ${options.name} regular directory`);\n    return removeFromDirectory(context, { ...options,\n      parent\n    });\n  });\n\n  return function removeLink(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst removeFromDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (context, options) {\n    // Remove existing link if it exists\n    options.parent.Links = options.parent.Links.filter(link => {\n      return link.Name !== options.name;\n    });\n    const parentBlock = yield dagPb.encode(options.parent);\n    const hasher = yield context.hashers.getHasher(options.hashAlg);\n    const hash = yield hasher.digest(parentBlock);\n    const parentCid = CID.create(options.cidVersion, dagPb.code, hash);\n    yield context.repo.blocks.put(parentCid, parentBlock);\n    log(`Updated regular directory ${parentCid}`);\n    return {\n      node: options.parent,\n      cid: parentCid\n    };\n  });\n\n  return function removeFromDirectory(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst removeFromShardedDirectory = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (context, options) {\n    const {\n      rootBucket,\n      path\n    } = yield generatePath(context, options.name, options.parent);\n    yield rootBucket.del(options.name);\n    const {\n      node\n    } = yield updateShard(context, path, options.name, options);\n    return updateHamtDirectory(context, node.Links, rootBucket, options);\n  });\n\n  return function removeFromShardedDirectory(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\n\n\nconst updateShard = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (context, positions, name, options) {\n    const last = positions.pop();\n\n    if (!last) {\n      throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n    }\n\n    const {\n      bucket,\n      prefix,\n      node\n    } = last;\n\n    if (!node) {\n      throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n    }\n\n    const link = node.Links.find(link => (link.Name || '').substring(0, 2) === prefix);\n\n    if (!link) {\n      throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND');\n    }\n\n    if (link.Name === `${prefix}${name}`) {\n      log(`Removing existing link ${link.Name}`);\n      const links = node.Links.filter(nodeLink => {\n        return nodeLink.Name !== link.Name;\n      });\n      yield bucket.del(name);\n      return updateHamtDirectory(context, links, bucket, options);\n    }\n\n    log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`);\n    const result = yield updateShard(context, positions, name, options);\n    let cid = result.cid;\n    let size = result.size;\n    let newName = prefix;\n\n    if (result.node.Links.length === 1) {\n      log(`Removing subshard for ${prefix}`); // convert shard back to normal dir\n\n      const link = result.node.Links[0];\n      newName = `${prefix}${(link.Name || '').substring(2)}`;\n      cid = link.Hash;\n      size = link.Tsize || 0;\n    }\n\n    log(`Updating shard ${prefix} with name ${newName}`);\n    return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);\n  });\n\n  return function updateShard(_x7, _x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter(link => {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return updateHamtDirectory(context, parentLinks, bucket, options);\n};\n\nmodule.exports = removeLink;","map":null,"metadata":{},"sourceType":"script"}