{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sydneybailey/Internship/Demo/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:transports'), {\n  error: debug('libp2p:transports:err')\n});\n\nconst pSettle = require('p-settle');\n\nconst {\n  codes\n} = require('./errors');\n\nconst errCode = require('err-code');\n\nconst {\n  updateSelfPeerRecord\n} = require('./record/utils');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/transport/types').Transport<any, any>} Transport\n *\n * @typedef {Object} TransportManagerProperties\n * @property {import('./')} libp2p\n * @property {import('./upgrader')} upgrader\n *\n * @typedef {Object} TransportManagerOptions\n * @property {number} [faultTolerance = FAULT_TOLERANCE.FATAL_ALL] - Address listen error tolerance.\n */\n\n\nclass TransportManager {\n  /**\n   * @class\n   * @param {TransportManagerProperties & TransportManagerOptions} options\n   */\n  constructor({\n    libp2p,\n    upgrader,\n    faultTolerance = FAULT_TOLERANCE.FATAL_ALL\n  }) {\n    this.libp2p = libp2p;\n    this.upgrader = upgrader;\n    /** @type {Map<string, Transport>} */\n\n    this._transports = new Map();\n    this._listeners = new Map();\n    this._listenerOptions = new Map();\n    this.faultTolerance = faultTolerance;\n  }\n  /**\n   * Adds a `Transport` to the manager\n   *\n   * @param {string} key\n   * @param {TransportFactory} Transport\n   * @param {*} transportOptions - Additional options to pass to the transport\n   * @returns {void}\n   */\n\n\n  add(key, Transport, transportOptions = {}) {\n    log('adding %s', key);\n\n    if (!key) {\n      throw errCode(new Error(`Transport must have a valid key, was given '${key}'`), codes.ERR_INVALID_KEY);\n    }\n\n    if (this._transports.has(key)) {\n      throw errCode(new Error('There is already a transport with this key'), codes.ERR_DUPLICATE_TRANSPORT);\n    }\n\n    const transport = new Transport({ ...transportOptions,\n      libp2p: this.libp2p,\n      upgrader: this.upgrader\n    });\n\n    this._transports.set(key, transport);\n\n    this._listenerOptions.set(key, transportOptions.listenerOptions || {});\n\n    if (!this._listeners.has(key)) {\n      this._listeners.set(key, []);\n    }\n  }\n  /**\n   * Stops all listeners\n   *\n   * @async\n   */\n\n\n  close() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const tasks = [];\n\n      for (const [key, listeners] of _this._listeners) {\n        log('closing listeners for %s', key);\n\n        while (listeners.length) {\n          const listener = listeners.pop();\n          listener.removeAllListeners('listening');\n          listener.removeAllListeners('close');\n          tasks.push(listener.close());\n        }\n      }\n\n      yield Promise.all(tasks);\n      log('all listeners closed');\n\n      for (const key of _this._listeners.keys()) {\n        _this._listeners.set(key, []);\n      }\n    })();\n  }\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   *\n   * @param {Multiaddr} ma\n   * @param {*} options\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(ma, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const transport = _this2.transportForMultiaddr(ma);\n\n      if (!transport) {\n        throw errCode(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);\n      }\n\n      try {\n        return yield transport.dial(ma, options);\n      } catch (err) {\n        if (!err.code) err.code = codes.ERR_TRANSPORT_DIAL_FAILED;\n        throw err;\n      }\n    })();\n  }\n  /**\n   * Returns all Multiaddr's the listeners are using\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  getAddrs() {\n    /** @type {Multiaddr[]} */\n    let addrs = [];\n\n    for (const listeners of this._listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()];\n      }\n    }\n\n    return addrs;\n  }\n  /**\n   * Returns all the transports instances.\n   *\n   * @returns {IterableIterator<Transport>}\n   */\n\n\n  getTransports() {\n    return this._transports.values();\n  }\n  /**\n   * Finds a transport that matches the given Multiaddr\n   *\n   * @param {Multiaddr} ma\n   * @returns {Transport|null}\n   */\n\n\n  transportForMultiaddr(ma) {\n    for (const transport of this._transports.values()) {\n      const addrs = transport.filter([ma]);\n      if (addrs.length) return transport;\n    }\n\n    return null;\n  }\n  /**\n   * Starts listeners for each listen Multiaddr.\n   *\n   * @async\n   * @param {Multiaddr[]} addrs - addresses to attempt to listen on\n   */\n\n\n  listen(addrs) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!addrs || addrs.length === 0) {\n        log('no addresses were provided for listening, this node is dial only');\n        return;\n      }\n\n      const couldNotListen = [];\n\n      for (const [key, transport] of _this3._transports.entries()) {\n        const supportedAddrs = transport.filter(addrs);\n        const tasks = []; // For each supported multiaddr, create a listener\n\n        for (const addr of supportedAddrs) {\n          log('creating listener for %s on %s', key, addr);\n          const listener = transport.createListener(_this3._listenerOptions.get(key));\n\n          _this3._listeners.get(key).push(listener); // Track listen/close events\n\n\n          listener.on('listening', () => updateSelfPeerRecord(_this3.libp2p));\n          listener.on('close', () => updateSelfPeerRecord(_this3.libp2p)); // We need to attempt to listen on everything\n\n          tasks.push(listener.listen(addr));\n        } // Keep track of transports we had no addresses for\n\n\n        if (tasks.length === 0) {\n          couldNotListen.push(key);\n          continue;\n        }\n\n        const results = yield pSettle(tasks); // If we are listening on at least 1 address, succeed.\n        // TODO: we should look at adding a retry (`p-retry`) here to better support\n        // listening on remote addresses as they may be offline. We could then potentially\n        // just wait for any (`p-any`) listener to succeed on each transport before returning\n\n        const isListening = results.find(r => r.isFulfilled === true);\n\n        if (!isListening && _this3.faultTolerance !== FAULT_TOLERANCE.NO_FATAL) {\n          throw errCode(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);\n        }\n      } // If no transports were able to listen, throw an error. This likely\n      // means we were given addresses we do not have transports for\n\n\n      if (couldNotListen.length === _this3._transports.size) {\n        const message = `no valid addresses were provided for transports [${couldNotListen}]`;\n\n        if (_this3.faultTolerance === FAULT_TOLERANCE.FATAL_ALL) {\n          throw errCode(new Error(message), codes.ERR_NO_VALID_ADDRESSES);\n        }\n\n        log(`libp2p in dial mode only: ${message}`);\n      }\n    })();\n  }\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   *\n   * @async\n   * @param {string} key\n   */\n\n\n  remove(key) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      log('removing %s', key);\n\n      if (_this4._listeners.has(key)) {\n        // Close any running listeners\n        for (const listener of _this4._listeners.get(key)) {\n          listener.removeAllListeners('listening');\n          listener.removeAllListeners('close');\n          yield listener.close();\n        }\n      }\n\n      _this4._transports.delete(key);\n\n      _this4._listeners.delete(key);\n    })();\n  }\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n\n\n  removeAll() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const tasks = [];\n\n      for (const key of _this5._transports.keys()) {\n        tasks.push(_this5.remove(key));\n      }\n\n      yield Promise.all(tasks);\n    })();\n  }\n\n}\n/**\n * Enum Transport Manager Fault Tolerance values.\n * FATAL_ALL should be used for failing in any listen circumstance.\n * NO_FATAL should be used for not failing when not listening.\n *\n * @readonly\n * @enum {number}\n */\n\n\nconst FAULT_TOLERANCE = {\n  FATAL_ALL: 0,\n  NO_FATAL: 1\n};\nTransportManager.FaultTolerance = FAULT_TOLERANCE;\nmodule.exports = TransportManager;","map":{"version":3,"sources":["/Users/sydneybailey/Internship/Demo/node_modules/libp2p/src/transport-manager.js"],"names":["debug","require","log","Object","assign","error","pSettle","codes","errCode","updateSelfPeerRecord","TransportManager","constructor","libp2p","upgrader","faultTolerance","FAULT_TOLERANCE","FATAL_ALL","_transports","Map","_listeners","_listenerOptions","add","key","Transport","transportOptions","Error","ERR_INVALID_KEY","has","ERR_DUPLICATE_TRANSPORT","transport","set","listenerOptions","close","tasks","listeners","length","listener","pop","removeAllListeners","push","Promise","all","keys","dial","ma","options","transportForMultiaddr","String","ERR_TRANSPORT_UNAVAILABLE","err","code","ERR_TRANSPORT_DIAL_FAILED","getAddrs","addrs","values","getTransports","filter","listen","couldNotListen","entries","supportedAddrs","addr","createListener","get","on","results","isListening","find","r","isFulfilled","NO_FATAL","ERR_NO_VALID_ADDRESSES","size","message","remove","delete","removeAll","FaultTolerance","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:transports'), {\n  error: debug('libp2p:transports:err')\n})\n\nconst pSettle = require('p-settle')\nconst { codes } = require('./errors')\nconst errCode = require('err-code')\n\nconst { updateSelfPeerRecord } = require('./record/utils')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/transport/types').Transport<any, any>} Transport\n *\n * @typedef {Object} TransportManagerProperties\n * @property {import('./')} libp2p\n * @property {import('./upgrader')} upgrader\n *\n * @typedef {Object} TransportManagerOptions\n * @property {number} [faultTolerance = FAULT_TOLERANCE.FATAL_ALL] - Address listen error tolerance.\n */\n\nclass TransportManager {\n  /**\n   * @class\n   * @param {TransportManagerProperties & TransportManagerOptions} options\n   */\n  constructor ({ libp2p, upgrader, faultTolerance = FAULT_TOLERANCE.FATAL_ALL }) {\n    this.libp2p = libp2p\n    this.upgrader = upgrader\n    /** @type {Map<string, Transport>} */\n    this._transports = new Map()\n    this._listeners = new Map()\n    this._listenerOptions = new Map()\n    this.faultTolerance = faultTolerance\n  }\n\n  /**\n   * Adds a `Transport` to the manager\n   *\n   * @param {string} key\n   * @param {TransportFactory} Transport\n   * @param {*} transportOptions - Additional options to pass to the transport\n   * @returns {void}\n   */\n  add (key, Transport, transportOptions = {}) {\n    log('adding %s', key)\n    if (!key) {\n      throw errCode(new Error(`Transport must have a valid key, was given '${key}'`), codes.ERR_INVALID_KEY)\n    }\n    if (this._transports.has(key)) {\n      throw errCode(new Error('There is already a transport with this key'), codes.ERR_DUPLICATE_TRANSPORT)\n    }\n\n    const transport = new Transport({\n      ...transportOptions,\n      libp2p: this.libp2p,\n      upgrader: this.upgrader\n    })\n\n    this._transports.set(key, transport)\n    this._listenerOptions.set(key, transportOptions.listenerOptions || {})\n    if (!this._listeners.has(key)) {\n      this._listeners.set(key, [])\n    }\n  }\n\n  /**\n   * Stops all listeners\n   *\n   * @async\n   */\n  async close () {\n    const tasks = []\n    for (const [key, listeners] of this._listeners) {\n      log('closing listeners for %s', key)\n      while (listeners.length) {\n        const listener = listeners.pop()\n        listener.removeAllListeners('listening')\n        listener.removeAllListeners('close')\n        tasks.push(listener.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    log('all listeners closed')\n    for (const key of this._listeners.keys()) {\n      this._listeners.set(key, [])\n    }\n  }\n\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   *\n   * @param {Multiaddr} ma\n   * @param {*} options\n   * @returns {Promise<Connection>}\n   */\n  async dial (ma, options) {\n    const transport = this.transportForMultiaddr(ma)\n    if (!transport) {\n      throw errCode(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE)\n    }\n\n    try {\n      return await transport.dial(ma, options)\n    } catch (err) {\n      if (!err.code) err.code = codes.ERR_TRANSPORT_DIAL_FAILED\n      throw err\n    }\n  }\n\n  /**\n   * Returns all Multiaddr's the listeners are using\n   *\n   * @returns {Multiaddr[]}\n   */\n  getAddrs () {\n    /** @type {Multiaddr[]} */\n    let addrs = []\n    for (const listeners of this._listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()]\n      }\n    }\n    return addrs\n  }\n\n  /**\n   * Returns all the transports instances.\n   *\n   * @returns {IterableIterator<Transport>}\n   */\n  getTransports () {\n    return this._transports.values()\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   *\n   * @param {Multiaddr} ma\n   * @returns {Transport|null}\n   */\n  transportForMultiaddr (ma) {\n    for (const transport of this._transports.values()) {\n      const addrs = transport.filter([ma])\n      if (addrs.length) return transport\n    }\n    return null\n  }\n\n  /**\n   * Starts listeners for each listen Multiaddr.\n   *\n   * @async\n   * @param {Multiaddr[]} addrs - addresses to attempt to listen on\n   */\n  async listen (addrs) {\n    if (!addrs || addrs.length === 0) {\n      log('no addresses were provided for listening, this node is dial only')\n      return\n    }\n\n    const couldNotListen = []\n    for (const [key, transport] of this._transports.entries()) {\n      const supportedAddrs = transport.filter(addrs)\n      const tasks = []\n\n      // For each supported multiaddr, create a listener\n      for (const addr of supportedAddrs) {\n        log('creating listener for %s on %s', key, addr)\n        const listener = transport.createListener(this._listenerOptions.get(key))\n        this._listeners.get(key).push(listener)\n\n        // Track listen/close events\n        listener.on('listening', () => updateSelfPeerRecord(this.libp2p))\n        listener.on('close', () => updateSelfPeerRecord(this.libp2p))\n\n        // We need to attempt to listen on everything\n        tasks.push(listener.listen(addr))\n      }\n\n      // Keep track of transports we had no addresses for\n      if (tasks.length === 0) {\n        couldNotListen.push(key)\n        continue\n      }\n\n      const results = await pSettle(tasks)\n      // If we are listening on at least 1 address, succeed.\n      // TODO: we should look at adding a retry (`p-retry`) here to better support\n      // listening on remote addresses as they may be offline. We could then potentially\n      // just wait for any (`p-any`) listener to succeed on each transport before returning\n      const isListening = results.find(r => r.isFulfilled === true)\n      if (!isListening && this.faultTolerance !== FAULT_TOLERANCE.NO_FATAL) {\n        throw errCode(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES)\n      }\n    }\n\n    // If no transports were able to listen, throw an error. This likely\n    // means we were given addresses we do not have transports for\n    if (couldNotListen.length === this._transports.size) {\n      const message = `no valid addresses were provided for transports [${couldNotListen}]`\n      if (this.faultTolerance === FAULT_TOLERANCE.FATAL_ALL) {\n        throw errCode(new Error(message), codes.ERR_NO_VALID_ADDRESSES)\n      }\n      log(`libp2p in dial mode only: ${message}`)\n    }\n  }\n\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   *\n   * @async\n   * @param {string} key\n   */\n  async remove (key) {\n    log('removing %s', key)\n    if (this._listeners.has(key)) {\n      // Close any running listeners\n      for (const listener of this._listeners.get(key)) {\n        listener.removeAllListeners('listening')\n        listener.removeAllListeners('close')\n        await listener.close()\n      }\n    }\n\n    this._transports.delete(key)\n    this._listeners.delete(key)\n  }\n\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n  async removeAll () {\n    const tasks = []\n    for (const key of this._transports.keys()) {\n      tasks.push(this.remove(key))\n    }\n\n    await Promise.all(tasks)\n  }\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values.\n * FATAL_ALL should be used for failing in any listen circumstance.\n * NO_FATAL should be used for not failing when not listening.\n *\n * @readonly\n * @enum {number}\n */\nconst FAULT_TOLERANCE = {\n  FATAL_ALL: 0,\n  NO_FATAL: 1\n}\n\nTransportManager.FaultTolerance = FAULT_TOLERANCE\n\nmodule.exports = TransportManager\n"]},"metadata":{},"sourceType":"script"}