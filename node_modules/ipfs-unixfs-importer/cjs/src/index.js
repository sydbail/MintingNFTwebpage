'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var parallelBatch = require('it-parallel-batch');
var options = require('./options.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespaceDefaultOnly(e) {
  return Object.freeze({__proto__: null, 'default': e});
}

var parallelBatch__default = /*#__PURE__*/_interopDefaultLegacy(parallelBatch);

async function* importer(source, blockstore, options$1 = {}) {
  const opts = options(options$1);
  let dagBuilder;
  if (typeof options$1.dagBuilder === 'function') {
    dagBuilder = options$1.dagBuilder;
  } else {
    dagBuilder = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefaultOnly(require('./dag-builder/index.js')); })).default;
  }
  let treeBuilder;
  if (typeof options$1.treeBuilder === 'function') {
    treeBuilder = options$1.treeBuilder;
  } else {
    treeBuilder = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefaultOnly(require('./tree-builder.js')); })).default;
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder(parallelBatch__default['default'](dagBuilder(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}

exports.importer = importer;
